<channel version="4.0.0">
  <id>e20d28dc-e360-4b54-a225-5c6cddeba9a3</id>
  <nextMetaDataId>5</nextMetaDataId>
  <name>HL7 ORU PDF to DICOM Sender</name>
  <description></description>
  <revision>45</revision>
  <sourceConnector version="4.0.0">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.file.FileReceiverProperties" version="4.0.0">
      <pluginProperties/>
      <pollConnectorProperties version="4.0.0">
        <pollingType>INTERVAL</pollingType>
        <pollOnStart>true</pollOnStart>
        <pollingFrequency>30000</pollingFrequency>
        <pollingHour>0</pollingHour>
        <pollingMinute>0</pollingMinute>
        <cronJobs/>
        <pollConnectorPropertiesAdvanced>
          <weekly>true</weekly>
          <inactiveDays>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
          </inactiveDays>
          <dayOfMonth>1</dayOfMonth>
          <allDay>true</allDay>
          <startingHour>8</startingHour>
          <startingMinute>0</startingMinute>
          <endingHour>17</endingHour>
          <endingMinute>0</endingMinute>
        </pollConnectorPropertiesAdvanced>
      </pollConnectorProperties>
      <sourceConnectorProperties version="4.0.0">
        <responseVariable>None</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <scheme>FILE</scheme>
      <host>C:/HL7/Misty/in</host>
      <fileFilter>*</fileFilter>
      <regex>false</regex>
      <directoryRecursion>false</directoryRecursion>
      <ignoreDot>true</ignoreDot>
      <anonymous>true</anonymous>
      <username>anonymous</username>
      <password>anonymous</password>
      <timeout>10000</timeout>
      <secure>true</secure>
      <passive>true</passive>
      <validateConnection>true</validateConnection>
      <afterProcessingAction>MOVE</afterProcessingAction>
      <moveToDirectory>C:/HL7/Misty/archive/20230914</moveToDirectory>
      <moveToFileName>${originalFilename}</moveToFileName>
      <errorReadingAction>NONE</errorReadingAction>
      <errorResponseAction>DELETE</errorResponseAction>
      <errorMoveToDirectory>F:/RPRS/ECG/error/</errorMoveToDirectory>
      <errorMoveToFileName>${originalFilename}</errorMoveToFileName>
      <checkFileAge>true</checkFileAge>
      <fileAge>1000</fileAge>
      <fileSizeMinimum>0</fileSizeMinimum>
      <fileSizeMaximum></fileSizeMaximum>
      <ignoreFileSizeMaximum>true</ignoreFileSizeMaximum>
      <sortBy>date</sortBy>
      <binary>false</binary>
      <charsetEncoding>DEFAULT_ENCODING</charsetEncoding>
    </properties>
    <transformer version="4.0.0">
      <elements>
        <com.mirth.connect.plugins.mapper.MapperStep version="4.0.0">
          <name>message_control_id</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <variable>message_control_id</variable>
          <mapping>msg[&apos;MSH&apos;][&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
          <name>patient_id</name>
          <sequenceNumber>1</sequenceNumber>
          <enabled>true</enabled>
          <script>/* 
Modified: 
2023-03-06 JER - Modified to populate patient_id from lastname + first initial firstname if PID-3.1 has no value
*/
var scriptName= &apos;patient_id&apos;;
var debug= 0;

var patientId= &apos;&apos;;
if(typeof(msg[&apos;PID&apos;][&apos;PID.3&apos;])!== &apos;undefined&apos;) {
	if(msg[&apos;PID&apos;][&apos;PID.3&apos;].length()&gt;1) {
		// 2023-02-28 JER - handling more than one patient identifier, determine for each pid evaluate if length LT 1 or NOT use lastName+firstNamefirstInitial
		for each (pid3 in msg[&apos;PID&apos;][&apos;PID.3&apos;]) {
			// 2023-02-28 JER - Instances no PID-3.1 use concatenated value of lastName &amp; firstNamefirstInitial (ritzj) lowercase
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; pid3 typeof: &apos;+typeof(pid3)+&apos; length: &apos;+pid3.length+&apos; msg[PID][PID.3]: &apos;+pid3.toString());
			// evaluate if PID.3.1 string length LT 1 get the PID-5.1 and PID-5.2 concatenated values as the patientId
			if(pid3[&apos;PID.3.1&apos;].toString().length&lt;1) {
				var tmp_pid3= msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString().toLowerCase()+msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString().toLowerCase();
				if(patientId.indexOf(tmp_pid3)&lt;0) {
					patientId= tmp_pid3;
				} // end if 
			// evaluate if PID.3.1 string length GT 0 get the PID-5.1 and PID-5.2 concatenated values as the patientId
			} else {
				if(pid3[&apos;PID.3.5&apos;].toString()== &apos;MR&apos;) {
					var pid31= pid3[&apos;PID.3.1&apos;].toString();
					if(patientId.indexOf(pid31)&lt;0) {
						patientId= pid31;
					} // end if 
				} // end if
			} // end if 
		} // end for each
	// only one patient identifier - evaluate if length LT 1 or NOT
	} else {
		if(msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString().length&lt;1) {
			var patientId= msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString().toLowerCase()+ msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString().toLowerCase().charAt(0);
		} else {
			var patientId= msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
		} // end if 
	} // end if 
} // end if 

channelMap.put(&apos;patient_id&apos;,patientId);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.mapper.MapperStep version="4.0.0">
          <name>patient_address_state</name>
          <sequenceNumber>2</sequenceNumber>
          <enabled>true</enabled>
          <variable>patient_address_state</variable>
          <mapping>msg[&apos;PID&apos;][&apos;PID.11&apos;][&apos;PID.11.4&apos;].toString()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.mapper.MapperStep version="4.0.0">
          <name>filler_order_number</name>
          <sequenceNumber>3</sequenceNumber>
          <enabled>true</enabled>
          <variable>filler_order_number</variable>
          <mapping>msg[&apos;ORC&apos;][0][&apos;ORC.3&apos;][&apos;ORC.3.2&apos;].toString()</mapping>
          <defaultValue></defaultValue>
          <replacements/>
          <scope>CHANNEL</scope>
        </com.mirth.connect.plugins.mapper.MapperStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
          <name>order_type</name>
          <sequenceNumber>4</sequenceNumber>
          <enabled>true</enabled>
          <script>/* 
Modified: 
2023-03-06 JER - Modified to capture the order description if no order code is provided
2023-02-01 JER - Modified to accommodate multiple OBR segments to concatenate the field values 

*/
var scriptName= &apos;order_type&apos;;
var debug= 0;

if(msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.1&apos;].toString().length&gt;0) {

	if(msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.1&apos;].length()&gt;1) {
		var str_order_type= &apos;&apos;;
		for each(element in msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.1&apos;]) {
			str_order_type+= element.toString()+&apos;,&apos;;
		} // end for each
	} else {
		var str_order_type= msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.1&apos;].toString();
	} // end if 
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR.4.1 str_order_type: &apos;+str_order_type);
	
} else if(msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.2&apos;].toString().length&gt;0) {

	if(msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.2&apos;].length()&gt;1) {
		var str_order_type= &apos;&apos;;
		for each(element in msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.2&apos;]) {
			if(element.toString().indexOf(&apos;COVID&apos;)&gt;-1) {
				str_order_type+= &apos;COVID-19,&apos;;
			// 2023-03-06 JER - Modified to capture the order description if no order code is provided
			} else {
				str_order_type+= element.toString()+&apos;,&apos;;
			}
		} // end for each
	} else {
		var str_order_type= msg[&apos;OBR&apos;][&apos;OBR.4&apos;][&apos;OBR.4.2&apos;].toString();
	} // end if 
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR.4.2 str_order_type: &apos;+str_order_type);

} else {
	var str_order_type= &apos;&apos;;
}
channelMap.put(&apos;order_type&apos;,str_order_type);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
          <name>entered_location_state</name>
          <sequenceNumber>5</sequenceNumber>
          <enabled>true</enabled>
          <script>/* Modified: 2023-02-01 JER - Modified to accommodate multiple OBR segments to concatenate the field values 
*/
var scriptName= &apos;entered_location_state&apos;;
var debug= 0;

if(msg[&apos;ORC&apos;][&apos;ORC.13&apos;][&apos;ORC.13.4&apos;].length()&gt;0) {
	
	if(msg[&apos;ORC&apos;][&apos;ORC.13&apos;][&apos;ORC.13.4&apos;].length()&gt;1) {
		var str_entered_location_state= &apos;&apos;;
		for each(element in msg[&apos;ORC&apos;][&apos;ORC.13&apos;][&apos;ORC.13.4&apos;]) {
			str_entered_location_state+= element.toString()+&apos;,&apos;;
		} // end for each
	} else {
		var str_entered_location_state= msg[&apos;ORC&apos;][&apos;ORC.13&apos;][&apos;ORC.13.4&apos;].toString();
	} // end if 
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; ORC.13.4 str_entered_location_state: &apos;+str_entered_location_state);
} else if(msg[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;ORC.22.4&apos;].length()&gt;0) {
	
	if(msg[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;ORC.22.4&apos;].length()&gt;1) {
		var str_entered_location_state= &apos;&apos;;
		for each(element in msg[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;ORC.22.4&apos;]) {
			str_entered_location_state+= element.toString()+&apos;,&apos;;
		} // end for each
	} else {
		var str_entered_location_state= msg[&apos;ORC&apos;][&apos;ORC.22&apos;][&apos;ORC.22.4&apos;].toString();
	} // end if 
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; ORC.22.4 str_entered_location_state: &apos;+str_entered_location_state);
} else {
	var str_entered_location_state= &apos;&apos;;
}
channelMap.put(&apos;entered_location_state&apos;,str_entered_location_state);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
          <name>collected_date</name>
          <sequenceNumber>6</sequenceNumber>
          <enabled>true</enabled>
          <script>/* 
Modified: 2023-03-02 JER - Modified to iterate through all instances of multiple field values. 
*/
var scriptName= &apos;collected_date&apos;;
var debug= 0;

if(msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].toString().length&gt;0) {

	if(msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].length()&gt;1) {
		var str_collected_date= &apos;&apos;;
		for(var i= 0;i&lt;msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].length();i++) {
			if(i== msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].length()-1) {
				str_collected_date+= msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;][i];
			} else {
				str_collected_date+= msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;][i]+&apos;,&apos;;
			} // end if 
		} // end for each
	} else {
		var str_collected_date= msg[&apos;OBR&apos;][&apos;OBR.14&apos;][&apos;OBR.14.1&apos;].toString();
	} // end if 
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR.14.1 str_collected_date: &apos;+str_collected_date);
	
} else if(msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;].toString().length&gt;0) {

	if(msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;].length()&gt;1) {
		var str_collected_date= &apos;&apos;;
		for(var i= 0;i&lt;msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;].length();i++) {
			if(i== msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;].length()-1) {
				str_collected_date+= msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;][i];
			} else {
				str_collected_date+= msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;][i]+&apos;,&apos;;
			} // end if 
		} // end for each
	} else {
		var str_collected_date= msg[&apos;OBR&apos;][&apos;OBR.22&apos;][&apos;OBR.22.1&apos;].toString();
	} // end if 
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR.4.2 str_collected_date: &apos;+str_collected_date);

} else {
	var str_collected_date= &apos;&apos;;
}
channelMap.put(&apos;collected_date&apos;,str_collected_date);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
          <name>Collate the OBX-5 values into PDF</name>
          <sequenceNumber>7</sequenceNumber>
          <enabled>true</enabled>
          <script>var pdfAttachment= new Object();
var strAttachmentText= new String();
var debug= 0;

for each (obx in msg[&apos;OBX&apos;]) {
	if(obx[&apos;OBX.5&apos;][&apos;OBX.5.3&apos;].toString()== &apos;PDF&apos;) {
		strAttachmentText+= obx[&apos;OBX.5&apos;][&apos;OBX.5.5&apos;].toString();
	} // end if 
} // end if 

if(debug&gt;0) logger.debug(&apos;strAttachmentText string typeof: &apos;+typeof(strAttachmentText)+&apos; size: &apos;+strAttachmentText.length+&apos; value: &apos;+strAttachmentText);
// encode string into Base64
encodedString= FileUtil.encode(new java.lang.String(strAttachmentText).getBytes(&apos;UTF-8&apos;));
if(debug&gt;0) logger.debug(&apos;Encoded base64 string typeof: &apos;+typeof(encodedString)+&apos; size: &apos;+encodedString.length()+&apos; value: &apos;+encodedString);

/*
//try {
	var decodedPDFString = FileUtil.decode(pdfAttachment);
	logger.debug(&apos;PDF Attachment decodedPDFString typeof: &apos;+typeof(decodedPDFString)+&apos; size: &apos;+decodedPDFString.length+&apos; value: &apos;+decodedPDFString);
}
catch(e) {
	logger.error(channelName + &apos; failed to decode OBX RTF string because: &apos; + e);
	throw(e);
}
*/

/*
//try {
	var encodedPDFString = Packages.org.apache.commons.codec.binary.Base64.encodeBase64String(pdfAttachment);
	// var encodedPDFString = FileUtil.encode(pdfAttachment);
	logger.debug(&apos;PDF Attachment encodedPDFString typeof: &apos;+typeof(encodedPDFString)+&apos; size: &apos;+encodedPDFString.length()+&apos; value: &apos;+encodedPDFString);
	channelMap.put(&apos;encodedPDFString&apos;,encodedPDFString);
}
catch(e) {
	logger.error(channelName + &apos; failed to decode OBX RTF string because: &apos; + e);
	throw(e);
}

*/
//var pdfAttachmentBytesEncoded = Packages.org.apache.commons.codec.binary.Base64.encodeBase64String(pdfAttachment);
channelMap.put(&apos;pdfAttachment&apos;,strAttachmentText);
addAttachment(strAttachmentText, &apos;application/pdf&apos;, true);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64">TVNIfF5+XCZ8TWluaUJveHxQdWxtT25lfHx8MjAyMzAyMTIxNDU0fDB8T1JVXlIwMXwzNF8xMDAyMjAyM18xMDM1MzR8fDI1Mnx8fHx8fHx8fExSSV9OR19STl9Qcm9maWxlXkhMN14yLjE2Ljg0MC4xLjExMzg4My45LjIwXklTTyANClBJRHx8fEdFMTQ3Mzg4MDl8fERvZV5Kb2hufHwxOTU2MTEyOXxNYWxlfHxDYXVjYXNpYW58fHx8fHx8fHx8IA0KUFYxfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCANCk9SQ3xSRXx8T0JSXjM0XzEwMDIyMDIzXzEwMzUzNF5GVkN8fHx8fHx8fHx8fHx8fHx8IA0KT0JSfDF8fE9CUl4zNF8xMDAyMjAyM18xMDM1MzReRlZDfEZWQ3x8fDIwMjMwMjEwMTAzNTM0fHx8fHx8fHx8fHx8fHx8MjAyMzAyMTAxNDAwMTV8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwxfFNUfDE5ODY4LTlfQmVzdF9QcmVeRlZDX0Jlc3RfUHJlXkxOfHwzLjgzfEx8fHx8fEZ8fHx8fHwgDQpPQlh8MnxTVHwxOTg2OC05X1ByZWReRlZDX1ByZWReTE58fDMuODV8THx8fHx8Rnx8fHx8fCANCk9CWHwzfFNUfDE5ODY4LTlfJVByZWRfUHJlXkZWQ18lUHJlZF9QcmVeTE58fDk5LjI4fCV8fHx8fEZ8fHx8fHwgDQpPQlh8NHxTVHwyMDE1MC05X0Jlc3RfUHJlXkZFVjFfQmVzdF9QcmVeTE58fDMuMTd8THx8fHx8Rnx8fHx8fCANCk9CWHw1fFNUfDIwMTUwLTlfUHJlZF5GRVYxX1ByZWReTE58fDIuOTh8THx8fHx8Rnx8fHx8fCANCk9CWHw2fFNUfDIwMTUwLTlfJVByZWRfUHJlXkZFVjFfJVByZWRfUHJlXkxOfHwxMDYuNTN8JXx8fHx8Rnx8fHx8fCANCk9CWHw3fFNUfDE5OTI2LTVfQmVzdF9QcmVeRkVWMS9GVkNfQmVzdF9QcmVeTE58fDgzLjB8JXx8fHx8Rnx8fHx8fCANCk9CWHw4fFNUfDE5OTI2LTVfUHJlZF5GRVYxL0ZWQ19QcmVkXkxOfHw3Ny40M3wlfHx8fHxGfHx8fHx8IA0KT0JYfDl8U1R8MTk5MjYtNV8lUHJlZF9QcmVeRkVWMS9GVkNfJVByZWRfUHJlXkxOfHwxMDcuMnwlfHx8fHxGfHx8fHx8IA0KT0JYfDEwfFNUfDY5OTcyLThfQmVzdF9QcmVeRkVGIDI1LTc1X0Jlc3RfUHJlXkxOfHwzLjU0fEwvc2VjfHx8fHxGfHx8fHx8IA0KT0JYfDExfFNUfDY5OTcyLThfUHJlZF5GRUYgMjUtNzVfUHJlZF5MTnx8Mi40NXxML3NlY3x8fHx8Rnx8fHx8fCANCk9CWHwxMnxTVHw2OTk3Mi04XyVQcmVkX1ByZV5GRUYgMjUtNzVfJVByZWRfUHJlXkxOfHwxNDQuODN8JXx8fHx8Rnx8fHx8fCANCk9CWHwxM3xTVHwxOTg2OC05X0Jlc3RfUG9zdF5GVkNfQmVzdF9Qb3N0XkxOfHwzLjQ5fEx8fHx8fEZ8fHx8fHwgDQpPQlh8MTR8U1R8MTk4NjgtOV8lUHJlZF9Qb3N0XkZWQ18lUHJlZF9Qb3N0XkxOfHw5OS4yOHwlfHx8fHxGfHx8fHx8IA0KT0JYfDE1fFNUfDIwMTUwLTlfQmVzdF9Qb3N0XkZFVjFfQmVzdF9Qb3N0XkxOfHwzLjF8THx8fHx8Rnx8fHx8fCANCk9CWHwxNnxTVHwyMDE1MC05XyVQcmVkX1Bvc3ReRkVWMV8lUHJlZF9Qb3N0XkxOfHwxMDYuNTN8JXx8fHx8Rnx8fHx8fCANCk9CWHwxN3xTVHwxOTkyNi01X0Jlc3RfUG9zdF5GRVYxL0ZWQ19CZXN0X1Bvc3ReTE58fDg4LjY4fCV8fHx8fEZ8fHx8fHwgDQpPQlh8MTh8U1R8MTk5MjYtNV8lUHJlZF9Qb3N0XkZFVjEvRlZDXyVQcmVkX1Bvc3ReTE58fDEwNy4yfCV8fHx8fEZ8fHx8fHwgDQpPQlh8MTl8U1R8Njk5NzItOF9CZXN0X1Bvc3ReRkVGIDI1LTc1X0Jlc3RfUG9zdF5MTnx8NC43MnxML3NlY3x8fHx8Rnx8fHx8fCANCk9CWHwyMHxTVHw2OTk3Mi04XyVQcmVkX1Bvc3ReRkVGIDI1LTc1XyVQcmVkX1Bvc3ReTE58fDE0NC44M3wlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XkxWTXx8fHx8fHx8fHx8fHx8fHwgDQpPQlJ8Mnx8T0JSXjM0XzEwMDIyMDIzXzEwMzUzNF5MVk18TFZNfHx8MjAyMzAyMTAxMDM1MzR8fHx8fHx8fHx8fHx8fHx8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwyMXxTVHxSVl9CZXN0XlJWX0Jlc3ReTHx8MS4yNnxMfHx8fHxGfHx8fHx8IA0KT0JYfDIyfFNUfFJWX1ByZWReUlZfUHJlZF5MfHwyLjA4fEx8fHx8fEZ8fHx8fHwgDQpPQlh8MjN8U1R8UlZfJVByZWReUlZfJVByZWReTHx8NjAuNjZ8JXx8fHx8Rnx8fHx8fCANCk9CWHwyNHxTVHwxOTg2Mi0yX0Jlc3ReVExDX0Jlc3ReTE58fDUuMDl8THx8fHx8Rnx8fHx8fCANCk9CWHwyNXxTVHwxOTg2Mi0yX1ByZWReVExDX1ByZWReTE58fDYuMjd8THx8fHx8Rnx8fHx8fCANCk9CWHwyNnxTVHwxOTg2Mi0yXyVQcmVkXlRMQ18lUHJlZF5MTnx8ODEuMTZ8JXx8fHx8Rnx8fHx8fCANCk9CWHwyN3xTVHxSVi9UTENfQmVzdF5SVi9UTENfQmVzdF5MfHwyNC44M3wlfHx8fHxGfHx8fHx8IA0KT0JYfDI4fFNUfFJWL1RMQ19QcmVkXlJWL1RMQ19QcmVkXkx8fDMyLjY0fCV8fHx8fEZ8fHx8fHwgDQpPQlh8Mjl8U1R8UlYvVExDXyVQcmVkXlJWL1RMQ18lUHJlZF5MfHw3Ni4wN3wlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XkRMQ098fHx8fHx8fHx8fHx8fHx8IA0KT0JSfDN8fE9CUl4zNF8xMDAyMjAyM18xMDM1MzReRExDT3xETENPfHx8MjAyMzAyMTAxMDM1MzR8fHx8fHx8fHx8fHx8fHx8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwzMHxTVHxCSFRfQmVzdF5Ib2xkVGltZV9CZXN0Xkx8fDExLjIxfHNlY3x8fHx8Rnx8fHx8fCANCk9CWHwzMXxTVHxCSFRfUHJlZF5Ib2xkVGltZV9QcmVkXkx8fDAuMHxzZWN8fHx8fEZ8fHx8fHwgDQpPQlh8MzJ8U1R8QkhUXyVQcmVkXkhvbGRUaW1lXyVQcmVkXkx8fDAuMHwlfHx8fHxGfHx8fHx8IA0KT0JYfDMzfFNUfERMY29fQmVzdF5ETGNvX0Jlc3ReTHx8MjAuNzZ8bUwvbWluL21tSGd8fHx8fEZ8fHx8fHwgDQpPQlh8MzR8U1R8RExjb19QcmVkXkRMY29fUHJlZF5MfHwyMy43MnxtTC9taW4vbW1IZ3x8fHx8Rnx8fHx8fCANCk9CWHwzNXxTVHxETGNvXyVQcmVkXkRMY29fJVByZWReTHx8ODcuNTF8JXx8fHx8Rnx8fHx8fCANCk9CWHwzNnxTVHxWQV9CZXN0XlZBX0Jlc3ReTHx8NS4yM3xMfHx8fHxGfHx8fHx8IA0KT0JYfDM3fFNUfFZBX1ByZWReVkFfUHJlZF5MfHw1LjYyfEx8fHx8fEZ8fHx8fHwgDQpPQlh8Mzh8U1R8VkFfJVByZWReVkFfJVByZWReTHx8OTMuMDJ8JXx8fHx8Rnx8fHx8fCANCk9CWHwzOXxTVHxETGNvL1ZBX0Jlc3ReRExjby9WQV9CZXN0Xkx8fDMuOTd8bUwvbWluL21tSGcvTHx8fHx8Rnx8fHx8fCANCk9CWHw0MHxTVHxETGNvL1ZBX1ByZWReRExjby9WQV9QcmVkXkx8fDQuMjV8bUwvbWluL21tSGcvTHx8fHx8Rnx8fHx8fCANCk9CWHw0MXxTVHxETGNvL1ZBXyVQcmVkXkRMY28vVkFfJVByZWReTHx8OTMuNDF8JXx8fHx8Rnx8fHx8fCANCk9CWHw0MnxTVHxWSV9CZXN0XlZJX0Jlc3ReTHx8My4xNHxMfHx8fHxGfHx8fHx8IA0KT0JYfDQzfFNUfFZJX1ByZWReVklfUHJlZF5MfHwwLjB8THx8fHx8Rnx8fHx8fCANCk9CWHw0NHxTVHxWSV8lUHJlZF5WSV8lUHJlZF5MfHwwLjB8JXx8fHx8Rnx8fHx8fCANCk9CWHw0NXxTVHxETFFBX0Jlc3ReREwgUUFfQmVzdF5MfHxDfEx8fHx8fEZ8fHx8fHwgDQpPQlh8NDZ8U1R8RExRQV9QcmVkXkRMIFFBX1ByZWReTHx8QXxMfHx8fHxGfHx8fHx8IA0KT0JYfDQ3fFNUfERMUUFfJVByZWReREwgUUFfJVByZWReTHx8NzUuMHwlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XlN1bW1hcnkgUmVwb3J0fHx8fHx8fHx8fHx8fHx8fCANCk9CUnw0fHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XlN1bW1hcnkgUmVwb3J0fERMQ098fHwyMDIzMDIxMDEwMzUzNHx8fHx8fHx8fHx8fHx8fHx8UEZ8Rnx8fHx8fHx8fHx8IA0KT0JYfDQ4fEVEfDU4NDc3LTFeUHVsbW9uYXJ5IEZ1bmN0aW9uIFRlc3QgUmVwb3J0XlZTUFVMUnx8XkFQXlBERl5CYXNlNjReSlZCRVJpMHhMalFLSmRQMHpPRUtNU0F3SUc5aWFnbzhQQW92UTNKbFlYUnBiMjVFWVhSbEtFUTZNakF5TXpBeU1USXhORFUwTWpRdE1EVW5NREFuS1FvdlEzSmxZWFJ2Y2loUVJFWnphR0Z5Y0NBeExqTXlMakkyTURndGR5QmNLSGQzZHk1d1pHWnphR0Z5Y0M1dVpYUmNLU2tLTDFCeWIyUjFZMlZ5S0ZCRVJuTm9ZWEp3SURFdU16SXVNall3T0MxM0lGd29kM2QzTG5Ca1puTm9ZWEp3TG01bGRGd3BLUW8rUGdwbGJtUnZZbW9LTWlBd0lHOWlhZ284UEFvdlZIbHdaUzlEWVhSaGJHOW5DaTlRWVdkbGN5QXpJREFnVWdvK1BncGxibVJ2WW1vS015QXdJRzlpYWdvOFBBb3ZWSGx3WlM5UVlXZGxjd292UTI5MWJuUWdOQW92UzJsa2MxczBJREFnVWlBMU9TQXdJRklnTnpNZ01DQlNJRGcxSURBZ1VsMEtQajRLWlc1a2IySnFDalFnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0ZuWlFvdlRXVmthV0ZDYjNoYk1DQXdJRFl4TWlBM09USmRDaTlRWVhKbGJuUWdNeUF3SUZJS0wwTnZiblJsYm5SeklEVWdNQ0JTQ2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEWWdNQ0JTQ2k5SFV6RWdNVEVnTUNCU0NpOUhVeklnTVRVZ01DQlNDaTlIVXpNZ01Ua2dNQ0JTQ2k5SFV6UWdNak1nTUNCU0NpOUhVelVnTXpVZ01DQlNDaTlIVXpZZ016a2dNQ0JTQ2k5SFV6Y2dORE1nTUNCU0NpOUhVemdnTkRVZ01DQlNDaTlIVXprZ05EY2dNQ0JTQ2k5SFV6RXdJRFE1SURBZ1Vnb3ZSMU14TVNBMU1TQXdJRklLTDBkVE1USWdOVE1nTUNCU0NpOUhVekV6SURVMUlEQWdVZ28rUGdvdlJtOXVkQW84UEFvdlJqQWdNVEFnTUNCU0NpOUdNU0F6TUNBd0lGSUtMMFl5SURNMElEQWdVZ28rUGdvdlVHRjBkR1Z5YmdvOFBBb3ZVR0V3SURFeUlEQWdVZ292VUdFeElERTJJREFnVWdvdlVHRXlJREl3SURBZ1Vnb3ZVR0V6SURJMElEQWdVZ292VUdFMElETTJJREFnVWdvdlVHRTFJRFF3SURBZ1Vnb3ZVR0UySURVMklEQWdVZ28rUGdvdlUyaGhaR2x1WndvOFBBb3ZVMmd3SURRMElEQWdVZ292VTJneElEUTJJREFnVWdvdlUyZ3lJRFE0SURBZ1Vnb3ZVMmd6SURVd0lEQWdVZ292VTJnMElEVXlJREFnVWdvdlUyZzFJRFUwSURBZ1VnbytQZ28rUGdvdlIzSnZkWEFLUER3S0wwTlRMMFJsZG1salpWSkhRZ292VXk5VWNtRnVjM0JoY21WdVkza0tMMGtnWm1Gc2MyVUtMMHNnWm1Gc2MyVUtQajRLUGo0S1pXNWtiMkpxQ2pVZ01DQnZZbW9LUER3S0wweGxibWQwYUNBeE56azNNQW92Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsQ2o0K0NuTjBjbVZoYlFwNG5PMTlXNDlrdVkzbXUzOUZ2Q3dHR0tDUGRiOE1CZ2FxeXQwTkREREF6bllETThCaUg3enQydzdhUFdPN3NjYnNyMStSbENMamN2anBSR1ZtWlVibUNUc3JzeU1ZT2hJbFVTUkZmdnp6NGI4ZHZ2cnE4UEYzZi9nL1AzMzZqNTkrL3QxUFAvL2ljREJMamdmVC92ZFYveXRYZC9qaFQrMlRyNnd4aCsvL1gvdXJmL04vMHpjUG4zN3owLy85elYvYnU0ZUQ1Uy9hZzB0TGlDa2ZmL1BYTDc3MjdZLy85WjkvbEs4ZDZHdExLcTc5VzMwK0hQN3loLzcrTDcvOXpoeitNS2crZmovZS9xWjF6eDYrLzMzL2IxY1g3L25aOHBmTmNTblZwb04xWWZHMTllRDdQejA4NmZEOWJ3Ly9hSXozeHNSaVRQaW0vVGJ0eDdXZk5zUVEydS8yUnZ6VTNtdzByZ29kZjViYTc5eCtmM3FnTi81WDMvOTdiNzB1SnR1SEorU0hUOHdTL1BHRFFNMzFwazYvYnBjWTg4UFg0K25YVHo3Z3IvdmVBK3JweVhPK0ZoNzlpN0Q2ZHovOTlwVFIycnc5ekZ6NzhXV3g5V0hTMExjZXZwZmF2OGN2WEh6bHYvL201ejhlUDZGQnRobjYyOGtiNXZCUFovLzE3NmZFNXZEUHB4OHVPYWV6ZncvLzQ5dXpMNXZEbjA3K081clVCdFBlL1BIa3plK09mNTl3NmFTVEorK2VqWFlMSDB6anhDdmtRK3VhZTNvZW5BM29ZamluZzdFblE4RTliOUxtcE4vRXpCOVAvc3MxR1pIOCtHVmswUjAvejJmVC9OMzFRRTY2cTBzaTRaMDVrVUdYVXVoRURsMUxvZ014MmdpLzI1elp0dndlWk0rNTlIbllzN3k5VDZSRGVCQXlvUXNla1JSTkdPWCtYaFk2cGlFQmxrNmIrL3I3NjlHZmpYTGJVbmI2bnI3Z0djczNsMW5LV2ZxM0NidFREbDd6OEl5TGEzeTg1S1JmMGlrblQzbnBQZ2xqN0svUHhla1pLM1JtVElkMnRTQWVPWndjMmdxbVl3cU42VVA3YVJOdDJ5UmJHbHY3Yjl1T0RQdXgvN1RGWUQ4OS9WaWZlUm85R25MdEIyczhQUjNiLzhlaGJHVHQyMS9menhTajhmb1A1K05veXMrWkRPQjlQZlo3dkx1cGptaXF2K2xUK2thbUdZNzExeWRpM1BZbFRyOC9YSXJ0dTVqV2pGWjBlbENsdzlkajVkN1hWTUx4ZmJyY3NlRkNLMy8wZkY0cWlmMHd0aWtzMGJweXJtYXZxbE5uTENIREtsNm9nbVp4cnYvRG41NHFVWWYrem8vbnp5aWlFZEIzTEZQOGNOYkhYTnRiUDE2K1JkK2lmNG84cGx3L3AxdytxTFZQMU9QYjB2RHB0MDU1OC91L255aXhMN3RWYWwxY0xoV2Y4dkhreUNOUi8vRkV6UXNQNHY4ZU5wQ0xkU2toUmp6Z1BpQXlwR21nck5MNC9qZXBPbzBabGdiODRjNEU0NWh0cU9DRVMvR1J3b1A0K0hDSFU0MUdheXRONVoxT1k1eW81dU5BRC9tK1Rybmp6S0VCMG40Y0NtaTQxeGxFNTdnckQrSjJxR1Fra1ZnVVozSDkzZFZzd3NHbWZwWjBzVHYwYmg0MC9XMmZTV2Z4b1UyRkwzN1hXUjcrZnQwNml5OWhvVVdCai9DUC9Rai8xQSt0ajdKcEhyOWhMaHhSRHlzcHVMQ0VhQzhYRXViVStuNWI0OUFGajlhNWRNcW5OUjNuN09pN0VKcG56RURzMkRDbXlmdy95ZmljSmNNR2o1RzlOV1Y0STU5dnZNODFoNkVzZFRxUDliN25NY1gybE5rOERuY0VIUWtmUDNPODJuWEI2NUJtbisyRWV4a3A1KzVHekEyRDdlTjlieFBmK0c0blkyVmRPRjU3ZU43SUZva1RKd1daQk81T3RPTGdLdThqTkNiMk85RHl0WDBKMS9zeWM0NFRsMmVhV3Z3aU1pdmRqY3d5NCtlK1pSYXQ4Wm5Jb2l0REp6NEs5ODJiRkZzVm5leHQ2Slp1SThwVDNReFBkMEhaZDhIRHcxN0pMakRsaVZmK1k4S0RvcTJMTFRrZjlNZ0tkWkZkaEZoaEg4eEtlTkZsZ05GbGlORlZrTkU4ek9nNjBPaHdjRDR2bHhGWHAvRkd1dU5qbzZoUkdYUVJlL1ZhR1hRVmkvV2szTGt0eU13ZXptMmZXVlJadm5ETHBYTmYyQ1JDNnpKRzY0bkMwSjRyZml1NnZsbEJGRmM2Q2VZY0R1UmpYT2dYRGRjNmlwWjdpZHJheExzN3V3TXRjZkYyRnRrMUhHZng1TnFUN0t0dituL0hIdDFGdis4dlBnUTZXOUtsc3lVZVB4dGJaRnlGYzBqUUNMVTI5N2NFNE5Wb24zSlNTOWtTTGRmcWFaT2g0WUU3OE9yWW03dGJKZkQ2TVYrTzlTSjBYbHlWMTFkM2NwdDFKOHNreXpLWk9WNWlQQjhiL2VhdGNYOXpEaU9yZkovU1R5ZVhrM2M4cmZtencwQytPYmxXdVgyT0g1ZTdZQVByaTIvVk5Gbk5CdGx0azdOM2R0dmtldUNQc0UwK2Q2dDllVTM5d3NhNWlnY3FQZGhwQ09ZZUg4U2FlanJKbmhzcTIwV1czRDBJYjB1dWk1TFk0Q3VxN3FhNHp1N2dBSTVvanVPVmFuNGUybnpVdzJOUGgreFpHbkpRcldRcTlVVnhqSkJMZDdZSTR0dGNCTWhsVG1rWjlPUHZiY09pUVhIbWxMOTJCRCt6Tm5YMHg3eHhwV3IzOSs0NjFaUHBWSWZYckFYNWJvMWZhRUxubXM0ZENFM3ppQ1NGZklLWmtPVlF2M1pjbmJocm9NZnYwME1DNE5BaVRwM21vWjRFTG45ekhXWDQyUUo4L1YxZDZEd0lITHA0anU1V2NJU21lYjFaOFo5alhzd3Uvd0dIZHZtL052RFBsUDlQSkF6OXdJdVJ2NnhMUzJXbmZWMXFMWDdyRVdEdHM0V1UyQlNYNUZPR1V1RHEyMmNlaG5MK3pmbDNnZkM1K3ZyVjlwS3YvKzNxdmNzOUp1LzkrL1YzTC9jYUUwNzNtelIzdWVmb1JZZGN1UkpNOVBydTRoMXRMVjU4dHNLeDdSeTlFbFpYWDMvOUhGMlJaUFI2Sm5hdThPT2FHOWU4c0ZlYzJETGtTMUVuNzZXcjBjNUZIcjN5eXJMN1R1UER4VGdSaDJiTDdhdWo5R2lLYk1vazJYWWhzQXVCWFFpOEp5RndUTCtzVFFSY0t4QzNyVmRyRnNJZm1xemFsZkJQNGROYWVDdTkxa0kvNlhVUi9zbWtxeUdnM010TExTNDBxOWJhcHNHZEF2NmRkK2RhajdzMFgrWDE5ZmY2ZWw0Wkxab3YvYk9OS3Y2S0Y0UXdHYzNpYXJQTWwyYXhQNE5Hbk9waTBsd2pkdkVraUN1L1d1Zkh4ZWljaVl2TEcwYjNvV2YyMjdzWm1Xc2pDck54bWRLRFNKN2NubGxacTAxRTBpcmx6R3B2MGpPTXVmb2xrNm4wSnRlcTV4bmRNTHE3VzZzK05vRzl3ZXArdnRXcVd0K3V0cldLODgxMzI3czN0NnAydHkrRVhlMitKTnpWN3JUYjNyc1EySVhBTGdUZXBoQTQydDZwYWFSeE43MVB1N09HZTMzOGZJbnVTTUlYNlN2bytBK3YxMjJkUDQrMkhCcVBhOW11TGJ1ZUpIRk1IUGp3RkdCdTRESTJsTS9WbGlQY0pxdGlhSHpWTERiRjZ5MHlneGpyTEx1QUdSdnZJcWd4ZW9YczJ4U3NpSmlRdytKSUh0RWZvVW9yeDcvalNrUEhqMzdVUG1wMmMyL1dqZ2ZicTRhb0JYc3RLenYyMmFHam9hMTE0WksxSndCbDlFSkh5VTFuNzBVSTNFb0xyME9TbVcxaWpKTDRDRVhRMTU3TjVlaTlOVm5sRjNNU0RsUFhwVjk2YURnOWdjRGJ5TmxwaGo2ejdqbTRYTU1TUTl6RzZ1c0UvdWZqeUJjK05kM0dRNU5EV0Q5MHRKcDhuUmI2bkN5WitKcWZrejBqQkdJYmp6NzJYRXJiY3l2OVcxMDJMdGlsaEkxY0dabW1INzdzUnBwNGZaK1RPK0s2Mjc1bVB2WTFVOWVBeko2UFExOTJ6ZmlVbHNpWjZadFhUZWg1eWMrd2FoUkxXNVNGWUhOWGRKc0NWRmEwQm1hUlhXUFJMMXZEUC8vdUx6OGRmdmdyL1cwT2YvM2hwOVZoMm5Db2g3Lzg3bkQxNFlYNmd4V2dWem5USWJqRjV1M255cFBNNzlNNWFaeGIvRm1BN1dvamNBR3BWc0UydTBDekRMYlpCc0E2dU4wK2dCYkNyVGFDWmlWc3N4T3VMWVhIYlpiVlpUQzNHTFp0T2JUcDlHMjN1dkhRMXJ2UmVqaTNIOVoySGV2a3BVek1oUzBHdzhvT25zdm96Y3pkWkRnOEs2TnJXa3JDeDlrWnU3LzU4a3g2bVJYWXp2akZGcXcwbngwQlEyWCt1QVpiTGE5blhVcGJ6SXZuNVZoMlMzSGIxOUlaeDlKN1dWZk9SaWtMdW5YSGxYZkRtVkRid3IxaHgzMlNIL01TdTIyTFdmYTgzS3E1NlN5ZklaL3lkYjNEOFhwN2E4cjdzdFI4dy9rVzN3MW5tbnA3MjFZTHo3blZWZzJSbTJ4WjVwWmI1OWFGUFd0WDdkbUpSYnVpcHM4VTlXMnErc2tvZlNLSGxGa2YzcmJsaEJjVVdsTEtvc0xMNm1iVi9XeFptZlhsdExxZ3RpeXB1MkZTWEdZeTZYTDdhVnZ2czNtRlhRMnp6NS9PVVJIQ2t1TDBVbXQzVkp4OXVEc3Fyb2IwNmgwVnB4ZWR1NnRoZHpWOHZxc2hudFRiK0xpN0dtNHdmc0oxUmRUeCt2b051aHJhcjNERGpndnZoalBUbTkvYjduNTNad04zZEgyLytWL3R6b2FMenIwN1o4T0dXL1BWSFpmdndPZmdOL2tjM081emVENXpldmM1ckx3ZTZYT0liOWpuME1SUkxidkg0ZUVidThkQmJlWGJlL2M0ME85alBaVHlmdTQzMmtLN1FXTTE3NFV4d1MvVzNzQ1lEeThVei9EaS9xb1NscExqZG5lVkpDOE1LTytRZHZmVlplY3UzRmQ1ajVTNTBaeW0wazM1Vjd1VDVxeHJKeVpqUnFIV3U1T0dPL3JBc2R4WEZVbjQzUlZ4MWJtTDJ1enBEbHdSWVpNcndyK01LK0xiVjZjSTlVVGdXNlR3MDY2Q3o3ZDNYMG02dGIxT3R5NExZK1daL2xkVG9PcFNqTmZ4bGk1aXM4OVMyUDNWaCtta2x0K2ppenFDTEd3YkhJbnhESEt4VjZiMGlZbzEyNVZGL0FBOHZ3YXZmd1lOY0hYRFpaWjZVb1JtRklmc1ZmOUdVcnRnMEF0cy9DaE1jL3I1TllSQVh0eEpqSDIrZnVyRFhEM2doVjFYUlBuY1l0a3dGOTVoeklqVjdhZ0pvblVoZENXQU5PRnpObk51cWZGYTBweE0zZ2s0bDFSYkZ5dCsxSVNpLytaeVFIVWQxQ0V1aGt1emFaUENhOVN2emdzMXpZVVl4c1NQZWdJbnBST05QMEZENkF1R3F4VzVrellHdGxoNUtFSkwzV1dhNDFDdU8zWWhRTEh3dk1YZForTlMwK3ZNbXA4dmpVZUFmbnpPK2prYzJxbm9NMXhCcjNnTnZTNU1FM1MrMUxBNEI4OFhJTitzV3dHMnVtbEx6TnpmRStmcEtxN1dWcVgyYnl2dnJtRkIwYnRybXRZcUh0U3E1MzBGRVVyMjA1cXFWL0phVlV0NWZYZWo3anU3NmJqUlVmM21lSzBnY0Qwem94K0ZUR1lQYTNKd0d3aFpYcjNxU1dzWEpadHd1ZGFSdWI0c0lOd1JxTSsxazRzY3BidEl1WHJ0SW1VWEtjZnU3U0pscTM1U3ZXeWJSOGtUZ1B6M3lqMVRucndjRzcxU2N3aitWK09aMnVBK1dlWDNKcGZKR25ldmI2cmFnckFhQlBoNWFKNE9jZjY1N29vWEdHKzJpOCtieG5zc1dIdXZZM1dtTGpIYkRXUDE1V25IaXVCTGd5SE5hTGZVTG9rZmVkUzM4Nkd1SXlMdmF0VVY4YTVXTWQyeVcyb0g1OTFpL1NxaytpNVVkcUd5QzVWajkzYWhzdGxXcTdKdGRsdHRnNjJtd1pEZGhOcStHM1FQSVdLSmltYlBWZjVmOThETTFQa2JyekhjNzhqVXFXNnBiajVxUXJBL3IvVjByeVAyMFVrMDl6c3gzSDJwU3pKYnh2dTJWallsb3dXL1pkeHZaMjJINGhhWE5xM3RYb2xDQW5MdWRielJOUnRrby9SNmpoSERxS0ZRSHVPcWlYZWNVaGF6Vy94NmhXZjZLSkVhU244UXFpcTFkUHc3S28zMUQzL1VQOHhsTkczSDQvZVVzc1ByVGluYjBYYXZ5SGNJSEkweDdxWWNvbkJ6T3N5N0FvNjFPU3lrODN3V1N0Qzd3ZUFnekpzVWJrNkIrZmljS1RCVERBWVg0MkozREliRGpzRXd1dGo1NUUvSzhIeHBMSVpYdnRHOWlVdEk5NEVXL1RKbnFtOVNwYnd5Zk9pcEtQUzFMQ2x5QnRFdURIZGh1Q1lNcTM1V3YxZGhHRUs1TFpYeDJmRzg1N2hUcFNscWVkL285Tm8zK3VwR1Q3cDU5NlUyK2lRdk83cXdCRHF0Sm5uWmNWTmVkbmlsRUhFeFdCbmx2bFgzclhxNFBFZGVHVWpjclE1YnRVN2ViWklBZU8rMyt1OTFELzVXSHo3MDRuK09IMy9peWIvZGw2OTc4N2Y2ODljOCtsOUFCdXFlL2NNYmxIOWJ3T3EvaEN6YzZMSC9Bc3piNUxuZjRydS96eVBFM2NBcTYrT1M2ZzJIeUFadzlzT2JQM2kzdWZkWEhmeFJkL0MvZmI1dGNmaXZycllQTHl2YVhwaHJxY25UL0JrMldYNEdtK3grdUZZTElkNXM1OXFHd2dHSE4zOGUrRmdFNmVMelRvUjNLOW1DOFVzdDZYTjJLWjBJOWQzeUxkZ2wxNXY0dHFIY3dGUHhUYlUwdHJ0R3Q4L0ViQzd3Yktqek1adVJ6N0E5dG5sZmxFbllOZzEzeUxZdDNoajF3dmpqczNCeDdrRGQ1amk1MFluS0xFOGF5eThjcVZGeHBFNWRxYXVPaExrcjRmWXRQbk9wSHZZdGZ2bmF0L2lHdWh6UHZMVy9yR3RXclF5NnUyYkhkM2JYN1B0MnpVck5BYWZxK240eER6aU5YaVhiRXBuOXp2eTlZWWtoYnArVzkydmVFeFRsZGt2cjQ0bDE3OSt6ZFc5VFdvcTl5VXF0SndITEwzd3g4OEorT0pPYTlueVRyL3hqL3htOCs3QjdmbS8wS1gzUTQwTGZQdGU4RFV1K1JjNlo4Zk9yZDNvcytGQ1dIQit4UXovKzZ2dmQ3M3VELzNMd3JieGJ2dEU5UTc2SmIyOXlsOTdFTTZvWmxIYWUzUlFpMXlSYnFUZHBIOC9Gc3kvcmoxR3FwdTdlbVBHZDNSdnpicjB4ZVhlYStFTTFTekxsQnNFNEs1WjVPTHo5WURsUGFDamJqNUxUak9WM3Erclo0cHJhOGlxTzRMdmhtU1BjbloxaHQzaEt5bEwzSmJaN1NaNDFOaTQzVmZBbSsyc2NBRnp2OWxmdmRLVUYydzZBc051dHUzOWs5NCtzZG1iM2oxeFFmSVovQkgycWY2Wi9nZzNwQndQYSs3UkVmMmxFWXllTDVmOWR6cmxoSDRZbmpGeHIwMVhRMjVrelFIY0R6QndBbytmbDhDajBSRGZEa0ZZbVdWL3VONVhvMUk1dEsrMjNYeTZRUzZySmdvU3JkSzZIWTVnbEdyMnc4YUJKRHlUcmdSZzNscmU4emNjWDJiWDBDdUhtWllvMWlIbkZGeGhOSWdBY3pTWDNIUklYYzAvWTYrSkJFNzJRQ2Z6NWwrTkMyM2w1L1pENTgzcjNqLzEwU21qdXYvNzlZUzJrOStPL0hYNzUzUi9ONGE5L1BIejliNGQvdVhFd1Qra2YzN3AzRUhaTTA4OGlDUUVUbmg4dXlzdUM4dlIvS3VUZERGNi9mbFNmUkRuOWV2MkFmanhlek9UV3dEVmR3cVJNd3ZHSFArbWJRN3NzT0hpSytuNGUrSXhKejcyTmk2czIzVi9QZzYxTHRNbStocDYveEVhZFhuVjgxYStYcGxjZGFnb0UxdFRsS1NvVFB6TlpZUjdsZlJzWGtsdEtMSDVuaEhWcGNYWWpUTTdiNWtTaFduejczamk0NkpicS9iNDUyakdZNERINGpqaVJLNVVNZXZkOENNRXZ4dXdIaDVnK1BxVTN1RGVlTnY3SW1VY1pWeXAzbmhLRDk4RlpaSmRZRkZmUnJWQkxYd0NPRXlqRjIvTjUvNllzdlg5UzNsLzM5U3IrRCt3QlFYNmdxU2RvelF0eWM5YnY2K1dMNmh1YWU0ZWVsek50NHhYdEt1TFAybUNtbmlMVlZ6UzhSVmIxRnIyRTdOKzY3L0NGejlSejlBeVgyU2NlSko4WFg1UHVRdHJpUkhxcW03RXA0TURNbWJUbExQVlBmcGJlT29xWlkraytSakZ6TXIzTUtGNXVsMi9BamtCdXA2M3NuOE1mVEJWR2hiVmJsc2ljdmJkelplS0dlcitNbWJtbDNqRm5zSnZxL1RKbTVyWjZ2NXladWJIZU1XZWdXK3Y5OG1YbTVucS9uSm01dmQ0S1o3NnNreXpjazVQTTNPd2d3NEEzN2RqSytURER1OWtRWmJYNzNJNWYySDF1NjErNFg1OWJmUUdmbTl0OWJwZXZ4L3JjR01pbDdqNDNlZTArdDkzbmRqYkszZWVtVWV3K040Vmk5N2xwRkx2UFRhSFlmVzRheGU1ejB5aDJuOXM2eGU1ejB5aDJuNXRHOFN3K04venAzRUxVZUxOdURWN1pnVnE2cmUyelNMK2FURnhKckgwdytMdzNKa1pCMXpIdGJ4Zmx2Nk5yUDVZUWQ5clBSL252a052UHAvYnpUZnNKN2IzYzZhaU16SXJoZUdFeVltTnh2a0xQRmZZeXl3S2RlRUMvQ2t1cWlremNzcmFQTW1TeFZSV3RhUEYzMWZpbGl2V2FRM20wWXdOczdLZlBIajl4QnRlOU11L0Q2NEV4WVJOajdya01ieXhMU3BydXUrL2FyL1pkZS9YNjg5dll0Zm1PZDYxMWJqSE81bjNiSG1BejMrN2I5dmo2ODl2WXR1bWV0MjJKQW4yN2IxclF6TGY3cGoyKy92dzJObTI4NDAzcnFKeUNMN3VLZkUzdzUzM2J2dWx0Rys1NDJ4SWlxcW1hdi9XV2JldGU1N2I5TXJHRVpsc3NZWjdGRW1ybHhqNGoyTzlKVjBuT1M0aHhYeVNucjVkYkpPRlZMcElRekZMc1V6ako5bFh5Rktza3ZzcFZFazNUNzdMZEQ1eXoxOHV0a3ZTRlZza05WNVliTHVFZWVRZm5qRnVTTDNYRElueFZ1UWpUNlhUZnlJKzM2emVqOUhwaEFlQnFYRnpaWkNqZUYrKzkxN0k1WWdsSHFoZzFLdjlRNHBoTHpveEw3eVFYM3ZMZXE1elNZRzNibEM2L3ZTa3RZenU5QWltcGY2Wi9nbWZ4SkNrcnVoM1JlK1g3TzZMM1lVZjBYdnRzUi9SK2hZamUxbnhCU0crL1Ezby9BdExiWmR1T0NGdDNUTytWdnUrWTNqdW10OWJRanVtOUliSHIvVEJpeC9UZU1iMzdhOGYwSHE4ZDAzdThka3h2ZWUyWTN1TzFZM3Jmb3JidG1ONm5yeHZOcXgxZmFNY1hXdnZ3eGZHRnJIMEJnS0d3QXd4ZHZoNExNTlJzbitoTTJnR0crTFVERE8wQVEyZWozQUdHTklvZFlFaWgyQUdHTklvZFlFaWgyQUdHTklvZFlFaWoyQUdHMWlsMmdDR05ZZ2NZMGloMlVPOFQ4aDNVZTNlNjdVNjN0UTlmM3VubVhzRHBGbmVuMitYcmtVNjNZRVBUdUtyZG5XNzgycDF1dTlQdGJKUzcwMDJqMkoxdUNzWHVkTk1vZHFlYlFyRTczVFNLM2VtbVVleE90M1dLM2VtbVVleE9ONDFpUi9XK2ZMQ2VBOTEwMkFmSEY4TjI5NHptSGZaN3JaMGRIVTMxZklDZHY2T2p2VlowdEIzMmU5KzErNjVkN2NRcjNyVTc3UGUrYmZkdHU5NkpWN3h0ZDlqdmZkUHVtM2F0RTY5NDArNnczL3UyM2JmdGVpZGU4YmJkWWI5WkFDdzdDdXNhZTA1MjJRNzd2UytTSGZaN1h5WHkybUcvOTFVeVhqdnM5MjJYY0R2czkyVlhkdGp2L3RwaHYvbjFSVS8rSGZiNytIbytLYWwvcG4rQ1ovRW9Vd21tdTF3YmdiTTFjUHorOWNUUGw0OVpVbkJWV2xpTXovelhGcW4rRDRlLysrR1B2L25MejM5M3hYdHE0WHBDWGFIM2YxeDkzK1cxVC9UMzE5NjkxZ2YrZFNVVlpac3ZLWGpLY1hHRWkzc3JHUEcyd0trSFp4VkZsQ3N4V00rZXZ2US8vU0g4TDNQNDdYcHJTNm5oN0Y4dHo2bHh5em12NURtNUxKKytSUGJYRytPeE1Zakh4dXc4WG0zdEZoN2JuQUdQNmRPZHgydXQzY1RqaUdRRmZicnplSzIxbTNqc2theWdUM2NlcjdWMkU0OU5Ranh1bis0OFhtdnRGaDRYSkNyS0xpa2V6K0ZZQVlmYmh6dUgxMXE3aGNNZWlRbS9TNGtua01RT0NXTDNoQnllcDV5OEVnT3o4WXdjUVNmL2F2ZjJvcEV0WHBPMHdTOHVOUks3V0t0d3NwRkV5Z1F2U3dBa3hUV1N1RGhOaHc1aHNkU0tYWExRU1VMcmk4OUxTVHBKc1kzRUwwa1RYcTBUdGpUK1Y5Q1h1RVRDdVNCc0JaMmtVazIxdXBTaWthUWx0RUhiUUpRcVNmdTZ0V1l4Nm9NeStTU3RpVlREVFNVaFdBNWpGcXZ5cFUzT29jYkZPNTJncGtNMWk5cENYV0k0bEtUM05MYm54ME5wRStoMWlsd1BPUzlKNDN4YloyMktzMStxMm9halVlWW11cUpPMFppYU1vRnZLeFJ0ZVlSRGFpeFYreEZvN3BJSG81MVRSQnB0YWl4Vng1SVhSOGZzWXJScGlXWEprZjYxMmxOYSt6NVNTeXJIRXNWZlV4dE80MGNiUmJOdFd6OVVhZGw0MWJncHoxSW9NczFjc291MlNsTnRTN0E5U1ozN2JCZGY2VW5hRW16TElrU2VXTzBadVhVejBaUFV4ZEVXWDNiMEtGVlc1YnBVUjg5U0Y4ZWNvbTJDSm45eUlMbXFVSGpLdzJ2OXpWby9TcVFGMXZwcnRkRVdGZzI1TFJGdFlrdWxDU3VHK0xaT1VTMUYrUmEzYUROZm1la2w2R3UwaVpYRzd0YmRxZzJsOG81djNTMmFhSytWNUhicnJxclZXMk5aUXRtbFJKVWswQ25WZWx5cVNwSkk3TGN1MTZTU0ZHSjhMWXRSKzlJRWRrd2ljVlVTdDZRbTJrMFRWMW1sQ1RSMTFHM25WSnBFQStaK2gwZlJGSkpHTkRoMVBWbG5TSGJUNkp6S1l5Zmphc1B6ZWp1QjBOVm9lRW5sRDZHRkorbTZ5aDlYbG1qNWtMWGFDcmVlRjdlbFdnc3FDZmZWT3ErdlArdmJYZzNjSy9VTXRUNlJDS1ZlQmYxWmhlYVNlcVdPS2hoYUV0UXJmWmtHUnl2WituWkVxUnhzdWs0N2UwZ2RNdXF3V0Y4cVlMRTMzYUZwMTlTbnJJNHBzSkpEZlZLRkppbUloZFEzcjBzQjBqUGJNY05hWUhnVVRac2s2bk1DeTR0eUJRTVBMNnRNVHBibktoUkU0MG5aSkJhb3A3aE5pUVNnYmRxTjEya3FEWWhvMUVlMVE2bnhqamlwbW9XMkhTa3hNSTJxWk5sMlpGQzUzK2gwa1cxemxTNDdzTlBiSVViVDNtaUNPaFYwTGlTbVVic3NLaU9SWkoyR2p3YWlxV3FYQytrUHRENVVROFNTK2xxSFBUT2pVVTBWOE9HNnRmV2lTRmZQYmt1Nkd6MEJUdkVFOVBMSEovL2lXd0xkSnUwWEJmb2tUd20rMnlmc2xGNmJzTlJFWHpOTm00N1NSRnZiNS9xRWtTck1Ub0tvK3hGc1l2bW5tOVNlaEJHVEJKM0VpeFNOb0JYU0I1ckExcTF1VHhZRXlmMmlVNUFib1owd0dYZ2ErQkR5K2tIVlNKTG44OWNBVDRPbk05d3U2aVY1NjRUM3JMMVk5VUdaRHp2cmRUT3g4WU9VanFZaUJ0VXFibWRUSkwxWGV3ekpYazh1Z0toSjRNajJWN05JZE5PNzBLblVqaWpWRmpWc3ZVZTFGNG5WKzZRZnBPMDRibXNzRVZpQWJvcTJCVURBZFpxRjU5amN0Y0JZcGZnNWNrTjRZR21TbGVoMERhN1paZTBoUWZjZ05TT1J2Q0dXRnFOQ2tiZ25xaDFhU0JIUHJMS3I5aCtOd3dJSzl0MjFwNmgyVEUyMGNkdXNWOVc4YXlvV0VlaktiTFB1MmtQQTZyU0dYUWVVQTZFM2trZ1ZMa0E2c0hGSEZLb1cxb3lmN01nZ1Z2MDZ0TTlNb1VhU2JyVkZNamxhSzE0My9qTHRsWkowUTZIWlBXMWJsNnI3Tzhqc2FUcHdCZXBYa3h1TkcyMFNkZjNlUmVwbU05S0RPaDZYV1lscnM2VGJMTTB1YW4waFR5VXdqd3pOa0RVVmFIR2UvVUJrWVFJYUo1YXEweVVlT1lIWlJSdUl6eHBOVzliTWFLOWJoa244eFVaM3dKSU41aXpQUnRBZlZVakdrLzJzV3paZXJJUkdveXV3Z2Qyc05Ha3VBWnFhZVViMFZVeWVkcUdwK3JNY3UvWmQxZmRMdnlEdzBJQnNNMUZrWXRYdFRZZGxFS3RZcDJGUnh4T2JBQTFaTGMyZVQzbzdTUzRTZEZjakdZN0c4ZVRyWHFEQU81aG9zbTZrRjVJVnRFQUNJQ0YxaEs0MTFQM1hqbTl1cGlCYlgydzZEOXk0VFhOaUFuMTFOU1VnaUQ5QWYxQ2pvZnNHVE5Qa2VXVWE2RE5JZFN4V2pjYnh3TnRpMVhjb1dhaUphUW9nS1hLN3BEc1ltM3JqbUFUMHh2T01COTFkU2lSa3hkUE8wVHNjV05NTnlBUFVhS2g0YUVDMmJLTXBsV25BcUNLUEN0eW9FRWtVa2doSUN1OVJpN3d5NUhhZ1N6b0xhTHkwRXoyZ1NaRnBDbXFuZXQ3cnVvc2pzdWQ4NGtuS1lpeEU0SEpwTk5rS2pRYzBOVEZOMU5kTzRUT2kwYVFLYUlLMGt3Q0orTWQwVDBrczR0TkxRTitLN0ZObG1nSm9nbGhCSmdFYW5pMXdMMGcwUlo2bHU4S2JQbS9sV2FwQ1RUUmV4cVVmSTQyR3JtNUQwbSs3aUlaYzRkUU84ZzJTL0plVEF2Z1BwVCtxUVVRMFBLTkpsLytKbFc5dUpnTWE2WEhTU1J6SmZhWkpnSVpzeVVaVEE2RGg2L3lzMzIwazBiN29haHFRVkNja09vMlhPYzlBWDI4MDhpUmQxMjRrb1FoTkJqUXBpYmNidFZNa2prSGZOdXhUQnJleGpZRDlIS0hvQmozUmVIbVFSelE4cUNZUUtxRHAvVW1ndzdMV0MzQVlONW9xL2RHdjF1aXlYUHBUQzZCaENWZnBsMDdEZTdpU2VxRFRoTXcwSHBDSVYxNlgyNDJFRjJrRk95OE81MzVBSFNiZGxXalFCWUNWZ2V1V1JxUGh5NFlLanJVa3JoNEtwQ2lBSmdnREt5Q0o0aVhUWmJJNFNaZ0dkVG1Mejg2aUxoZWhjWUNrZGhLOU8xbnVFUXd3YWhxTjdkY3NCZEIwSHlKWWdoSlJROE9xZ0NiMC9qaEFFemYwT1FtTlIyUFB2YytvUDBWb0F1cFBsV25YblNpSkRZaEpPNFVqc1hDZjVacVRmTFVKMEhnck5JQkVlZ01FV0dGQktNNUpuYVpmd09tcU8va0QvYkJkZEpvc1BkYjE2VVJlNHptSjBJQjd4VEkyQlRpSjY1Z3NJSmZaazBLbWxJRTBSZHp6OEg1UzR2d01vdW5pQ1p3Qm9qTlNPeFhSRkJ4VFNEU3g5d2ZSOEpST25pVTNFd2F4T2ZjcFJjMlF5VXRUaXRxcGNUS2wyUkIvK1ZrSjBIUU9Pa1RTTDF3UWpaT3JZbys2NCsyRVBVUlRKeXVzMFFSaFQwWDk2VmZYRmcwOXlRYXNGZEdVY2RtazArUTBXUm1adHpCZVlZMm1YOG5yVmxMbTdUQ1pDeXQzNEdqRloyNWd3aDg3ZG5MSWdLYlBlMER0OUhsM3FNOWVucVhienhSSEorUFNyYTFHRS91elBLS1JaM2swcmhSbis4S1M4NTU1aVBxY1pUMEgxRTZSWjNsRVU5MmNoMVdlcGFzSTJZMjFBY2J1dWtnb2lDSk9TWnkwb29leUVJMXNITjJsMldpOEREd0ZSTk1YYWdVMFFUWmdSTzJFT20rbkh4VWUwU1RwczY3VHlEVVpqd3VRWk5sYkVUWFRsekxpY3Nsem10ckZwVDZqZnJhT3ZhalZVQmI0SVhjZ2lmUTNvVWM1YVFaRUpubjIzOU1pRFlDbXI2NWFFSTIwb3l0WUZDemNoNFhhQ2IwZE5LN1krNU1SVFc4SDBTVFpmZW9SdVVlbG5ORS9OaXFGV2Q2RDNJb1Nsc0kwRXVTR1ZpMWJCVzVCaTVaYkNRdGFSK1NzaVFIdm9kRVppMmk4dVA0am9zbmNqazB6R25TL2tMM0V5cmtsenB1cGlEdERVdmtaZXhMa0lNdjVDRzRJSDNaWmdmTlp4VitJcEVmdFBrVVVpMm5LeEkvUWFGaTRvaWp3MFU1QWg0ckUrdElDczRoRzR0NXFtdE9BV1E4am1xdkFjY21VSmpRdUs3R2hMczVvSnYzWlJDTXJGVWo3SUNwU0lJRU9hR1NUbHRuUTBRWGZvSmwxbVI4MW5ZaUFOUEFnUGdMWWpBemF6dHF3NEk1d0xHUm9LUVpSTUEzYTU5UlJEdUJERFBZU0RBd2Y1Y09jd2QyTmpMc1RXZXhVMUo4ZWNwMW16UVJrMWdkUmZ1SlNaNnM0SWowaWlNTW40dTdRNVJYRnlTTnBXbVZ4d1YzdTVBNGE2ajRrS2VuV2FDcVpKdm9SZTA4aXNrNjhPTllpVm1lTG4wMkZCUFhUaVY1bU5KUHpzZlR6TWM3YUNjaDk0aVg4UGVEenVvaThNSkJHRGdCMDlzbXNHemVqbVkzY1Rjek56aHlMeEg5ZmhBWWQ2V0ZjRFNSNGpFZzdXRG9KalVVTGxYeGRsTzJCK2hQN1pROTZWdkx6ZHZMVXp4Zmthc0FoSDFXUTZYTEFOVGxvSnVJeXk4YUJ3Nm96SGJZMzQ1RGRHc1E5NStDalJCTzJhTko3MG9pRnpRaHpIQnA0MzhSNTFzeEUvZXFDSjgrbUllSmxta1crdzBleHNoeVJuUkE0cWd5cWxIVFBIeU5XVFl1RUJ1a1hOTG5mREtjRjlZVzNlVUwyZWhCWG1RTnhoS09kQUM0cE1xZk1zV1FxczJjRjVCNk9ReWtDR202VVRDdUwzTjV4T09hQXVJakRNK2NSbXltZ0R0NkQ1U2hlTjVCOG1PUHcyRnJVbmVoblVqbU82elNQdXBPRnhxRCtsSDZSaVByVFR4TFlUcFZ4VFVtZ0VJeUxMQXcwOENyeURRNjh1MzNCdGtuRDdRdXNrU1JyR1VVd2ovNUVFQ1ZPREJUajJxQjJ1bXlDejJMM2VrRDZZSlFiYnloV1lwZE5LTk14eW5WUldOQ3dvckRIUXBydUEwTHJxenNOSXRyR3FidHNFVTMzRHNOdFhQcHRDRnBpWlhyRGRWenZGaTZ4NlcxSWtwc0Y5SG0vUUUyQVp1NzZUUktZNFJEL2ttaG9EcmZUamU4WkNkem0yMGlFd1JVeGo2OUcwWWlDZEJmY0g2WnhHMTdRTExBVEdqMG9kbDlMbmRGTVJoM0ZycTUxL3F5SWxrU2NlUTQ3eWF3N1lqeFp4TDlZNXFzbWxvM1BRcEhTamFaekdVMVZ2NllzYU4zaytZeDNXWUxtb1Y5a1ZzU2Mwclh4R2NtRU43bk92RWhwMkJnRmRiblltY3FlaGxvZnB1MGdyMWNhbGk2VUZQMDh5MmdsOS9NTUtCOUpEcENJaFdTTUcyajZlUjltNGdJZWVrbVV2TWwwaGM1Q3RFVjludk5IMUErUHV1TzZpZ0xQSVdFejdMSVI5MDlHWnpDclhnbWZuVVZvb1ByQlFVRUpxLys4TkJKVy8xbWdnbWhxVXNrdGsyRHR2ekFOVkZIWTZaeDFQS0NqQlZXUVoxQXcxQnFOUjlZYXEvOG9ySmo4cHJRS0s3S3lKQk1tVG55MGJJbFZmS2REWmdSbEVjRDdvOEkwQ1RtazZQWTV3VmdDejk3TWhQSVRLVkRBTVUyQmNSUkZRdE5SM0FKWkFLRERscStlRThKQ3lSd0d4VEdiS01xTDFpa0ZqYUhZUG9xR29qZ0pGQVJIcHF4NE1UUWFCdERwQjQ5R2sxbWs1Z3F5RUVSNkZ4Zzl5bTV5V3h6cVR1Q2p0Z1FVMnlmWG5BWEJBeVcrRWJJRjVlZ2xCbmNoTEJPUXp5Q3BNQlZwRUczajBTRlpIWml1S1BISkZZMDlDcVFSMGFCTU5CS3BqVWJYQ2FQd3Azcmc4SXljRFUwMCt0NlNLRU9pMFdHRVFtVVBXUTNBNHFYY2lzUTArdGJwS1o0MWdIeGx5c1NpL2tTUXZpbVhKRFdpUjNHbUg5SG9MQXdTUzBkWWFYbzdScnFjZ1UvZFN6cHB6VUJKOVJKS1R5bmZlazZ6R1B2VWpycFVmZUJ3c1ZxQVZlYzVIcXFSNkJRU2pWZ0JEaUtsSUpPV1duWE1Ec3BrOXRJWmtDOHZnSnVFUjZCT3FHTzNoRE1vTlVLd3hKaEdiMGZpNUNwQUltSEV0Y3J0NkF5MGpGUktOTG9SWkRNTmlOdFJTZGlTZHdiRmpncGlHOUhvOFlxV1k4cm9VYm9UeUZwU1Vxa2RmZWlHUTZxNUNCaUM0bk0wTEE4dUJRM2JrVVFEVVA4WVpNT1pDSnpMaGhGcW5Fa2dEdE53Q0F2VGFNK3FuQkRwRE1nMHE1ek00VXpSQlhObEpBdW5LazZWTDd5Y05icCtVZGxEMlpvQWZUVzAvNmtWMVd0UU9HMkNTTlJEbGlBc0NwT29lNkdkclRWSlgxU29FZzVESkJKVnVTOHNKNGhFZlZEbVd6bml2c3FYekovUkhLcXFORHZGYUxXb3FTS2syOUpDQ1BxbFVYYXl0YjBlNnBBNUpocHVTY3B4RUFHaFJua21TU3dtMFFnZ2NjaWFhUXRQRlRNcHl1bWM5T01uaGVQaHJGSHdtRWxWVUMrN0U0Y2Zrd2FrdXNRb2g5Y3hLSnlhdVVBR0ErbGpFY0FBRjhwcUx3QTJxU3RJQlFSbmtmMVhXTWZVWVpQRVcwdW94b0NFakZ1RTlpcFJTVDNxVnlHUkNJa005bndVOEtzRUlHSHBab2N5OHRRUk8xYThLUWNUUUREVHFVK3ByaG9GWTdWeXVuSFNTZkpJajFZcEtBY1AyV3NTWEFCTnc2NVIwb0pSUVphTitBT0s3Z3FKUmk3aU0raXVHZDRBRHg3VXIwYXFUaEhGYzZNRFlCdHhBRVU0b0NEK0tGWGNTaFlsaWxpTlp0d1VJcTcwaThLTWh0enY5d0R1V0krNzk0aTNBVitFUlVuOFIwNG1JdWxzOFpNUk9RaGlIc1h0Q3RqU1hjQ0FLejFQQmZXa3gwZ1kxRW9QR3dKRDdoRWJlZExab0J2MWcyUUhWRHgvM1I2Nm5pdGhYenF1YW1GY2dJQ0tjdG1mQUo2aVVPaVkvMzVFREtnK2d1RGxBZ3NBaEJPZVltOUZwK2pCVGdZMFVqcW1oQXB6S0FHbUllaW1Sd2lDdDZTbnZnY1dyV1NXcXZGU2duaENScDdxWVdqZHBCVDdac1NvcDJoZ202enBVd2FjTzRrMFZ2WDJnUUt0S3VsVXF2ZVBVR1VpZFZnMW9oTGJJd2pJSlBGZFFnVFE2NVEyZmtBSjg1bFBBSVRrUVY3Y3lyVVFnTktkTXRlUTBIUjdGbmQwQktzMkJLZGhKSEF0eEZoNkNkeENGell1a2dFV0VXcy9TWStCcXh4emxZMk9pZHdXUlZPdU1zb3BNbnljWlpUcDJjeUc5Z1NDR0FCMmI5dHZrbmFsbTgvTjlzZ0l1YWhaYlUxVEkvMFcyUHROVThnVkFTSnlQRWVCejJIMW1MUitCSGZZV3Frb0RjSnhNbk5GT0J1RWswb1Vlcnlma3lnODQ0Q1R3NGxmMUFCMFJzY3VGK0l4Y0NVeEZoc3pXZmQraVo1bFFUQ2t0NEoyR0VBWWdYZXNjbHMwQ1Y0U0NzaWhwSkxJSlpJekFJek9DLzQ2SVJtcTNDRVBJMCtHN2w4VUthemZWWG54Y1R0UXlJWE9BbEpOeVBXbmtRUkJ0SE1JY2pKWXdXOUU4YnFCSTBGb3VoQnFQNWtBSHFYYzA1RXJpTC9Bd3kzeDhtMUs5ZFJPd2tzVUxFUTl6ajJ3c0NJYS9WSTFTQ0NSOThBTkZ5UTB3Z2R3MjBkbmV4YmNSUWRvc3VBdTZpVHNTdVlsaG1nb0d0Y0RTNHV6UHFTZGlDNFNlRVl6dUFBZzFVaHFUdWxpVm5CSGlBYlVJMkFmRDlFQWRFR3htajF3bFZOVVJHUVMzWEV2S1BxOGZYVFlOaGJxakJWWkFBMHBiYjVPa0F5N1NwWUJUWWQ1Qk05aUhOWUFBbGM3U0NHS1pZdHlyeDlRSm4yLzhBcW95RUtVa0krQUV1VWpWOTFnRU5VS2FCZy9ENlc5eUcwOVNRNkFuMWNFYWh5RjFJdTNLeUNKRVlzRWN6dTBUS3VBSmpwZHlEV1NLSWlTRUYyd3g0MTdlTTJabUNZakdrYlBRd1Z5a2xqQkFRWE5ERFEvSk1Eb2FsWmdKeDBnaVFKZnFlK3N4TmUyREUySmJvcXRsTU1EWURzU0hVRHdsWWdteWJNQWNwUmJCQVVUd3ZBSjZDUzYvZzdTWVFDVUpzbkxJU0pvS1Q5d093RlFXaEJreW9pdjdIdC85Q3R5c3F4a1dBQVVLblJZUlRBUG9oQ0ZoRUNHeEhjZTBLSFZFZXNTQWtHTFlpV2pHNmdrWWVNUVQ3S0x1QVRxdGhCRW5KenJnQ0s3R1NwbEdrQ2pJQ0JFcnBwRFF0RVZnc2hHMVJBaDJscWVRVmQyWVpyQlJYTGlFNWhvUUtCTFlWMG1BTkRtSkpmTlJJSnd3TWlaSys0RW5TWkxuU0lFa3RhaE5NR0dxSXVkd1Z1eXk0TFJLMUgwVGhBa1NJZmFTWE9TTEkrQ3dGeFZtQU9pMVl6c3ZReVNPZ1RCU2pSTG5hWS9DWUpLeVl3RFZBVWpoMXBHK2ZYOW9Da0FhcTJET0FVWVgyY0ZKck9BcFVPaFh6SVJxSmtrRTZGYmF0a08yRk9QSGxVRlJWU0hYdXdJUklSR0NramtTUW0xRW1UZ0lNM0p5VEZjRVpQZDBpRkVFYWhTNlFDaHFEdFZxc21neEdVamp3SlFFZUt0RFJWRFRuakpLNFhoaVVGQVJDSHdUUlNBVUYyWWRtUVVhZ2ZDWk9RNVRaRnh3WVIxWTJmODZjVi9LMDRzZGRKbkVOQWQ1Q0N1T0plek40TzZrNFRORUtVZ2g4bks2Tm1UY0NhQ0lJZWpJS0VjeHdyRGFZYXlKM0I2b0hRSDViOEZtYXlLYUtLYmQ2ZmZDWUFzQ0k3R21TeWVJMEp2UnJIUkhhRVhScWtiV2FnVjBjaE5KUWdoVHVOS3hhTmtnSjZFR2FZNVA1TjJZbThIa0NSSmFkZlY4cEVIWVhCNlIwZTM5SWc3UFZVZlpGSm5BU3dCWU1BNWoweDlrTkdUSmRnZHprUWVYQWFaOFhsY1hZRnNrN3dJdUlCQkpCMWJJQUdTSXNnbkZqR24ydG1qaW1Uc3dYYUtJTEZNMm5FOTh6WUNtbzdFRFpJNXk3R1lHcUxwTU1qd1dSMEcyYUUrZDdScGo4WmVaaERRdVF3WVZyQ1lqOGk2QVpEWUdWSnlyb1BOWUtzZlFYTjFKMk1XWnlWRkZnQ1NLS3NIbkd5MXIyVk1JbHNpb2xGMVBOeUl1Tk1sQmtnN09PTGg2a0dYeFl5SjBKMUF4WXdGWDFFN1ZvSXlMQ0J4SFhHNUFob3ZXWGNHdGRNblMwKzdLMmJBVmxvMHJOZ3hjOUd6VXBnL3E4ZVNHTVFlU1JVRUJHVUdhMTNNZ0t6V2MxcUtQVUpXSjBEVDUxT0hGeWgyMlVKUzVqUitockpkck9Ub29qdTZZc2Z1ZzhPS21NZDJuTllWZFRpSGNhT2cwM1RJQkV6VEYyQUZORlhBUWZWN1VLcURKOGhOdXVBbW1nNzBZd0dOVGZOMm5EeExGKzdGaVFLR1hQekZqY3p0Z0o3Vlljb0RhaWRNNHRLSXBvTmE2MW1VeFMwZGd4V1NTRWF3N2swcTdvaWlpRWpxL0ZFRDJyZ0NtZzU3RGR1cHZjdDZPMzVncUFSQVltZHo3c2ZhQVR6MlkrMkErZlJqN2VnbmV2SEh0WVA2MDllT2JvaVdJN0lza0FkSFpObUUyQk1ubU1URkR4UjhOUExVOFVqUXlQTU1qNlQ0QVY2Qk90eWhqZUZFMUEwRDc2anF1cGxld2h5aXA0UWhuRkF6SGFFSHJQWXdFSG9pZXBTYnpybVUvc0hyS3d6QWZUajBIcHlMU3JOMzNQVUlhZko4NkgxOUFZRVJscW40Q2dPUzM2TkhkVlE1c0FiRFdHQUp0ZE1YV0VHelZXZVl6U1dPMDArL0NDNENmeFV0eURwck5EYk1aQ1hYNllPUVFVVFNvU1VLb3VtZ0VLaWRydVhxenBEU29hUWNJQmpRSmdIUjVIbG51aFFza0NaTk9qUEF0ZEdJa2l4QU5BZDVQcVRjd1VuUms3SWdrZ0NOdk9OZUlXUy9FZ2RNcFVGZEZwd1ZoNXJwVUVFRmRibWpyNEV1SjlrTkR0eVdsalIyZys3eXBDUnEyVlhBRUR2Q0RsWFVIemREWmk5SDJDSGRCVlFHcEJBYzFvQ2tSZDN4TTZqQjBrRTNIUER2bEE3ZU1hT1I2YktBSlBvNVNlOHhZazZTSGhzMG9SMW5YUTlQTEdsQW13ZjByTnpCc2hHWGUxb0U3SE1XN25qRXdiNy9nUEdUanZzUExiQ3VLc09GV2pjc3d2a0d6R01ENnI3VDBndXBPWENiUnpUeUxLQ2o1UUZjcnQ4dUVzME1EcW5rQWN6dFVUdE9udVhSMkozc3dBamJrZlVjVVRzZHZTOGhFbm1VUSt6cG16MmdvVXN6SGxHRTJZTFBjb1pPSmxUV1Y0UWt3dU9FQnQ2eDhqd2FlRWZiZ2pSZFp1alJYeVVmYXpPZy92VHlBdzZOYThnTXRDYzZpbTVFazlYUGJMZ25PbnFWUTg4cWNiNG5panpMSWY3VXZ2L1EwcWhwSm5mTGxFQ01LSGhzRmJuWGdSTlJCSmNjQ2wwSlpJUmJRa0p2OE9hVGhPZUlBSGlJSnM2SDd1cHM3UlF4Mk9DY1N5d1FYdStsUXdVdWlJUEJ6UjhWMG16YmxLRWN3TzUwN1FDMjAzSCswR3dObUQ4MEUxMGFBS2xjeE0rTndsZExtVlpxS2FYcjcraEJYWDMzYU53ZFVOdm5HWTNIcTczTWpvZ3k0UG5nNWhzUTFtaFl0ZThJeEw4YVpnZEpFYVBZSVg5QXA1a01mUk5OWHp2NlZOU2g4UUJKV1k4YUR5Q3hjd28vVTFQcVVIY0NwSm1xbm5Xb093SFNpUGdLaURsRDNiR0labFlYcGRGNE4zK1dqM1ArK0RMYlczWElPRFQwTUVQc0xiMkM2R1R0aEJubTV4UFNTSmNUSkptVmpTbDFqdUphNmhDNVFGR3BjMmpWdDB3am1KV3FjckFucTUvUlB6WlovY2h5bnBZL2JhRDU4WEUwZ25sZ0lJMUFtMEtCRmpvOGJKd0pxekFSbnIxNEY5cld2cGQrU3pOQkhVQTRkS2tEUjlXanJXOW5aWFQ2Y1JpUnE2R09lbU1KRGN0SXdRdGJaalNUS1dXVWU0OHU0SXRjQndXc3p0Y1pnUE1EelNiRkJDb2RVMTI5ODlDaDY2azZMQ3VvQzNUTHlzMW1IWHF1ajZvSm5LNnVtc0J6dFh0aTRMQ2M3QnpqWmpTVHBXSHJiTnA3b0JZb0ZDQmdVMXhUWmJvSzQwVDFsYm9yRWFuUXZVWVZXc3pzZTBSbFlJYUJnVkxOUmpzSWQ1KzZmT0JZa1ptdURpL21paFNaQ09oMnF0UE10dFpPczlNOE40MGNKNlhPYWJhMHM5UHNORHZOS1UySFNJTitwSzc2VEZVNlZIZHRXbDN4d1VHRW5VaTlNM00xREt1N3N3SmxnMmFtN3U0MG1LWVhlWU1LM2F4ZzVsRG9BcjVKNkdhRmgyZEZ4eDZFUHRwdXZVR3RyK3VwMEQwdElJYllEOTZMeEVKLytvR0xZS0JoQlNtQ2taQ0N5UmNiR2Q4U3NCcWZVVkJTa1IxWUZuU1BWNlF3QmJyZTVTRFppcTg1NlVZMUdSUm1JQm5wQ1JwTGlYejNLZUFvQTdMcVUwWnJXY29QWkx1ZzBDV3lKSE5DNFI2U0hsa01taXNHdXVVd1RoVFJUSmY2RlBXSEl0REpWcUk0TW4zb25IVWxnVE1LU1phVFJIaXQwV1JpTWswWlNyamp1Z3NGbC80anoycUJTYzZTR0ZwZ0xSSkowcVhhREhyZUM4ZkJpQWRGSXpHTWQyOFEzZ0hudWZLVFZCSzVMNndJSTQ2Z0ZRTFQ2QWdOREhOSUpQcWxUd2ZLcUNpTXRnT0FOQnFkeDhrSkRqV3FyMEpBTElMK0RERm9pb3hjeDZBcDdBV3NLT29tNW1PcERiMmRORXB0NkxJOVNoWnZSVUVhN1VDTGRVYkR5ZThWcVE5UnVGUFJUUXlsdVFZRzRkYmxoY0FHRUkwZVhCZ2tlS2M2aEVNbUFZaFVzVU1sQ1RJVEhvai93QmlGazZJZWtyQlNVWG5ySU1pNzFZTkNTYjVLTlE2UEtsc0lCRWlqMGJQb3ZjUzBVVUVUbFNSS2ZZY0FmSUJld3RncmNrVjd2cHpqWWVrMGdnY0JhNTc0WGh6RWc1eHJWNlNvaHdmNUZvN2pscWdabFVLaVBLc0g4ZFV1Q09TOFIwaU1raVZSQVVRK29ReGFtUWc5b2xUUUNua21JTHFrbFFsVkY0OGw1RFZlRnpvYVpwSjE2b0dDUVhDWU1peGRPdGt3Q3Uvb1ljOVVhY09KVkZFbjNVckNXSFZBODdTU2pWaFJpTHFSdTRVS0szWmtXY3dveXRwSURDZlJxTk51SkN5OG9uUVVJd2tYRmNXZEdvRzh4SDFtbUhsVWtNQktiUVVvZGF2NDF5c0lDYUdpSG5JRXFIcFQ1ZXFSRlVEODF5Z2xiRUIxMkNvNHlSVWtDbFNHL0twRzNjQnkxQk9GR2psZEJUV3pncnF2NU1DZjFMSXFqQURFRjJCcTNZL0VrMWl5dmxsNkhId0JaZ2hsbDFUUlNMVmxSNXB4T3ZUOEVZWEVzZmxGbEJxRm9Mc1ZxK2ZKVXBxc1p4SjFPUlhHRXVDa1pSVXd1ZGRScTNvcm1kRjRlbTY5UWlMUm1nUTlvSFczbDlMTVdaL29YbmN4UngxZ28xY2V6OEFBbHM4WWVxYnFKTFJjcU1DY1N1STVHaU9EbU96TXkxK0szcWtVdE0yeTBZVkw1bXdKVXNQMXJuQkdGSU9PcVYyUmxPa0VqT3hlZUM4bEFKNHRTSWxObDFmWGYySkVJRmJsaTA3Q3BySFhsMjRTdU9KR29vYWFKWWxZU3lCQ2pHRFBwTFNIR3NXU0pLb3lHVDEwS1hXWUN3Qm9rM3FNYkFVUEVwRG1XUFhWM1lIbFVMbkxsQ1hYS2V1V1ljb1NSSlYwUGJpUjhQVjlBcFZ2OHJFS0toaTA2YlhURVVuRXQzVXA5N1RiaExvaU40Y1pQS2RuNEtQZStvNVFBL2dmSnJBVk5FV1NNYVNHTjQ1WkJISmhrQURuWThxai9JcHhrNzRFM1hzMFNQWjZHZWV2MjBPUVVwUEJUVWczUThJc3Z1MWdWQzlEN3JDYm1xWVh6SkJscG5vbmdwZWdTNk52YzBLMERYakpCMy9FektrNlNSUTRQVkNZZzA3bGtQUWpOd1JCQmZhNndoa2tkZGNENzFtSUE0NWNOZE1DSzFVTXJLOCtpQ1VqR1N5cS80UFErakxiQjNvbExVWjRxYnFYT0xMVG93Qk03OGlab3Jub0JtVmtpQ1YyUFNxN2x3RkZrbzZHbS9obU9la2hGWWw5Qndub1pZa0RHYWs2c0s2aHRCRWs0SktUaXRBRWY2bHhQUFB4bUVHR0thRytVTEVMOWNnaUdJUEV1cEJlL0k5N291ckxoWXlERE1LUHhkYko0Q1FTMDU4QTdsUmpoYk04Y3dHR0ZXVUdFTHFXYW14VHpjdERCcXVUU25LMDJjZ1p4UE1iTHR0WWdIU2dlaEZNb1Z2MGpPZFRrTVZLam9GQ2plajJzK1dDN0FYbE1GZ3VmMWRBaVF2THJuQ0p1dFZjTDJ5SFZuQzMydVJHNDBiMXdPL3BPS0t4b29zQUp6cU5zU0NxdzBtbWlVRWhYRjRBcHd5cUJ1RkZzYmNvdjhnTEdvdEZIbDl5L2xWMjlVVGtSTFRNYU4wL1Q3VVFDanU1REhKcGNnRUxpL3lNQWdyblVHQzlsK0EraC9JWENNZy84cVE1NUtvbEY2c3JZQlVMTGo3UjZLNmk0RmlWY2hVVTNmQlNnZ0RCakFWeHczb0VNeE00MXBYTEZlczBMT3A0WWxIUkRRb0E5Q2hxbUxDNXBSQ0czb3hVcC9ZSW16eElBY3RHbzZOakVnaHprU0lYZ0lUVWtVYWl1MWlEaEZCNlZOeWM4RktqRkpVQXRUS1lRRjlkVVJ4UEFjRWJFZzVYbnRHdytjblZYMUJSamw2WkFsU3Y0QXhDTGhnUkFFMlFnaEdvK0RtRERRUEhFUmtNamtsQWJ6elBlQUN4d0pHdldYam53TElkVWdwQ2w2WXhDTW95aXRXZ3U3SEtOR0JVREd3U1VGUjJyKzJCL09WVTI0UDNLQ2ovMFRGZUE1cHhBV2NOS0pnanl0VVBWWGxBN2ZSQ0JycDdPb29GSGRCTmVzeGlMRVJVam9TQjM1bkdBNW9xeFE3MFlLb29hYk5VMGg1ZHJBWnBKd0dTekJSNnRINHNveTRBTEJGaXBVcUJIdHBOUlZ2RkN0SXZCYU5VZ0FvSkZWQ3BMSkpEMGxWSUxrY2l6OUxEb0pQQVE0WUVqcEZrUnAwQ2gyaXkxSjNRdzQ1R3laSUVUdlRFY0hwY284RUNtaUMxRlZCMWxDVHNBYVVlYksrVWtkRDl2NVVlNjFFcWlSV0xTUlVIT2ZQcGdocVFaQ0h4Z0tSWFRkQjNEVlUra2VJQnVyNmUvQ0pQMG5YdEpEN3BrSEVBUlpKNkVSVzEwNUg0OVcyVEJCeGZWenBUa0dvdUJkV05FUlN5VUJCdmdnd0tWWnBLb2pLRkF1NVVrOXpNTkpxTW5sV2xQM3IxaFNRNFc2RUE5RXp5a0F0NnVRNitrT0tBUFFZMWMrU0NrcW9IQUJMQkpkZmxkaVBKdmI0QUlPbnc1Z0YxdU1PYmcwb2pFc2NDUWUyVHdDVVJKTHNGTkIyc1dNOFJTa2tVTktDU1UzVVo4WkxwTWpsMTBDQUVxNTNTZ0lTMnFNdWxRMHNEa2c1Y0MycnZkTndjQTR5YVhzb0dvaytUVDF4b3dCTE1BNVZXdjlkLzhJcURNaXQ1SUcvRFBuZmtiWS9Hbm51ZlVYODY4blpBL2FrZE1odVYxaG5JMnc3UVdEL3Jjdzg3UlNHUmRNc2txTDJJUkhvREJGZ1pXUDBWOVNZS2QwQ3RxU0k0aWdZRXpWQTFvSTR6N0FGTjJVQWlOSHFBVXlwalUxUVVwempRbkNPZ3NYS1ZaQ0NOb01McE1XdEpvZ2trQkU2bjZlSUpuQUYxb0xQQzJrTWQyUmZJbFo2TGo2REFLWTdUejU4bE54TUdzYmtEcmhmVVRBZGNoMkdsSFhCZG4xSzY4KzZyRU5WTDZoeDBpQ1RqR3ptaWNSMGJHWFhIMndsN3NobDRxS0RBZ0pGMGJnVGkzVy9hSXdxcHpVYkFhaEJJUE5HVWNkbWswM1MwVTRQYUtYNnl3cklaOEhLNmxaVE5nTW9GYzJIbFNoaXQrTnh4MlNGLzdOakpPdnBFdG1QZUEycW56N3REZmZieUxGQTB3ZzRjWE4zYXluWUE0WUxLSlhiZ0xIczByaFJuKzhJT01INkwranhRdWxFN0E2VWIwWFNVVzhqRDJySFpVVld1dmpaZ3JTeGg0YXo4MTRTa2d5anIyQVRaaldNQUZQeHhFbXRoY2FCK1h6eTYrWktkaEhVZ2hPVHNSaVVIMkU0L0tqeWlTZEpuWGFlUmF6S0lWWjJkeExOWVlMRlNYVE41RXVKeUIxR0dOTFdMUzMxRy9Xd2RlMUdyb1N6d1ErNUFrZzc2akI3bFp0bndSQ1B0Z0xKVWZxeXVXaEJOQjQ5RzZTU2hEd3UxMHdHU014cFhuTUhjRXMwTXpEcjdJMGF5OXF3OUt1V00vckZSS2FQTW5xQ0UvRW1ubWNEYVVTVStBUUJCaXpaSklpT3MrZGRSYU55c0dRY3lMSEt2TnhCUXFVd3ZxWG9PcVJLZEJ0MHZaRDhRUU9POG1ZcTRNeVNWbjdFblFRNUdpYzRyWmI3TENwelBLdjVDSkQxcTl5bWlNb1dtVFB3SU9Rd2NYOTMxUGRwQldFaEVJNUZ4dWw4amh3SDJVOU9jQnN4NkdORmNCWTZyUS9PamNRMTg0amlqbWZSbkU4ME1hQy8zUWhNQkZkOEtpeVF0NDJabVNIS0RadFpsZnRSMElsQWFiQTRqRlJzMEk0TzJzelpRMHNoWXlOQlM3RlU2RE5ybllSSDdGNWIySEdqdllVWXpZWEIzSStQdVJCWTdGZlZIdUpQVHJCa0VGNVI3ZlpLNDFOa3FqcmllcXhXZ0pOZ2RJOUhRRmtuVDJoR09VSCtjM0VGRDNZY2taWEtUQmVibitsR2RJYWRsUDhDZG9EcGIvR3dxL0VDV0QyVkdNemtmcHhBWm81MkEzQ2QrWUJQQTg3cUl2RENRUmc0QWRQWjFkQWMzbzVtTjNFM01UVDlxb0xrNFc0U29pRndPNDJvZ3dXT2tGd2tOcy8ySGJqT3kxUDZoUXNpb1A3RmY5cUJuOWZxN3NKMDg5Zk9GQVoxdVVKODdYbklPTTVxSnVNeXljZUN3Nmt5SDdjMGduTHNjUmhVSjlDalJoQzJhOU5MaCsyRXpzNm9nVkFQNmdJRndSak1UOWFzTG5qeWJob2lYYVJiNURoK1ZCQWpQSXhvR2EwWHNpd0puQ1ZYVElxRkJvTTVvdnhsT0Mrb0xiL09FN1BVd1lCOXpuTFdEMEVlcE85MENLTE5uSVl5YkhPZlZ6WWltWXB1ZUs0UEhtWmNyRHMrY1IyenV0YTl4aGZGKzhRUkl1c2ZXb3U1RVA1UEtjVnluZWRTZDNNc2d3d3JqL1NJUjlhZWZKTENkWG1WcFNnS0ZvTlJ6Q2dzYWVNZmZnZ1B2Ymwrd2JkSncrd0pySkEwTUpUMnVZUFFuZ2loeFlxQVkxd2ExMDJVVGZGWVdYTkdLdUp6U1RLekVMcHRRamVnNGtJYlJzRHJRc0lVME16anpmQ3hmRnRFMjdpVkNQYUxwM21HNGpYc05SNGVXV0puZWNCM1h1NFZMYkhvYmt1Um1BWDNlTDFCUmJmcTU2L2RZQ2N5ajVkNFI5V0U3M2ZpZWtjQnR2bzFFR0Z3Ujg2U3FDQ0FZVmZvS291azEyOUFzU1BrZ1JEQ0RyaDgwazFGSHNhdHJuVDhyb2lVUlo1N0RORWVUSDQ5Q0dOZEVVK2FySnBhTnowS1IwcGtoSkdCMW9aekdOV1ZCNnliUFo3ekxFalFQL1NLekl1YVVTUm02UVRMaFRhNHpMMUlhTmtaQlhlNGxuS0JFNm1wOW1MYUR2RjVwV0xwUVV2VHpMS09WM004em9IejBLbjBSQzhrWU45RDA4ejdNeEFVODlIb053OGwwaGM1Q3RFVjludk9uZytLajduVGdmRGlza1hvUHp6TngvMlIwQmxmQlZZUm5aeEVhcUg1d1VGREM2bjhTbkVlby9yTkFCZEhVcEpKYkpzSGFmMkVhcUtKWWdVbkkwUElSdEFXTExIamVYQVZOYWE5S2pNS0tjeStTREVIL0pCTW1UbnkwUmtBa3lzd2ZSVmtFOFA2b01FMUNEaW02ZlU0d2xzQ3pOek9oL01UTWdGQkVVMkFjUlpIUWRCUzNRQllBNkxBVnRJK0VUQTBPZytLWVRSVGxSZXVVZ3NaUWJCOUZRMlVFMDVzNmNFNEFBU1FVMGhuSHdhUFJTQkhEREpBZWswanZBcU5IQlFHVWtJVmdpSHhnWkNJUTJ5ZlhuQ1VoUEVpK0Vlb1YvVFFhZTBSRjFPTnZ6VUJGMURXSUtHaTJGUlhBaUJLZlhOSFlZeG80YUxwbkpvcTNoR0N0ZEJyaFQvWEE0U2tWM1JqOFRtOUhBdVV3Vm1GbER4a0U0d3NDbmR0bzlLM1RVenhyQVBuS2xJbEYvWWtnZmJORHlVWDBLQ2ZvWkJHd01FZ3NYYzJvblk0eG1JRlAzVXM2YWMxQVNmVVNTazhwMzNwT3N4ajdOWVA0Tmg4NFhLd1dZTlY1am9lcVJiL1k5eEtOV0N2d2hEdVcvdFNNRGxYWTU3eWdmSGtHQ0NJYWZhODdka3M0ZzFJakhOL1lNSTNlanNUSlZZQkVRbG5sYmVOUk96b0RMUmVhSXhyZENMSU10TVR0cUNSc3lUdURZa2N0WXhZUmpSNnZhRG1takI2bE80R3NKU1dWMmdIUWdCeFM3UXdxaVd2NHlITEdnMHRCdzNZazBlaDJoMkdRRFdjUWFMZGhoQnBuRW9qRE5CekN3alRhc3lvblJEb0RNczBxSjNNNFUzVEJYQm5Kd3FtS1UrVUxMMmVOcmw5VTlsQzJKa0JmR1ptU1dsRzlCb1hUSm9oRVBXUUp3cUl3aWJvWDJ0bGFrL1JGaFNyaE1FUWlVWlg3d25LQ1NOUUhaYjZWSSs2cmZNbjhHYzJocWtxelU0eFdpNW9xUXJvdExZU2dYeHBsSjFzYm9LdG1qb21HV3pJeGZySXpJR0VuU1dKeExmb0dTRW5RWUxNdVpsS1Uwem5weDA4S3g4TlpvK0F4UTd6UHhPSEh2U2FVUW1MWTJ5V0Z3TmRKb3RTUEt3Q3BqVUNxQnk2N1FpRUtVZ0hCV1dUL0ZkWXhkZGdrOGRhMlpaVUFDUm0zWkZPcXlFa2NsZFNqZmhVU2laRElZTTlIQWIraVBDYTFMMTR5OHRRUk8xYThLUWZUNnlSMDZsT3FxMFpoQlhnUjFDTGxtNXFlSHExU1VBNGVzdGNrdUFDYWhsMmpqRlhmUUpMNXd3WnYxRW40SWo2RDdwcmhEZkRnUWYxcXBPb1VIUUZQZFVKS2ZoOHNVaEdOZUJSQXBVTEpva1FScTlSSXowc0FYT2tYaFJrTnVkL3ZBZHl4SG5mdkVXOER2Z2dUQUVQb1pJcEczR3NBeVdHTUNEaVRvOENnMDIwUjZHM1BpZ0hMcWFjamdNZjBHQW1EV3VsaFEyRElQV0lqVHpvTFNrME9rbGNLcUdnUHB2M1BFZ2JSd2JYSi8yRXQxUHVzcVc5Ly9LLy8vT05mVndkaStIK0h2L3hoOWROZmZ2dWRPZnhoL1pzZnYxLy95amZtOEpVOWZQOTd4UUNRemp2K2grVDc5MzlTKy9YOWJ3Ly9hSXl2di9wZUM0MXZ1Mk9ReGFZemhHL2E3OUorVFB1Ny9UYSsvWHcweHJYM3pTZXRtYSsveDVPcGNPL0c2VlFTQmNaa05xYTE0YXpQcFYxTkpWaFBKRENyYVFUV0hQNTVqWmprdzhNLzY0a0ZwUGMxbzJTdFl5N0xaMnQ3NUR2RXNGVm1iRnV5bEhnL2Z0YVhyYjVvVjVjc1dyQVB5elcwdlJhaXVtQWZscXYxNit0c1paWE4xOWlyWmdrWlFkdFlFdDRMU3l4WjFOdDRFdDhOVDVxQ3Q1RW42ZDN3cEdtN0czbVMzd3RQSFBrNnR2R2t2QnVlNU0zSFRuMHVua3dVbDY0ZXJDb3VsL3JGS3VPa21hamtZUDcrN3grblIweDZUNTZ4KysyOWRlYXV1eC9MWFhlZlhMejMyMzFIM3ZJNzduNTJyN3I3cXZuT2NyK1BncW9FbE9MZnVnbnZhcmZObTQwZVA1emI1WmJlUzYvZlBtL0d1WG1sNW5tYmlqK3RmL0pNeHZuVU5VVzNQTTBVZXR5eW5xcGNyMk54Vy9QRUMvZHVXTVFwYXh1WlZGOTJkMjlac2JhNmZjWHVLM1ppZUwrcUZadnF2bUwzRlR0eEtYNnBGZnZxbkNjU1FMNjc3TTlaNHNQdW5yNWdpVFc3Si9hY0pTVy9xTS94RlhJaytTMGMrZmh1T0dJUFlkT3VDZTlLdmxJazJWYXV4QmZ5Mkh2eXV2cEhPczVpYStoRi9IN1VlMlB1dVBjMjUzdnVmYnpubFVNaFUzZmNlNVB1dVBmbG5oZE9ySGZjZVgvUHk4YTYxOVA1SzRQNEh3NS85OE1mZi9PWG4vL3VGNURzRjFzKzB6NVpmMy85WGQyRDlCQm5XQk9WYzAwbmEwS2ZrWWR2Y1QzVms0a3dERXhNQ2xiMStZejc5STBjUGFYZ0VockdLZXVQREY5bjg1WisyTFBEc3lseDFwOXFjYjlzWC92NWQzLzU2ZkREWCtudmRQanJEeitkOWN5NlNKNnp6KzNWaGZwRldTcVovdlcwREVQd1o1eTRWREZQRk10cmRkSnl0REYzMFV1NUxFTWI5L3N6bG8rUVdDOTNhajdMWFpwM1BlNDF5MTFhK05SKzhrTU1MTkdGancvLzdXSy9penN6VjQ2S3A2WnVJdi9rMFN0WktHSmxvVDZlVGhUVzJqRWIxM1QxTXgxOVRUZS9aR2Y3VGNsNUtaK3I1cWM4UFZmSE9UQitmQmlDTUpjWlM0eTI4dC8yMThUUTh5K2U2Tys2M3Y3aS9Pamg5aE9lZkxqa1NUMWpDZC9wOW5VVzR6MnlvZFlsWjlwdG1CSHUxeWZ6Ym1VZDhPOFB0T0h1Y2VBQ2xrSTU3SGprNXB0N1hlR01jMkRtSTNSdEx0MWQ3MlhLSEtRMHhNazQyMXB0MGxsOER6VGVEeFJ4U3o2ci90TU9CdnZwNXZGcmFzdVd3eUk3eXVHa0xMSzhsQnVPaThOMXdNdm5zUEgwSHNxMERpaU11d3hmZjRwRjhkUWphR0lzMGxKSHczQ3ZmeGlVMXUvd0tQSVRyZEMxZDYvZjYrOTgvZE52UC8zSFR6Ly83cWVmZi9IL0FmbW9lVllLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ28ySURBZ2IySnFDanc4Q2k5VWVYQmxMMFY0ZEVkVGRHRjBaUW92WTJFZ01RbytQZ3BsYm1Sdlltb0tOeUF3SUc5aWFnbzhQQW92Vkhsd1pTOUdiMjUwUkdWelkzSnBjSFJ2Y2dvdlFYTmpaVzUwSURFd056a0tMME5oY0VobGFXZG9kQ0EzTURBS0wwUmxjMk5sYm5RZ0xUSTFNUW92Um14aFozTWdNeklLTDBadmJuUkNRbTk0V3kwMU56TWdMVFF4TVNBeE9UazVJREV5T1RoZENpOUpkR0ZzYVdOQmJtZHNaU0F3Q2k5VGRHVnRWaUF3Q2k5WVNHVnBaMmgwSURVd01Bb3ZSbTl1ZEU1aGJXVXZRMFpNVGxCQksxTmxaMjlsVlVrc1VtVm5kV3hoY2dvdlJtOXVkRVpwYkdVeUlEa3hJREFnVWdvK1BncGxibVJ2WW1vS09DQXdJRzlpYWdvOFBBb3ZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxDaTlNWlc1bmRHZ2dOalE0Q2o0K0NuTjBjbVZoYlFwNG5GMlZ5MjdpUUJCRjkwajVoMTRtaXdqM0c2U29KRUlTaWNVOE5NeDhBTEdieU5KZ0xPTXMrUHN4VmRjMW8xbHdKSXA2M2k2Nmw5dmR5NjVyUjdQOFBwenJmUm5Oc2UyYW9Wek9uME5kekh2NWFMdUZkYVpwNnhIZm1QWHAwQzl1d2Z2clpTeW5YWGM4bTZjbnMvd3gvWGdaaDZ1NTN6VG45L0t3L0RZMFpXaTdEM1AvYTd0L1dPNC8rLzUzT1pWdU5CV1JhY3B4eXZMbDBIODluSXBaY3N6anJwbCtic2ZyNHhSeDh6RHM4ZlBhRitNNHdrb245YmtwbC81UWwrSFFmWlM3eFZOVlZaNG1yanpkTFVyWC9PK1F2UVMrSC85R2VJNFF4b3JZRmxla3pGRnM0WTJVYVF1L2lwVHBCVFpIeXZRR215Vmxla1crUU1wazRSZEptUjFzVzFMbU5mMHpwZENoWjdjbVpVaW9rVWlaUFBKbFV1WUFQODR1VEtqaDJVTVlaejlXUkppZ1MrVHN3b3dhbmljUXhua09VWmlaNTU0NXV6Q2dodU11aEFHOTJCZFMrZzM4TnFRTUdUYnVUQmpRbjJXRmhSNDZXNjRvOUtock9aUFFJNS9scVlRZXM5bG5Vdm9WYkR5VjBHTTJ5eE1JL2F5cEpXWEFIdmdOS2VNOEIyK1pNR0RYSEU4dkROQWdiRWlaRU91bDJ3UzF4ZStWbE9rWmZ0S1piQmY2YzN4aXdvQnpDenlwTU0zenNzSkNENTBkS3l3TXM4NjhqVUkvNzJRbVpZTDJ2aUpsd1AvSThRVENnRGtjZHlFTTZDVkVVaWIwYkZsaG9ZUE9sck1MSFdwWS9wY0tIZjZybnI4SkEyeVdzd3M5YWxROHZkQkJnNHBQVE9od2JtRk55Z1FOL0pxVWNiYXRTQm1Sejh2R015UE92T0xwaFE0YVZIeUtRb2V6akJ0U1p1eEc1Q2hoUnF3UHBJenpQYlFtWlVaLzdwV1VBVHZrUkdIWmF1anNLbEw2K1U0TXBNeW9VWEYyb1VNTnk5bUZIalZXODQwKzhibVNlMTN2NzlzZFB6MUVSbCtRK25NWXBzZURYeXQrTlc3dlJkc1ZmZEQ2YzIrbXFOdm5EN3hlaStjS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBadmJuUUtMMU4xWW5SNWNHVXZRMGxFUm05dWRGUjVjR1V5Q2k5RFNVUlRlWE4wWlcxSmJtWnZDanc4Q2k5UGNtUmxjbWx1WnloSlpHVnVkR2wwZVNrS0wxSmxaMmx6ZEhKNUtFRmtiMkpsS1FvdlUzVndjR3hsYldWdWRDQXdDajQrQ2k5R2IyNTBSR1Z6WTNKcGNIUnZjaUEzSURBZ1Vnb3ZRbUZ6WlVadmJuUXZRMFpNVGxCQksxTmxaMjlsVlVrc1VtVm5kV3hoY2dvdlZ5QmJNMXN5TnpOZE9GczRNVGhkT1ZzNE1EQmRNVEZiTXpBeFhURXlXek13TVYweE5Wc3lNVFpkTVRaYk16azVYVEUzV3pJeE5sMHhPRnN6T0RsZE1UbGJOVE01WFRJd1d6VXpPVjB5TVZzMU16bGRNakpiTlRNNVhUSXpXelV6T1YweU5GczFNemxkTWpWYk5UTTVYVEkyV3pVek9WMHlOMXMxTXpsZE1qaGJOVE01WFRJNVd6SXhObDB6TUZzeU1UWmRNekpiTmpnMFhUTXpXelk0TkYwek5sczJORFZkTXpkYk5UY3pYVE00V3pZeE9WMHpPVnMzTURGZE5EQmJOVEExWFRReFd6UTRPRjAwTWxzMk9EWmRORE5iTnpBNVhUUTBXekkyTmwwME5Wc3pOVFpkTkRaYk5UZ3dYVFEzV3pRM01GMDBPRnM0T1RkZE5EbGJOelE0WFRVd1d6YzFNMTAxTVZzMU5qQmROVEpiTnpVelhUVXpXelU1T0YwMU5GczFNekZkTlRWYk5USXpYVFUyV3pZNE4xMDFOMXMyTWpGZE5UaGJPVE0wWFRZd1d6VTFNbDAyTVZzMU56QmROamhiTlRBNFhUWTVXelU0TjEwM01GczBOakZkTnpGYk5UZzRYVGN5V3pVeU1sMDNNMXN6TVRKZE56UmJOVGc0WFRjMVd6VTJOVjAzTmxzeU5ESmROemhiTkRrM1hUYzVXekkwTWwwNE1GczROakZkT0RGYk5UWTFYVGd5V3pVNE5WMDRNMXMxT0RkZE9EUmJOVGc0WFRnMVd6TTBOMTA0TmxzME1qUmRPRGRiTXpNNFhUZzRXelUyTlYwNE9WczBOemxkT1RCYk56SXlYVGt4V3pRMU9GMDVNbHMwT0ROZE1UTXhXek0zTmwxZENqNCtDbVZ1Wkc5aWFnb3hNQ0F3SUc5aWFnbzhQQW92Vkhsd1pTOUdiMjUwQ2k5VGRXSjBlWEJsTDFSNWNHVXdDaTlGYm1OdlpHbHVaeTlKWkdWdWRHbDBlUzFJQ2k5VWIxVnVhV052WkdVZ09DQXdJRklLTDBKaGMyVkdiMjUwTDBOR1RFNVFRU3RUWldkdlpWVkpMRkpsWjNWc1lYSUtMMFJsYzJObGJtUmhiblJHYjI1MGMxczVJREFnVWwwS1BqNEtaVzVrYjJKcUNqRXhJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LTVRJZ01DQnZZbW9LUER3S0wxUjVjR1V2VUdGMGRHVnliZ292VUdGMGRHVnlibFI1Y0dVZ01Rb3ZVR0ZwYm5SVWVYQmxJREVLTDFScGJHbHVaMVI1Y0dVZ013b3ZUV0YwY21sNElGc3dMamMxSURBZ01DQXRNQzQzTlNBek16TXVNek1nTkRNeUxqZzVNVjBLTDBKQ2IzaGJNQ0F3SURFMElEbGRDaTlZVTNSbGNDQXlPQW92V1ZOMFpYQWdNVGdLTDFKbGMyOTFjbU5sY3dvOFBBb3ZVSEp2WTFObGRDQmJMMUJFUmk5VVpYaDBMMGx0WVdkbFFpOUpiV0ZuWlVNdlNXMWhaMlZKWFFvdlJYaDBSMU4wWVhSbENqdzhDaTlIVXpBZ01UTWdNQ0JTQ2o0K0NpOVlUMkpxWldOMENqdzhDaTlHYlRBZ01UUWdNQ0JTQ2o0K0NqNCtDaTlNWlc1bmRHZ2dPRE1LUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXdMams1TkNBd0lEQWdNQzQ1T1RRZ01DQXdJR050Q2lBZ0wwZFRNQ0JuY3dvZ0lDOUdiVEFnUkc4S1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveE15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDakUwSURBZ2IySnFDanc4Q2k5VWVYQmxMMWhQWW1wbFkzUUtMMU4xWW5SNWNHVXZSbTl5YlFvdlFrSnZlRnN3SURjdU9Ua3lJREV6TGpBNE55QXRNQzR3TmpSZENpOU5ZWFJ5YVhnZ1d6RWdNQ0F3SURFZ01DQXdYUW92VEdWdVozUm9JRE15TWdvK1BncHpkSEpsWVcwS2NTQWxJQzB0SUVKbFoybHVRMjl1ZEdWdWRBb2dJQzB4TURBZ1ZIb0tJQ0J4Q2lBZ2NTQWxJQzB0SUdKbFoybHVJRlpwYzNWaGJBb2dJQ0FnY1NBbElDMHRJR0psWjJsdUlFTmhiblpoY3dvZ0lDQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1VHRjBhQW9nSUNBZ0lDQWdJREF1TWpBNElEQXVOak14SURBdU1UY3pJQ0J5WndvZ0lDQWdJQ0FnSURFMExqQTROeUE0TGpreU9DQnRDaUFnSUNBZ0lDQWdOeTR5TnpjZ01DQnNDaUFnSUNBZ0lDQWdNQ0E0TGpreU9DQnNDaUFnSUNBZ0lDQWdNVFF1TURnM0lEZ3VPVEk0SUd3S0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ1pnb2dJQ0FnSUNCUklDVWdMUzBnWlc1a0lGQmhkR2dLSUNBZ0lGRWdKU0F0TFNCbGJtUWdRMkZ1ZG1GekNpQWdVU0FsSUMwdElHVnVaQ0JXYVhOMVlXd0tJQ0JSQ2xFZ0pTQXRMU0JGYm1SRGIyNTBaVzUwQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9LTVRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnb3hOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJRE16TXk0ek15QTBNVFl1TVRRMlhRb3ZRa0p2ZUZzd0lEQWdNVFFnT1YwS0wxaFRkR1Z3SURJNENpOVpVM1JsY0NBeE9Bb3ZVbVZ6YjNWeVkyVnpDanc4Q2k5UWNtOWpVMlYwSUZzdlVFUkdMMVJsZUhRdlNXMWhaMlZDTDBsdFlXZGxReTlKYldGblpVbGRDaTlGZUhSSFUzUmhkR1VLUER3S0wwZFRNQ0F4TnlBd0lGSUtQajRLTDFoUFltcGxZM1FLUER3S0wwWnRNQ0F4T0NBd0lGSUtQajRLUGo0S0wweGxibWQwYUNBNE13bytQZ3B6ZEhKbFlXMEtjU0FsSUMwdElFSmxaMmx1UTI5dWRHVnVkQW9nSURBdU9UazBJREFnTUNBd0xqazVOQ0F3SURBZ1kyMEtJQ0F2UjFNd0lHZHpDaUFnTDBadE1DQkVid3BSSUNVZ0xTMGdSVzVrUTI5dWRHVnVkQXBsYm1SemRISmxZVzBLWlc1a2IySnFDakUzSURBZ2IySnFDanc4Q2k5VWVYQmxMMFY0ZEVkVGRHRjBaUW92UVVsVElHWmhiSE5sQ2k5Q1RTOU9iM0p0WVd3S0wwTkJJREVLTDJOaElERUtMMjl3SUdaaGJITmxDaTlQVUNCbVlXeHpaUW92VTBFZ2RISjFaUW92VTAxaGMyc3ZUbTl1WlFvK1BncGxibVJ2WW1vS01UZ2dNQ0J2WW1vS1BEd0tMMVI1Y0dVdldFOWlhbVZqZEFvdlUzVmlkSGx3WlM5R2IzSnRDaTlDUW05NFd6QWdOeTQ1T1RJZ01UTXVNRGczSUMwd0xqQTJORjBLTDAxaGRISnBlQ0JiTVNBd0lEQWdNU0F3SURCZENpOU1aVzVuZEdnZ016QXdDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ0xURXdNQ0JVZWdvZ0lIRUtJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1ZtbHpkV0ZzQ2lBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnUTJGdWRtRnpDaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01TQXdMakF3T0NBd0lDQnlad29nSUNBZ0lDQWdJREFnTUNCdENpQWdJQ0FnSUNBZ05pNDRNU0E0TGpreU9DQnNDaUFnSUNBZ0lDQWdNVFF1TURnM0lEQWdiQW9nSUNBZ0lDQWdJREFnTUNCc0NpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pFNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tNakFnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0YwZEdWeWJnb3ZVR0YwZEdWeWJsUjVjR1VnTVFvdlVHRnBiblJVZVhCbElERUtMMVJwYkdsdVoxUjVjR1VnTXdvdlRXRjBjbWw0SUZzd0xqYzFJREFnTUNBdE1DNDNOU0F6TXpNdU16TWdNems1TGpRd01WMEtMMEpDYjNoYk1DQXdJREUwSURsZENpOVlVM1JsY0NBeU9Bb3ZXVk4wWlhBZ01UZ0tMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTWpFZ01DQlNDajQrQ2k5WVQySnFaV04wQ2p3OENpOUdiVEFnTWpJZ01DQlNDajQrQ2o0K0NpOU1aVzVuZEdnZ09ETUtQajRLYzNSeVpXRnRDbkVnSlNBdExTQkNaV2RwYmtOdmJuUmxiblFLSUNBd0xqazVOQ0F3SURBZ01DNDVPVFFnTUNBd0lHTnRDaUFnTDBkVE1DQm5jd29nSUM5R2JUQWdSRzhLVVNBbElDMHRJRVZ1WkVOdmJuUmxiblFLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ295TVNBd0lHOWlhZ284UEFvdlZIbHdaUzlGZUhSSFUzUmhkR1VLTDBGSlV5Qm1ZV3h6WlFvdlFrMHZUbTl5YldGc0NpOURRU0F4Q2k5allTQXhDaTl2Y0NCbVlXeHpaUW92VDFBZ1ptRnNjMlVLTDFOQklIUnlkV1VLTDFOTllYTnJMMDV2Ym1VS1BqNEtaVzVrYjJKcUNqSXlJREFnYjJKcUNqdzhDaTlVZVhCbEwxaFBZbXBsWTNRS0wxTjFZblI1Y0dVdlJtOXliUW92UWtKdmVGc3dJRGN1T1RreUlERXpMakE0TnlBdE1DNHdOalJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lETXdNQW8rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lDMHhNREFnVkhvS0lDQnhDaUFnY1NBbElDMHRJR0psWjJsdUlGWnBjM1ZoYkFvZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUVOaGJuWmhjd29nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lERWdNQzR3TURnZ01DQWdjbWNLSUNBZ0lDQWdJQ0F3SURBZ2JRb2dJQ0FnSUNBZ0lEWXVPREVnT0M0NU1qZ2diQW9nSUNBZ0lDQWdJREUwTGpBNE55QXdJR3dLSUNBZ0lDQWdJQ0F3SURBZ2JBb2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQm1DaUFnSUNBZ0lGRWdKU0F0TFNCbGJtUWdVR0YwYUFvZ0lDQWdVU0FsSUMwdElHVnVaQ0JEWVc1MllYTUtJQ0JSSUNVZ0xTMGdaVzVrSUZacGMzVmhiQW9nSUZFS1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveU15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDakkwSURBZ2IySnFDanc4Q2k5VWVYQmxMMUJoZEhSbGNtNEtMMUJoZEhSbGNtNVVlWEJsSURFS0wxQmhhVzUwVkhsd1pTQXhDaTlVYVd4cGJtZFVlWEJsSURNS0wwMWhkSEpwZUNCYk1DNDNOU0F3SURBZ0xUQXVOelVnTXpNekxqTXpJRE00TWk0Mk5UWmRDaTlDUW05NFd6QWdNQ0F4TkNBNVhRb3ZXRk4wWlhBZ01qZ0tMMWxUZEdWd0lERTRDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURJMUlEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURJMklEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEZ3pDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01DNDVPVFFnTUNBd0lEQXVPVGswSURBZ01DQmpiUW9nSUM5SFV6QWdaM01LSUNBdlJtMHdJRVJ2Q2xFZ0pTQXRMU0JGYm1SRGIyNTBaVzUwQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9LTWpVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnb3lOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVlUMkpxWldOMENpOVRkV0owZVhCbEwwWnZjbTBLTDBKQ2IzaGJNQ0EzTGprNU1pQXhNeTR3T0RjZ0xUQXVNRFkwWFFvdlRXRjBjbWw0SUZzeElEQWdNQ0F4SURBZ01GMEtMMHhsYm1kMGFDQXpNaklLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdMakl3T0NBd0xqWXpNU0F3TGpFM015QWdjbWNLSUNBZ0lDQWdJQ0F4TkM0d09EY2dPQzQ1TWpnZ2JRb2dJQ0FnSUNBZ0lEY3VNamMzSURBZ2JBb2dJQ0FnSUNBZ0lEQWdPQzQ1TWpnZ2JBb2dJQ0FnSUNBZ0lERTBMakE0TnlBNExqa3lPQ0JzQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNCUklDVWdMUzBnWlc1a0lFTmhiblpoY3dvZ0lGRWdKU0F0TFNCbGJtUWdWbWx6ZFdGc0NpQWdVUXBSSUNVZ0xTMGdSVzVrUTI5dWRHVnVkQXBsYm1SemRISmxZVzBLWlc1a2IySnFDakkzSURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5SRVpYTmpjbWx3ZEc5eUNpOUJjMk5sYm5RZ01UQTNPUW92UTJGd1NHVnBaMmgwSURjd01Bb3ZSR1Z6WTJWdWRDQXRNalV4Q2k5R2JHRm5jeUF6TWdvdlJtOXVkRUpDYjNoYkxUVTNNeUF0TkRNeElERTVPVGtnTVRJNU9GMEtMMGwwWVd4cFkwRnVaMnhsSURBS0wxTjBaVzFXSURBS0wxaElaV2xuYUhRZ05UQXdDaTlHYjI1MFRtRnRaUzlWVWt4U1VGZ3JVMlZuYjJWVlNTeENiMnhrQ2k5R2IyNTBSbWxzWlRJZ09USWdNQ0JTQ2o0K0NtVnVaRzlpYWdveU9DQXdJRzlpYWdvOFBBb3ZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxDaTlNWlc1bmRHZ2dNelEzQ2o0K0NuTjBjbVZoYlFwNG5GMlNUNHVETUJERjc0VitoeHpiUTFGVEUxc29BNlhkZ29mOXc3cjdBYXdaaTdER0VPM0JiNzh4Q2JPd0IzK1F5WHZKeEhuSnBieVd1cHRZOG1HSHBzS0p0WjFXRnNmaGFSdGtkM3gwZXBWeHBycG1paXZQcHEvTmFqRlg4emhoWCtwMllLY1RTejdkNWpqWm1XM09hcmpqTm5tM0NtMm5IMnp6ZmFtMlNmVTA1Z2Q3MUJOTEFaakMxcDN5V3B1M3VrZVdlTSt1Vkc2N20rYWRjeXdLNWhWZnMwSEd2U01MblRTRHd0SFVEZHBhUDNDOU9xVnB1Z2RIY1lEMUNyWDZMK0JwTU43YlB3Yy9BakdYNEd0N3Z3b1VzY1lsRVBOOTFKMkJLSXBReTNNZ3lpelVoQUJpd1dNdEE2SjhpZDRMRU9VeDF2enBnVExlSVNRUWk5aExlSGtnVDJQUEJSQmRSOEY3QUdJaDRqdThJbEJFWGU0VmdUTHFSQUhFSXVxeUt4RGRud2ozM29Eb1hoUHVTSUdZWDJPTkF6Ry9oWm5SYkpiNXVaQXhTa2Z6dE5ZRnd5ZlJKMkxKUXFlUndtb0d3NXhyK1g0QmdFeThBUXBsYm1SemRISmxZVzBLWlc1a2IySnFDakk1SURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5RS0wxTjFZblI1Y0dVdlEwbEVSbTl1ZEZSNWNHVXlDaTlEU1VSVGVYTjBaVzFKYm1adkNqdzhDaTlQY21SbGNtbHVaeWhKWkdWdWRHbDBlU2tLTDFKbFoybHpkSEo1S0VGa2IySmxLUW92VTNWd2NHeGxiV1Z1ZENBd0NqNCtDaTlHYjI1MFJHVnpZM0pwY0hSdmNpQXlOeUF3SUZJS0wwSmhjMlZHYjI1MEwxVlNURkpRV0N0VFpXZHZaVlZKTEVKdmJHUUtMMWNnV3pOYk1qYzFYVEk1V3pJM01GMHpPRnMyTWpSZE16bGJOek0zWFRReFd6VXlNRjAwTjFzMU1URmRORGhiT1RVM1hUVXdXemMxT0YwMU5WczFPRFZkTlRkYk5qWTJYVFU0V3pFd01EUmROamhiTlRNNFhUY3lXelUwTVYwM05GczJNVGxkTnpaYk1qZzBYVGd4V3pZd05GMDROVnN6T1RkZE9EWmJORE01WFRnM1d6TTRPVjA0T0ZzMk1EUmRYUW8rUGdwbGJtUnZZbW9LTXpBZ01DQnZZbW9LUER3S0wxUjVjR1V2Um05dWRBb3ZVM1ZpZEhsd1pTOVVlWEJsTUFvdlJXNWpiMlJwYm1jdlNXUmxiblJwZEhrdFNBb3ZWRzlWYm1samIyUmxJREk0SURBZ1Vnb3ZRbUZ6WlVadmJuUXZWVkpNVWxCWUsxTmxaMjlsVlVrc1FtOXNaQW92UkdWelkyVnVaR0Z1ZEVadmJuUnpXekk1SURBZ1VsMEtQajRLWlc1a2IySnFDak14SURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5SRVpYTmpjbWx3ZEc5eUNpOUJjMk5sYm5RZ01UQTNPUW92UTJGd1NHVnBaMmgwSURjd01Bb3ZSR1Z6WTJWdWRDQXRNalV4Q2k5R2JHRm5jeUF6TWdvdlJtOXVkRUpDYjNoYkxUVTNNeUF0TkRJM0lERTVPVGtnTVRJNU9GMEtMMGwwWVd4cFkwRnVaMnhsSURBS0wxTjBaVzFXSURBS0wxaElaV2xuYUhRZ05UQXdDaTlHYjI1MFRtRnRaUzlNV1ZoVlNGVXJVMlZuYjJWVlNWTmxiV2xpYjJ4a0xGSmxaM1ZzWVhJS0wwWnZiblJHYVd4bE1pQTVNeUF3SUZJS1BqNEtaVzVrYjJKcUNqTXlJREFnYjJKcUNqdzhDaTlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1VLTDB4bGJtZDBhQ0EwTWprS1BqNEtjM1J5WldGdENuaWNYWlBCaXVNd0RJYnZoYjZEanpPSGtzU3lreGFLb0pPWlFnODd1MnhuSHlCTjNCTFlPc0ZORDMzN2NTeFZDM3ZJQi9tajM1WVVLYXNQN3dmZlR5cjdGWWIyNkNaMTduMFgzRzI0aDlhcGs3djBmbEZvMWZYdHhHK0o3YlVaRjdQNStMaE43bnJ3NTBGdHR5cjdIVC9lcHZCUUw3dHVPTG5YN0dmb1hPajlSYjM4cVkrdjJmRStqbi9kMWZsSjVZaXFjK2Q0eW85bS9HeXVUbVhKc3pwMDhYTS9QVmJSTVVlb0ZQSDFHSjNTeVZGUUp1M1F1ZHZZdEM0MC91S1dpMjJlNSs4WWFTdGNMcHp2L2c4QVM4YlQrWitqS0ZFSWdLUVZLTlFmckwyaEVOYXNWU2dFdzFxTlF0aXdabEFJQldzN0ZFTEZHcUFRY3RZMktJU1N0VFVLd1pLbVV3VFJjQnhzVUdoWjA2bFNvdUY2cVd0RXZlTzRkRHJSOEIyRlJxSGVjOXdlaGFibWV3c1VtbWYvMHVsRTREc0FVR2k1WG10UldHblNER1dSV0hJdUpuV2RXSEx2VFkzQ2tudHZTaFNXWEsrdFVGaXhGOVlvdE05NlV4WkU0RnlnUXFGbHI5NmgwUEMvQkl0Q3kxNmRYRVR6dkZlajBEeDdtaWFGYUhoZTRod0t6UnZOdDh6eFBPdHhJWlZzVW5zUElTNVIydHEwUGZQZTlON0pZby9EcUtKcmZyNEJ3cC8yYVFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNeklEQWdiMkpxQ2p3OENpOVVlWEJsTDBadmJuUUtMMU4xWW5SNWNHVXZRMGxFUm05dWRGUjVjR1V5Q2k5RFNVUlRlWE4wWlcxSmJtWnZDanc4Q2k5UGNtUmxjbWx1WnloSlpHVnVkR2wwZVNrS0wxSmxaMmx6ZEhKNUtFRmtiMkpsS1FvdlUzVndjR3hsYldWdWRDQXdDajQrQ2k5R2IyNTBSR1Z6WTNKcGNIUnZjaUF6TVNBd0lGSUtMMEpoYzJWR2IyNTBMMHhaV0ZWSVZTdFRaV2R2WlZWSlUyVnRhV0p2YkdRc1VtVm5kV3hoY2dvdlZ5QmJNVE5iTkRNMFhURTNXekkwTVYweE9GczBNVE5kTVRsYk5UVTFYVEl3V3pRd01sMHlNVnMxTlRWZE1qSmJOVFUxWFRJeld6VTNObDB5TkZzMU5UVmRNalZiTlRVNFhUSTJXelV6TmwweU4xczFOVFZkTWpoYk5UVTRYVEk1V3pJME1WMHpObHMyTnpGZE16aGJOakl4WFRNNVd6Y3hOMTAwTUZzMU1UZGROREZiTlRBeVhUUXlXelk1TjEwME5sczJNVEJkTkRkYk5EZzRYVFE1V3pjMk4xMDFNRnMzTlRWZE5URmJOVGcwWFRVeld6WXlNbDAxTlZzMU5URmROVFpiTnpBelhUVTNXelkwTVYwM01GczBOekJkTnpGYk5qQXlYVGN5V3pVek1WMDNObHN5TmpGZE9EVmJNemN3WFRnM1d6TTJNVjFkQ2o0K0NtVnVaRzlpYWdvek5DQXdJRzlpYWdvOFBBb3ZWSGx3WlM5R2IyNTBDaTlUZFdKMGVYQmxMMVI1Y0dVd0NpOUZibU52WkdsdVp5OUpaR1Z1ZEdsMGVTMUlDaTlVYjFWdWFXTnZaR1VnTXpJZ01DQlNDaTlDWVhObFJtOXVkQzlNV1ZoVlNGVXJVMlZuYjJWVlNWTmxiV2xpYjJ4a0xGSmxaM1ZzWVhJS0wwUmxjMk5sYm1SaGJuUkdiMjUwYzFzek15QXdJRkpkQ2o0K0NtVnVaRzlpYWdvek5TQXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDak0ySURBZ2IySnFDanc4Q2k5VWVYQmxMMUJoZEhSbGNtNEtMMUJoZEhSbGNtNVVlWEJsSURFS0wxQmhhVzUwVkhsd1pTQXhDaTlVYVd4cGJtZFVlWEJsSURNS0wwMWhkSEpwZUNCYk1DNDNOU0F3SURBZ0xUQXVOelVnTkRFekxqRTROU0F5T0RjdU1qSXhYUW92UWtKdmVGc3dJREFnTVRRZ09WMEtMMWhUZEdWd0lESTRDaTlaVTNSbGNDQXhPQW92VW1WemIzVnlZMlZ6Q2p3OENpOVFjbTlqVTJWMElGc3ZVRVJHTDFSbGVIUXZTVzFoWjJWQ0wwbHRZV2RsUXk5SmJXRm5aVWxkQ2k5RmVIUkhVM1JoZEdVS1BEd0tMMGRUTUNBek55QXdJRklLUGo0S0wxaFBZbXBsWTNRS1BEd0tMMFp0TUNBek9DQXdJRklLUGo0S1BqNEtMMHhsYm1kMGFDQTRNd28rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lEQXVPVGswSURBZ01DQXdMams1TkNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tNemdnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXekFnTnk0NU9USWdNVE11TURnM0lDMHdMakEyTkYwS0wwMWhkSEpwZUNCYk1TQXdJREFnTVNBd0lEQmRDaTlNWlc1bmRHZ2dNekF3Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdMVEV3TUNCVWVnb2dJSEVLSUNCeElDVWdMUzBnWW1WbmFXNGdWbWx6ZFdGc0NpQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1EyRnVkbUZ6Q2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNU0F3TGpBd09DQXdJQ0J5WndvZ0lDQWdJQ0FnSURBZ01DQnRDaUFnSUNBZ0lDQWdOaTQ0TVNBNExqa3lPQ0JzQ2lBZ0lDQWdJQ0FnTVRRdU1EZzNJREFnYkFvZ0lDQWdJQ0FnSURBZ01DQnNDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0JSSUNVZ0xTMGdaVzVrSUVOaGJuWmhjd29nSUZFZ0pTQXRMU0JsYm1RZ1ZtbHpkV0ZzQ2lBZ1VRcFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqTTVJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LTkRBZ01DQnZZbW9LUER3S0wxUjVjR1V2VUdGMGRHVnliZ292VUdGMGRHVnlibFI1Y0dVZ01Rb3ZVR0ZwYm5SVWVYQmxJREVLTDFScGJHbHVaMVI1Y0dVZ013b3ZUV0YwY21sNElGc3dMamMxSURBZ01DQXRNQzQzTlNBME1UTXVNVGcxSURJM01DNDBOelpkQ2k5Q1FtOTRXekFnTUNBeE5DQTVYUW92V0ZOMFpYQWdNamdLTDFsVGRHVndJREU0Q2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEUXhJREFnVWdvK1Bnb3ZXRTlpYW1WamRBbzhQQW92Um0wd0lEUXlJREFnVWdvK1BnbytQZ292VEdWdVozUm9JRGd6Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdNQzQ1T1RRZ01DQXdJREF1T1RrMElEQWdNQ0JqYlFvZ0lDOUhVekFnWjNNS0lDQXZSbTB3SUVSdkNsRWdKU0F0TFNCRmJtUkRiMjUwWlc1MENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS05ERWdNQ0J2WW1vS1BEd0tMMVI1Y0dVdlJYaDBSMU4wWVhSbENpOUJTVk1nWm1Gc2MyVUtMMEpOTDA1dmNtMWhiQW92UTBFZ01Rb3ZZMkVnTVFvdmIzQWdabUZzYzJVS0wwOVFJR1poYkhObENpOVRRU0IwY25WbENpOVRUV0Z6YXk5T2IyNWxDajQrQ21WdVpHOWlhZ28wTWlBd0lHOWlhZ284UEFvdlZIbHdaUzlZVDJKcVpXTjBDaTlUZFdKMGVYQmxMMFp2Y20wS0wwSkNiM2hiTUNBM0xqazVNaUF4TXk0d09EY2dMVEF1TURZMFhRb3ZUV0YwY21sNElGc3hJREFnTUNBeElEQWdNRjBLTDB4bGJtZDBhQ0F6TURBS1BqNEtjM1J5WldGdENuRWdKU0F0TFNCQ1pXZHBia052Ym5SbGJuUUtJQ0F0TVRBd0lGUjZDaUFnY1FvZ0lIRWdKU0F0TFNCaVpXZHBiaUJXYVhOMVlXd0tJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQkRZVzUyWVhNS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F4SURBdU1EQTRJREFnSUhKbkNpQWdJQ0FnSUNBZ01DQXdJRzBLSUNBZ0lDQWdJQ0EyTGpneElEZ3VPVEk0SUd3S0lDQWdJQ0FnSUNBeE5DNHdPRGNnTUNCc0NpQWdJQ0FnSUNBZ01DQXdJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1EyRnVkbUZ6Q2lBZ1VTQWxJQzB0SUdWdVpDQldhWE4xWVd3S0lDQlJDbEVnSlNBdExTQkZibVJEYjI1MFpXNTBDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tORE1nTUNCdlltb0tQRHdLTDFSNWNHVXZSWGgwUjFOMFlYUmxDaTlCU1ZNZ1ptRnNjMlVLTDBKTkwwNXZjbTFoYkFvdlEwRWdNUW92WTJFZ01Rb3ZiM0FnWm1Gc2MyVUtMMDlRSUdaaGJITmxDaTlUUVNCMGNuVmxDaTlUVFdGemF5OU9iMjVsQ2o0K0NtVnVaRzlpYWdvME5DQXdJRzlpYWdvOFBBb3ZRVzUwYVVGc2FXRnpJR1poYkhObENpOUdkVzVqZEdsdmJnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElETUtMMFJ2YldGcGJpQmJNQ0F4WFFvdlJuVnVZM1JwYjI1eld3bzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqazFOeUF3TGpjMk9TQXdMamMzTmwwS0wwTXhJRnN4SURBdU9UWTFJREF1TnpVM1hRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1BEd0tMMFoxYm1OMGFXOXVWSGx3WlNBeUNpOURNQ0JiTVNBd0xqazJOU0F3TGpjMU4xMEtMME14SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wxSmhibWRsSUZzd0lERWdNQ0F4SURBZ01WMEtMMFJ2YldGcGJpQmJNQ0F4WFFvdlRpQXhDajQrQ2p3OENpOUdkVzVqZEdsdmJsUjVjR1VnTWdvdlF6QWdXekF1T1RNeklEQXVPVFE1SURBdU9EY3hYUW92UXpFZ1d6QXVPVFExSURBdU9UWXhJREF1T0RneVhRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1hRb3ZRbTkxYm1SeklGc3dMak0zTlNBd3xFbmNvZGVkIERhdGF8fHx8fEZ8fHx8fHwgDQpPQlh8NDl8RUR8NTg0NzctMV5QdWxtb25hcnkgRnVuY3Rpb24gVGVzdCBSZXBvcnReVlNQVUxSfHxeQVBeUERGXkJhc2U2NF5Mall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzBOaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRjZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzBPQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRrZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFNQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRFZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFNaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRNZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFOQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJREU1TGpnME15QXpOeTR3T1ROZENpOUNRbTk0V3pBZ01DQXhNalVnTWpOZENpOVlVM1JsY0NBeU5UQUtMMWxUZEdWd0lEUTJDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURVM0lEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURVNElEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEYzFDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01TQXdJREFnTVNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOVGdnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXeTAxTGpFMU1pQXlNQzQyTmpZZ01URTRMamcwT0NBdE1TNHpNelJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lEUTBNamtLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdJREF1TmpneUlEQXVPVE0zSUNCeVp3b2dJQ0FnSUNBZ0lEYzRMalF4TVNBd0xqQTNNaUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREF1TURjeUlEZzBMamt3TWlBd0xqZ3pNeUE0TkM0NU1ESWdOeTR5TXpNZ1l3b2dJQ0FnSUNBZ0lEZzBMamt3TWlBeE1TNHpNemdnT0RNdU9EVTBJREUwTGpZNElEZ3lMamN3TnlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURneExqVTJNaUF4Tmk0ek9UY2dPREF1T0RreklERTBMamczSURnd0xqZzVNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdPREF1T0RreklERTBMamczSURjM0xqZ3pPQ0F4TUM0MU56UWdOell1TkRBNUlESXVORFU0SUdNS0lDQWdJQ0FnSUNBM05pNDBNRGtnTWk0ME5UZ2dOell1TWpFM0lEQXVPVE1nTnpZdU5qa3pJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNOeTR4TnlBdE1DNHlNVFVnTnpndU5ERXhJREF1TURjeUlEYzRMalF4TVNBd0xqQTNNaUJqQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DQXdMalk0TWlBd0xqa3pOeUFnY21jS0lDQWdJQ0FnSUNBM01TNHhOVGNnTUM0d056SWdiUW9nSUNBZ0lDQWdJRGN4TGpFMU55QXdMakEzTWlBMk5DNDJOaklnTUM0NE16TWdOalF1TmpZeUlEY3VNak16SUdNS0lDQWdJQ0FnSUNBMk5DNDJOaklnTVRFdU16TTRJRFkxTGpjeE5DQXhOQzQyT0NBMk5pNDROaUF4TlM0MU16Z2dZd29nSUNBZ0lDQWdJRFk0TGpBd05pQXhOaTR6T1RjZ05qZ3VOamN6SURFMExqZzNJRFk0TGpZM015QXhOQzQ0TnlCakNpQWdJQ0FnSUNBZ05qZ3VOamN6SURFMExqZzNJRGN4TGpjeU9TQXhNQzQxTnpRZ056TXVNVFl4SURJdU5EVTRJR01LSUNBZ0lDQWdJQ0EzTXk0eE5qRWdNaTQwTlRnZ056TXVNelV5SURBdU9UTWdOekl1T0RjMElEQXVNelU0SUdNS0lDQWdJQ0FnSUNBM01pNHpPVGdnTFRBdU1qRTFJRGN4TGpFMU55QXdMakEzTWlBM01TNHhOVGNnTUM0d056SWdZd29nSUNBZ0lDQWdJR2dLSUNBZ0lDQWdJQ0JtQ2lBZ0lDQWdJRkVnSlNBdExTQmxibVFnVUdGMGFBb2dJQ0FnSUNCeElDVWdMUzBnWW1WbmFXNGdVR0YwYUFvZ0lDQWdJQ0FnSURBdU5DQXdMalF3TkNBd0xqUXdOQ0FnY21jS0lDQWdJQ0FnSUNBNE1pNDJNVElnTVRjdU5UUXpJRzBLSUNBZ0lDQWdJQ0EzT0M0ME1URWdNVGt1TkRVeElEYzBMamc0SURRdU9EVXhJRGMwTGpnM09TQTBMamcwTmlCakNpQWdJQ0FnSUNBZ056UXVPRGMySURRdU9EVXhJRGN4TGpNME5pQXhPUzQwTlRFZ05qY3VNVFEySURFM0xqVTBNeUJqQ2lBZ0lDQWdJQ0FnTmpjdU1UUTJJREUzTGpVME15QTJPUzQyTWprZ01qQXVNekV4SURjMExqZzNPU0F5TUM0ek1URWdZd29nSUNBZ0lDQWdJRGd3TGpFeU9TQXlNQzR6TVRFZ09ESXVOakV5SURFM0xqVTBNeUE0TWk0Mk1USWdNVGN1TlRReklHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdaZ29nSUNBZ0lDQlJJQ1VnTFMwZ1pXNWtJRkJoZEdnS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3TGpRZ01DNDBNRFFnTUM0ME1EUWdJSEpuQ2lBZ0lDQWdJQ0FnTVRNdU16STFJRFV1T1RjMElHMEtJQ0FnSUNBZ0lDQXhNeTR6TWpVZ01pNHpNelFnTVRBdU56UTVJREF1TWpNMElEY3VNekE0SURBdU1qTTBJR01LSUNBZ0lDQWdJQ0F3SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F3SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQXhMalV4TXlBeE1TNDNNVEVnYkFvZ0lDQWdJQ0FnSURjdU16QTRJREV4TGpjeE1TQnNDaUFnSUNBZ0lDQWdNVEF1TnpRNUlERXhMamN4TVNBeE15NHpNalVnT1M0Mk1URWdNVE11TXpJMUlEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01URXVPREV6SURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TVM0NE1UTWdPQzQ1TmprZ09TNDRPRE1nTVRBdU16WTNJRGN1TVRNNUlERXdMak0yTnlCakNpQWdJQ0FnSUNBZ01TNDFNVE1nTVRBdU16WTNJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhMalUzT0NCc0NpQWdJQ0FnSUNBZ055NHhNemtnTVM0MU56Z2diQW9nSUNBZ0lDQWdJRGt1T0RneklERXVOVGM0SURFeExqZ3hNeUF5TGprM055QXhNUzQ0TVRNZ05TNDVOelFnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNBeU55NDFNVFlnTWpBdU1UWTFJRzBLSUNBZ0lDQWdJQ0F5Tnk0MU1UWWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lESTJMakE0T0NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUxTGpBME1pQnNDaUFnSUNBZ0lDQWdNall1TURnNElERTNMalU0T1NBeU5DNDJPRGdnTVRrdU1EY3pJREl5TGpJNE15QXhPUzR3TnpNZ1l3b2dJQ0FnSUNBZ0lERTVMamczTlNBeE9TNHdOek1nTVRndU5UWXhJREUzTGpZME5TQXhPQzQxTmpFZ01UVXVNRFF5SUdNS0lDQWdJQ0FnSUNBeE9DNDFOakVnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREUzTGpFek1TQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMUxqSTVOQ0JzQ2lBZ0lDQWdJQ0FnTVRjdU1UTXhJREUyTGpnNE9TQXhOeTQyTXpVZ01UZ3VNVGMzSURFNExqVXpNU0F4T1M0d05ETWdZd29nSUNBZ0lDQWdJREU1TGpNNU9TQXhPUzQ0T0RVZ01qQXVOakF6SURJd0xqTXpNU0F5TWk0eE1UVWdNakF1TXpNeElHTUtJQ0FnSUNBZ0lDQXlNeTQzTXprZ01qQXVNek14SURJMUxqQTRNeUF4T1M0M05ETWdNall1TURnNElERTRMalUyT1NCakNpQWdJQ0FnSUNBZ01qWXVNRGc0SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTXpjdU16WTVJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdNemN1TXpZNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016WXVNemc1SURFNExqa3dOU0JzQ2lBZ0lDQWdJQ0FnTXpRdU56a3pJREU0TGprd05TQXpOQzR6TWlBeE9DNHhORGtnTXpRdU16SWdNVFl1TmpNNElHTUtJQ0FnSUNBZ0lDQXpOQzR6TWlBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTXpJdU9Ea3hJREF1TWpNMElHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UWXVOalkySUd3S0lDQWdJQ0FnSUNBek1pNDRPVEVnTVRndU56WTFJRE16TGprMU5TQXlNQzR4TmpVZ016WXVNVE0zSURJd0xqRTJOU0JqQ2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdOakF1TWpreklERXhMalUwTWlCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURrdU9UUTNJRFU1TGpjNE9DQTRMalkxT1NBMU9DNDRPVElnTnk0M09URWdZd29nSUNBZ0lDQWdJRFU0TGpBMU15QTJMams0TVNBMU5pNDRNakVnTmk0MU1EVWdOVFV1TXpNNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBMU15NHpOVEVnTmk0MU1EVWdOVEV1TnpVMklEY3VNemN6SURVd0xqYzBOeUE0TGprMk9TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklEY3VNemN6SURRNExqTTVOeUEyTGpVd05TQTBOaTQwTURrZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURRMExqYzROU0EyTGpVd05TQTBNeTR6T0RVZ055NHhNakVnTkRJdU5EQTNJRGd1TWpZM0lHTUtJQ0FnSUNBZ0lDQTBNaTQwTURjZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURRd0xqazNPU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdOREF1T1RjNUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJREV4TGpjNU5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lEa3VNalE1SURRekxqZ3dPQ0EzTGpjMk5TQTBOaTR5TVRVZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURRNExqWXlJRGN1TnpZMUlEUTVMamt6TmlBNUxqRTVNeUEwT1M0NU16WWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTBPUzQ1TXpZZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdNVEV1TlRReUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ09TNHlORGtnTlRJdU9EUTNJRGN1TnpZMUlEVTFMakUzTWlBM0xqYzJOU0JqQ2lBZ0lDQWdJQ0FnTlRjdU5UYzNJRGN1TnpZMUlEVTRMamc1TWlBNUxqRTVNeUExT0M0NE9USWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTFPQzQ0T1RJZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMk1DNHlPVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09Ua3VOREUxSURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnT1RrdU5ERTFJREV4TGpVME5TQnNDaUFnSUNBZ0lDQWdPVGt1TkRFMUlEa3VPVFEzSURrNExqa3hNaUE0TGpZMU9TQTVPQzR3TVRVZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURrM0xqRTBOeUEyTGprMU15QTVOUzQ1TkRNZ05pNDFNRFVnT1RRdU5ETXlJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTVNaTQ0TURnZ05pNDFNRFVnT1RFdU5EWTFJRGN1TURreElEa3dMalExTnlBNExqSTJOeUJqQ2lBZ0lDQWdJQ0FnT1RBdU5EVTNJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQTRPUzR3TWprZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURnNUxqQXlPU0F5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBeE1TNDNPVFVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUE1TGpJME9TQTVNUzQ0TlRjZ055NDNOalVnT1RRdU1qWTBJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQTVOaTQyTnpFZ055NDNOalVnT1RjdU9UZzNJRGt1TVRreklEazNMams0TnlBeE1TNDNPVFVnWXdvZ0lDQWdJQ0FnSURrM0xqazROeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJREV4TkM0Mk9UY2dNVE11TnpJM0lHMEtJQ0FnSUNBZ0lDQXhNVFF1TmprM0lERXpMakE0TWlCc0NpQWdJQ0FnSUNBZ01URTBMalk1TnlBNExqazJPU0F4TVRJdU5qVTFJRFl1TlRBMUlERXdPUzR5T1RZZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURFd05TNDVNRGdnTmk0MU1EVWdNVEF6TGpnNU5TQTVMakE0TVNBeE1ETXVPRGsxSURFekxqUXhPQ0JqQ2lBZ0lDQWdJQ0FnTVRBekxqZzVOU0F4Tnk0NU1qVWdNVEExTGprd09DQXlNQzR6TXpFZ01UQTVMall6TVNBeU1DNHpNekVnWXdvZ0lDQWdJQ0FnSURFeE1TNDROamtnTWpBdU16TXhJREV4TXk0eE16RWdNVGt1TmpNeElERXhOQzQxTURFZ01UZ3VNall4SUdNS0lDQWdJQ0FnSUNBeE1UTXVORE0zSURFM0xqUXlNU0JzQ2lBZ0lDQWdJQ0FnTVRFeUxqSTVNU0F4T0M0MU5qa2dNVEV4TGpNeE1TQXhPUzR3TkRNZ01UQTVMamN4TlNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFd05pNDROVGtnTVRrdU1EUXpJREV3TlM0ek1qRWdNVGN1TVRReElERXdOUzR6TWpFZ01UTXVOekkzSUdNS0lDQWdJQ0FnSUNBeE1UTXVNamN4SURFeUxqVTNPU0J0Q2lBZ0lDQWdJQ0FnTVRBMUxqTXlNU0F4TWk0MU56a2diQW9nSUNBZ0lDQWdJREV3TlM0ek56Y2dNVEV1TWprZ01UQTFMalEySURFd0xqZzNNeUF4TURVdU56azJJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEEyTGpNNE15QTRMall6TVNBeE1EY3VOelUxSURjdU56WTFJREV3T1M0eU9UWWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lERXhNQzQ0TXpNZ055NDNOalVnTVRFeUxqSXdOU0E0TGpZek1TQXhNVEl1TnpreklERXdMakF6TVNCakNpQWdJQ0FnSUNBZ01URXpMakV6TVNBeE1DNDROek1nTVRFekxqSXhNaUF4TVM0eU9TQXhNVE11TWpjeElERXlMalUzT1NCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDFCaFoyVUtMMDFsWkdsaFFtOTRXekFnTUNBMk1USWdOemt5WFFvdlVHRnlaVzUwSURNZ01DQlNDaTlEYjI1MFpXNTBjeUEyTUNBd0lGSUtMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTmlBd0lGSUtMMGRUTVNBMk1TQXdJRklLTDBkVE1pQTJNeUF3SUZJS0wwZFRNeUEyTlNBd0lGSUtMMGRUTkNBMk55QXdJRklLTDBkVE5TQTJPU0F3SUZJS1BqNEtMMFp2Ym5RS1BEd0tMMFl3SURFd0lEQWdVZ292UmpFZ016QWdNQ0JTQ2k5R01pQXpOQ0F3SUZJS1BqNEtMMU5vWVdScGJtY0tQRHdLTDFOb01DQTJNaUF3SUZJS0wxTm9NU0EyTkNBd0lGSUtMMU5vTWlBMk5pQXdJRklLTDFOb015QTJPQ0F3SUZJS1BqNEtMMUJoZEhSbGNtNEtQRHdLTDFCaE1DQTNNQ0F3SUZJS1BqNEtQajRLTDBkeWIzVndDanc4Q2k5RFV5OUVaWFpwWTJWU1IwSUtMMU12VkhKaGJuTndZWEpsYm1ONUNpOUpJR1poYkhObENpOUxJR1poYkhObENqNCtDajQrQ21WdVpHOWlhZ28yTUNBd0lHOWlhZ284UEFvdlRHVnVaM1JvSURJd05ESTJDaTlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1VLUGo0S2MzUnlaV0Z0Q25pYzdYMVppMlJKZHVaNy93cC9HUm9hNnJidGl4QUZtVmtMQ0FRalZVSUxoQjU2cXJjWnFrcXE3bUlhemErZnM1amRjQTkzKyt4Nlptd2VjYU9Jekt6d0UvZWFuV1BMMmIrZkQvL2o4TVVYaC9kLy9QUC8vdW5EZi83MHl4OS8rdVZYaDROWmNqd1krdStMOXE5YzNlSDdIK21UTDZ3eGg0Ly9qLzdWZnZOLzhXOGVQdnorcC8vNys3L1JUdzhISzc5b0R5NHRJYWE4L2kyL1B2NjF1MTgwaDFvNk5hSS8vbzE0OXd2NFYrNStLZEdmUjc5MDc5Zis1KzkvK2N2UlovUnJpL2VIdjUvOHlCeis2ZDcvLzUvVFh6R0hmejRsV0hKT0ozOGUvdlhiZTQ4d2h4OVBmcEpqWGt5bEgvOXc4dVB2anY3dlgzVGdmL3pwRDZmRFB2cjVQUzVzNDVBaEh0MEFoMmlvN3ZHNGMyK2FaNU04bmFJOW1lQnNOclN2VHViQ0RQL2g1UC9ka2tyeS9TK2ppL2FJSXQ5YkdOOWRtdDdKRkU0bTkrMFAvLzFmZi9uYnlSdjV2OE5mLzN6MHM5OSsrNTA1L1BtWTZ2M0g0NCsvb1dQQ0hqNys2WmdObnRra3EwaitaZWtRcUpiKzRmeFNhL0dIanovZWUrbkhQeHorMFJqdmpZblJtRkRvT3h0ajdaY2ZqeG42OWNkTDg3czNpK2VaWWFxTFNmTVp1amE3bU9nNzM4cnNuSW1MeS9QWkdacVo4WThoUjNCSWVRZE9xYlBmRzk0YVo3OTZkc0FkLzZwWmJEcjc5WXM3L2tRV2pWMUxQUHg0NGFmT3RUK0U0blNuODVlanU4Q0dzN3RBUHdqOGUveVBGUFFwNjcvanhRZTFqMzRZZlpSTGY2enRMN1puRCtJbjJMTm55T3VWUy9RVWMzRUk5MW43cDkrYy9HQjBmUEhYVE1Bbk54Z3Yzek14NFUzVUpuRmhLK25YK1liU3I1TnQxVWd2Yks0MnhIdGJqUDYydExkSVVmcjQ0OFd4dEJQeTNwblJQbCtpODNkbnpEZVhhVUs0STBtWFNMNitQNEh4NXRTdlRYeWtKWlQ1VDI5bERQN3BlRnJUVXZoTTNzVFp5MXg3SEpZODdkS2lpM2V4aGVhL2lRKzI4bmxOMzNSKzIzZXZsaWZaTGNWdFhSdTJOSjdRdldZL3ZGYWVPQmNXbnpaeTVEMTlCNzd4SDRBYlkxV2N2NjQ1N3AxYnZMc3pOZ2NQdVhDemI3amJ0OTN1by90OTJ3MFA3dmpyYjNsNHoxOTcwNC91K20yMy9mbDlmM2JqNHp0L3l6S1kzL3ZidGgzYWVPT3RkM0h6b2UxM3BRNXdvZ1hRMmV6cnBaMTNZZS9OejZMTmJObDBsVDhxaXpaYzZmTkwvWEdaOUR4clo4c2xmM0tBeDZNcjdmMmI0ZEtHYS8rRVMrRklHYXB2aFV0elJlQk1ZUnlxQXAvRUg2d1FQSnk2RU1LUzR0UkEzTldGa3c5M2RlRnNTamVoTHRBdWRTTUhBb2wzc1h5clQrN05EVTZFVjYrQmhDV0d1SlgxRDNnb3Z2RFZhTjMyR3lNZDZSKzhMdk9iWVZLS1MvSlhhbW01Y1lwTjd2VGxyb09jREszeDZaMnVwQmVoZzR3LzJ4aHpmSml3amowUDY1UWxaZVd4L0l0T3Nib1U0OGZScW52WEFCMjU4ZTVXcVJ6cmVjVEFqdVZvVXdIQm5RdHl1N3hhTDYzVGV5djA4dG84dDdKSTI1T3Noa3VCc0syQnZudnJFYTNFNTU1dnRxUWhiNXJ2Ti9ydDdhM08xUm5hRE5GdW1Lc3ZOei9YUUJydmxwbCtwU3M0OENwMlBhaDdzN091Zm5IelNYTVUrelNDL1RBVGhySG8rMUhzNnd6WmVNTW1yUGRsaWY2aUNjc2ZGZUdPcjR2eCtxVDEzL0hpdzlZUGZ4aC9TSVpuZTdUdHI5OU4ySmR0d3VhUlFUcVBmTzltNjl0em5MdXJIT2NwYkRZMHBwSGd3K0UxdXMzRDRzb1Zidk5qTHZtM3dpVkhmMVYzbGNscUc2OGVMYlF3dURhTzByUmpWQy94OTVlR3U0M2ZtT09JNXdPdVk3NWZmWTJjc04xY1p2VkZabTloOTgwd0tTNnpEWHd4OGxYR1hxZFA1aG4ycmZEWGk5N28zc1FsaHl1OGVPK2ZPRUoycmU0NFRKdlpZa1pzTWlTMm1oSmpZMktyT1FFTmlrOHhLU1pHeGZWbXhkaXcyR3BhWERJdUxwZ1hNd1BqMnJ0aWJHUWNYdUZOTVVxd1lTR2xxVFh4RlBmSlJxdmlDZGk2eWJyWVlsL2M1alhzcm1DVjJCdmxpb3M0emNNL2gxZXZ2R3l6UUM3eUxZMFRuRjQvMzdiWUpCY3ROMWIvNHVOeWJYamZiTFZPdGt0aEpnY3NpYUVzWnRMNGhQdG5tNjB5RU1FMklkd2cyN2JZTGllYzgyMFp2ME9iLzdPNE9MZGhidWFRMkdiUG5QRDNnL0o0Wk5FOG1tWDRzSGJQTVA5dnQzdjBkM2E3NSszWlBlNERXelcwdDRmbnB1Vk04dzJxUEJrbGR5bUZtaTVDWHg5MmcyazNtSzQwbUtxL1N2V1BSN2QvK2ZMamJqSmR5YmN3RGtrY2RwTnBIZVE5US9QRHFHQ1d2MTQ5MTFKZG5MMG1EdE8vM3lySFBrSHJmcStyN01hMTdwVE8wam92UEdiWHVYZWQrODNvM0tQMEp0Rlp5NTBTK0E2RUpQSmhIcm5ZVmV6ekVlOHF0cWpZNFJQMHhEU3UzVGtjZHYzNmJwajMrTVovaHk5My9Yb2IxM3I5VTk1REVrZGZlMGppZWRsMmRVZ2lIQzFqdjRja1RyOGV3RGg2cHhmU2pSdEhwUzdlN0tsWXUzbTBtMGRIbW5tNWEySXdEa3U0eGJpNzh0UTlMS0cvc3R0TVoxOFBaRFBSRFdXdnVxRzZCZ0JhTGgwT3U5bDBOOHg3eVJ4cEQwdDhnckhwMzdLUnZvY2xydVpZSlcwcFhYbXErVmVoZTF1YWRQSjdQdEN1Zk8vSzkxRnNJdTRSaFYwNy9nVHRPT1ZQMG83alc5YnlQa0U3UHViYnUxMDd2akpweHo5K2l0Z2VWQmlPZEE4cVBGQlFvYUpEY3c4cWZISlFZZExiK0ZZTUcwNmhUYnRaczVzMXUxbHpUVlBrclcyUk4zYVllbVBXMG9aR3ljY0NNZVhOR2tzdVhlblgzZEFTK1BEcWRYNmJHQnIxcXVzODNrdGVlN05SR0dmU2txOHJxc24zYXVyckhsUFlZd29iRlc4YkZ4TmVBTWMrVCsxR240NC9HMytDMWJPajNyQTJMeTdkVHdyQ3FydVYvKzVMbko4WXMyZEVhZXZUNGE5L1BKeDhmS0ppanBYTG1WclpSMTRPNVhPYTJqb3o2V283RVBKNHNWOEZtemU2d2EwKzN6STZzNkdMTzMwaVltZWM2WldrdjgzNkRIMGU3T0RFYm5Sa0RqQ2kxR2NZam4rLzhOUDdvT0Q5cDVjMitobEFlQ2NXQ2QrREJsOC9HeGlZMFpQVk5UVHp2dnM4NitwbHNZQ09YY1FEK2ZqcG1FRGJ6bDYrWDM2K1BQbytUSGQyUXVuWDczNXorT25DajkvLzIrRzMzLzNGSFA3Mmw4UFgvM2I0bHl2bjhwQXVsKzFiQi9VMlhGeU9YTmxEVitlanQ4WDF1cUE4TndQMFMzSStIcHkvZkZNZm1XeGZQVmJmMG9rcnlqbExaNjkwZnY3K3gvSHVHSG1nRHFUM2hzSGErbHczeTJUa25oRWtTbzYzTi9MZzYrTFpWSDBCSTMrZXZUcjFvSDNSdkpaVEQ5cUExVE5GWGQ4eVpPTkZSczRYd2R6RGZ4MFhVbHlLenpzajZKcDFpOTBaUWVQam5ETHJkazdRWVJPV3N2T0Jya0VMcjhFM3hJbWFsN2h2RGRJdmtsOUsyam1oMW8rdHRiNCtUanhzV051Wnp6S3ZodHg1U0xTUjFWa1VsOG91dk12dW9oT0gwY0N4VG9hZ084eENqRStCR0lIMDVhMkw4N0pmWk9RWkdmbEdodDRSN0I5QlRxS1ptK2lTajJTK0wyNkdMVVBIMGRSMTlMaU1vUzNwUmlHS24wZHptYm1SaG82azdrcXlRMWZTYzJpTzI3Y2RqZ1JOM1VxUEVQSStjaTlsdjRRUXh1NmxMUTZtaHdxWmdZMjR6ZEcwNVpyMUQzN05YanVMbWRQcE5tWXhjMEE5enl5ZWM1OXZ5Q3hHTHFtdEFwaW54MDYxeVFGenR5eVNxeE5RTjNCbDRxSjZ1NHladUt6ZU1HTW1McXkzeXhuczBucTdmSm01dU40d1o3REw2KzB5WnVZQ2U3dWNtYm5FWGd0bm50YUJGbTdKZ1dhMitNN0dNTkZIMlZidmhnNjJlcGg1NFhZSDIvb0x1NFB0NGkvY3JJUE5QNzJEemUwT3R2T3Z6M1d3a1FsSEUvRzdnMDIrZGdmYjdtQTdtZVh1WUJ0VDdBNjJBY1h1WUJ0UTdBNjJFY1h1WUx0TXNUdllSaFM3ZzIxQXNUdllSaFM3ZzIxRThTSWNiTW5jVklaYURsSldQL1d5eGQwL3RqNW45NDlkZk00cjlJK0ZwL2VQK2QwL2R2NzF1ZjR4R3hkU3FmUHVINU92M1QrMis4ZE9acm43eDhZVXUzOXNRTEg3eHdZVXUzOXNSTEg3eHk1VDdQNnhFY1h1SHh0UTdQNnhFY1h1SHh0UlBJcC9ESDg2NS9seEs5b0xFUEZiYk13eGU2L3EvalZxYjJmYkVQbXZ1dFJKNzYrdkhyNXAxM05QTzVIMXp0MWRaM08vM0x2dnR1ZHVHV1o5eStSOUdqUjlPMjRtUEtJNVNrSjA2bXgxNVFGNCtWQjdzOXVIMXN6NjgwM2M0MStFSmRYQlZiUGxNRjB2TFRxWVA3bWZFaTNvUjJxbnRLSGZkdmxzVnhxNFNSNitxK2NhS2FDamIwc1R6emZUN25SbFROakVtRnNHRTBoMlNjSHR1L2FjNE9kOTE3N3FYWnR2ZU5kYWw1ZGE5azE3Z0kvNWR0KzA2OWZQcjJQVHBsdmV0RFVzZnVnTDM3ZnRGL3UyUGZ2NitYVnMyM2pEMjlZbHM2UzQ3OXB6Z3AvM1hmdXFkMjI0NFYzclhWbHFmUWpEMXIzTWJmczBlYVptV3lGM25xV1lXdjlnNmFVUHVrcHFWR1NiZlkyc1g4KzNSc0tMWENPQlhXUXA3eWZKeWRmenJaTDRJbGRKcFB2R21GRDNWWEw4OVh5ckpEM1JLbm5vS054bnh1Q2NkVXZ5WWNNcWZEbDFLbHZrNmI3UmI4OW9oVis5eUJPQWhyYllFdXlyNDczM3d5WTg1UTRrTjhZUmxiOURQUXVGdmpOOWY2RHZSTCtVKzg5ZXBFaUR0NHV4MWI4K2taYStuVjdBTVRuK2JQd0psdUo2S1RNMFlrbG5DZjZ6TlhBSGVIZ20rUG55WVV4dzBSWU5JLzdGcXNDWm4zV3FpMXkzb1JuOXcrSFgzLy9sOTMvOTVkY0QrVjlhRjdRWURwZmgxL2tUbHk1L2hqNjUvUE5MV3Mvdkx0WkxiYzNtQ3h3S08rUVFEczU4UWxIVzFoUy9PemtJd1B1UFE3Sy9EejRabGR1TkMrNUF5ZDNoOE8vK0VQN0RIUDR3ZXVaU2FqajVjMVNmSnh4MDFoOUdVOG9seXVjL0RENy83dUxQNTRtTE8rOFB1bnFMZ2J6bnozZmU5NjhINW4zSW1QZjArYzc3L3ZYQXZKK2NPWFkvYzQ2K0hwYjN1VUxXMDhjNzUvdlh3M0krSk1oNStuam5mUDk2NFBQRzRlUEdQVGpuSDdKbzVZblVYUGNKc25WRDJkSXlvc0VlL3ptNWpkT1NaaGV5a095U09vU0hsUlRMSjhUMjUrZElLZGlsVmlIS2RpaW40RGgzVVlqR2wzendTMDFLRk1aRVlhbHgrcVM0ME9rZ1JPTmRUcDlXUHlYS1MzVlRvckxNT1ZEcHhKb1JSVHJXeXBUSUxpVlBpZHhTMG16YzBTOWx5cVlZbGpKbFU0eExtYklwcHFYWUtWRmV5cFNtTEhsT1ZKZWNaMFRKTEhuS3BtU1hQRjF5eWZHcW5UM0o4eU5tVHdvczJCbFJYUEtVSm5FMzlCbFJYdEowWjZiQ0o4Q01xQzZwc2FrTWliSlprcktwanZkNHRrdGlOdVhGQUNMSFlJcENOTlplczErU1dIMExNQzV5NElJdEpuS0FLQzZ4Q0pHUFk2SzB4Q3hFQVl3cEx6RUpVUUpFWllsaWppNkFwaTZSMlZRUUJ3cWQ4RTZJN0ZncXhYSnpmU1p5NEVsdWlWTWF6ek9YWVk4djdSS1dvRnh5WSsyM3hDWG96Z1JDS1drSlBLYTRlUEE2a2dZdnViRDQ4V29xWlFuTVN3L0hWQmU1RDkwQ2xNZHFGbjZiSEN4REdydDRZcE92dlBDR1JOd0RuSWdLNzVnaGtlZXBXMCtMQ2J3dThLSzFQcUx0eTJreFFYcDNWUENreExrejFsV2tsRlhhSTdUa1hPTGxPU1FxaTJmRnlUUGZoMFNWRjV0MWhoODRJckxHTEk0WVplRjZzc1l1ampobHcrSUNvSEw4RUd2dFlpdWdvbVZDRERXRlQ1Y3hsYnpLbW9TMm5qVnhjVTRlV2RBYmFSOVlIVjRHVk1RQ21hbEJVeXc4TitaYVJZK3FQR3ArRmpqTkxjYy9rd3lyQUFFeE42UHdBeXdJYTJsYktidkEyckxXODFIT2t5am9XWUczcUx3WUNNakdSZHhTdkh6R1JJbVBWNmIxYUZoMERla2FCQ2UvdFhSVTh4cXNhRXZ6eDRhWTZrVHRHRkxScGlBcDh3WkM2NFpiajNuWml3WTl5eTJHZDJ4aENZeXAvR0s0dXcvSkhCRHhHV0xSN1U0a1lneDRqK2NYZVgzeW9RVjhzand4dGhuby9FTmp5bUl6MEVrYXdTcmw3TkVnaDNKRno2cHFFRmk0cVlsSFZXOEtkSEF4bi9UT0FkeWlBN2tvVlVBdjlHbzVpRkkwcGdwcUZWakVMZUk0Rzk3RUI0T29rdGdPWGk2RU1WVVc0NEZHRjlIZ2kxZ1B6RFN3SUdoQVJhUUVtTVhYYnRXMUE0amtUSk9yQnozS2lmMUEyNnlpWjNreElHaGpCOEIzMGozWWd1Q2pCTDFSN21jK2p5SzR4OVRDNEtNTnZUQ0xEVUduWkFYU0lWMHV5NEdMOWlFWnJteEYwT0dkd0tPaUVRdUJMb0lJZG12a3RFcTVldEJGUUxZckdSSVY2ajJXYkZmNm1QU1JDaFpXbEVFVEVWckpaTHZTTFU1RURuQ0JiTmZFaWcyU0g1bXVwTTRSVVVFc0tMd1ZTTEZCRDZwaVJ0RGRpNjRjc2wzWlJDREZJWUxaa2ZFYWcyZ1pDVXlQckZjMkpVaC9BTmFySmZPVmJRbFNEUW9ZUGRtdmJFelFBa1dpSVFPV0xRVytxTkhvRTU5NnZIR1FjTWlHWllPQ05xRkg0eXBpVWJBeWlaNVZ4YVNnR3hHOWtjeFlOaGZvSmpOZ3E1SWRHNXljUmhsUk9iRXFIRllkR0hKYmJoL0VMckpreGE0d2NLL21xRGFEWFBwanFzUlpYSHgwTy9UR3JLWkZRRmFoelVWdGl3Z3ZDN0puMmJqd1l0UU5xY2lnWmNPQmIzd2diTEpvdlJDaFk1a3NXall2ZklLSFZoSDlrQWVQekFzeWF0bThJSFlob2loMkE5MzdTS2NocTliTlpWM0VYY0VLRUxKQnlLNWw2NEx1T3FTUmtXSEwxZ1VwaThEWXRtVFpPdGxsWUZ0WDBZdG1HN1p5ZzBpNTZUSjZueGZqZ204NndGTXlicTNhWWdWUnhXNWNCTUF0dWdTczJtTG82S0lUWGhvSldhaHIwZjFsNVp3SGtxYVBqZHdZWVAwNXVpM0p0T0JMckFBaWJqSGNiUGd4a1dNcmdJZ0FEeHhObmk0NUlpcm9TWUhOQ2hwVFFBT1BmTUJVNkZaelBPcUNGZ3RSc0FaR3JBSW1walBTSEVITVZmU3lJallGVFJGRXZCM2RiMnhUMFBDQjh1VEk5R1Z6Z2ExcE1IaStCYjNZeWNBUTRBeHVOaXJvTHhBUGRyUmQyS2lnS3hNbzA0NCtycklCRXlLS1lpN1lncWVZSk5MQXh3SjZWaGFqZ282WURCWURIeHRSamlza2F5dXFCU3Y1UUFWMmRJVTNld0hOa1laZHRCa3QwQ01kWGZSRjdpL2dobkpPRmd4ZEZJQWtpRkhoTXg2NXFBSnM4SUQxNTVMR0d3emM4YVF2U01EQllxcWlFUWZoeFppcWlrMUJKZy93SkR0dWhHL2xXV2c1ME9XVzFMZVowTE9jaEIzd0JlMzROczBpbllxZUZjU3E4TkRZZGw0MFlMNVYwZUNUUkI1Y3hvL0tFbm9na2FOSGlYT1FGY2tJRmp5elNYYVlCNDhLMGxHTy9VSm80NU5jMkdxZzdRZ2N1STVrek5FSE9nRFFiaVd6TmtZMVJjSGd5YXhsMjRMT09LRFdPVEpyeGJhb3lNM2h5S3hscThIQWNJNGp1emJLeVd6UTRJdVlGa2JVaHpGVkZkT0NiZ3d3UXpKcmc3VEpBK2FhSTZ1V1RRWWlBdnFhSTZ1V3d4REdvTEN0aStJUGwxR0JHWkpkeTRZRnUxM1I0T1dpRjhzZFVTV3hHUXlNN1RteWJUa1lZUXJTSXgwWnQyeFpZTys1SS9PV0xRdGVYT0JaU2V3MFhxakFuSFpKMWg1ZlpNRCtjTWxwUk1JZzE3SWo4OWJyam9WdkRJdGFmdWhJSXV0V0FoY1oyWWN1SmJFWjZFaENSM2lTdUFZWkRZQ2txRjJCMTBPU0hjaW5LWEFZT0RKdG5WcGhhRkJrMnJKZHdkY2RPQ2pKdEhWeTI2R3poaXhicXhjR1VPQWRtYlpzV0xDRER3MHJpbUhCUnlGZ0JKbTJiRmh3SEE4eFFpek1pVXZWa1duTDhRajI5QUtpS25ZRjM1eGd4UmM1UUpnUndCSGdDanR2bWZIb3pDWEwxcFR1N3gxVGVRbEhlSWNNTEZlQ2hpTXE1QU9adGtiMXU0cW9rZ1l0QWp6ZXlMUTFhclNpVFUybXJWR2pGVEdpeXVHQUZpa1p2MVVEUE1EdDRNajRaUU9EVkhTMGVjajhGZE9oSXBlcUkvT1g0eEYwMTZGanNubzFNQUkwVnNqOFpRT0RIYTlnYVpFNXh3WUdkcnc2OXFhSzN4WHNNSFp2VnZHN29rRVZOaS9vcFhEa2xjOVpOc3pIRFBVMDRpSjJMUmlUcDl1eWlDODRJaUxIb1lnS3RTUFBVVmpIdGlZUW55ZUpGTFgvZ2ZIa1NVa3BJajJQcGlmSk1oTHpySUFxU3lpQ1ZwVkJMeXdhaXBEY2dqRlYxVkNFUjBsMlhOZkt4Z1VITE1BYnJkV0FSVUhHazZjdHcyWURYYjZJcVR3Z0RUR0N3ZHNndG9XTHlFNzJWbFlMWDc3QU0rYXR4Sm5sV0VOVVdhd0dNbXJBRWVLdHhDclkrWWY0VU1XMndHZXlaeDNGYVZ3TkxHWTY5SkxlQWhrOXk0bmQ0S0YrNFozWHpDWURWNm9lMlh5RkFjdklrMlJpdTFuUkc1TW1OemxnQlhzU1g5U01IQ1JyVnpTOWlWZlBtS2hxZWhOWThONUljcE5IcWpLRGNVaDJrMFBKTnA2dVUwbHZNc2lKNkwzTVMwS2ZhRmhCVEF0MmlZT1Z4VEZ5WFg0Z2N1MzFJYnlVUVZUSnMwVnV4UU5UMExPS1JDTVNYRElNdFZWblFSTFA2NjZJMW8wR0gyVFVjb2lBNWNkYVdKUUR5YUkzZW9sR2NFWUhJQXBxV0xnRlBTbUtYVUduSlRxMWdyQ0pyM3QwaVhFNlhCWGJOcUpoRlFsR2NOQVBVVlV4TE5oRERVUk54cTNUYUt4QlZKWnRpNHJYS1JtM3BObXlJeGR3aTJ4YnNobHFRWTVjVDZhdEpEb1pGTFAxWk5xNm1aWHN5YksxNmdkQUp3aFp0cExvRkpIVzdXUFJSS2VNbGdNWnRoS0tRQzRtVDNZdG14VzBzTkFFeWE1bHM0S3oxY0NCbEp5bU9TWGtSZk5rMTFyVmdnR3p5S3cxZGJyQnlLNDFiYk9pS1NheEsrZ3lzR2p3V2UyS3ZLQVhGalVZS2xLVmZSTE55RXJyaGpFVldiWnNWdEQ1RER3ZFBsdk5jZ3JvZEdCdnFjZEthZGFTQjUvUUpVZTJyeVE1RmJnRnlmYVZKS2VLQXJhZWJOK3FlVHNaRFN2MUxDZWtoV1F0ZS9ENEZpRGJ0Nm9XZ3JaOVpxZ05DWitDS1JZaldVNDQrOVNUN2N0aEM3cXMwVjFldFBiQlpUaEZNbjRsSURFWlY5Q0FCUFJWK1JJbHpjbGhpNENNWHc1YmtCNklicWNpQlJBV1g2MWsrM0pBd3VLanJjaFM0T3NKYWQ1azJZcDFVVkNjenBObG0xdFFESXlMTE51c09TbG8zVlF0ZzBDTG1jemFyQWFyUTFTUlRRdEcxUVBDSWJzd1MwNHlvcEZrL0FxZEY3NUtGUVJIYXhFM0t5dUh0Y0R5SkdQRXFtQzNNcWdZNHVzN3FHbVBudVhFckRBQmJmdGd0QkRDd0F5bXdLNWk5ZFFuUUJRMUdtR1JUaHFNV09QaTVNMkFLbXZNSWlLTk9oZ3RodURJQm5wamxXZ0UzV0FnWVNWWWNZSHdEUWJTS1lNVmU0OVYxNFNveEJuRWFqQXFXTE5hRStFS1VzWUMzZlJCanpZUVB3eFdzbUVsMUlXZWxkUzI4TWhKRXpoWFdhc0MwUEpTNDE3U1BSRlZsWUNFejBndkNFN1d1MFEvd2Jqb0ZHMFhGS0J4WWxxUTdRRE92K0MwT0lLb2dPNGFTTWdjamlBcWg2aWlKam9WZEVRRXRvaUNlbWNCVWRZOEovRlZqNm0wUUlKOStxaXVza3FlRTdUZEEzM2NvaEVKVVVsY2w5YzhXczNlYWN3Q0pxY0hyd1VTRmlibEJLOEZFaFpXakFYV0hMejZaOUc0a2dRa3NIODJzS3BpNVlSRHU0eUU3RFFpaG9iVkNpUUNVbklEclNxYlo3bENnUk95azFTN29NSlh4Mi9pNUNQMFBzL1dCYWY0Z0tFSHFZNmdLOWFnSjRsanRrS1BTQ0RUMXZLREFETzFRSzlHZUg1d0RWdmh1YUVySlVoZGhOWUVEWW5JcU9VNGhJR3BiQ0ZLaVl6VThZRFZRbFl0bXhWYW9UT204bUpXMEZXRzlxQWs0Y0pzTUNMUlFBUmVLMlQ2VnIxWTBhT1MyQlVXWnA2R0tNNXd2bGZCWW9sYUZzR1pPV0Foa09sYlZRTUdzZE5BdG0vVndBNmtzbUpXT01sUkdsT3g5MUNVZkRDc3BHVVJuTjhDK01EZ3cxbWR2T2haVWN3SzcrRnFJTnUzYUVJc0dudnV4Uk5vS2FkV0ZwRlJBbE1nMjdmWVNVcFJJTk8zekRLS0FsbStiRlFFYUVVSHNtdWwrQnF2MHF4MUVjRkNabVd0aStDU0cwQVVKUmJoc2FTejVDOUl1UkNRZEpZRWQ3bFVBVXZKcnMxYTZJVEdyblVSRGt1bkdJMUZKR1M2aDJJMUZnR3pkRU1SdjdOVXBDQXFPYkY1VXlNTHBFaGxCUHVYVU04Q3NtdVQxcG9nZHBXa3RrV0ZoMm5KWWx2QVNGY2d1elpxc1lsSEwyejFFUTZlOFZWVWFURWh3WXFvc3VtNUdoWHNqQ3JSVlRZUFVZTUg4Y25XaUlraytZTHpqTkhJU1NWbkduVDhjZTZ0Qkd1QjV6bndoU3JGSmdtOXJXaU9rNFU2VWRXNkNMWWp4MVRSR0UxeWlzakhHNDNWSktlTTdJQkk0ZzNxWEFmTEtySjMxMnJxTENEU3VnZ0xDMUFqamRxcjY2V2dGeWJOY2FxSTg1RzFnWmJZaDZpS0dCVnV3bFN0aTNCUWhZcWFZaXkxanFoM2lOVWNKM2liUitzV2RhZG1RT08xZU1Lam5STnRLNHVJa0ZzMmFvb1RyR1dJV2xRZ1JpWjZWdFlzSitobGk3Wm9sbE5GL3NaSVFwWXNKMWluSDUxcFdVNGdMVFk2cTFsT01Fa2hPZ21jaXZNWjdCOWFMMWIxRmFCR1JUTGtyT2J0QUlNaE9pMk00THhzTkM0NXNLUmtFaEJsaVVZNG1LTEZUZk01eTRsWUM2ZFlKV2FSVVhJSTQ3bEwwWFZBdVZDUm93S2FsQWc4VVpHcm9jVDNCVWk4bWhZdzJoSkpkczIwQUxkMDlGR05CcGo0RzcxVUxxTFZUa2NSWHhTSVFLb25BakxYSXl1UGhXMDlnNFlzZTRYdVMzUUtCYW5oclE3bGpjUWc5ZUdjQlFWZXg5a0JuZ2NlMEpNOEd4UVZWb3hGYmhrMThjaEdzblk1L21Bc1BEV0MzTWtTZlFVeUNWSUJLcTV5c09DQytFYlk3ZTRSbFJaRVlCZCs1TDVSV2ptTVJzK05vNXc2V3dIZm96aWNKSVlPeHNXdG8zU3JBNXJRNjZ3ZEdudlVPdXVJM0U2UkRGcTJKeHlzdG9sazBJbzlZWkQ3STNMN0tPMTBBanRhVlRVb0FsUmxrdFpFWVBkbzVBNVMyc2tGbkdaazBDYjFhWUxjbVVnV2JWTHpDMmhya1N4YWFkamtrUDg2SmkySndLMEZJcmVSQ3BwaUF4WTk5NUhTZEIyRG5sVzBhWk5GR21sTVZiT2JLdkk5eGF4VkVUN0RJNVNNMnFqVm15RENHclBVclV1dEVPQnFsc3A4YVlDQm5oVWtXdUZnZjZlWXRTckN3ZlRIeUEybDNLeUlKSEpIS2IxU2daa1d1YVdVZHNsQkw2eTlMQnV4dm1oWkJIZHNBVVJXb2hEWTF4ckpxQTJhQ3dzTTVGaTgyaFVCSGwwbHFGMEJzODlpa2JJSXNtZlE3Y09kcFNSWkZKQmsxdTF4YzRGWXhMRFVCa3hqb3NwM1FNWG5aSlY2Q0w2andjN2h4bEtCaVdCalBNZjZVb1Y1aUpFYlM3bEpUbTBVZE52WjFWcTFGb0t2VmpTb3RDWTJvUmRtVFd6Q1Y2dm1JVWxFRzhpUEhjbFJybFp3bVNkak5FYmgwQUdmakpaRDBOVUtGa05paDBYVGFqT2c4b3RtQ1hoRUZNU2NjTkJsbVloUFZtOWdjTGNtbytVUURsYmFKQ09CaDRsOW1VeFJjd0ttbHlSdUx0VU1UUEFzYmk3bHhNSUVnWjlrdFI0Q251L0pTbVdqR0pnRlVIbXRtaWpvVEU1ME5rclZSRVgzVHVLbG9GSEZnTWFsOVJEQllxb3NjWWpna09HUnVMbVVwc0lDYXloWmFldkRIV2xBKzRUa2pEYXRzWWhFVzdwR3BLQW5Ub25SenBIQXNrck9iZWo4bXRnOXFqMFIwUXVEdG42RmJ0bmt0QjRpb01oSGNrbWJPR1hrNlU2OEliU1pJWHBmNmQxZkRYcGg3VTJjMFBuZ2pjWWhJa3FKUyt3Y2lLSXdBN3MrcVNOY2poRXdlbTR1cGM3aWdKNGxtcktrU0tKbmFWa0U3S3FVYUo5bU1Wb0RJc3BzWG1nVjBKaElhczhLckZCTlhzSkRPYUFFalJURUJFdXcwVk1LVWhHUjhHVVJ4UENJTUVrNXNicHR1Zmx1UlUraUxjcGRmTkd3STZ1aEVlWUxKKzN3SE9IZG00TDBtSnc5cWJEaUdEMHFsMGhCK3Q5Tm5oU2xpUTBUQVJvcGcrQldVT2hCbk1KTmpBUmFhSXBpMFVmWXpDeEZhYndRQzRyekpqSm55WkxnNGxXd0NhSVVRQ1M4ejdtZFZKQ1d3V2pnaFptWUloNTRaWEVrbURtUXVKMlU1U2ErNk81TFVnR1JMVkpDVTVMY3FnemRPNG5tUlZkZURuQ25rQmxMSmdRWlFjQXFTMGtLOTNLQmgwV1M0b2NDRTBkVGttNEViSkdnSnhVMkg4alVRQ3VjdTBoeGQxckFiekpmeVh3b0JkNzhXY29lS2g0MmNkb25kcWVoaTVoc1Z6WWZBb3BIcEN4eHQ1cWc2cGxsc2RXQ1RKcVVXODJEd2UvanE1enROVGp5b3ZaRFFFNitSSWFyMDBvNnhFOWFBRTV6WFNHVjdaWUJpQ1duNHJwbEFLbThaaS9Cb3V2RTNhTTBrVDhocXFqMlEwRUhQbmVQRXM4Y0NQQ2tva1VQenFHT2k2bUlENUFOQTRPb3Fwb1BHZDVudElhdHR0OXdpTXFLK2VEeGZWMWROd3lRQnM3dG85UXlBSHVIdTBmTmZFaXBSclVlS2xJOHRVR1RaRHlBRlYrMTZDRkFXejl4V0ZmN1dxTUxncnRIcWFvTHhKTzVra2E3aEJkRVpjVjQ0RXZYQWlvbjNSbEI0SVpJSklrcGVoUll5OXBoaTFzdkFoVWcwNVpuNHlGbTVEbkk3QXhJMGxnUjZKM1phTjBEM1hJR2pVdFNqTGxwWWtCdmxDUlFicG9JRk1ac3BKRXNOMDBFWm5YbU5sTFNEUkVOeTJyZFE0TGx1TmxLNHdxbVFxd25JNWZOaHdUMTVrem5GWnNQQ2E4YUsxM0N1R2NpdUF5ejFicUhiQUJKbHFCRGhnbnhXVnJQTVZGRzg2dVN4WlJoZzk2c1FVcWJvU002T3kxNnlEQ2NsWjBXUFhDekMvUkdjY0pJdDBmUTBwK3piNzFRQVpzemM3REVDUlhpaEJPRUVLWUNIcHVzZm1ydUw0bFdvSk91QUV3RmRNaXNmZUdaQ3RUVVpPN2JsYlNqSmRpdzNFY3FDaFZ3ejJXdjFRL1pBME0rY3hzcEo5MHhFWjRFdDVHeVFvWEV5RlZmUWdSVWxzeFIvaXBVNkVqeVd2eVFBM0xiWnkrOTBMaHBKeHg4bGFCRGp1aGV5ZHhJS2dnVmVCU0hscndRb2JNNWFPMURocFVibWZ0SUNSRUlIZVVnZGo1VFZmUkN5V25tdHFUb3RndWkvekVWV3FkQlN4OHlUSHJJM0VjcUNCWGlWcFdZUTA1SUM4emNSOG9wRlhnaE41S3kybmtWYkorb3RROU1CWWhFTnhKdWdiMVBGaTNuTXJHb3dXbER0N1RYTlIvUjRKUGtNdkdaQkdRZHRmWWh3MHpVekRhMjA1c01QYXVLalpHd3FzR211TnpvYU5razBkcFlod0RXYjA1YSt4Q2hXcGFUWUlpd251VFFzNlN5bDd0ckF5bHlHeWxGeS9Ib1VZS1JJam9sZWxZV0V5UEFUcFE1U2VrRE53RkFMSzJheXhUZzlaT041akxCTGt1WjcybHR3NEVPVkZwVlltTWtxSTVrcjhFSFZMcWJ1WkdVWnFxamRjcU5wRm9VQmowcmFTNFQ3RUtldVpHVWhsUVJ0NHJtTW1IMWdLeGN5V1V5a0tvWXpXVXFHR0hJYWpwVFJzY2JONUlLU29TbzFoSUlVQnlWdVpHVU5xVkh0MkxSQ3ZxSHg0TDlseDJkMFNzdUk2MGROZ3J0QStIK29iTEdGZmNQMVZGZWlmdUhLbHBXM0Q5VVg3TGkvcUZpaUJYM0Q2V3JkOXcvbElPOTR2NmhST0NPKzRkU2FUdnNIMHF1N0toL0tJTjVSZjFEUkN2cUh5SmFVZjlnaWxSSC9VTkVIZlVQMGF5b2Y0aG9SZjJENGZxTytsZFFZTG1qL2lHaUZmVVBFYTJvZjhnbHQ2TCtJYUtPK29kb1Z0US9STFNpL2tFdllVZjlRMFFyNmw5QmZwV08rZ2RkSVpwQkJ1c2VPdW9mSm1xb2Z3bEJJM1hVUDB6VVVQOVFFNDhPK2dlYkI5eUIvaUY5ZkFYOVEwUU45UThTZGRRLzJFMjNvLzRoN0tRRytnZEpWc3cvb09mZFlmNEJWMTdIL01ORURmTXZvNFNQanZrSC9la2Q4eStpM05xTytSZlFreHJtSHdRU2E1aC9mRzJPYVJUeUw4QW1BQjN5RCtiMWQ4aS9qT0l2SGZJdm9sQk9nL3p6MEtmVElQODROUUVRTmNnL2lETFdJZi9FNWh3UmRjZy9oK0dHT3VRZkxQSllJZi9nK3UyUWZ4WUcwRHJrbjRYR3hRcjVWekZnWVlQOFF4ZCtSL3lEc2JFVjhjOWhVTU5XMEc1UWJWcEQvS3NRVHJRQi9sVjRLemE4UHlKQ0tCb0s5MWN6aE8xUXRMOWFNTHlnZ1AwWkF5Rk9HdGdmY2Nxajl5bllud25JdnVwZ2Z5d2h4S3JhNms0Z3pGZ0QrN013bjd1RC9VMmdDaHZZbnkzSUJkUEIvamlPT0VIN2N4NGo5Q25hSDJkY29Ra3EycCtiUVBRMXREK0xoOTdnL21EeitoWHViekt1Mmh0aElTQ2hEdmRuNExidmNIK0FvbUg5UlRpL2p2V1hVVlJpeGZxRHlia2Q3STliQVNMb1BRWDdJeE1FUVdjMXNMOElzem83MkYrMDZQNXVZSDgwTEhSaU5iUy9VQ0FFWm9QN3cxcEZoL3NMQVNQbXRiSjJtTEhRNGY1Z0M1dU85dWNoUEU1SCsvTUJZd0lxM0orM0VOSlY0ZjRjekZ2dGNIOE9HbjRkN3M4RkRKcW5jSC9zYWdPY1Y3Zy9QZ2dSdEszaS9VbXZHRVMxbHJXajgxc1IvNlNzSGF3YmdmeVQ4Z1ZBazdWZVBVTnRSVEgvNU5wSFlJV3RxdDFqckx1RyttY2hlS1dpL21ITXBBYjZWMkZmeUliNXh4bjFnRWFMMnZGSm80Qi9QQ1JFbERvb0IyQm5nL3Vib0hRMXVEOERVYWc3M0orcDhIQm9jSDhXRlVSM3REOEw0NGNkN2M5Q1U3aWgvZGtLMWJxRzl1Y3cybTVEKytQK3pZQkl3ZjRjQnJoc1lIL2FUbmxNMWNEK0pzTnFZSDhCd2d0MnNMK0VjZndVN0E4djVBYjJGeUFHU0FmN3d5MmVPOWhmQ0NoTTB0SCt1RWNTd3Q1VHRMK1FNWTZmb3YxTnJycUc5aGNxY2tWMHRMOElyY3lHOWhjTlJFTnVjSDhSSW5GMXVMOEFtdzUwdUw4QUV6azczRi9BSUpFTjdpOEU1UC9vY0g5aEF1U1hPeXdIZkZaWmRLR2lyYUY0ZjZMQUljQTdMV3YzRnNQaVdXMmZXMUFHUzRQOGsvNHpVOHcvMGVRUnhsNVFMSEVEUVVVVTlXOEN4c3F3ZnpOb0g4WDlZd3N3b2FFcjhKK0ZYYzFYNEQrb1k2ekFmeGo5cXdQL1JZaTQwWUQvREt5ejZjQi9Cc0llZE9BLzR5Qndvd0wvR1pqUzJZSC8rTzRFUktrWHNLT2hLK3dmYm52V1lmOE1ETzkyMkQ5NHYzYlVQeTYvQXRKcHFIODJJVk9sb2Y3WmdvSkpIZlhQV1JUdTc4Qi96dU5uS2ZDZmc3QU9IZmtQdCt6b3lIOWE0VE9tS3IxK0hjSVdLdktmaDJwMVIvN0RSMkJIL3NNWnNCMzVMM2dvb0liOEZ5TEdHbFRrdjVBaFZsVkQvZ3NGQWhnMTZMOEFuWVVkK2kvQ2RKS08vY2NoTy9Rc3dmNkxzQXFrWS8reDZZM0E3QlQ3YnpMNGh2M0hzVTJFeEtmWWZ3emJCNGdVK28rZUNPSXdIZm92R0R4RmhmN3pHU1ZITmVnL25IUFNvZjg4VE5qczBIOE9BMjAxN0Q5WGtEKzBnLzl4L3h4QXBOaC8zT2NKdlZDeC81eEZTbmpIL3NQdC9EdjJIOFpoN3RoL0ZqWUs3dGgvMWtJRTNvYjlaeW84U1JyMm40RzkyVHYybjRHYWM4Zis0ODdYZ0VpaC80eUgxMktEL2pNQkF3UUs5SitCVFRVNzlOOEUzS3RCLzVrS1pkMmcveGdCZTQ3K1oxR3BYQWYvNDQ2Z0NEOVB3ZjhzeENQbzRIL093TXRNd2Y4Y3JJWHM0SC9jaFI4UUtmYWZ3empaRGZ2UFZhaFZOdXcvajZGdUcvWWZXNmVBU0tIL2ZJTFNhZGgvSHJyYmo3RC8wT0FWK3cvM2Z1bllmeHlOUkdDRGl2MFhZTGZuanYwbmJYN0hSQXI5cHdBMlk2cFc2bDRnWEo4aS93WG9qdW5JZjN5TW83SFg1dklFRkpyQ2xPRTlVTmRDZDNSa05lUy9nTlhBaHZ3WHNMWFNrUDg4Uk1ycHlIOCtRVjQxNUQvdm9Ua215SCtUNXZNTittOEd6cTNZZndMcmdvQVNxMEtMQndqZG9PaC80dUVDdUF3Sy95ZTVtZ2o0em1rUmU4S29mYjRiR1JCTFVCRUFMV3pJMEJBQUxheHBXUkVBb2RkalJRQ0VIVWc3QXVBRVFxb2hBQnJVb2JnREFKcUljZThVQUJCM1N1OEFnS1pBbmlvQUlMMFhJU0UyQUVBTGpkd09BS2hkSmNkVUNnQm9NWjVIQXdERXZaVTZBS0J6R0w1UUVRQWQ3S1BRRVFBZFRHSHJDSUN1WXFTOWhnQ0lRSzQ3QUtEM0tHN1hBUUE5ck9Yb0FJRGNtd0ZSS1FDZ3J4QnNxaU1Bd3VZVVJ3aUFFTDZ3UXdBaVRiZWpBQ2E0SWpvS0lFWVM3U2lBR095bm9RQkdtSFBSVVFDeGw3V2pBRWJZTDdlakFESkNISHFqb2dDR2pORUpCUVV3Uk14VFJRRU1IcUp1TlJUQUFIMHRIUVdRUGYyQVNFRUFQZFIwT3dpZ2gxMEtPZ3FnaDlEdUhRYlFaVlNxMW1FQVhZS1FSZzBHa0VFVDBlZ1ZCdEJaZUZvMkdFQ0x3ZE1hREtCTkdDelE5dnduNEpCcE9JQnNzS0M5b1VDQUU1eThEZ1NJVDVJR0JKandEQnNRWU1SVUt4RGdKaHhBdEdFN0VHQ0J3RnNkQ1JERGMzVWtRUEM2RGdPSW9jd2FEQ0JzUzNnRUE3Z0pCUkR0c0RzVVFIUUwzNkVBSXVUVk94aEF0SzQ2RENETTNscGhBR0dMd3hVR0VDWS9LdzRnaG1WdU9JREJZb2cvQlFJTStEaHFRSUNjakRvSEFvUkdXOGNCREJtcXNBMEhNTUMwckk0REdDbzgyUlFIa0NPWWN4ekFnRG92ZGhqQWdER1NHd3hnZ0Yya09nemdCTEc0d1FENkNpK3hCZ1Bvb2VuVFlRQTlGcUxDQUNLczVZWUJpUE41T2dhZzFvSVBxUm9Hb0lPUVFCMERVQk1JeDFSYUR1OE14Q3h1R0lCOEhJSGwwR0FBYllCNG93b0RPT25Fb2ppQWd0V0xpTFFhM21RTVlLaVZFU2JDczFTaEFBVU1FUUNYZEN4QUI3RmdPaGFnQlNHNUZRclF3aHFwRGdYb01PYWVRZ0hDMnRvT0JXZ3dVaytEQWpUUXFiaENBVTR3RVJzVUlLd3k3bENBRmpiWDdWQ0FiQUFDSWtVQ3RCVWxYcXhJZ0E3aHZuVWdRT1N2N2ppQURycVBPdzRnUisvUUJCc09vRU0yeUlvRENEdGFIZUVBb3JYVmNRQWhHRkdEQVF3R3NsUmhBRGt0RTlBMEdFRFlqV0dGQWNRWVBCMEdFRmE2ZGhqQWdNRWNHd3dnNTFLaU4yb3RQRGIrT2c2ZzVtV09xUVFITUVDODNvNER5QTAwd2VBYkRtQ1k0TzFwTFh5QW5waU9BOGpXSFhxalZrMTRpRVBXWUFDNTdTVWdVaFJBancvVGhnS0lhODRiQ3FDRDlXRWRCZEJGaUIvVVVBQWRyS0ZwS0lEU1ZCL2g2UWtNSUlkb0VLQ2dWc0xiQ004SHhRSGt3QkZ3bkRZZ1FBbENvZkxjdENnR0ZEcHh0UjVOaTFiR1JGb0pieUxFSXdxdGJpSWc1WHRGQTRRdGNGWTBRSWRyaXhzYW9JZDF3eDBORU9YT0tCZ2dyR25wWUlERVVGUTUzY0VBSFlSeTdHaUFNSW44Q0EwUVFVcmR3UUVpZUxFT0IraFExc0lLQnhnZ3BtcUhBNFNXU29jRHhOZDBnd1BrNHdFQi9UVTRRT2ltWGVFQVlYUEtGUTRRdG1Mb2VJREJRS0N1aGdjWVlCcFl4d01NTUUycUF3SkdaQnV0Z0lDb0FtM0ZBNFI5d1ZjOHdBSWhuQnNlSU8xdDFBbWdBUUxTM2thTHF3RUNSck1GRURCZ2dNZ0dDQWlqaVIwUU1HRE5yUUVDaGdoUDB3WUlpTk5yT2lCZ01DaVZxZ01DY3JjcEJFR29sUk0rWURoREJRVDBzRzFhQndUazFGVEFWQVVFWkZVSkRVc0JBYlV0MnBoS1N5Y2NxcTN0ZUlCMGNTS05SZkVBMlJzS29xb05FRkJTTHFhSWdIeHpJc05ISVFHbExRb2FGNmRqU1RVRG9CRk1RS2tHUmUvTFdtUGhJRXZ2VUFFaE1HSXJuNEJkN2xkVVFBT3hIVG9xb0VYZXU0NEtpTEVmT3lvZ203cUFTT3NuR1BZUHZWQlJBWEUrVDBjRk5CVmllRFJVUUR1Wm9xSUNXdGhFdTZNQzJrMm9nQk0wcDQ0S2lBV2txSUM0WjJ5SEJYU3dFVjJIQlhRdzg2TERBbXBYd1RGVmd3V0V5WllyTENEVUYxZFlRTGo3VjFoQW1OTFRZUUVyQnVsVFdNQ0FBclFkRlZDYjZZeXBGQlV3d05xM2pncklOeitDMzJ2MUV3bWlyelZVUUZ4WjJXRUJaMVFLQ3hoZ3VWYURCY1NZRXgwV2tHR3RFT2Fkd2dJR1dNM1FZUUU5OUYxMVpNQUp5RlJEQm1UdEV4QnArUVFHVUduQWdOWmg1QjJwKzBySTVtendnSktaaXFEL2l0WndRMlRvQmhBb2xSOElRMDhRQXVYY1F1MkhySm9aSGdXUEdrWWcrd3dSaXFlQ0JGcnQyanVtMHZJSm1FcSt3Z1JHQ0Y1NUJ4TUlwOWhnQWpFTVhZY0poS2xHSFNiUWVDaWdCaE9vT1U1aktvVUpOREJWb3NNRUdoaFhhRENCQm5ZUjdqaUJPTXUxNHdSYWozeHFIU2VRK3pnZ0pFVEZDYlFZa0svaEJPTDZqNDRUaURHV09rNmdnNjA5RzA2Z3d3dTE0UVI2aXgrbE9JRWVRd3MzbkVBUEhmZ2RKM0J5MzNXY1FOaGhZOFVKaERIYUZTY1FWb2QybkVCZzMzV1FRQzRlbUlNRXNrOEo5U2hUa01CbzRJbmFRQUlqcklMcElJSFJZZmcvclorSTBESFZRUUk1cXdJOVMwRUNJd1o1VlpEQWlMenVIU013V2d6R1ozb0NGTVRaczczbEUycVAxMEFDSi9kK0F3bWNxRWtOSkRBWS9DeXRuL0FZVFZ0UUFnVmhBTFd0a3g1TTB0c0R2VkNBQWpuVENEMnFhaTAzREpvMnBFQ0JiVUNOOGdRcVVGeDBZSWFLRmNqdVBnakw1OVhLZ01rU0RTMVFVb2dRbGRaUFdCakVYT0VDS3dLazdtaUJHWldSckdpQkdLSzhvUVVLT04rSXFJTUZHZ3VScEJwWUlEYWFPMWdnRndOUHdRSVpUZ3UxT3d5OS94T0VGRlN3UUlPNjUzYXN3QW5NU3NNS3hCcFh4d3JFcGJzZEsxQmhDNFpVRFN2UVFtMjNZUVZhMklDMll3VmlaYmRqQlRvUDRUNGFWcUNEWGRJN1ZxQ0R3UFlkSzlEREJzNGRLNUJPRzRUbDFiQUNQWFNyZGF4QUQ5TzdCU3ZRdzhEamloVm84SU5zejRGQ2dKd2RLeEJDcXE1WWdSSGRCVWRnZ2VoUnNlZEFvY1hjd0FLamdTZzRDaGJJdWdHQ01GU3d3T2kyZ0FWR2g4YmVzQUlqOUpaMXJNQm80V3BvV0lIUlFNeWdoaFVZQ2hSMXd3ckVqYTRhVmlDK3FSdFdJRi9DQ0ZoSXdRSW44YUdHRmlnSittaUtWVzBNdkNBVUx4Qlg1VFc4UUVHcUJVUmlJVTZDbUEwd3NHYU1UOGk1SjlWQzJTaGlZTUU3UjlzKzU0cUhKSWlCR1FLSE44UkFUdkJFc0lLQ0dKZzgwbWc2WW1DRmE2cEJCaWFJOGFhUWdSRWVvUTB5TUVKOFFrVU1qTWc5MFJBREkyeHgweEFEWTRhTFhCRURJeXdiNjRpQk1QbW1Jd1k2MUUrc0l3WUdqUE1uMVJJSk5tMXVpSUVKZXJNNllxQkI0R2NOTU5CQkdMVUdHSWdhSWpXOHdBeTdTRFM4d0Z4UTJtdkhDNFJKUGcwdjBNRUhOY0RBZ0xFQVJaa3EwQ3ZUQUFNTERJUjF3RUNZOWRFQkF6RndhQU1NeEFlS0FnYldncUVBRlM4UXVteFh2RUNvcVhlNHdJaGgrVXczSUZBMzhUdTRRS1NwMzhFRklnMzFEaTRRU2ZrT0xoRHgvUTR1RUNtZksxNGdLRUk0d2d0RTI3ampCUWJjVmJ5dVdCNEltSy9oQldMRnN1TUY0dEYzdkVDWThicmlCUVpVWmQ0QkEySDdxUlV3c0VCVnZTTUc0cU9oSXdhaTJQWUtHSWczWWdjTWhFMVZWc0RBaEk2SERoZ1lZREZ3YnBpQ0NJdXBBd2FpM2o4clhpQ0d1T2w0Z2RDcVdmRUNFd1NJYTNpQk1VT0F1SVlYR0dFSnlJb1hDRk5SVnJ4QWkxWjh4d3YwRUQrcDR3VUdkSGl2ZUlHdzFmYUtGd2d0L2hVdkVCYlRybmlCME8vZThRSVREUHNlUVFZaVdKMEdHV2p4Q3h0a29FT1h3UW9aQ0F0TlY4aEF3UGVPRjRqeHREcGVJTVo5NjNpQkVBQjZ4UXVNK0kwTkx4QldOYXg0Z1JqVHJlTUZScVFjcm5pQkdLV3M0d1VtaklEWDhBSVR1b1ZYdkVBWUgxb0JBMkZaNFFvWW1PQXVhNENCR0dxdUF3WmlmTGdPR0poUXB0QUtHSmdnSkdMREMwd1ljNi9oQldKQWlnNFlpTEo2Vjd6QURCZHF3d3VFYVNFclhpQSttanRlWUVhcThJb1hDTXNQVjd6QWpNRU9HMTVnaGxCbWQ0Q0JhSmQxd01BSUFWRTdZS0JINnM4S0dHalJnbWlBZ1FtbVhuYkFRSVdQR1ZNcFlDQmZMR2lLQ2hpWVlCNWFCd3lNc0pWeEJ3eU1DVE5DQVFNamJIVFFBQU1qN09YZUFRTTFoaittYWtVU0VZTVBLbUJnMkFRWTZERWlYVU1NWlAwVWlMRWhCbm9ZUysrSWdkN0FNMXdSQTEyQndLTU5NZEJGK01LR0dPZzhpdGVzaUlFR1NyRWhCdUkycEIweEVLY0xkTWhBNjVFWnVFSUdRaTlxaHd5RXRlOE5NWkRqSTRoYnJVNGlZVDRvWXFDQjZUWXJZbUJDTy9ZbEFPL1pnNkgvTEZmUmNoUEN3L2VYNGVsT0h2ZnRELy85WDMvNTIyQlNSdjQ3L1BYUGc4OS8rKzEzNXZEbjBXKy8vemo2dFcvTTRRdDcrUGlud2Vja1dKbUlrei9ZMHZyNEl4amh4ejhjL3RFWVQ3WlorR0JNTlBSM29UODhmYituLzAvNi80SCtOaCsrL0RnQ0FQejY0MHlDUTFaZExjTWhxbUdYSVBHSHU2ME1CR2dIeUljajNFTXpRRDIwNXZEUGwzK0IxWkc3UDBaSWlIUzlPam9oTGcrU3NTcmQ4S2o2RHJOeHdLQ3RLNWZ6QlByM2FQV2l0VHRZdVhqZDNxMWFiNlN2Nm5qZDNxMWF1a0NNL2FyOTdVZXI4K0xhM0xJeWI0UmhsdFNGcXprVzNqTEhIQmxNVjNNc3ZtV09lVklqcitaWWVzc2NDNlMwWHMyeC9KWTVGc204dUpwajVTMXpMSkdwdFpsalliOHJIWHRJcitmWUU5eVZVNTIyYVlzRG5mYSt5amxnckQ0cURsSEYvL1NiejFjc3B6TWhkcjZXcVRneWFWL0pWTHpQcjJVcXdhZlhNcFhvNDJ1WlN2TGh0VXdsZTM4alV3SHVMcmt2MjR5NGcyQ2hTYjB0bDFjZHU3T2tucjhUUm1kTStJYitMdWYrTWZmTkxmbkZsa2gvdjN5M0dNbnh4OUZuaitvVTIrQWRkbFlReGo1L3AyelFnMS9XZnJIbVVaYjVEVEtOMjl0dloxdDhHYWZEdHJWdHM5dlg5dW5YdnJidmovVElRbjRaYS92bCtodWMxdXR1YzJtOVZhZU0wOTV3MjN3eWI1aEp4Vy9qVVh6RFBOSWFzam1QMGh2bWtVM2JlSlNmMmVjcGZoei9BR1oycEljOXIzY3RNZUQ0YTVsSnlLOWxKcTltZGVYNlNpWVMwaXVaaUhVdmNTSm5xdlUvSEg3OS9WOSsvOWRmZnYyckNlR3Z0bjQ2L216MHllam55SDY5eS9VS2t1U2FUczRrYlBtdUx1bjczakFzWk1HRVBYV1MzWGVPM1hlS25UbkRHQXdqbmZ4NTN3L0dRenRkTjV5b2JDcjkrTlR2OWQxbG5wOE1leXlMYlJ3eWgzUUxIQkxGNXRHNGMyK2FaNU04bmFJOW1lQnNOdWFRVCtiQ0RQL2g1UDhaMHp6NS9wZlJSWHRFa2U4dGpPOHVUZTlrQ2xoUnZlVENQMWRIVDVUUVM2b25kMzczdW9ya1g1YXhUaTBIVGhnUnV2aFQ5ZlBJSysrTmliRWxuWEk2akQxVlFvOVV6N0hDK1N3elpHQjVrK1l6ZEcxMm5Gb2I4ODNNamxHZTgzeDJwZ1ZISGw2TzRKRHlEcHhTRjY2dnU5ODh5eEtlM2ZOM3Y4cnRXQzRrR1YvWThXY1h2SkZRekk4WGZ1cGMrNk1IYSs3Uk1EaW5EV2QzZ1g0UW5QQkNtcWZKVTlaL3g0c1BhaC85TVBvb2wvNVkyMTlzeng0a3VKWm56NURYSzVmb0tlYmlFTzZ6OXA1Q2cxU1p1V2Y3NkFaYkxrVTJ0MWpyNDJqbXlENi9ZSnVQN2ZMN1c0eit0clMzU0pPNVlKb2ZuUjladzQ2Y2toL2RKUlA5ekR5Zm1lYWJtRUhySVBPZm52WFdFUHpUTVlhYnZpY0IxTjNBSG83UU1udXNhOUZhcm1xd2QvOHZuNytubjc5N090WTk3VHFpcTNZYnF5U2xtWk4wbVQzdlJvN0QxOEFTeCtYQWZ1c1MwbFR2STc3VVY4dVhVclJ0L0JhdXZOZHZVeDZBRzlpOHZPWjQ1eTZUTHVYSkNYL1JHSjdlNWR0dTg5Rjl2dTFHQjNmNjliYzZ2TmV2dmRsSGQvdTIyLzM4ZnIvZ3NzRHVpaTN4NjlrOXY5VXZqektYeHQ3NGk3NTQ1SW0vNnM3ZmtxMTBrcW5rQnRHeEMvNzZ1YmQrSTk4MnFRV1B5a1BwNUpPa2wrd21WcnB2bnA1THo3TzZiT1htU3ZqYU96bmlTN3YwNmppSytQcTQ1QmlKMlcxZlB5dVg0amlPK0FxNU5GVVZUbmowUVZYTHk4ckNKL0huMHozUzF5a1VESUVkcHlianJsQ2NmTGdyRkdkVGV1RUt4YWtiZ2Uzanl6dlZMY25jYVJndlZRMHBrdTVuNkRzTkFtYS8rODNocDVlcHZ4UnVzYjc5K3RudTROQ2Y3ZXJPK2VCNmdzdlJSVjYrM05XZGU0UHJxVktOUzN5bHYvdHlWM2RPaG5iejZrNUszUDl5VjNiVzM5aVZuZUZUdnIxWlpTZnFuZWp6MjNTUXNCSlh0bXNZYTlPbk4zUGFtMGhiK3dyTndmVHZOOE9oRFJHVTAwVDk5dDMxcS9CbU9GV3pPaENlYnkwOWxlN0FvR0ZtajcwYy84YXVQUXlmOHUwUE54dDdJZTNodzVkN2FHVVByZXdhdytQN0djSzQ5T2pyWFZ1NFhXMkIreGNudjBkV2puOWpWeGVHVC9uMmh4dVBySmhCUVRjSk00UTc1U0tNSWlyWkg1NHpzV08vVjE4b2g2SmdGVzVkakdtL1NlOFA3Z1hlcE5jWHpUMUtIWWc5cndNcGpLTWpYSlovMFMxVGwyTDh1THpsbnVyRzUxZ2VHZ2lHOFZaR2E5VXdDTTU2VHQ2TFR6OW9BUWxqUFZWVTZuWkIzSFB6N05KaXY3Zk1MN0g4WGcrYnROajdTL25JTkQwTHlCa0dLdXNmaDZCVk9Cd2Y3bkZpamd1emg1ZXJkUGlxa3JabThmVHo4NnNyTThqUUhWckErVnZqM1V2WDRpYnVuM3FmOG1SYm9RMjF2WWpIR1ZqRmMzR3JqZzZweXdmVTJlRTBPcGcyZEI4NkV0NVJqUlEzbWhXSk5Da0lBMzJUU215U3pKcXFJUkw5b1BTeGpodlV5ZTgyU2N2bi9MdnZtb0JpKzMwR2ZuamZubS8xWnhMTjlIZTFYUEw4MnNaM0lRSEVrVTV1Y1k0SWJlV2piWDVlRHNaZjl3NWN0RFkrKzdnRVo0RmpmRDUzNVZsd2NUVnQyditYMXRGNVlvTm5BTCtMcFhkYlN3cy9kZWM5L1d5NVA3TWRGbEtldXB2MDI5dWJuYXRnNFpZTmMvWGwxdWZxR1prb2t3NHhuK3RYTFFpWjdnNjhVRzUyM293ZFpyYk1tdy9jMDhMWko3Zzl2WU8zNThTcEUyL1lteE9NWTl6SFM5NGMvc2hMTmpEOUl6WnZ6dnJ2T0hoWUhIbHoxZzl6NlkrMi9mVzdOK2VGZTNPRy9obHpaNTJNQWg5c0dFeHRjY01JblNNN3AzKzk3a0RUaGhMZmh5dnl2UjN2aDdzaTkzWHppdDVXM25wNGpTNmlrQVRwY25jdDZ0ZDUwbXRjU3RtZHIzZGZaN3FjZDB1Mk80ZnV2czQ0bEF1cE9zL0tJZXlHdlZhOUdSYVliMnNLdDBIWDNhcnRqdlhkclJvdjFIay9SZXVkNkwzWGE3NWozWGVyOW50Si83M1lMUS9yd0Z2YnA4LzE0Q3RhdzRJdCt4aE5ZYS9UaWJkb3hWdjE0bzJhOFViZCtDbTY5ajZ2YUx4ZnJKM0Z0azZQMVRmTHFzSW16QldzQ3MvWkMzcWI1ZlVFYk50a2dUMmtEWGFiSzlGZHdkS3BUZllwVnRuaDFXOWc1ODJTekZXSFhXZzhtL1N1ZUFPOHk2UWtoU3M0bDQ1VzNZZkhYM1ViVUdpOExVdDFrblJ3czNoazF5cFcyMjd1cDhPaWVSbHNpOHY4RURqaDNLYmo4K1ZBMHp5em5zUWRYZU5WeHl6c0FNZGZuM2hJekxqNnNBYjlzTUhMYnREMzM5a04rcmRtMEkvUk1EZTFkbmxidHRLMnNxZ3RoVkdITjJBRWJXbktjbkxOYk9pdmRuajltcnpQUzY1WGNLMDNzeW1Qajl6MGdybVdNeDBUVjYyMmVxUTBmdGl0bi9WcnQzNXUxUHJoQStEOWJ2MmNmajJBOVRQcDhYUWoxcytnMzlOdSsvVGYyVzJmTjJmN2dHQm1kRWRWbUo4YnpOeHRwQXREM20wa3RaSENKOWxJL3ZHMTFwZTd4N2ZrODEyVGEvUUdPTFlwdzIvbjJmVTVmenZQcnM4Q2ZCS2VQYTE2UFd5SnRpdlkvWGQyQmZ2TktkaFYwNFBzTUgvUDBqM3VEbGNHSS9iRUxWVzBFKzJaSzdTZ0IzZGczSkNlVFNkSnZ1cFdldC9pRUwweDJic3ZkMTE3MTRGMlhmdjhhOWUxZDEzN2FYWHRjVVBCWGRudXY3TXIyMjlOMlhaZkErVjVMN25aZm4zSHhkUzk1T2JTcCtlZFhjZ2N1cEdTbXpsUzJCQXI3RVdaZlp0UXd6NnRYc2RBM0xERDRTMkVZNjZ0b1pnQVpCME9lNzVhSCtTRmR0L3Z2OXp6MWE2Ti9IRytYOWp6MWRhdlBWL3RlZG4yeWZscUdSWHM3Zmxxcnl4ZkRYMDYvbXo4Q1Q2dytqRVZzMTlNU2VuK01UVTc3dnJ2bDRPNXZrc2VhWWd4NnNLaGYxVVZKMjZYTi9kNW1LbTNZN2pVK1JtWFZnM2R3RU92Z3ptNGRQa3o5TW5sbjE4eS9uOTNVZFBlZWdzRnk2MTJmUWdIWjl6MTZ2d1dKeEYvSFR1SzR1aWVZN0svRDArOWZ4cCtNanIzU05ML1BQam8zLzBoL0ljNS9HSDB6S1hVY1BMbjRWKy9IZEFTQjUzMWg5R1VmSW55K1ErRHo3K2JuYzFEcnU2OGw5VmJET1E5Zjc3enZuODlNTzlEeHJ5bnozZmU5NjhINXYza3pMSDdtWFAwOWJDOEp5c2RzWjQrM2puZnZ4Nlc4eUZCenRQSE8rZjcxd09mTnc0Zk4rN0JPWCsxN2ZuOGFxNzdCTm02b1d4cEdSbDM4dWVMdXhGdVVFYmhZV1VrTWNIWS92eGsrUVRMa1VYTGdDZmpqUlFjV2VCS2hHaVNVeHBBNUJjYmxjZ2lvbFJuYnd1TDgwcFRFRkhPUWxUQWs2SkV6NWtvSTZMU3hqMCs2RU5hdkhLcEZFUlVsVTBGUENrdmRLRllSYUVaRXJWM0lZb3UyeExHUkhXVnJVTkVxVEZwdkpXajZjSXREaEZOaFJ0dEYyNnhpS2dMZDB6alZ0a21SRlNVU3hrUStTN2JIQkZSbCsyWTN6RjAyYUxYeGVtNzRnYlp4clFZNVZHR1JFMjI2SFY1bGExSFJFMjI2SFdsQ3hlOXJxekNCYStyeS94QmRSWHVlRWpKckJzWEVqWGhvaWZaVmJqak1iVmpFc3dzdVNYNjZidjhCdUVTVWQrNDQ2MlVRaGR1OW9pb0MzZE1FMWZaRmtTVTAreEJxWWsyVlVUVFJRdGVsdGQ5aTJpYVpOSGJ5aXJaaklpcThpaUJJZFV1WEVDVXpRYmhadE9GbThaanlyWUxOd1ZFbEtZRHowNHl4YXhjOUlDb1NUZU9tY25JU2ZxZ2lHaWFlTWZIWkE1ZHVyRWdvaTdlTVUxY1FweU9PbmJweHZFMnlhbExOd0taNUM1ZE5PN2NwWXVlVkZicFdrU1V5bFJ3dFVzM1JrVFVwVHNtS3FaSkYvQ1NhSnAwNDNqY3hhN2lkWWlvVHRsVTNDcGZpNGlhZk1OWUtzV3Y4aDB2cHhLNmZJRWZrb2lhZk5Icm9xQkdUMllYdTN5QlVGSVhMeHBTV3NVTEpwZWJlQU9rYWVJTllFaGw4WG0ybjRpb2lSZU51M2J4b3RmVmRmdU8xMEExWGJ4Z2R0V3U0bzJJS00ya1cxMlhMbnFiNjlJTllOeCtGVzlFUkUyOGlDaDA4VnBFVXhyUm1DWjI2UVpJMUtUcng5S3RxVXNYRS9YTkMxNlhWK21PYWNwaWxFbStJcUs1Y09zcVhFUXpsNjAxWmhWdWdWUjVPbkJyeUxhcVc2aTZnQ09nY2wzRThGbHVsWEVDVkg3ZHdnNVNOU21EcFdCTjRBdERxTkRvNHlyb0RLblNmUENwaTlwN1NOV0U3UU9neWwzWXZrQ3EzUFlFWWxkWmhSMGdWUmMyZWxaZGhaMGdWUmMyWUwwMXE3QURwS3B6ZmxtN0NodHNJZnA0dnF0VlJ4UWlRT05YV1Z0STFUYzI0S2tOaTV0dkRhTHFzZ1pFY1JWMWdsUk4xRkE4YVJXMWhWUmQxR2hjbVdVOEhWZGVSUTMyb2kycnFNSFdzTFdMT25oSU5kLzhqSTRjcGl1UXFGS2VIUFRXMlZYVURsSjFVWU94TzlkbEhTQlJFN1VESzk3NVZkU1FhSDZLdU5BRjdRcWthb0oyaU8reEN4cU9QWFZCd3plbUptaUgrSjRYMjVobElWVVROQnhXNlpKMkVWSTFTY054MVhWWFk2b3VhaUFnYjNnTHp1WklWUE1YZXJ2S09rQ3FMbXRBNUZaUmcvUEIrMVhVSGxKRkhid0ZDOEtIVmRZT1VuVlpJMjdGTG11YklGV1ROYVJLWGRad2pvbTk2L0lzc0xwODdySzJBVkxWK1JSTGx6VjhWT215dG1qd2RSVTJlR013aTRuVEtRYXpDaHVNSzloVjJKQ295ZHFDUXltNFZkWU9VblZab3lsNlByTm1LNEtvdXF3QlVlaWlOaGxTYldCVzdLSTJCVkkxVVJza25zUm05bFNJdVl2YUpFalZSRzNBNGdxbGk5cFVTTlZrRGVkWXU2emhHeXQ3WjJlamoyYVZ0WU5VVGRhSXE5R3V3ZzZRcWs0WFYzUmJoRTFVTmMrSDVWZGhnelVZdzdxdkhhVHF3Z1ppakxFTEd5MHZvdW9iRzRneHBuVmpRNkltYTBTVVYxRUhTRFhmMXJHc2txNlFxa2thRWRYMUJQZVFxa2thU1NlWkxtbDA4eWU3U3JwQXFnM1hkWEliVHZEa3R0eldpVTdkS2JlSXFBa2F2UzkwUVNNZGo2aktoaGZHOWE0dWtLcE8xYVNVMk9hWnZqQjFTYU1aNWsyQ0xxdWdLNlNLODJXYTZpcG9ENm5TWEJOa0tLM3BlVVJFZlVzaktydUsya0dxTG1vMExMZUtHbE9WT2J1eVgyVU5pZnJ4amFZWTF1TWJEU3V1c3JhUXFzc2FFQ1UrWkdaTFBxZFYxR0FKNXJ4aFV4UFJmRlBuMGlYdE1WV1ROQnhWWlEvTDdJQWdxakszdG9ycGtrWnY1S0x5UEYybnhYWlJBMGtYMXlXTkRwc2kwY3ZwQzMwWE5SeThYMFVOMkZYQ01yY2VpS2p2YXJBZ1NseGxEWW1LbmZNaGRWR2pZNFNvUk5RV0JmUnR5U3BxQzBsRXpnWXFuYVdJbkUyQnZwRlNwV0dNaVNoamk2bFkwTVpEUVZjamd1WW9CS1lpUWRlTTB2WnNwU09YUTBNTzB4QWpxNGNIV3hVM0U3MFQ1TFV3RVVtWkdJWThVdlFpRWpJdGlJcUpTTWEwbGtHdWphMkJSVndzeWlOaElub1JiV21EbmtSSHJjVDJ3VHFvaVNYTVJCRVNrWUQ1YlVoeW1lWEwwWFpNUktPaExRaldlQ1ZPYzRBWXZxeXd5R2poSmNTa0t0SWxPNlpDSXBJR3NRb0UyQnd0V3BJdXZYUkN4RHZZV0RBNXg1OTZpVUJob3Bva2hnT09mY2N0bm1TZmcyUEYwYVkwTFgwM1FTbzVxdU9TMFFTREh0VUZqajNJU2UwczJuaU9UaFE2ZmRseG5CT2t5dG9FRTNpN25Va3NabkdZRmtqRlo3VTNLSWZQTWN1ak9CMTlnVlFzYVErRFJZN08xdURVWVJvaEZjdWFPK29qcXNxeWRna3lsWS84SUV3RkZqdFRzYXlkUVJhN28zdElaSjJScGNwVWlkZGdRSmUzMDZ1V3J6WVE2MklxRmpieEl3RmhXeS9DNXBVUklCVUxtM1lJcUhoeU5HemUxUlhsbWpOUktYd2hPY1Q1eUZQanJBY0xpVWpTMWVHUjAxSExxU0VPU1RDem5QbW05SkNJeEV4UFFsdUh0aktwRWhXbXRqTVJDYmxHdkJJcXk3aG1sR2JHUkNKaWcvUWxSeXRUUkV4SFZvQlVJdUlJUlV6SGtBKzZxREJWS2JKQUlaWEVhbm14cHdDcGVEOXJXSE5NNVdVL0c2U0RPaGQwUDhONkFhYUtXVUppSUFISzBjZldTb1FLSFVaRXhmdVpJMEZvOEVuMnM0ZlppVXpGd3ZZQjVZbzVKeHVMb3hib0ZpT3FJdUVJaXdaZlJOWSt3Yk9iRDlxaXd3SkVWWTl1NkZ4aktqbTZLNG9STStLNUh0MlF5TElqV2FLdEJWS0pxQTNLZDNSZURIQmVnVGxES2ptNkk3d0d2TmVqRzhiS21VcjJkVVYxTkk1WTdwcFdreUZWRWYwSVZHUTRIM1ZiUThPTHFmam9oa3FpbytYQ1IzZEdEbk1tNHFNN1FBMkRsaWNwbXRWaEpoUVd0Qmd3aUliRVhQQzk1Q3RMbVlnZ242b2MzUWJGbzEyUVU0aUdaREVSbVcwVmxoTzVZRmtlRlZQSVpRcVNWVjF3S2x5RHNrdVlxcWpSaVZTaTRHVWptd2lQVUtLaVFmTXRnZFRmRUZpK0xaOW9UQlZsSjdOdWtTRVY3MlRhbzFBeVNROXRnd3hycHVLZFRHZUhSWE5rcUZaVklTdWtJakdMTG8wNFVXUW44NkdWSUZXUm1Ec2NmTlZET3lKM0xWT1ZkZ0VBcW1qWVB1TlFjOEZVTE94ZzBCYU1WbVJOeXhVZEMxSENmL3lvQklsWTFMNUNyVHg2RVRVZE5CbFRwU0NYbDBFekRDSnFOblV5cEJKUlo2aVZ4eWlpZGg2ZWFrU2xKa1ZFUkVsRXpXcytRS3JDTzRPMkpKcGlGbEdUTFFQOEZrd2wreHFmTjdHSXJFMUFqaWtYcThoYVRYTkVSYStxRlI0UmlRNWNQZ1JCNml6VGtLUko2UVlEVDVibFhEMGNFUkh4d1kySG5lUWlyZmljU1Z4SldRMWNMa2thbWxXWVFzOUVKT0lhVVEyY1M0RWx6SmUzZzBRaVlJL0tUVnlLS3VDTW41WDA0TGFRNVltMVdYR1VnTldaNkp3NlNBWmhnRVJKclhYa1ZFcEZqMjFzaHhOVmR0TWR6MjNtMGxRakp5cnU5VW1uS0JoV050SVJNRmk0NDdPTWh4TkMwQ21hcmV4bHVpNlE3a3RVTE9xSTc1d3N6ajdPU2tCV0lUZU04NUpKNENBUmk1cU9OalQyd0pLbU15dGdJcFoweE82OEhFWFNkQnFoZTRLb1dOSmMvNG9tbUVUU1hBQ2JJQlZMbXFpUW9aQ3ppRHBoZFl5b1dOUjhiS0hSaXdlVnFlRG9pNGhhQzJySFZGVkV6VlNBOStxMGJna0hpSXBsblN6VVFvcGxZV3NKTHlKaVlTZDRqQlFKYkRJUjZJWEFWQ3pyQk5OSlhmR0MzWkpnT1IxVHNhd1RiS3pnU2xCWmV4UkJZeXFSdFllbmZJa3Fhdy9xNzVsSVJPM2hFaXlKQzF1WUNpMUJEUm5JZ2tpUVNyWjFSdlovS2JLdDhiVkNSQ3pwZ0tNQ1pLR3hxSVBEWTYrc2NMTWFETll5MzgreDV3OGpLcFkwSkxIYXp6V2dWQjZtWWpHYkRPZFhwVFJwWnExVmNlWlZXRDdzU0pNaE1aY0E5UUl5d2tuS2RBeWltNjdLRlpld2lzVWVUUzdJQitFeHBpRVp4NExDa2E2Szg0cjdGa1JJUkJLT01Jcm8yTTBjbVFoZEZGV2FjYytlVktSdkx3enZNbEhSZ2FOVlIrZnM5RzJWeFl1SlBDMFJFdStNeUxKNDUwUWszaGtSWjVoZ29UQk44bE1pUHhjdkUrWDU2MElUNzRTb2lSY1J4UzVlVEZUU2xDZzE4V0thT2lmS1hieUlxSFR4WXFJNEgzZGxSOGFjYUM1ZmphRE9pZWJ5dFhhRGZObkFtQTVjTTM3bVJIUDVraUVkTnRETTVVdTN4VnkrN0U1Mkc0amluRTFwZzN5SmFJTjg4eGI1NWkzeUxWdmtLM0hvR1ZIZEl0KzZRYjdPek9YcnpBYjVPcnRCdnM1eHhzbWNhQzVmamxMWERVUnorYnF3UWI1RU5KZXZpM3dUem9ubTh1VndqOXRBdEVHK2VZTjg4eGI1Rmc0UXpvanFGdm5XRGZMMVpvTjh2ZGtnWDI4M3lOZXp2VFdqY1J2RTY5MEc4WHEvUWJ4RU5CZXZEM1B4RWsyZGN5bHVFSzlQRzhSTFJCdkVtN2VJTjI4UmIrRXlsRG5SZkhKMWkzanJCdkVHczBHOFJOVEU2d0NSNVJRaFZ1Z3RKRkw1eGdDSVhKTnZRbVB5VGI0VjByQjRLL0tqK1JCRXZCVnEyRVNVSEJORnhJSEk0azBCUlc2WUtFdHpMRVNUV0x6WkkzY1BFNUY0YzBHZVZ4L0VFVmRnNUpDSlN1UTBSSWVlVkZpODFTS0RuSWxvWGpXaW1JMFBsY1ZiQzdKOWZaUjh6OVpXQTFGeGUwRFMvb0g3ekxNanRmU3VEWWlxZDZNRFJGSkl4dlgrU01ic2t4V25PT0JuOU14dXpuaEptQ29YeVhncGFGUkJlanU2aWdLZVRGVTA0US94S3JLWUpVaVpJRlgxNGpoSHh3Yjdpck5HRnRIZ3MwaGFDendSRmZkNERBbGxnbm4xS0hNeFlzUlVMT2tJZTJsNTJ1eTJPY1VUcE1yaW93WVpCVDRaa1hXQ3lTeE14WTBlRSt3SDRKTVZXU2VQbkRsTXhiSk9NRTNQSjhucTVIb3F0Qlhaa2VxbFZDcWlOM29SZHNwNDlFRklFSytDQ0pwN0RJSkZRME5tUVd1VFFVVEZndVl1ZzJDUDBjUlkwTm1nMEExVFpTR0N3OHJTOURFYkZFSm1LaFowdG5EM0pMbEptUXF5WFpKcHBlWUt2YkdLb0RQYytrVEVjczZ3QTVkbkRpU2hBdEY3eng3ZTdPRzltN1hiY3ZZb2JkTm5iYmRNVkNDZ3lWUXNhTzZUaUo3bFZkQUIzb1paV3k0VEZkSjJzalpkcHIrQTM1V3BSTklCM1NsWnV5NXpiMFpJSkhLT3lJL3RjMUk1UjlUVGhxbTRDMlNPeU9mdnN6WmV6akQrNi9sMjRyRUZSS0tDamxnNDJuc1plN3VaS3VuUTBYMVl0UHR5amlqbG5xbVNNc3VpWjJrRFpsb1ZJRjdtdFlhRlR4cVAzcWc5bUJOZU5FVXl6emhXaWE2Nm9sMllJejdoaTdaaDVycDc5Q3p0d3h3aWlsa29sb3hCU1hndm9ZRjlCNEN3TkU0WHd1M0NPVHFkaU9EOFN2UHpEV0NFZERvcklDNEQ0eGI2dzlQM2Uvci9wUDhmR0Vqdnc4c0FLUnlpQTl4QmVId0JNRHhHQ0I0ai9JQVJlc2NRdTBPcSsrLytHS0VLQ1BKWUdHQUtLTzdZNkd6OERyTnh3S0ROU0krTFc3K2ZEdTl4WGJYZVNGYnllTjNlZzlEOHF2M3RudzlEOTNrWlJsZm8xUXdMYjVsaFpINWV6N0g0cGpsVzdmVWNTMitaWTQ0VXRhczVsdDgweDhnZ3Y1cGo1UzF6ekVlL25XUGg2YTdLcVlMV1ZKK0JnblpmZnhvd3RnRWJENkdtL3ZTYno5ZVNwak9wOGJYTXhJYjZXcWJpakg4MVU0bnB0VXpGazhIMFdxYVN3bzFNQmZnNzVJNXBNNUpJaS9kdnpPZFJ4LzRNeVhYdmhORVpFNzZodjh1NWc4UjljMHVPa1NYUzN5L2ZMekpFSzIyS3c2TjVSVGE0QngzZkwra0Jkc29HM2ZGbDdSZHJIbVdaM3lEVHBQeCtNOXZTeXpnZHRxMXRtOTIrdGsrLzlyVjlmNlIzYklzM3RiWjkzZGYyNmRlK3R1K1A5TWhqOGpMVzlzdjFQem50NGJUTllmZFduWFRFcE9JM3V1amVNSSswNDhpY1IvRU44NGpCb3Jid0tEMnplOWV6ejhvL2dIY2swc09lMmRIRFBhRmZ5MHhDZmkwemVUV3JLOWRYTXBHUVhzbEVySHVKRTVscGpmaHo5T240czlFbmwzOSsrYWRqSyswdVdhc21ic2FiamhiUVdHaDN2K1U1OWZ4SVV2VHpKUlcrbnF2UEo4TGgzOGhSU2ltNUcvU3hYRlpaWE9iL2xuSFlrME9WRklCNHJBRDhsbjdybHovKzlhZkQ5My9qZjV2RDM3Ny82V1JnMW5HZXdDY1A2dDZOelkybk12L3BlWkdHNEU4WWNWODdPZEpJenJVUUsrblZNa1N2Zll3TWI0K1BKeHp2bm5SdmpLdWFSY2lPY2UrYXN6eTNETUlQOUozdkhPZVNiZmorN3Y5ZFZDZDdmSCtzdWF6YXlraERRUzZBMWV5bjY1dDd4SnJUNkFaVytqQWJMNmw1SjhyZEpaWHVQanZwYjI1c2svS3BQbmZNMDFNdFRqQzErNGNoS0hPRnNjeG9xLy9QRVg1ejd4ZVBsTDZ4cXZmcy9JZ05lQm56NU4xOW50UVRsa2lRcHEyekdHK1JEWlg3VEVuZkdjZ0k5OVdSM0cxTDNlVy8zL0dHdThXSkMyU1pGZndwT0hQenphMnVjTTdlejJZK1EwZXlkRGU5bHhsZWhkc3JUZVpKYTlXVmxwbkU4MzNYY2diZnQyL09WUHB3OWZ4SFdzdVd5eUp6NCt2SzBBemNTM3Y3ZFhFNEQzcC9DaHVQbmJ1R0JqQmduSDJFaysyaFowREhXT1NsanFiaFh2NDByTGI2UmJQSUQ3UkNMLzMwL0dmdEoxLy85SWNQLy9uVEwzLzg2WmRmL1g4KzBPOEpDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tOakVnTUNCdlltb0tQRHdLTDFSNWNHVXZSWGgwUjFOMFlYUmxDaTlCU1ZNZ1ptRnNjMlVLTDBKTkwwNXZjbTFoYkFvdlEwRWdNUW92WTJFZ01Rb3ZiM0FnWm1Gc2MyVUtMMDlRSUdaaGJITmxDaTlUUVNCMGNuVmxDaTlUVFdGemF5OU9iMjVsQ2o0K0NtVnVaRzlpYWdvMk1pQXdJRzlpYWdvOFBBb3ZRVzUwYVVGc2FXRnpJR1poYkhObENpOUdkVzVqZEdsdmJnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElETUtMMFJ2YldGcGJpQmJNQ0F4WFFvdlJuVnVZM1JwYjI1eld3bzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqazFOeUF3TGpjMk9TQXdMamMzTmwwS0wwTXhJRnN4SURBdU9UWTFJREF1TnpVM1hRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1BEd0tMMFoxYm1OMGFXOXVWSGx3WlNBeUNpOURNQ0JiTVNBd0xqazJOU0F3TGpjMU4xMEtMME14SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wxSmhibWRsSUZzd0lERWdNQ0F4SURBZ01WMEtMMFJ2fEVuY29kZWQgRGF0YXx8fHx8Rnx8fHx8fCANCk9CWHw1MHxFRHw1ODQ3Ny0xXlB1bG1vbmFyeSBGdW5jdGlvbiBUZXN0IFJlcG9ydF5WU1BVTFJ8fF5BUF5QREZeQmFzZTY0XmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpNZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJOQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJOaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpjZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJPQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmprZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzNNQ0F3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJREU1TGpnME15QXpOeTR3T1ROZENpOUNRbTk0V3pBZ01DQXhNalVnTWpOZENpOVlVM1JsY0NBeU5UQUtMMWxUZEdWd0lEUTJDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURjeElEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURjeUlEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEYzFDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01TQXdJREFnTVNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjeElEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOeklnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXeTAxTGpFMU1pQXlNQzQyTmpZZ01URTRMamcwT0NBdE1TNHpNelJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lEUTBNamtLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdJREF1TmpneUlEQXVPVE0zSUNCeVp3b2dJQ0FnSUNBZ0lEYzRMalF4TVNBd0xqQTNNaUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREF1TURjeUlEZzBMamt3TWlBd0xqZ3pNeUE0TkM0NU1ESWdOeTR5TXpNZ1l3b2dJQ0FnSUNBZ0lEZzBMamt3TWlBeE1TNHpNemdnT0RNdU9EVTBJREUwTGpZNElEZ3lMamN3TnlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURneExqVTJNaUF4Tmk0ek9UY2dPREF1T0RreklERTBMamczSURnd0xqZzVNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdPREF1T0RreklERTBMamczSURjM0xqZ3pPQ0F4TUM0MU56UWdOell1TkRBNUlESXVORFU0SUdNS0lDQWdJQ0FnSUNBM05pNDBNRGtnTWk0ME5UZ2dOell1TWpFM0lEQXVPVE1nTnpZdU5qa3pJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNOeTR4TnlBdE1DNHlNVFVnTnpndU5ERXhJREF1TURjeUlEYzRMalF4TVNBd0xqQTNNaUJqQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DQXdMalk0TWlBd0xqa3pOeUFnY21jS0lDQWdJQ0FnSUNBM01TNHhOVGNnTUM0d056SWdiUW9nSUNBZ0lDQWdJRGN4TGpFMU55QXdMakEzTWlBMk5DNDJOaklnTUM0NE16TWdOalF1TmpZeUlEY3VNak16SUdNS0lDQWdJQ0FnSUNBMk5DNDJOaklnTVRFdU16TTRJRFkxTGpjeE5DQXhOQzQyT0NBMk5pNDROaUF4TlM0MU16Z2dZd29nSUNBZ0lDQWdJRFk0TGpBd05pQXhOaTR6T1RjZ05qZ3VOamN6SURFMExqZzNJRFk0TGpZM015QXhOQzQ0TnlCakNpQWdJQ0FnSUNBZ05qZ3VOamN6SURFMExqZzNJRGN4TGpjeU9TQXhNQzQxTnpRZ056TXVNVFl4SURJdU5EVTRJR01LSUNBZ0lDQWdJQ0EzTXk0eE5qRWdNaTQwTlRnZ056TXVNelV5SURBdU9UTWdOekl1T0RjMElEQXVNelU0SUdNS0lDQWdJQ0FnSUNBM01pNHpPVGdnTFRBdU1qRTFJRGN4TGpFMU55QXdMakEzTWlBM01TNHhOVGNnTUM0d056SWdZd29nSUNBZ0lDQWdJR2dLSUNBZ0lDQWdJQ0JtQ2lBZ0lDQWdJRkVnSlNBdExTQmxibVFnVUdGMGFBb2dJQ0FnSUNCeElDVWdMUzBnWW1WbmFXNGdVR0YwYUFvZ0lDQWdJQ0FnSURBdU5DQXdMalF3TkNBd0xqUXdOQ0FnY21jS0lDQWdJQ0FnSUNBNE1pNDJNVElnTVRjdU5UUXpJRzBLSUNBZ0lDQWdJQ0EzT0M0ME1URWdNVGt1TkRVeElEYzBMamc0SURRdU9EVXhJRGMwTGpnM09TQTBMamcwTmlCakNpQWdJQ0FnSUNBZ056UXVPRGMySURRdU9EVXhJRGN4TGpNME5pQXhPUzQwTlRFZ05qY3VNVFEySURFM0xqVTBNeUJqQ2lBZ0lDQWdJQ0FnTmpjdU1UUTJJREUzTGpVME15QTJPUzQyTWprZ01qQXVNekV4SURjMExqZzNPU0F5TUM0ek1URWdZd29nSUNBZ0lDQWdJRGd3TGpFeU9TQXlNQzR6TVRFZ09ESXVOakV5SURFM0xqVTBNeUE0TWk0Mk1USWdNVGN1TlRReklHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdaZ29nSUNBZ0lDQlJJQ1VnTFMwZ1pXNWtJRkJoZEdnS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3TGpRZ01DNDBNRFFnTUM0ME1EUWdJSEpuQ2lBZ0lDQWdJQ0FnTVRNdU16STFJRFV1T1RjMElHMEtJQ0FnSUNBZ0lDQXhNeTR6TWpVZ01pNHpNelFnTVRBdU56UTVJREF1TWpNMElEY3VNekE0SURBdU1qTTBJR01LSUNBZ0lDQWdJQ0F3SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F3SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQXhMalV4TXlBeE1TNDNNVEVnYkFvZ0lDQWdJQ0FnSURjdU16QTRJREV4TGpjeE1TQnNDaUFnSUNBZ0lDQWdNVEF1TnpRNUlERXhMamN4TVNBeE15NHpNalVnT1M0Mk1URWdNVE11TXpJMUlEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01URXVPREV6SURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TVM0NE1UTWdPQzQ1TmprZ09TNDRPRE1nTVRBdU16WTNJRGN1TVRNNUlERXdMak0yTnlCakNpQWdJQ0FnSUNBZ01TNDFNVE1nTVRBdU16WTNJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhMalUzT0NCc0NpQWdJQ0FnSUNBZ055NHhNemtnTVM0MU56Z2diQW9nSUNBZ0lDQWdJRGt1T0RneklERXVOVGM0SURFeExqZ3hNeUF5TGprM055QXhNUzQ0TVRNZ05TNDVOelFnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNBeU55NDFNVFlnTWpBdU1UWTFJRzBLSUNBZ0lDQWdJQ0F5Tnk0MU1UWWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lESTJMakE0T0NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUxTGpBME1pQnNDaUFnSUNBZ0lDQWdNall1TURnNElERTNMalU0T1NBeU5DNDJPRGdnTVRrdU1EY3pJREl5TGpJNE15QXhPUzR3TnpNZ1l3b2dJQ0FnSUNBZ0lERTVMamczTlNBeE9TNHdOek1nTVRndU5UWXhJREUzTGpZME5TQXhPQzQxTmpFZ01UVXVNRFF5SUdNS0lDQWdJQ0FnSUNBeE9DNDFOakVnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREUzTGpFek1TQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMUxqSTVOQ0JzQ2lBZ0lDQWdJQ0FnTVRjdU1UTXhJREUyTGpnNE9TQXhOeTQyTXpVZ01UZ3VNVGMzSURFNExqVXpNU0F4T1M0d05ETWdZd29nSUNBZ0lDQWdJREU1TGpNNU9TQXhPUzQ0T0RVZ01qQXVOakF6SURJd0xqTXpNU0F5TWk0eE1UVWdNakF1TXpNeElHTUtJQ0FnSUNBZ0lDQXlNeTQzTXprZ01qQXVNek14SURJMUxqQTRNeUF4T1M0M05ETWdNall1TURnNElERTRMalUyT1NCakNpQWdJQ0FnSUNBZ01qWXVNRGc0SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTXpjdU16WTVJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdNemN1TXpZNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016WXVNemc1SURFNExqa3dOU0JzQ2lBZ0lDQWdJQ0FnTXpRdU56a3pJREU0TGprd05TQXpOQzR6TWlBeE9DNHhORGtnTXpRdU16SWdNVFl1TmpNNElHTUtJQ0FnSUNBZ0lDQXpOQzR6TWlBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTXpJdU9Ea3hJREF1TWpNMElHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UWXVOalkySUd3S0lDQWdJQ0FnSUNBek1pNDRPVEVnTVRndU56WTFJRE16TGprMU5TQXlNQzR4TmpVZ016WXVNVE0zSURJd0xqRTJOU0JqQ2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdOakF1TWpreklERXhMalUwTWlCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURrdU9UUTNJRFU1TGpjNE9DQTRMalkxT1NBMU9DNDRPVElnTnk0M09URWdZd29nSUNBZ0lDQWdJRFU0TGpBMU15QTJMams0TVNBMU5pNDRNakVnTmk0MU1EVWdOVFV1TXpNNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBMU15NHpOVEVnTmk0MU1EVWdOVEV1TnpVMklEY3VNemN6SURVd0xqYzBOeUE0TGprMk9TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklEY3VNemN6SURRNExqTTVOeUEyTGpVd05TQTBOaTQwTURrZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURRMExqYzROU0EyTGpVd05TQTBNeTR6T0RVZ055NHhNakVnTkRJdU5EQTNJRGd1TWpZM0lHTUtJQ0FnSUNBZ0lDQTBNaTQwTURjZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURRd0xqazNPU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdOREF1T1RjNUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJREV4TGpjNU5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lEa3VNalE1SURRekxqZ3dPQ0EzTGpjMk5TQTBOaTR5TVRVZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURRNExqWXlJRGN1TnpZMUlEUTVMamt6TmlBNUxqRTVNeUEwT1M0NU16WWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTBPUzQ1TXpZZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdNVEV1TlRReUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ09TNHlORGtnTlRJdU9EUTNJRGN1TnpZMUlEVTFMakUzTWlBM0xqYzJOU0JqQ2lBZ0lDQWdJQ0FnTlRjdU5UYzNJRGN1TnpZMUlEVTRMamc1TWlBNUxqRTVNeUExT0M0NE9USWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTFPQzQ0T1RJZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMk1DNHlPVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09Ua3VOREUxSURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnT1RrdU5ERTFJREV4TGpVME5TQnNDaUFnSUNBZ0lDQWdPVGt1TkRFMUlEa3VPVFEzSURrNExqa3hNaUE0TGpZMU9TQTVPQzR3TVRVZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURrM0xqRTBOeUEyTGprMU15QTVOUzQ1TkRNZ05pNDFNRFVnT1RRdU5ETXlJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTVNaTQ0TURnZ05pNDFNRFVnT1RFdU5EWTFJRGN1TURreElEa3dMalExTnlBNExqSTJOeUJqQ2lBZ0lDQWdJQ0FnT1RBdU5EVTNJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQTRPUzR3TWprZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURnNUxqQXlPU0F5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBeE1TNDNPVFVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUE1TGpJME9TQTVNUzQ0TlRjZ055NDNOalVnT1RRdU1qWTBJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQTVOaTQyTnpFZ055NDNOalVnT1RjdU9UZzNJRGt1TVRreklEazNMams0TnlBeE1TNDNPVFVnWXdvZ0lDQWdJQ0FnSURrM0xqazROeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJREV4TkM0Mk9UY2dNVE11TnpJM0lHMEtJQ0FnSUNBZ0lDQXhNVFF1TmprM0lERXpMakE0TWlCc0NpQWdJQ0FnSUNBZ01URTBMalk1TnlBNExqazJPU0F4TVRJdU5qVTFJRFl1TlRBMUlERXdPUzR5T1RZZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURFd05TNDVNRGdnTmk0MU1EVWdNVEF6TGpnNU5TQTVMakE0TVNBeE1ETXVPRGsxSURFekxqUXhPQ0JqQ2lBZ0lDQWdJQ0FnTVRBekxqZzVOU0F4Tnk0NU1qVWdNVEExTGprd09DQXlNQzR6TXpFZ01UQTVMall6TVNBeU1DNHpNekVnWXdvZ0lDQWdJQ0FnSURFeE1TNDROamtnTWpBdU16TXhJREV4TXk0eE16RWdNVGt1TmpNeElERXhOQzQxTURFZ01UZ3VNall4SUdNS0lDQWdJQ0FnSUNBeE1UTXVORE0zSURFM0xqUXlNU0JzQ2lBZ0lDQWdJQ0FnTVRFeUxqSTVNU0F4T0M0MU5qa2dNVEV4TGpNeE1TQXhPUzR3TkRNZ01UQTVMamN4TlNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFd05pNDROVGtnTVRrdU1EUXpJREV3TlM0ek1qRWdNVGN1TVRReElERXdOUzR6TWpFZ01UTXVOekkzSUdNS0lDQWdJQ0FnSUNBeE1UTXVNamN4SURFeUxqVTNPU0J0Q2lBZ0lDQWdJQ0FnTVRBMUxqTXlNU0F4TWk0MU56a2diQW9nSUNBZ0lDQWdJREV3TlM0ek56Y2dNVEV1TWprZ01UQTFMalEySURFd0xqZzNNeUF4TURVdU56azJJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEEyTGpNNE15QTRMall6TVNBeE1EY3VOelUxSURjdU56WTFJREV3T1M0eU9UWWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lERXhNQzQ0TXpNZ055NDNOalVnTVRFeUxqSXdOU0E0TGpZek1TQXhNVEl1TnpreklERXdMakF6TVNCakNpQWdJQ0FnSUNBZ01URXpMakV6TVNBeE1DNDROek1nTVRFekxqSXhNaUF4TVM0eU9TQXhNVE11TWpjeElERXlMalUzT1NCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjeklEQWdiMkpxQ2p3OENpOVVlWEJsTDFCaFoyVUtMMDFsWkdsaFFtOTRXekFnTUNBMk1USWdOemt5WFFvdlVHRnlaVzUwSURNZ01DQlNDaTlEYjI1MFpXNTBjeUEzTkNBd0lGSUtMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTmlBd0lGSUtMMGRUTVNBM05TQXdJRklLTDBkVE1pQTNOeUF3SUZJS0wwZFRNeUEzT1NBd0lGSUtMMGRUTkNBNE1TQXdJRklLUGo0S0wwWnZiblFLUER3S0wwWXdJRE13SURBZ1Vnb3ZSakVnTXpRZ01DQlNDaTlHTWlBeE1DQXdJRklLUGo0S0wxTm9ZV1JwYm1jS1BEd0tMMU5vTUNBM05pQXdJRklLTDFOb01TQTNPQ0F3SUZJS0wxTm9NaUE0TUNBd0lGSUtQajRLTDFCaGRIUmxjbTRLUER3S0wxQmhNQ0E0TWlBd0lGSUtQajRLUGo0S0wwZHliM1Z3Q2p3OENpOURVeTlFWlhacFkyVlNSMElLTDFNdlZISmhibk53WVhKbGJtTjVDaTlKSUdaaGJITmxDaTlMSUdaaGJITmxDajQrQ2o0K0NtVnVaRzlpYWdvM05DQXdJRzlpYWdvOFBBb3ZUR1Z1WjNSb0lERTVNRFlLTDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlFvK1BncHpkSEpsWVcwS2VKenRYVnR2MnpZVWZ0K3Y0TXRlQ3BqbC9RSU1BNW9yTUdEQXVoallYcnMyYlZZazN0SUVLN1pmdjBOSnRraUpGT1ZHaVMyYk5PUUxMekxQcDNNaFA1UFdQZm9lTFJibzVQclRuNnZUdjFhUDE2dkg3eEFpV0V0RTRMRm8zbW5MMFBzN0tGbFFRdER5UDNqWHRQekR0VVNuNzFiL3ZIdUFYSVJvMVpBaXByQ1FTbTllcSticFptMURncXhaMXg2cTc3ZVFiWVBoSm0wakJjOWVvMDZ6WDk0OTNuaGwwQXh6anI0R1dRVDkxUG44T1d4QzBNOWhCYXkxQ3A3UnI1ZWRVeEIwRitSb3FUR3hrSDBiWkY5NW45N1dIYjllZlFpNzdlVjNVQmlIRUFHTVpvQVFkSlU5SHpvZE1YdENoaUxTUU1DY05HQlhnU3dPOE52Z004UEtLTDUrSWJYU2VqVjBSekd1WXVJRklnVENYZDcrKy9mTlEvQ043b0crZlBMeVhsOWVFZlRKcjNXeTlJc3Z3RTFRdFB6b3cyQ3cwclVXVmU4a29oWWJBdEF0N3pyZnR2eUFmaUNFNlIrWEhlUzRia3N2dXFYQ3RvV3FXNmpvcHBDenNQQjhHUU9vQThOWTYyQVNDeWZUTmpaU1BVSjhheHkwNHM3T0tWWG95elVLaWorK0dxSE91VzYzSFRmSWhGM09OdzJrSnQzV09hVnFoU1E5MFYzcUsxaWRBalZycWw3UW5ySTFIYXpQWDcwQWhzdTdhQWZpMnRhVVkwM1RPcmV1STFSUzg5WlZCdlN2VHVkZHdkSzZXS2Y4OVdtdkVPZFlVTEE1MWI5TU9lMWNuK2hySkxmcnl0ZTVuMk5uNkxyMWRlVktBem9PZlZPR0picUxsR2pLSzJjQ3hiZVI0cXRlWHRwQzZyVEhHSUNvZ3lCVTVTK0hBaGdtalJrbXRJNTNmOU5QMW5OaWRmcnRGVnBGc2s5K1I2K3ZiZ2g2dUVIbnY2TzNXd3FUanVRUlVTZXpub1NicTFXWnVWRXpWa1JFSFY3YTVVV2QzcERiUTRqWEtnVXZYRk1zRll6VUdZLzVQOThEa3JPWVg0cDRwcnh2R210UXphekFhcXl0NUlqRUFCNktFblVaUjFRa2RDc0lrNzIrUDhFVjFEMFhRbUFwcWxISnpIb3VMY1hNTXJvUFBkK05yU1pPMUo1cTRjSkxBcDR4VUErRGlKcHZTY0lZQlRLdkJEa3d0MFhCR0t5SjBRVUlxalcyVkJlVlFFeHBUSmxpQlFrdUZjejlpMHBBSUpTRGdmQjRrSkJjWUMxWjBRbWtHTWRXMGVJbXFoa1FWZFllSGhKVER0M2lOTklXTTZ3a09oUE9yRnBLaVRKc09PY0pZc21mV0hFYm4xakIrTktqTE1WenpiN3lVV3hvekR4V08rUHNTSW9mU1RFa1NZNWttQ1VaNG9xeWJGR01LY2xieG14d1NmSkhlUWJwZVpFQnEyUnhxNHh6U2VQWXBDU2Z0R2FVYUpKUjJzSDRjUXZMUzNxK2NlelNrQmRNK01GaFR4aXdURWJEb01lcUpNczBobWVLK3JveDNtNjhLWTdqbThhRVdqNTVxTjFXaWh6M05BOHBjanpVYnFUWXBaMG5UemFPbVJwN0FYTEFqaGhSSnNBZG95UjVnTGRISmNOVUhTOHdPZWJxZUpISk1WbkhpMHlHMlRwZVlISk0xL0VpazJPK2poZVpIQk4ydk1qa21MRkRRZVpsZVRReEp4NU5ZY0xkaEQ1TG83SHpKSTNtTGRGU3FVclpGVmlGYS9NYUZLNHQzbUMrWEJ2ZkFkZkdDdGZXVDAvazJnUmhtQWxMQzlkV3BjSzFGYTR0a0xKd2Jla2FoV3RMMUNoY1c2cEc0ZHBTTlFyWGxxaFJ1TFpVamNLMXBXb1VyaTFWbzNCdHFSclB3clVObCtZeDl6WktZOU1IZXN3ME13M3ZWcnNpV1dwWFpOUEZhbGM5dHNQYkl2blo5SnNWZHkyMmdnazg1M25aS1RrODJTbkJhcFR3UExHUlZmS1dSMDF0ZHZXV05YSUdoNFNxWmdJc3A3TE45UlRSNUxZdFo1ajJoY0RLSm1Md0dGKzZHZWRnYXBPaGZNalpOaUh2bWJhUVphZmFCSmtuazJrRGdlU2JTRFEyUUtMNSs4RnRuanlMMjc5TDA1Qm4rd2lNR0FXTW1SaVlsL3g1ekFnc2FXcE9VYXgyVWF5MmwrNFB3MnIxaksyV2FvNDFZeVhZOWl2Y0Y3TTlhTE5WTXpaYnBoaTJQTVhHRkxOZEZMUHRwZnZETUZzNVk3UGxrbUVxaXRHaXdkTmNGcVBkcFB2RE1Gb3hZNk1WZ21NdXpBUXpXN2FmWnZzeWExYlppRFdyOEtSenkxVXBuMnlSNlpSYUlqbkRVbXBadE1SUHU5TVNzWmRhb2hqRldpbFd0TVJQdTlNU3VaZGFvaW5CVmd0YnRNUlB1OU1TOVVKYU12WHZjRS84R1k0Wmk3a2FNKzdabjEwdlk2NG51NmdQVHVIYW51MmxCeERNTFl3bTR1Q3c1enk1MmNpSVRTMHBVN1Y0KzVmUXdzQ2g0VGlGUTBFanZjN2J5MHNxRGNQV0duTjRsOVNzeldrUDNHUzZMRlVTejQvbnBxKzNkME1OOStmeVJubkw1Tk1CdTIzRjNiMC9QTDBnYmlPTWdYRWl0bHdIVjl5MTBMTDZBM3VZY1FRQmVoT1c0OEY0VEQrbzluc0JPaVY4blhvTnJSNnZ2NnpRK3dmM25xQ0g5NnVnWTVSSnQzL21XenZWVVFhQ0JYTjczb1JiRzROaEhoNEEwVlY0VDgzN3NaOXlkek9KcW92Vk95b0E4MkJycE8ralFLRXR2SUpESWJ4ZWF5Tk43V0NrYWh4TzQyeXFjdmYrcFAzTUpOUnpiVTU4ZzlpWVFVcjVoNXhKRzVJSmd0QkFPcmRDR1BZZXd6Q091T2xFZnlEVmhkT3RnUUx2cG5UcXBoTmR2KzhXUExXZVhEVGUrN1FHVWRMNk16MXpnRDcxcmhLN3dFTVNtT1psTVhuVHhjUUdrSWlMTnFoMUkrSThZTEFXYTdjcUxnTUVPL091TzYzMW9IcDk0d3h1am9KVDZWYkR1RDJldzVLVGk3bHFPRlVDYTVLWGtKMjZlNERNMlphcCt4TTJtNVh6alZ1TTZZZ250eUlFampkdTRnakhTWE5BWUtDblc4dWZHcldNQ1JhYUdXd3NqRVNvRHBkTVp5Q05EREsvQlViV2pBaXFrU1IwSUFFY2ZRWURuMW9DY0dQdXRtcURZckQ5RndQMFFMTmhLZlJFR2hyTDdlYzFPZWVyRCt2NzRmMFBJS1NpOHdwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjMUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOellnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pjM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOemdnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pjNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tPREFnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pneElEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tPRElnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0YwZEdWeWJnb3ZVR0YwZEdWeWJsUjVjR1VnTVFvdlVHRnBiblJVZVhCbElERUtMMVJwYkdsdVoxUjVjR1VnTXdvdlRXRjBjbWw0SUZzd0xqYzFJREFnTUNBdE1DNDNOU0F4T1M0NE5ETWdNemN1TURrelhRb3ZRa0p2ZUZzd0lEQWdNVEkxSURJelhRb3ZXRk4wWlhBZ01qVXdDaTlaVTNSbGNDQTBOZ292VW1WemIzVnlZMlZ6Q2p3OENpOVFjbTlqVTJWMElGc3ZVRVJHTDFSbGVIUXZTVzFoWjJWQ0wwbHRZV2RsUXk5SmJXRm5aVWxkQ2k5RmVIUkhVM1JoZEdVS1BEd0tMMGRUTUNBNE15QXdJRklLUGo0S0wxaFBZbXBsWTNRS1BEd0tMMFp0TUNBNE5DQXdJRklLUGo0S1BqNEtMMHhsYm1kMGFDQTNOUW8rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lERWdNQ0F3SURFZ01DQXdJR050Q2lBZ0wwZFRNQ0JuY3dvZ0lDOUdiVEFnUkc4S1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNE15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDamcwSURBZ2IySnFDanc4Q2k5VWVYQmxMMWhQWW1wbFkzUUtMMU4xWW5SNWNHVXZSbTl5YlFvdlFrSnZlRnN0TlM0eE5USWdNakF1TmpZMklERXhPQzQ0TkRnZ0xURXVNek0wWFFvdlRXRjBjbWw0SUZzeElEQWdNQ0F4SURBZ01GMEtMMHhsYm1kMGFDQTBOREk1Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdMVEV3TUNCVWVnb2dJSEVLSUNCeElDVWdMUzBnWW1WbmFXNGdWbWx6ZFdGc0NpQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1EyRnVkbUZ6Q2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNQ0F3TGpZNE1pQXdMamt6TnlBZ2NtY0tJQ0FnSUNBZ0lDQTNPQzQwTVRFZ01DNHdOeklnYlFvZ0lDQWdJQ0FnSURjNExqUXhNU0F3TGpBM01pQTROQzQ1TURJZ01DNDRNek1nT0RRdU9UQXlJRGN1TWpNeklHTUtJQ0FnSUNBZ0lDQTROQzQ1TURJZ01URXVNek00SURnekxqZzFOQ0F4TkM0Mk9DQTRNaTQzTURjZ01UVXVOVE00SUdNS0lDQWdJQ0FnSUNBNE1TNDFOaklnTVRZdU16azNJRGd3TGpnNU15QXhOQzQ0TnlBNE1DNDRPVE1nTVRRdU9EY2dZd29nSUNBZ0lDQWdJRGd3TGpnNU15QXhOQzQ0TnlBM055NDRNemdnTVRBdU5UYzBJRGMyTGpRd09TQXlMalExT0NCakNpQWdJQ0FnSUNBZ056WXVOREE1SURJdU5EVTRJRGMyTGpJeE55QXdMamt6SURjMkxqWTVNeUF3TGpNMU9DQmpDaUFnSUNBZ0lDQWdOemN1TVRjZ0xUQXVNakUxSURjNExqUXhNU0F3TGpBM01pQTNPQzQwTVRFZ01DNHdOeklnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNCbUNpQWdJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1VHRjBhQW9nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lEQWdNQzQyT0RJZ01DNDVNemNnSUhKbkNpQWdJQ0FnSUNBZ056RXVNVFUzSURBdU1EY3lJRzBLSUNBZ0lDQWdJQ0EzTVM0eE5UY2dNQzR3TnpJZ05qUXVOall5SURBdU9ETXpJRFkwTGpZMk1pQTNMakl6TXlCakNpQWdJQ0FnSUNBZ05qUXVOall5SURFeExqTXpPQ0EyTlM0M01UUWdNVFF1TmpnZ05qWXVPRFlnTVRVdU5UTTRJR01LSUNBZ0lDQWdJQ0EyT0M0d01EWWdNVFl1TXprM0lEWTRMalkzTXlBeE5DNDROeUEyT0M0Mk56TWdNVFF1T0RjZ1l3b2dJQ0FnSUNBZ0lEWTRMalkzTXlBeE5DNDROeUEzTVM0M01qa2dNVEF1TlRjMElEY3pMakUyTVNBeUxqUTFPQ0JqQ2lBZ0lDQWdJQ0FnTnpNdU1UWXhJREl1TkRVNElEY3pMak0xTWlBd0xqa3pJRGN5TGpnM05DQXdMak0xT0NCakNpQWdJQ0FnSUNBZ056SXVNems0SUMwd0xqSXhOU0EzTVM0eE5UY2dNQzR3TnpJZ056RXVNVFUzSURBdU1EY3lJR01LSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09ESXVOakV5SURFM0xqVTBNeUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREU1TGpRMU1TQTNOQzQ0T0NBMExqZzFNU0EzTkM0NE56a2dOQzQ0TkRZZ1l3b2dJQ0FnSUNBZ0lEYzBMamczTmlBMExqZzFNU0EzTVM0ek5EWWdNVGt1TkRVeElEWTNMakUwTmlBeE55NDFORE1nWXdvZ0lDQWdJQ0FnSURZM0xqRTBOaUF4Tnk0MU5ETWdOamt1TmpJNUlESXdMak14TVNBM05DNDROemtnTWpBdU16RXhJR01LSUNBZ0lDQWdJQ0E0TUM0eE1qa2dNakF1TXpFeElEZ3lMall4TWlBeE55NDFORE1nT0RJdU5qRXlJREUzTGpVME15QmpDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQlFZWFJvQ2lBZ0lDQWdJQ0FnTUM0MElEQXVOREEwSURBdU5EQTBJQ0J5WndvZ0lDQWdJQ0FnSURFekxqTXlOU0ExTGprM05DQnRDaUFnSUNBZ0lDQWdNVE11TXpJMUlESXVNek0wSURFd0xqYzBPU0F3TGpJek5DQTNMak13T0NBd0xqSXpOQ0JqQ2lBZ0lDQWdJQ0FnTUNBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTUNBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURFdU5URXpJREl3TGpFMk5TQnNDaUFnSUNBZ0lDQWdNUzQxTVRNZ01URXVOekV4SUd3S0lDQWdJQ0FnSUNBM0xqTXdPQ0F4TVM0M01URWdiQW9nSUNBZ0lDQWdJREV3TGpjME9TQXhNUzQzTVRFZ01UTXVNekkxSURrdU5qRXhJREV6TGpNeU5TQTFMamszTkNCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lERXhMamd4TXlBMUxqazNOQ0J0Q2lBZ0lDQWdJQ0FnTVRFdU9ERXpJRGd1T1RZNUlEa3VPRGd6SURFd0xqTTJOeUEzTGpFek9TQXhNQzR6TmpjZ1l3b2dJQ0FnSUNBZ0lERXVOVEV6SURFd0xqTTJOeUJzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNUzQxTnpnZ2JBb2dJQ0FnSUNBZ0lEY3VNVE01SURFdU5UYzRJR3dLSUNBZ0lDQWdJQ0E1TGpnNE15QXhMalUzT0NBeE1TNDRNVE1nTWk0NU56Y2dNVEV1T0RFeklEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01qY3VOVEUySURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTWpjdU5URTJJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQXlOaTR3T0RnZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURJMkxqQTRPQ0F4TlM0d05ESWdiQW9nSUNBZ0lDQWdJREkyTGpBNE9DQXhOeTQxT0RrZ01qUXVOamc0SURFNUxqQTNNeUF5TWk0eU9ETWdNVGt1TURjeklHTUtJQ0FnSUNBZ0lDQXhPUzQ0TnpVZ01Ua3VNRGN6SURFNExqVTJNU0F4Tnk0Mk5EVWdNVGd1TlRZeElERTFMakEwTWlCakNpQWdJQ0FnSUNBZ01UZ3VOVFl4SURZdU5qY3pJR3dLSUNBZ0lDQWdJQ0F4Tnk0eE16RWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lERTNMakV6TVNBeE5TNHlPVFFnYkFvZ0lDQWdJQ0FnSURFM0xqRXpNU0F4Tmk0NE9Ea2dNVGN1TmpNMUlERTRMakUzTnlBeE9DNDFNekVnTVRrdU1EUXpJR01LSUNBZ0lDQWdJQ0F4T1M0ek9Ua2dNVGt1T0RnMUlESXdMall3TXlBeU1DNHpNekVnTWpJdU1URTFJREl3TGpNek1TQmpDaUFnSUNBZ0lDQWdNak11TnpNNUlESXdMak16TVNBeU5TNHdPRE1nTVRrdU56UXpJREkyTGpBNE9DQXhPQzQxTmprZ1l3b2dJQ0FnSUNBZ0lESTJMakE0T0NBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURNM0xqTTJPU0F5TUM0eE5qVWdiUW9nSUNBZ0lDQWdJRE0zTGpNMk9TQXhPQzQ1TURVZ2JBb2dJQ0FnSUNBZ0lETTJMak00T1NBeE9DNDVNRFVnYkFvZ0lDQWdJQ0FnSURNMExqYzVNeUF4T0M0NU1EVWdNelF1TXpJZ01UZ3VNVFE1SURNMExqTXlJREUyTGpZek9DQmpDaUFnSUNBZ0lDQWdNelF1TXpJZ01DNHlNelFnYkFvZ0lDQWdJQ0FnSURNeUxqZzVNU0F3TGpJek5DQnNDaUFnSUNBZ0lDQWdNekl1T0RreElERTJMalkyTmlCc0NpQWdJQ0FnSUNBZ016SXVPRGt4SURFNExqYzJOU0F6TXk0NU5UVWdNakF1TVRZMUlETTJMakV6TnlBeU1DNHhOalVnWXdvZ0lDQWdJQ0FnSURZd0xqSTVNeUF5TUM0eE5qVWdiUW9nSUNBZ0lDQWdJRFl3TGpJNU15QXhNUzQxTkRJZ2JBb2dJQ0FnSUNBZ0lEWXdMakk1TXlBNUxqazBOeUExT1M0M09EZ2dPQzQyTlRrZ05UZ3VPRGt5SURjdU56a3hJR01LSUNBZ0lDQWdJQ0ExT0M0d05UTWdOaTQ1T0RFZ05UWXVPREl4SURZdU5UQTFJRFUxTGpNek9TQTJMalV3TlNCakNpQWdJQ0FnSUNBZ05UTXVNelV4SURZdU5UQTFJRFV4TGpjMU5pQTNMak0zTXlBMU1DNDNORGNnT0M0NU5qa2dZd29nSUNBZ0lDQWdJRFE1TGprek5pQTNMak0zTXlBME9DNHpPVGNnTmk0MU1EVWdORFl1TkRBNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBME5DNDNPRFVnTmk0MU1EVWdORE11TXpnMUlEY3VNVEl4SURReUxqUXdOeUE0TGpJMk55QmpDaUFnSUNBZ0lDQWdOREl1TkRBM0lEWXVOamN6SUd3S0lDQWdJQ0FnSUNBME1DNDVOemtnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJRFF3TGprM09TQXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEUXlMalF3TnlBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURReUxqUXdOeUF4TVM0M09UVWdiQW9nSUNBZ0lDQWdJRFF5TGpRd055QTVMakkwT1NBME15NDRNRGdnTnk0M05qVWdORFl1TWpFMUlEY3VOelkxSUdNS0lDQWdJQ0FnSUNBME9DNDJNaUEzTGpjMk5TQTBPUzQ1TXpZZ09TNHhPVE1nTkRrdU9UTTJJREV4TGpjNU5TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05URXVNelkwSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTlRFdU16WTBJREV4TGpVME1pQnNDaUFnSUNBZ0lDQWdOVEV1TXpZMElEa3VNalE1SURVeUxqZzBOeUEzTGpjMk5TQTFOUzR4TnpJZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURVM0xqVTNOeUEzTGpjMk5TQTFPQzQ0T1RJZ09TNHhPVE1nTlRndU9Ea3lJREV4TGpjNU5TQmpDaUFnSUNBZ0lDQWdOVGd1T0RreUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DNDBJREF1TkRBMElEQXVOREEwSUNCeVp3b2dJQ0FnSUNBZ0lEazVMalF4TlNBeU1DNHhOalVnYlFvZ0lDQWdJQ0FnSURrNUxqUXhOU0F4TVM0MU5EVWdiQW9nSUNBZ0lDQWdJRGs1TGpReE5TQTVMamswTnlBNU9DNDVNVElnT0M0Mk5Ua2dPVGd1TURFMUlEY3VOemt4SUdNS0lDQWdJQ0FnSUNBNU55NHhORGNnTmk0NU5UTWdPVFV1T1RReklEWXVOVEExSURrMExqUXpNaUEyTGpVd05TQmpDaUFnSUNBZ0lDQWdPVEl1T0RBNElEWXVOVEExSURreExqUTJOU0EzTGpBNU1TQTVNQzQwTlRjZ09DNHlOamNnWXdvZ0lDQWdJQ0FnSURrd0xqUTFOeUEyTGpZM015QnNDaUFnSUNBZ0lDQWdPRGt1TURJNUlEWXVOamN6SUd3S0lDQWdJQ0FnSUNBNE9TNHdNamtnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0E1TUM0ME5UY2dNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTVNQzQwTlRjZ01URXVOemsxSUd3S0lDQWdJQ0FnSUNBNU1DNDBOVGNnT1M0eU5Ea2dPVEV1T0RVM0lEY3VOelkxSURrMExqSTJOQ0EzTGpjMk5TQmpDaUFnSUNBZ0lDQWdPVFl1TmpjeElEY3VOelkxSURrM0xqazROeUE1TGpFNU15QTVOeTQ1T0RjZ01URXVOemsxSUdNS0lDQWdJQ0FnSUNBNU55NDVPRGNnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0F4TVRRdU5qazNJREV6TGpjeU55QnRDaUFnSUNBZ0lDQWdNVEUwTGpZNU55QXhNeTR3T0RJZ2JBb2dJQ0FnSUNBZ0lERXhOQzQyT1RjZ09DNDVOamtnTVRFeUxqWTFOU0EyTGpVd05TQXhNRGt1TWprMklEWXVOVEExSUdNS0lDQWdJQ0FnSUNBeE1EVXVPVEE0SURZdU5UQTFJREV3TXk0NE9UVWdPUzR3T0RFZ01UQXpMamc1TlNBeE15NDBNVGdnWXdvZ0lDQWdJQ0FnSURFd015NDRPVFVnTVRjdU9USTFJREV3TlM0NU1EZ2dNakF1TXpNeElERXdPUzQyTXpFZ01qQXVNek14SUdNS0lDQWdJQ0FnSUNBeE1URXVPRFk1SURJd0xqTXpNU0F4TVRNdU1UTXhJREU1TGpZek1TQXhNVFF1TlRBeElERTRMakkyTVNCakNpQWdJQ0FnSUNBZ01URXpMalF6TnlBeE55NDBNakVnYkFvZ0lDQWdJQ0FnSURFeE1pNHlPVEVnTVRndU5UWTVJREV4TVM0ek1URWdNVGt1TURReklERXdPUzQzTVRVZ01Ua3VNRFF6SUdNS0lDQWdJQ0FnSUNBeE1EWXVPRFU1SURFNUxqQTBNeUF4TURVdU16SXhJREUzTGpFME1TQXhNRFV1TXpJeElERXpMamN5TnlCakNpQWdJQ0FnSUNBZ01URXpMakkzTVNBeE1pNDFOemtnYlFvZ0lDQWdJQ0FnSURFd05TNHpNakVnTVRJdU5UYzVJR3dLSUNBZ0lDQWdJQ0F4TURVdU16YzNJREV4TGpJNUlERXdOUzQwTmlBeE1DNDROek1nTVRBMUxqYzVOaUF4TUM0d016RWdZd29nSUNBZ0lDQWdJREV3Tmk0ek9ETWdPQzQyTXpFZ01UQTNMamMxTlNBM0xqYzJOU0F4TURrdU1qazJJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQXhNVEF1T0RNeklEY3VOelkxSURFeE1pNHlNRFVnT0M0Mk16RWdNVEV5TGpjNU15QXhNQzR3TXpFZ1l3b2dJQ0FnSUNBZ0lERXhNeTR4TXpFZ01UQXVPRGN6SURFeE15NHlNVElnTVRFdU1qa2dNVEV6TGpJM01TQXhNaTQxTnprZ1l3b2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQm1DaUFnSUNBZ0lGRWdKU0F0TFNCbGJtUWdVR0YwYUFvZ0lDQWdVU0FsSUMwdElHVnVaQ0JEWVc1MllYTUtJQ0JSSUNVZ0xTMGdaVzVrSUZacGMzVmhiQW9nSUZFS1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNE5TQXdJRzlpYWdvOFBBb3ZWSGx3WlM5UVlXZGxDaTlOWldScFlVSnZlRnN3SURBZ05qRXlJRGM1TWwwS0wxQmhjbVZ1ZENBeklEQWdVZ292UTI5dWRHVnVkSE1nT0RZZ01DQlNDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURZZ01DQlNDaTlIVXpFZ09EY2dNQ0JTQ2o0K0NpOUdiMjUwQ2p3OENpOUdNQ0F4TUNBd0lGSUtQajRLTDFCaGRIUmxjbTRLUER3S0wxQmhNQ0E0T0NBd0lGSUtQajRLUGo0S0wwZHliM1Z3Q2p3OENpOURVeTlFWlhacFkyVlNSMElLTDFNdlZISmhibk53WVhKbGJtTjVDaTlKSUdaaGJITmxDaTlMSUdaaGJITmxDajQrQ2o0K0NtVnVaRzlpYWdvNE5pQXdJRzlpYWdvOFBBb3ZUR1Z1WjNSb0lEVTNOamtLTDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlFvK1BncHpkSEpsWVcwS2VKenRYZWx1Sk1lUi91K25xRC83eHdEVGVSL0F3c0NRMWdnd3NNQ3VOUytncFViU0doUnRTd01idTArL0VaRkhWV1ZHZFRlSDNjMXVva2NpV1ZtUlYwUitHUmw1UmYxaityZnA3bTY2Ly96VC96dy8vTzM1eStmbkw3K2JKaW1DbXlUOGQxZWVRdExUNHk5QXVWTlNUcC8rRDU1S3l2L0dsTlBEOTgvLy9QNDNlRHROaWhLcVNYdGhuUS90THlYZlRqWW5sRk9LTmZhdStNc1UyczBwZHFkQjVwS1V1ckpIenlwSUlaTldVN0JPS0cyWG1YWFovZWYzWDM1ZTBHb2w3dFIwWjBCWTNrMVJCK0ZqY090TU1DTCtOLzM2MCtvdEpuYktDbThtZ3duVDlPdm5hUlhqeDk4dmd2K1Y2L0w1K1llK0pydHJpVldMMDcrNm92L2NoZis2cnJDYy9tT29LM0R3bDI5WGI2MFNNb0xrcExCcFdyTWNvekNoa3A1V3BBUVMxOEJ0SVNhVll5b1JqVkV0YUpEMnVFNllTYzZJT09SWlNFNDRDMW0zSXB6SHVLVXlPZkRJc1pCSjZ6eE5FbFpEalFyUnhCeXpGRkdEWnN5emtESUxUeXlwTU51S3lLSll5WE9kNTdwTnY3c1lYQWlISFdyeHU4ZUkwU0I4ejRQRUJDZTg1VkZpUWhBNnpUQXhJZWE0VlhRMXpBQ2wwamlrTkZwdHgxWk9hZVpTSnc0c2xSY1dMYUR0Z2x6QVJic2N0NVpUd3h4Z0NvMUZUS1ZWdmxzNVJTNHIrYjRUMEdncEJiRG9RMEsxdUFhTmRrb2tYMmxQSGMwSXIrQjFvV3BuS1c2RWpvWENhMkdOMU1jdWJhWWxBd1BDa0craFdSRXM1VnZMU1I1ajF6cmwwQ1BMUzZhdDgxVUp3T2htcWtvaHh5M2x0TEFaODYyMHpNc1RUeXQ4eitVVXVhemsrMDVBWTBBU0t2S2dzUWE2bmVGQlk0MFROczZnc2NaVDNDcThGbVpBVTJrY2FCcXROT1pjVG03c1dpY09OSlVYRGpRbUF2OTZCbzJCYWxQY1VrNExNNkNwTkE0MGpWYjRuc3ZKY2xuTDl6cEF3NXN0UWJqSnE0aUt1TE5hUUdTbWt0YlNpV0NvVWVObFl2UVVVMHVoVVZZMXFFYmxYa2hHd3pEVDUxbElSaVJzdUZZRUFBWGlsc3Jrd0NQRFFhWjBvSE1pV215elRMU1dJcFlDU2tnekdSSWxWLytKb3hRK1cvWlpDa3RKWGdjZzltc1JHRWlEblJ6TUMyS3ZSS1FTMmhkU0p5V3BSY0lCSVJPdHREa205QmdVVnd0RGorOGxYMGpRK0hySXRKQkE2QTZicnhVU3dXWnAxYUhBSThzRWticGVEamFuakZDblREUW01SmlsakJhMlk2YUZSRXc4OGFUQzcxd0lpV01sMC9lQ0U3RExndWJWaUVIcFJWNlBHSkIwTXJNaU1kZ01jZTVoTGF5NGlVV21jYnFrMFVwZm44dkptcURXaVZNbmxSZE9vUmh0aGZTelJqRmE1N2kxbkJyV1hMNlp4dW1WUnF0OHQzS0tYRmJ5ZlNlZ1FidkxLUjQwMmtIblNUeG8wTjZNZGdhTmhsa0Z4cTNDYTJFR05KWEdnYWJSU21QTzVlVEdyblhpUUZONTRVQ0Q5bVowTTJqUUhxVzRwWndXWmtCVGFSeG9HcTN3UFpkVDVMS1M3enNCalZVQnRPcmtJR2szSHFFK0RVVG9CZzdRd3c3WFA1QmtVVjlqTENVTWpVVTFiQWFqSWhNMHpFS0hEQXZKQ1VralVTc0ExL2hhUlNqd3lGYWVTRjJtQ3UxaEhDUnlKc3JtbUxXTUdqWk1wcGtFTER6eGhNcHJLd0lGTWN2eE9wREJHcTkzd0VVSURCcm05MzJmRWJaaUFmcE5XRUNoQnMzUXRlazlBNFJLS1czVThxWVdMRFZnVUhDM0pEMTFwRlVlZDEwSmQ4dTZkSm5PMVgvaUNZWE51NlVJRnZLN0RoUWNZTEhDaEkxRGhBVnRtQ3luSDhDUWRLbnFCMmx5ck5wbmFualFENFhBNllkS3FuMjNGWkM3ZHFrSWc0eGFlUVlaYUVSYTFmU0R3YlhUQlRKYWVFUkdKUTNJYUlUQzYxd0VDR0loeC9lQ0RGcGdHSUdSdkZDY3FvRFJOZFora2xLT1V5UlZnejBveW5zR0U1VlNtcXZsVFkxWmFzQUJJdGVad3dQWUltR0dnOHp4S2hwS2tBRkRwb3hZS084ckZHcnVpSVFtdDNjQ0JJMnJ4NUZCQWxyZHlqQlFJUE03Rml6ZzlwUmF5YXFFeldEd1p3SURoMGFxRGRZS3lNMVpLc0lnb2xhZWdZU0dpYVhXRFJNYXVqZkZMR1cwOElpS1NocGcwUWgxakd4RjRQZzV5L0dkSUFOVnMrY25KTmFEOGNUUFI2d1BXY0oxSGNoSGpOcFdpVXFRbVkwVUVqY1pxYVM2V05YS0tFdFp1VHJzY2xobWdwMit3Z3doTFJiRURPZ2h2NWk5bGlBM2VjMGtkdTVhU0hYcTJzb28wbGpLOURwd3dwcWF4bTZ0aENXM3RSQUdpbjJ4RGdhQ1dTNkQxZUM0Q2xZb3pDSllwWlQxcVpZL3JWNlZlckFyWU5zTFlOQlkxcmIxTDZFaUtwN29vV2NiMUVzQ1dpN1FDNk1aRFllZ1ZGU2hBRmxNUnRYMXNwU2NYd1NIR3FuTjFiTkdrZExhdVFnUUd5Z2NNMWNwS09FRFBBd2pabVlCeUVwNU5YTllGdC9lM2RxYlVscFl4d3huR2pTL2M4eHdwbUgwMGJMT2duVE1zYXFLcitGaEhsUUkzRVNva3VwUTB3cklJMUdwQ0RPYzFjb3p3NWxTSU1EVWhqTWxVNDVaWjFzMVBBNW5sVFFNWjQxUWVKMkxBRUVzNVBoZWtKRzN4RGlkcFowWFhyRktTenRVTWsxcmFaZEU2WCtrdGxwNDFGdVZ4Q2l1UmlxYWF5NkVGRSt0RHFPN0toT004bExKQ212YTZyM0tlM3l0akJhMlRLYVp4T2lmUmlyOHpvV1FPRll5dlE2Y3NNTVpIdld5YW9xNGJUSXN2bG82OVZGb3ZaRlpUb2dVcXJZeHh3VzFUSXV2Tld5WlJkSkN3Mk5lWTc2RkJnTU5MYjYyY2hTZEJxdDF5cUZIbHBkTTY1b1Q3S2lBaTZLRnFzQ1FvcmlsbkJhMlRMNkZsbmw1NG1tRjc3bWNMSmUxZkk4TWxHK2YvdmZ2UC8rMnJrODlma2ViVFRhZnpZck04VHRKLy9YSDcvN3c3WGR5K21tZDVmMm5kWlNQbFArbkg5Zmw1aE9FOUVkaG4vZzBGdmZwaCtuZnBUVHBqNS8rMnNIYk42cjI4S1BnUjhMUHgveGpWSi9pbTArOHNBYUJIQzR1R0Z3TW5zdTh5ZXNnZWVFbWc1RUJUMVRBUUh4UjhncWp2TUE2bUNYMmNhU0RYZmpXQXNXREpRckVlSlBuY2VRSjQ0U1RNc0EwRnJkNEwwbWVJQXdIMG5CUVBmZ2ZKamZ3OC9FNEFoa09keThCWm1Ca3NpcFA0blF2am4xeTNSSVlMN0pCYUZ0aTJ5KzRwZWowQU1WT1VMdEY5WVpjb2wyS0dlUGZpS3ZyWmorekgwZG11NTdGUlhCcFJwcStWbkhOb05CV09IT0l0SXFLa1dhWG1ua1Ivd3ZhMEs5ZVlGZVlmQkxrMHJRUUNNdWlCZ0wxREpPWXJJMGl2Q3RoKzFDMDFKbHNDU2RqdWtBcE9XYnNDNDFzNDFxQUtMUzNFQ0R1NkN1VEYwWHN4UWhQVzhad25kVlhGWnk5bjhkQjZyMW9NTGpUQ3cwM3dQRiswbVVKN1pUV3dVNDloZlBGaTVPR2psa0t6aFNjUEdUYzJGaWxjd2JKcUxxbmVqbHlNUWJuaGJtLzJLcHMvSXdjZWhjTGl2enBaYVFCUGFpM0wwdEsrcUhZQWlGTENxWG1WSkZNUlpZdTd4NFdhdnNNRXNQdE1aZjhKYzVQWkpIQ2ZaYVVEUXVjWVRpVnY2Uy96ekJ2MGJkcHkyM2FjaFhpZWovVEZ0d1JzNjRjVmJvZ2pRNDZ4M3dvK3NnV3pWMjF1OHE2NjV4ajRpNjloUnRHTWtsL1UxdzN4WFhwNHJvdXhiV3oxK0Y1S1JrRDdleHhiaWYrY1JVZEwrVzV6N2ozTTExaEI0U0p0b2tIWUVyWlAxNS8vekZDKzBONDFad3lNWEdoVFJJWDQ2VTdmMjlnT3Vna0FpcmNBRDFRNGxHdDNub1lENnk4MVRyTGNhd0F4Z2ZPeTg1cUZGUjJSelBBYkhDOGl4Q0ZlNFI0MVowTzA2d1BKQnpsdkFuYlM5UXhUcUJJNW5TU0UxRk5RZEtCdis0RUNsN3V6UzRrUEhmcVJ3TXBDTnVmM1ZsemMvOFZEb04ycnJhQ1hhZWpoaHBMSVVQMG5IV3MzZ1RURDh4T2JMOWFmVUdRSDA4amVTdkNobHNjbnk5bFd1WTQ4N0VncjA0RGVZWk53S3duWHN6SXBjYmRJaTlDejZYSGUrNVpBT2ZGdS9GR3BJUUtIZWVDM0ZMVlRhRWZwTkNOUzNqK2xmZjZsSXpBMDBmUzRKVGp5bFc2QVpWdWdGR0o1NzhIUnBPd2h2UzJHcThRYUJvSDBubng3ZlQycVp1TGdQWVY2ZlZERVFJeTUvc0JFaVRqT0loYUtlQmlGRHpoa1VydnZBRGhHUWNXdDgxNnNUOEFmbjBkQngyalpTVVBBMFF2R2JBN1hCNGJoc3NTVG9vVUtaMDBaKzA4V25xaGxZZDZlVEJHbzdUVGJYRDRxc0ZCYTRDejMvRHVCalFkVDJ2OG5BM2pkRW1FdDM2UVQ3cVZ4cGcvR2wyaHZJbjlvMzBFMVFLanNuY0JaaXBhVDdkQjRpUTl3QnBTZmx3UFFJZU9EaDMxa0FWMTVUM0FhT0xDVzRYVDk0NVJ3TDdPMXpiVGNEbGI1M3VaWVhTSWVlSVpMeGh5Rm1jQTNsdDJVVlhlbFB4QkVMZUtYUEx5M2hoaGRvV2VEOUczM05YUEFDeEFOWmxzeUF4ODRra2pVdkl3NGVsdU81ZlRrdGFNdEZOUGNrSHM3dUloZnZWS0hxK0JSN2VoNVBIdUZMYSt4bzV3NVQzQUJObzhSQ1Z2ek1Db1FiOE8yQVhzY0JNYnp3U0JEakQ2NlBnLzFhSmRYclBpdkNYZ290M2swbmhsOHhxWDdFd2tWaFRESk16TFhBVHdqa3QyVVdmKzFYbTFXUUN4NDBXMjZUWlFmOTFTWFZEc2ZXbDZiOFpMNmxlb25nek9vekl2REk4NGZnK2FpZFF6eC82cHpVLzBxSHZCZUw3NlVSa3ZIOEtvelByM1JhOExBVnBkRDFma3J3NzB4U3AxQm0yOTBSazZvZDc0d1NhbHpWWm5GS3I1aXh5VHVZWEVJSUxaY01TTG96SU95MzY4Sm45MVRRcm1FdW14Uk5md2Z4bG9rUVptUDFwWldpUUFmSUpwZHJpV1JxWGxzUTBuN1lWMlNsdnJyQ3VFM2hSZWVEWVpZNHNXQ0FNcmdkTU9UOTdkYksxYTdOZkEydk1ERDc1K0Q1WldVVkNNb1VYWHJVWTd5K3UzTWJPTTNNRHhkRHZQY3F4cEpPN3ZlZDdPSWh2WE00N1FISGxYZEVZRTlMcUVIOE55dUQ2bUpyejFpVUF4d3VrVDdYeWViWDZ0UERsa0F5TXI5VG8vQ1pVN2l1MVZ2aklvTTBOaU9PdU9FSWc4SkdoSEIrMlliTGhwL3E4MGFOQXAzNFpqTXBoc09rdmdEdGR2MEFDRFdoRlNkZWdaRFZZWVMvanVaeGZhZStyNjZJWFhueFhnS21yOG5ocFlVOUFNVWlZLzNlYmRKK2tBWU1wN2ZxVkpSZER4aFA5aEorVHE4SzhpQU45bElQZVROQlVDbnZray9UNDRWNHVLWEtRYk90dHpWZzN2Y05JSXNBNzQvYThrOVUzRmYrMmNOZUEyQ090ZkVIMmo0Q2RJdlJ4UE5GMGR4dEZYdC9iQWpFYWQzVy9xQS9kVGNJd0pnMS84SVM5OWdMZnpIbXRSZUZYRlNUVUZuREZIZFR2SG5zVnpqQzB4UmVzVExPaVR5VENSNHhHbnF6UGFrMFhUSExIYld6V2c4SzNoRVo5MDd2UjZkQ0grRllEZnVySzA5WDVYOXhqMVJRLzJCZEJIa004QXQvaEptQlhBRitBdUxtL3E5V1M2cnJ4OExtNXdiTDI2WE55ZmtNT0t4UlZtaXZPaGhOWDhucTVGaDg1MXcwT09zMHhQZWJvU0RvdDB6Vy9SWEErcXJ5M3BNTStQU0Z2MlFOQmlNaTd1cHExdThxM2Mvc2hsdWFuNFRNTG5lcTNiWlRjdlMxa003bCtLbnlYNmF4ZDFYY2l4bFdHTFk2dUgrUjNLUmEydXlqWHRzYVU1ZGwxQW5iKzdIcVZIT2F4VTZhNytXbE5hQzRNSCtsV1hheVVzVVhZUkxZd0VmV2JkcXgzYVMwcjErOUYwSmN6MEErcjhWdUdYR3lZYWRQQURRSlBDR2Rqaktxckd0ekhBRTR3T0N2Y1JJbjRkU09GZDUyVk1nNXNwa04vNnJBYjZaNGVrWnIzYVpSQURFRmV0N2JoSVRQU25JR0RPQVpGSnQrQnlDZlFsMEpoQzBmWEhaUVZnZXBTdmFQK3lldWt4aWZIdzVEQU5ucHhGbFVOenNHVnloeCs4ZDVQRjRpWGVRWnVmbHRFazhoTFJnRjNXVWVIK0FYM041V2tWTnlpSW05WW5QaXhXQkp1cWw1UUUrZW4rUktQRWlTL0U5dXZYRGc4Z1lDWnJDNW80amYwQkF3Q1Y3ZXUyeUdENWVvbkhIMmVWdTZWd2Q5c1gwQm9hSlkwZXM3RmxUQWZhMFhwWTJRNmM1YkJRcStqTDMwRHJLZ2RBK05SMWxLcGZxMTc0VVBSaTBXc3V6djFmL1dsdFBTeHNoMjNMNFEwWmQrUWphQS9qU3QxK1R2ZnpZc0FjWklCc0R5Ukc3aDVJaHZ2Wk5hM3Z4NUE5OWk2ZVRudjFGd2hDOEt2ZnZhR0lWVnNiaUdnYVNyenMvbklUZVB1VyttRVNrcE8vQmdsUnp6K1pkSHBEcEdkeXphSmFNYmlQR3ptdHB3TW84UFhncFBHYjNxYitrUm0waXhpaEE4WjNISHNMRmw3YjJkVHV6blptYlk4MmdkcFM4NzFQSG1nQXFXYnF4NTY2dzRGTjU3eG1kcitablU1bTFkZmVWWGR3K1B6TmE4ZlBEVHRZU1RCTXRSbnQ0QkZ4SzNtam5leW0zbkxXdXZ3aXF1eU1PdGRoakJhaENCQmtBRk9NeDFVZGxlK1c2T2tWcGlMRE9sQVNGWVp5QmhzUjgwZUlsOVE1NDJXcTE5aGttM3BQNGQxaVJyajdWb3oyZ2Ywb2EwSWM2TmV3WDA5dHlkVlg4WUJwNnJSVlZ2T3VuNTdpdjZQNWNEeUxQSEFEaHZ3dzdaUUtlWEV1Zm5SUkVncC9mSjJndzdNcjcvQXZTRTk5VTk3Zlp5bGhYRldsaUQveXhIN1Jzck5uNlVjVUh1UzlaNi9raitqSmgvNGZoYjlMRitjNjd0TEhoWXNYT1JVck9yaXUyN2pacFIwUDlPTTdUVHFuMktQS2ZsSDN5WjVnclFxRVA1ekk3ZEhyVFUwVnJsSFpMbXdBbWt1N2JtMnhXeVBjWng4Y2NYVytEbVc0YWVqRHFFVDJXUXFjcmJEZld1RHNoZjBXQTJzekhHUTFzSGJEUVpaRHY0ais0eUdMNkMvUTNqSnVDUDdDMUlnN1FIbS8xcUs0Y2tXN3c4SlkyUmpGQzMxZGxDZGI0bjdEeG5DTWpSR3o3YkZ0WTd4R2pneFdaN1NpK3pDWk9MUWUwaHFIdGNkV2l6QnRzdDBxQjlrZFE2UEU5ZTdIU3l5RVFlVDdoSDdCQW92b09HNFR5Q3Vid1JhYjRiNUFPQjVCTXRzMndnc2NLbTZPZENERDIwajNGaU1kYnNsbHdZdWtuYi84NFU0SkZXQmlzV3ZFSzF2RmRkdTFLUW8xajNSMW01Z1V5bktFdEtjWUJYZHFiNFdINDdSQ2RNc1F3aDRWUHZTZ1ZWWkNCNnU0WVlCMnA1M0QzN2dTS1h4d3JNNEMzUkluTlY3K3BWTHd0Z3JSeXE4YXBFU1BUSHlnSmZSMDg3UkZpNzVrSXpGYUxwd2VINW1haFJyUDRKWWZKUzVQYkFLaVVaWlBQSTFLenRrMkx1aHB6T3ZuRFVHcDBiTVgvaU12VlpsSWg0QndmM2FybW5LcmpqSm5rMy9sU0pKbDB5REI0djRveGFXbmpTWWgya2FURUMxWDFwUXRWSnVXZkI0aWxyN3JiaXNvL0hjNHN1WGt3TVFaOVJNSjZpQmtPOXhzTi9qckY1NG1XWmpHc0Uwd28ydS9YSitBeU15dGtuRE4zMjgxZmFSdjV3cHNrd1JKWEtTSFI2YUNMc2NKQ0Z4S1JVOGJHUlBOa2dNS2pFb25iQnY3YjltTU1MZ0ZqOGN1ak1kRENsL2JsZ1pYamphMGxHdzBybVYweURUcVhNVTBTR3pUVU56OHE2NVVQZklWa2F5Q29kd3Q5VnJNcER5eGhSVWFwS0JrVk1HWnhRdG9MM1Rqd1kxTXQvYTZ6UFlDdGNQNGJ5TTUzZHJyQXRzTFArSGcvYTI5eXIvenR0ZXV5ZXZGVFlDVUFUTXR5blRJUEVoOUtEOHFyMXhGVStZN1IvM2FCb1B2TmgwSllIVjRPdjR5UVBzUVlKUERJVGxnT2gvd0V5YkJFNlRUQXMwY2hTYVhNUU02UEJwVitmdzIzVTNETENOZW9QZDQ2ck9QSGNtWDFlaXRDbytMb2t0clBIT0pwenZ4N0dOK3lHYzkrM3d5U2FFdFRVZFNsVVlmRkhRSlN0Rk5wejVCUU44TnltTCtIbytVNDUxWGwydWJIL3NFbEVzbTBTSFhuRmJSSTFzQ09TSE85WkNsYW5LajlwTFlrMmh6Wm80eFA1SktIMU9qUVVtU2ZCb29NZVg2MDdWZGFnR0R0NXpZVmlwekZqeWtTdE14azJyajl6RjdySzJXUTNaMzlFdnJ5Z21FNzkxaFhUa3NkZ0lOdjZKM3FzVmw3VVZLcU5hRmxkcStabmtDMllaV2xhK3dKQ2tqZzhqVU9MUDU5Zk0wNnY3ZmQ2K09OVmc3RWIyay9oOEJuNjlqZ1ZZS2NRNTVWZzZnMTRmMHF2VWhuSWRyenNxQTlqQW0vOHB4T1BPQUZDOXBIWnVqMGhQR1psYVBrRVFKNkZlTFNRL2M4bEROVHRaaStIelBaOXc1a0toSFMwY0d6MEplMFgrOG1CVmU5bWNYK1hIZG10YXVLUW9uWnZyQ2pNdzNGREFxUFZCc1RtNUVDK1hYSEZXUGZ1YXBBalUvV1l2WnlQaDhjZzR3TzdXNDFHZXNqUytYY3pLczFheFFEcEhNQzAzQ2RMeXdhY0ZNOTdjWVZ0ay9IVms0VjJXeGF1dXl4OW1YV0t5aGJGNnBlVStWTG9qSmNnRGozQWRoK1BmODIrMmhkUjRIa3pmZFVkeHR1TStwakZqNzY5MitOb1VwZ3FQUFM2QlZ0UnhrMnVEQ0kreVFlcXdQK3dCUzFCSXBmNEJVWHo3Lytqdzkvb2JQY3ZydDhYbFZNYVdoVjVtdnJsUi9tM0VubUY5MnM5SGs0VXVXSjREZVpQekcvVWFUUDE5bzZtZFo5WHgzc2QzZFd4eTVhUGNoUzFqWFRhbjdvOS9QMDFIaTl5MnhqbTk3MUxzVEowMDdFcDVUMkxyVFpJYUQyNllSbDRleWxqdDQzRzdkaFY1MDZ1VGhhS05nbjB3KzlESkpLNUhnMmJYNXZ1czFpaUVsRVVJZUgzWUpRdjlwMGU3MVMvYXFYSUR6MThpNGNuaGhFcWZ4dXprZnJ5RmZEWWY0b1R1NW4wUDlrSGZocjdjdnF4alEwY0UrUGovazB3bDBRQ2NVVzhmUEIzVm9pdjl3MWp0NFFhT1hUVnprQ1d1WGVIdEVPdlUrQkY1NUc0aHpsckZjL3pnK0tJN05BYWd4bk83dFpFTmZQaHVBZzZDUDNSaUgyOC9qdS9MbW0rY2ZIdjcyL09Yejg1ZmYvVCsyMTRlNENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS09EY2dNQ0J2WW1vS1BEd0tMMVI1Y0dVdlJYaDBSMU4wWVhSbENpOUJTVk1nWm1Gc2MyVUtMMEpOTDA1dmNtMWhiQW92UTBFZ01Rb3ZZMkVnTVFvdmIzQWdabUZzYzJVS0wwOVFJR1poYkhObENpOVRRU0IwY25WbENpOVRUV0Z6YXk5T2IyNWxDajQrQ21WdVpHOWlhZ280T0NBd0lHOWlhZ284UEFvdlZIbHdaUzlRWVhSMFpYSnVDaTlRWVhSMFpYSnVWSGx3WlNBeENpOVFZV2x1ZEZSNWNHVWdNUW92Vkdsc2FXNW5WSGx3WlNBekNpOU5ZWFJ5YVhnZ1d6QXVOelVnTUNBd0lDMHdMamMxSURFNUxqZzBNeUF6Tnk0d09UTmRDaTlDUW05NFd6QWdNQ0F4TWpVZ01qTmRDaTlZVTNSbGNDQXlOVEFLTDFsVGRHVndJRFEyQ2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEZzVJREFnVWdvK1Bnb3ZXRTlpYW1WamRBbzhQQW92Um0wd0lEa3dJREFnVWdvK1BnbytQZ292VEdWdVozUm9JRGMxQ2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdNU0F3SURBZ01TQXdJREFnWTIwS0lDQXZSMU13SUdkekNpQWdMMFp0TUNCRWJ3cFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqZzVJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LT1RBZ01DQnZZbW9LUER3S0wxUjVjR1V2V0U5aWFtVmpkQW92VTNWaWRIbHdaUzlHYjNKdENpOUNRbTk0V3kwMUxqRTFNaUF5TUM0Mk5qWWdNVEU0TGpnME9DQXRNUzR6TXpSZENpOU5ZWFJ5YVhnZ1d6RWdNQ0F3SURFZ01DQXdYUW92VEdWdVozUm9JRFEwTWprS1BqNEtjM1J5WldGdENuRWdKU0F0TFNCQ1pXZHBia052Ym5SbGJuUUtJQ0F0TVRBd0lGUjZDaUFnY1FvZ0lIRWdKU0F0TFNCaVpXZHBiaUJXYVhOMVlXd0tJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQkRZVzUyWVhNS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3SURBdU5qZ3lJREF1T1RNM0lDQnlad29nSUNBZ0lDQWdJRGM0TGpReE1TQXdMakEzTWlCdENpQWdJQ0FnSUNBZ056Z3VOREV4SURBdU1EY3lJRGcwTGprd01pQXdMamd6TXlBNE5DNDVNRElnTnk0eU16TWdZd29nSUNBZ0lDQWdJRGcwTGprd01pQXhNUzR6TXpnZ09ETXVPRFUwSURFMExqWTRJRGd5TGpjd055QXhOUzQxTXpnZ1l3b2dJQ0FnSUNBZ0lEZ3hMalUyTWlBeE5pNHpPVGNnT0RBdU9Ea3pJREUwTGpnM0lEZ3dMamc1TXlBeE5DNDROeUJqQ2lBZ0lDQWdJQ0FnT0RBdU9Ea3pJREUwTGpnM0lEYzNMamd6T0NBeE1DNDFOelFnTnpZdU5EQTVJREl1TkRVNElHTUtJQ0FnSUNBZ0lDQTNOaTQwTURrZ01pNDBOVGdnTnpZdU1qRTNJREF1T1RNZ056WXVOamt6SURBdU16VTRJR01LSUNBZ0lDQWdJQ0EzTnk0eE55QXRNQzR5TVRVZ056Z3VOREV4SURBdU1EY3lJRGM0TGpReE1TQXdMakEzTWlCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNQ0F3TGpZNE1pQXdMamt6TnlBZ2NtY0tJQ0FnSUNBZ0lDQTNNUzR4TlRjZ01DNHdOeklnYlFvZ0lDQWdJQ0FnSURjeExqRTFOeUF3TGpBM01pQTJOQzQyTmpJZ01DNDRNek1nTmpRdU5qWXlJRGN1TWpNeklHTUtJQ0FnSUNBZ0lDQTJOQzQyTmpJZ01URXVNek00SURZMUxqY3hOQ0F4TkM0Mk9DQTJOaTQ0TmlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURZNExqQXdOaUF4Tmk0ek9UY2dOamd1TmpjeklERTBMamczSURZNExqWTNNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdOamd1TmpjeklERTBMamczSURjeExqY3lPU0F4TUM0MU56UWdOek11TVRZeElESXVORFU0SUdNS0lDQWdJQ0FnSUNBM015NHhOakVnTWk0ME5UZ2dOek11TXpVeUlEQXVPVE1nTnpJdU9EYzBJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNNaTR6T1RnZ0xUQXVNakUxSURjeExqRTFOeUF3TGpBM01pQTNNUzR4TlRjZ01DNHdOeklnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNCbUNpQWdJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1VHRjBhQW9nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lEQXVOQ0F3TGpRd05DQXdMalF3TkNBZ2NtY0tJQ0FnSUNBZ0lDQTRNaTQyTVRJZ01UY3VOVFF6SUcwS0lDQWdJQ0FnSUNBM09DNDBNVEVnTVRrdU5EVXhJRGMwTGpnNElEUXVPRFV4SURjMExqZzNPU0EwTGpnME5pQmpDaUFnSUNBZ0lDQWdOelF1T0RjMklEUXVPRFV4SURjeExqTTBOaUF4T1M0ME5URWdOamN1TVRRMklERTNMalUwTXlCakNpQWdJQ0FnSUNBZ05qY3VNVFEySURFM0xqVTBNeUEyT1M0Mk1qa2dNakF1TXpFeElEYzBMamczT1NBeU1DNHpNVEVnWXdvZ0lDQWdJQ0FnSURnd0xqRXlPU0F5TUM0ek1URWdPREl1TmpFeUlERTNMalUwTXlBNE1pNDJNVElnTVRjdU5UUXpJR01LSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ01UTXVNekkxSURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TXk0ek1qVWdNaTR6TXpRZ01UQXVOelE1SURBdU1qTTBJRGN1TXpBNElEQXVNak0wSUdNS0lDQWdJQ0FnSUNBd0lEQXVNak0wSUd3S0lDQWdJQ0FnSUNBd0lESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ01TNDFNVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhNUzQzTVRFZ2JBb2dJQ0FnSUNBZ0lEY3VNekE0SURFeExqY3hNU0JzQ2lBZ0lDQWdJQ0FnTVRBdU56UTVJREV4TGpjeE1TQXhNeTR6TWpVZ09TNDJNVEVnTVRNdU16STFJRFV1T1RjMElHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdNVEV1T0RFeklEVXVPVGMwSUcwS0lDQWdJQ0FnSUNBeE1TNDRNVE1nT0M0NU5qa2dPUzQ0T0RNZ01UQXVNelkzSURjdU1UTTVJREV3TGpNMk55QmpDaUFnSUNBZ0lDQWdNUzQxTVRNZ01UQXVNelkzSUd3S0lDQWdJQ0FnSUNBeExqVXhNeUF4TGpVM09DQnNDaUFnSUNBZ0lDQWdOeTR4TXprZ01TNDFOemdnYkFvZ0lDQWdJQ0FnSURrdU9EZ3pJREV1TlRjNElERXhMamd4TXlBeUxqazNOeUF4TVM0NE1UTWdOUzQ1TnpRZ1l3b2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQXlOeTQxTVRZZ01qQXVNVFkxSUcwS0lDQWdJQ0FnSUNBeU55NDFNVFlnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREkyTGpBNE9DQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01qWXVNRGc0SURFMUxqQTBNaUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUzTGpVNE9TQXlOQzQyT0RnZ01Ua3VNRGN6SURJeUxqSTRNeUF4T1M0d056TWdZd29nSUNBZ0lDQWdJREU1TGpnM05TQXhPUzR3TnpNZ01UZ3VOVFl4SURFM0xqWTBOU0F4T0M0MU5qRWdNVFV1TURReUlHTUtJQ0FnSUNBZ0lDQXhPQzQxTmpFZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURFM0xqRXpNU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdNVGN1TVRNeElERTFMakk1TkNCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMkxqZzRPU0F4Tnk0Mk16VWdNVGd1TVRjM0lERTRMalV6TVNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFNUxqTTVPU0F4T1M0NE9EVWdNakF1TmpBeklESXdMak16TVNBeU1pNHhNVFVnTWpBdU16TXhJR01LSUNBZ0lDQWdJQ0F5TXk0M016a2dNakF1TXpNeElESTFMakE0TXlBeE9TNDNORE1nTWpZdU1EZzRJREU0TGpVMk9TQmpDaUFnSUNBZ0lDQWdNall1TURnNElESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ016Y3VNelk1SURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTXpjdU16WTVJREU0TGprd05TQnNDaUFnSUNBZ0lDQWdNell1TXpnNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016UXVOemt6SURFNExqa3dOU0F6TkM0ek1pQXhPQzR4TkRrZ016UXVNeklnTVRZdU5qTTRJR01LSUNBZ0lDQWdJQ0F6TkM0ek1pQXdMakl6TkNCc0NpQWdJQ0FnSUNBZ016SXVPRGt4SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F6TWk0NE9URWdNVFl1TmpZMklHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UZ3VOelkxSURNekxqazFOU0F5TUM0eE5qVWdNell1TVRNM0lESXdMakUyTlNCakNpQWdJQ0FnSUNBZ05qQXVNamt6SURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREV4TGpVME1pQnNDaUFnSUNBZ0lDQWdOakF1TWpreklEa3VPVFEzSURVNUxqYzRPQ0E0TGpZMU9TQTFPQzQ0T1RJZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURVNExqQTFNeUEyTGprNE1TQTFOaTQ0TWpFZ05pNDFNRFVnTlRVdU16TTVJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTFNeTR6TlRFZ05pNDFNRFVnTlRFdU56VTJJRGN1TXpjeklEVXdMamMwTnlBNExqazJPU0JqQ2lBZ0lDQWdJQ0FnTkRrdU9UTTJJRGN1TXpjeklEUTRMak01TnlBMkxqVXdOU0EwTmk0ME1Ea2dOaTQxTURVZ1l3b2dJQ0FnSUNBZ0lEUTBMamM0TlNBMkxqVXdOU0EwTXk0ek9EVWdOeTR4TWpFZ05ESXVOREEzSURndU1qWTNJR01LSUNBZ0lDQWdJQ0EwTWk0ME1EY2dOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lEUXdMamszT1NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTkRBdU9UYzVJREl3TGpFMk5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURFeExqYzVOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJRGt1TWpRNUlEUXpMamd3T0NBM0xqYzJOU0EwTmk0eU1UVWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lEUTRMall5SURjdU56WTFJRFE1TGprek5pQTVMakU1TXlBME9TNDVNellnTVRFdU56azFJR01LSUNBZ0lDQWdJQ0EwT1M0NU16WWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTVRFdU5UUXlJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdPUzR5TkRrZ05USXVPRFEzSURjdU56WTFJRFUxTGpFM01pQTNMamMyTlNCakNpQWdJQ0FnSUNBZ05UY3VOVGMzSURjdU56WTFJRFU0TGpnNU1pQTVMakU1TXlBMU9DNDRPVElnTVRFdU56azFJR01LSUNBZ0lDQWdJQ0ExT0M0NE9USWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTJNQzR5T1RNZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ1pnb2dJQ0FnSUNCUklDVWdMUzBnWlc1a0lGQmhkR2dLSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdMalFnTUM0ME1EUWdNQzQwTURRZ0lISm5DaUFnSUNBZ0lDQWdPVGt1TkRFMUlESXdMakUyTlNCdENpQWdJQ0FnSUNBZ09Ua3VOREUxSURFeExqVTBOU0JzQ2lBZ0lDQWdJQ0FnT1RrdU5ERTFJRGt1T1RRM0lEazRMamt4TWlBNExqWTFPU0E1T0M0d01UVWdOeTQzT1RFZ1l3b2dJQ0FnSUNBZ0lEazNMakUwTnlBMkxqazFNeUE1TlM0NU5ETWdOaTQxTURVZ09UUXVORE15SURZdU5UQTFJR01LSUNBZ0lDQWdJQ0E1TWk0NE1EZ2dOaTQxTURVZ09URXVORFkxSURjdU1Ea3hJRGt3TGpRMU55QTRMakkyTnlCakNpQWdJQ0FnSUNBZ09UQXVORFUzSURZdU5qY3pJR3dLSUNBZ0lDQWdJQ0E0T1M0d01qa2dOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lEZzVMakF5T1NBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXhNUzQzT1RVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBNUxqSTBPU0E1TVM0NE5UY2dOeTQzTmpVZ09UUXVNalkwSURjdU56WTFJR01LSUNBZ0lDQWdJQ0E1Tmk0Mk56RWdOeTQzTmpVZ09UY3VPVGczSURrdU1Ua3pJRGszTGprNE55QXhNUzQzT1RVZ1l3b2dJQ0FnSUNBZ0lEazNMams0TnlBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURFeE5DNDJPVGNnTVRNdU56STNJRzBLSUNBZ0lDQWdJQ0F4TVRRdU5qazNJREV6TGpBNE1pQnNDaUFnSUNBZ0lDQWdNVEUwTGpZNU55QTRMamsyT1NBeE1USXVOalUxSURZdU5UQTFJREV3T1M0eU9UWWdOaTQxTURVZ1l3b2dJQ0FnSUNBZ0lERXdOUzQ1TURnZ05pNDFNRFVnTVRBekxqZzVOU0E1TGpBNE1TQXhNRE11T0RrMUlERXpMalF4T0NCakNpQWdJQ0FnSUNBZ01UQXpMamc1TlNBeE55NDVNalVnTVRBMUxqa3dPQ0F5TUM0ek16RWdNVEE1TGpZek1TQXlNQzR6TXpFZ1l3b2dJQ0FnSUNBZ0lERXhNUzQ0TmprZ01qQXVNek14SURFeE15NHhNekVnTVRrdU5qTXhJREV4TkM0MU1ERWdNVGd1TWpZeElHTUtJQ0FnSUNBZ0lDQXhNVE11TkRNM0lERTNMalF5TVNCc0NpQWdJQ0FnSUNBZ01URXlMakk1TVNBeE9DNDFOamtnTVRFeExqTXhNU0F4T1M0d05ETWdNVEE1TGpjeE5TQXhPUzR3TkRNZ1l3b2dJQ0FnSUNBZ0lERXdOaTQ0TlRrZ01Ua3VNRFF6SURFd05TNHpNakVnTVRjdU1UUXhJREV3TlM0ek1qRWdNVE11TnpJM0lHTUtJQ0FnSUNBZ0lDQXhNVE11TWpjeElERXlMalUzT1NCdENpQWdJQ0FnSUNBZ01UQTFMak15TVNBeE1pNDFOemtnYkFvZ0lDQWdJQ0FnSURFd05TNHpOemNnTVRFdU1qa2dNVEExTGpRMklERXdMamczTXlBeE1EVXVOemsySURFd0xqQXpNU0JqQ2lBZ0lDQWdJQ0FnTVRBMkxqTTRNeUE0TGpZek1TQXhNRGN1TnpVMUlEY3VOelkxSURFd09TNHlPVFlnTnk0M05qVWdZd29nSUNBZ0lDQWdJREV4TUM0NE16TWdOeTQzTmpVZ01URXlMakl3TlNBNExqWXpNU0F4TVRJdU56a3pJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEV6TGpFek1TQXhNQzQ0TnpNZ01URXpMakl4TWlBeE1TNHlPU0F4TVRNdU1qY3hJREV5TGpVM09TQmpDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0JSSUNVZ0xTMGdaVzVrSUVOaGJuWmhjd29nSUZFZ0pTQXRMU0JsYm1RZ1ZtbHpkV0ZzQ2lBZ1VRcFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqa3hJREFnYjJKcUNqdzhDaTlNWlc1bmRHZ3hJRFEwTXpBd0NpOUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVUtMMHhsYm1kMGFDQXhNemswT0FvK1BncHpkSEpsWVcwS2VKenRmUXQ0Vk1YWjhNeTU3UDF5ZGplYjNXUnoyYzJTUU5pUURWbHlXUWpKSVNFSUJEQUUxQ3dRRExBcU54VzVYd1NoQklHQUZTaW9vUFZLS1ZXTHk2VTBJRmcrYTZtb1ZGdTFSVnVyV0dxVmdsSzFsa0wyNUgvZjJiTWhnUDIrdjkvelBkL3ovOCt6TXpremMyYm1uRFB2L1ozM0hCWkNDU0Y2c3BMd1JKcTJjTDczTzN6TDc2SG5NVUlNZWJmUHVlUE9FVU5QM1FIdFkzQk11bVAya3R2bnYvOEhuaEJuRmlFRG41NSsyNVRvVitUT0hZVGNDT09rZkRwMHBGbjBJK0Q4SXB6M21uN24vTVUxT2I1U1FocGhmdC9YWnQ4OWJjcVhQL25UZTRRcy9aU1F3cGZ2bkxKNFRtYTc0ZStFN0h3ZTVudm56TDF0enZjK3p6a0U1MjhRb3BQRmN5U2RFSEVIY1NmTG5ra2dpWjZ1VDd2V1h5bVZNVXBoMTkvWmZLSWNUc3prVG5hZEY1OGlabTU0MTEvNUNESER2TC8ydkZQWGVTRkU3R1FuZVk1c0lLdklJbVZQY2tTbkhrTGl0RjN0bnFmV3MrQzRCM0EzbGZ6cjlGdkkvMzZLa2Qxa3M5cmVEU3NqUGRxUGt1bmQ1dytUamVyS1ZyTjZLN1N1elA3UDAwZVFueVJuNkV1VXUyN3Nmc2lFL0lMOEhQQXhra3dnWThYZmk3K0h2bWF5Q1k1MmdQbEtlcE9WQ09WaXNvZ3NKVlBnV0tXT3JXSTRJbXpzVGxadmdiNHRnT2NueWNQMGJUS0t6Q2RSZ0tvN2FmemtCSmtKYzBmQmZXYVFWOG5UOEt3VlpCYlEwOGIxSWphZWRIMEJkN2dEOFA3ZlR3K1NhZVFoY2t3NW9ud0pUNCtTaGVSZTdodmdEMExNd2tOZFg1SHhaQmlzWVJZWnBaMmg5Q2RueUpFcmx3b25pVTN6SlBLTVFzaXo1Q0NaVGJEdWdQckZmMzhoWFVTWkZyOHp2ckRyTzEycnhjL0VQd2t2Q2VmNHFKQkI3aUwzQVdVZkpUOWtyYzJBcmQwa2xWSXBsVklwbFZMcC84ZTBHdXpvVnJLMWEwM1hIdEpFQ2pWcFpBL1kyV0ZLczlnS0Zua041RW5NOHY2UVBBSSt4bW55T0drQUQrQkExNmRYM2VVeHNOZW53U05wQUI5dkRDSHlUV3VpRXlkRXhqZmRPR2IwcUlhUkk0YmZNS3l1ZG9oY1V6MjRhdERBY0dWRmVkbUFVR24va21CeHY2SkEzOEkrdlF2eWUvbnpmTjdjbk93c1QyYUcyNVh1VEhQWWJaTFZZallaRFhxZFZpTUtQRWRKRVhYSDNIWE45VE5qR1hXdE1aTi9xRi95eGt4akxvd094b2pkNC9QYnZLRmdwSjg2S3lZR1lzVFJFRXRyYk41TDVNcElUQk80ZHNxWUdKOHZmZW1EaTBkN3ZQVXhJUi8rL0NPblJHTjltcHA5ZnVtM251N3hDRndUeTZ4cjl2azhNUzRmL2tiQUVQeU5uT0tOeHFSRzZQZDVFajBqWXFTeEdZK09ybzhyb1pOVStpSlFOalhIY3BLbmtjaTNMUkljN0s1ajF5eHpERzJYOXBveTZvYkdTTnBlWXZvNFJwdzQ3VUlsdUtKVnNUNEJXSWdFTFhZM0VvelJ0QzlqMUJHanp0R3c1S3NmZ1pkOVZQa3RPS2lQenZUWFIyY0FScU90VjNCNklZRlJuN2ZkMjk3VWJBdEJreTI2SWZicTJPYTlSa09kdis0MkEzUVExa0gyR296UVk4UU91TVdjdmRSVVRWbURNOVVQM01zUm5SblFaOGZsMXVNeE15WnZhSVdHZnlqZ0RVWWNWMFk2dW81dDdEbEU0TEpreTVGb0pSWVIwOVRGdElsRmVHZkU1Q2t4c3NHN3QraFkrOFlPaVV4dERaaWkvdWlVU2MweGZncE0yRXY0L1BycDQyTlpEWTBUb0FzZUJVZnJkQytTZXlncmtIamUrdW5lZGpqSHVhMVErb2NpMGEvcWowNi9yUlhaaExiNmg4S1l2cTU1cmUrWUoyYUh1ajVtQzhUTU1NMjg5SXlIYjY5M3ovRGlhWHY3V20vc1NWaHVqMUVmbHNBRWJsaDZlNzBmbmdZM3E1OVppeVFKZHBPTmNlT0lLQ09PdkdHS043Wnk2c3dFNzAzWm1PUi9YN3NVTTMzakErb0FmZUJLZHFHS3ltanJURnp5ekNrSVp2MU1iL3VHMnhpb0d4bG93Sy9lK3BsRDhjQUxnZnZKVFhEMWhPYjY2Zjc2S3c4RXdLSEI1MTk3cmM4WHl3amdoZTN0OWJqRUtWRllmV0xKTUhCbC9TZ1RuZ0NGOWRURjVQR3NJdU1aRGVDSjhwU2hFYlZMblRBQkw4T1IxcUdSaUM5QmQ1Z2EwK2F2Rll2OTNuYThvelkvbGhhUWZLL0EyTEYrUlExTnpmVkRQUXo2R0ZmWFBQaTgyM01lMmcyTjNkM1VEWFBhZytjOUNSdzFqUE0zakUxd3dmUmswVG8rSWNCY04rVmhxanFmM2ZXazIzTVMyc1A4dzFyYjI0ZjV2Y1BhVzl1bmRIU3RuT3IzU3Y3MnZTWlQrNXo2VmkrVGZBcjloemQ0WXNNMlJtSlM2M1E2RUlpTS9EYXNxU0htR0RzUnlUUE1PMzFLUWxuVStIMlZIcDh0a3B6VCtLK0dWVGtEamdlK1J6bHJsODdCMmt5Z2tUemVZYWhlT2tBcmVHSlN8RW5jb2RlZCBEYXRhfHx8fHxGfHx8fHx8IA0KT0JYfDUxfEVEfDU4NDc3LTFeUHVsbW9uYXJ5IEZ1bmN0aW9uIFRlc3QgUmVwb3J0XlZTUFVMUnx8XkFQXlBERl5CYXNlNjReSllvcHJPU21acENEYVl4bldRSHlNUTV1N2tGSjRTUDU5VFBHcVFnQ2JsUVpCdlhlV0xVWGJ1THpvUXh0NkpESlZEaUpyUnpibkRqM2txbWVmVVFPQm9CMnJUaHlMRG5pdkFsSFZpWkh1aTl2OVFPdDNBM2ovZ3VlN3NuUDdUYS8zUnNPTXZ3emRSdU5IUnNQTUY2c2pPa3FWWEk3NnBwNUQ2ZTJPQStQTFVNQTFGZFZ6QlZnRnlKT1FFdTJTMzd2Vy82WUZJaUpkYzNIUEZVUnIyUUQ5VVpoenZBQVNnMW8wYmY4SnlqcVRwSW14V2hWaktaalB3RmR5bFE2NzZxRXdXN204ZGEzdDZyYzFSTXMxUUJFcDM4N2JEQkg4Z040bnNSOG05MlBFTDdCVkpxcXFmT0hvU3g1ZklrWkl5TXhDK3JqbU9VY0syQzlucnBtTDJnZmtOYXhyT0d0OTA1SFlzZThyVU9aR29oNGVuWjNkSDNVT2hUVkhpd1pwM2hVdG9ZeWdkcXJlZTMvbnNOWEFvZXYyaGlaRHR3ZGsvc0NCTjR5ZUN5VGx2SE5LcFlxUGFvVTRiTkdJQ2hYajNkak1Ubm5ldXcyakwvcXJNZDkwU0Q0WUxpeVcvYkhOOGVHQlpLM1NwemZFUEQwUEIxK3pmQ0k1REFCVEhodEl4Q3BZSDhxUFZmMUFYM2xSQmZva2VXZXBXaFBPRnE3MTAvWGpkMHIwM1hqSmpTRGhhczlKQkhpWFRlK2VSOUh1YnJXMnNqZVhqRGVmTWdMemhEcjViQVhPL0hFaXlla2djSWQ5M0U2TnQ5elNDWmtKUnNWV0FjN245WkJDZXZUSmZzb21kYkJKZnFreElNSzJJTmt3c0dJa0JpUms3TUY2Tk1sK2xheVBwYjJFb1JmTm9peVR0YkxKczdNZWZaUzdOb0hQWWNwSVhwSzlwdW9tWHIyd2xWTnJMdURydHlybHoySkdTdGhocHhZNGJxYnJqejZwZ25OKzAwRUxtTWxQS2dXRTZCN0pTQzhFV1FKbmpFeEppRVJ3YjJLZVROUGVOb2xWTmV4U0FCVjJwOVJEODRBTnRtYlQ5YzE5b1JwVWl5dG9XbWlKMFlqL2FCdkZ5RkNtN2lROEVSTE1tV2psdklDNFVWUkw1RGdTWHM0ZUJLcW1wUDlTMEkybnkzZlovUHQ0di9ZZVpBN0dCOHBMcnpVdmxVWVEwVFMySFZXSTRzeFlpUXU0aUc5U1lpOElKZG11UG04UGsyUlBFdFdWbkZUSk11aEliWEUzaFFoR28ycEthSVJhdHczdXJsTWQ2WTduODg5R2pDWk5hTURIVjMvUEdpRXV2OVIwRFVmeVduUWwrODJRYUdIM3Z6OE1sNS8xTm5SZFU1T2h3R25EdnFjMXFOOEZwendXVENMNytnNnN4ODYrV0FnRURqOURodzJXSDJQZGpnWWJDRTFBZUtXWGdsQXlWcG5zQkhzWDBMekNzb0dsSWRLd1ZYVzhIa2FaMXA2cUJUYzZvSjg2cWVPZnpGR3QyNk5IWDU4KzQrT2JyajFydGt0azJmTzRHL3BuUDRnLzNEQjF0aVJ4eDU1OXVpRzFqdFpOL2Y2ejUvWmQvS2w1NTkvazF2MHdMSWxhemZldTJSdDg2Vko0czVMamE4OHZlL05ZejkrN2sxdTRjWjdGNjE5WU5uU05xRENvcTdQTk5YaVBsSkhiaUYza04vSldjMDMwa21qS0I5cG9DMGphV01GYlNxbkU4MTBwR3drbzhkMmRIMHFtNkNSUFpweXVkUW9TSWk1U2RBaGpoaGpGd3pCeXNKZXR3WEZyS0ZaTFE5RnNnVEQwRzBSZzRNTVBoY2hqb0VqYUtVWXNoYU9LQnBuSDNOYkw4SG5DbjFSNVB1aXVmVUxsNnU1aUxmT2tha3N6eGluQS95TzA1bXdBT1NPVzIwTm5nYWNBbVpiN0s1dzhEUm1HN1FRdjNna01KdzRiSGJpQ3J1RE5sZTRmMG5nMXNrdExRRWFhTUZFYm0xcEVmT0t1ZDRXM2c4VllMZWltQzhiVU0yRlNuTTR3TEkyaDNlVjJ3SEZ2VVBwNmE0MEN3Y2RnUE1LcDBhVFgxck53V1M0MHBtV3c5RUJ4WncvVDZPRnBxdThYUHhCK0phUjlRVjlacXg4SkRMN3dNb2I5anlSVXhYTURrZlgzVGhtVmN1QTlldnI1OXphMUdkc2sxNzNoSTduQ3VTYmd2NkJnMnI2NUZUN2V0M1krYjFSSzJjMzl4cDh4NHhGWTJwbWppNHF2V1UrSFp3ZkhwWTNkUUhONkZlVnQrSmVWMjY0YVVDZ3NUcS9mTWFPNlBiMzZ0TUhOVXdzdjNIcCtFQ2djVTc5NGljcVBXTmE3eHAwRDVXMkZkVDVmSU1LSjNiOCtMRWhKVGVVdUNUVEl4YkxkMzBWSS9yY3VuYnFzSnlNd2VQdUdqbDBlcjJmajVjT0szYk9uRmc0dkxyRVZyUUFOTkZHNVRCM3M3aUQ2TWtRT1NCS1JqcWFZbEhKVVExUHZPSlpEVDFMaUZHSHROQkpRQXZkV1Y1SzhQdHBScERUdnoxTmFtcUFsMXNDQWVvbk5vbUdvT0RHYjFGZW8rVmJsZVBLWVRxVjAzSjZlcGZTcG1nVkk0Rm5wa1BueCt5Wkl3OFJUZGVGL2ZCQUFvWmVOa0tqUXMrZURJSjE0U2Y0b0xNNmNCbGtNejVhWjZTYXN5STVTL0dwVE01T0I3b2Y3dWgrK0xOYmFLVnlmQ3NVaCtsQytuZjZUM3F2c2lYK2ovZy84ZG05bFl1MGlwd0JqcStYczhNOERSUEt5ZncrZ1hnQlF0SUhIa05XY3JJdFl6algwWFYyUC9SaGpRcUNDNHEwQlNVNzh5UUlzdlJONWtsOGJrcys3M2ZRcWljWExEaWpwTkZ6K0lSTjlCSzNqMXNHVDhpU0pZNk9pOXdJNXNRTEExNUthYkFGMUVHd0pRRFgrc3A4M0w3NEg3azhlbWtWWGplbjZ5eHRKSytEUHN1U2JVUVRtMGdjK2hkeStTRFA4VUV6UFBvZVFEUmM1K3FoR0Q0c0hqS2tPRmhibTE1YlhGeFhWMXhjQy9mcE90Tmw1L3NCZG5tU0lac1hVVW9rRUV3S3Axd3dTSmphQ2JSUTBEQjh2M2pqZG02UHVPT2ZpelhyUUNQZjNQVVh2aE0wZ0VUY3BGQjJrdlUyVzZaenZXeXdPblpFckZyUnRTTWlacWh5Qm51Y3pQT0EvL053c3pST28vSG5GUlNBUU5uTHkwTmVYdko1YlhEd25VT1c3Wjg3KzBmenEycVcvbVFCL2ZsdTVRUGxKTzFIQzdtM0R5aG5memJ0MW9OVS85d1I2djM1dExpTmk4WTN4MThFSEp3aGhIdEhQRXdzSkZzMm03V2tuZXEwV21yV1VqZlFHUjRZb3NIengwUDlTMkFEYk9HMVpkVjhSWWg3WjZkanhNVGJTc3FYTEpoZVVDMzh6dEcvcEs5cGx6VlVVKzlEck41SkNQOHhRTldYVk1rNU9ZNzFCdWd0eWw0diswaTJ4WnU5UGVKMUd3eWlSZHdSc1dnQk9Cc0p1WU5NaDRTVE1OckQ1MHNCVENiem9CUEtBRWFtTDZBTjZzRG45S0VLcWFqbWVhSHdodGJLa2ttM2pQWFhQN2VzK2FHN2FucmZ1SGpzYmF0SDUzS3ZkVzdvTTJuYjdERXpaSStRVnp0MWlEZXpXTzRkcTdzaE5IVlR5MDN0UytjTUhINTdKREx3ZXpkTTJyaGl4WTJWdDk4K0E5YTlES2h4Q05aZFNPYktROUxYWnpwNjhicThQQjFaTDF1dEFWMUdKclZtVWlPZm1lbk9kdStJOUxJN0hQWWRFWWZEa0swdDExR2lrM1JlSGEvbmRUcURhRkRweGtCRGZZaDRaQkJlNmFJQUpVQnJBMmhkWVVaVUMwRGJ1d3hzVGpWWEp2bjhaU0d2YllBdkQ2Qm53RXVpTTRmbkQ0MVljM2pPeVNXYlgyeFlja3RRbWJQb0hqcFYrZktSTmV1UFR0Z3lQYXg4UE9MZUNTSDYwSlFuN3FrZUU1dGJNUHgybVdac29McXZiMytpcVhUQ2lsSEtuOGNLdW9ybVJVQndvRFlSRE1DeEZ1SWsxWElPVDhWMmpTeFpOQnFyU3lmb3JMb2RFVDIxV2F4V0RYU3BqR0FQaDBLNGZxQVMyb0JRS0ZPS2x4NkhsZHRDVHIvTmIvTWhiMUFmY0FuZjFOSHhkSHp5NUdNdmJBc3B2ZWhuRGZjdnVVdmMwVG42SWVVRk92YTdNLzkyOFIvM2RJN21YbHI5cTkzcmtGOTJBdDVQd0ZyOHBFa3V5bXJQZExrU09NL1g1UUtHYzNNTmJyZG5lOFN0c1NPYWdRTGZqbUtHWDNjd3dKYVh3T3oxZUIxUXdEaktBVHpFSjdpS1B6Rjh6WkY1cjA3WnNuM004dWJna2YzWnNqdzRvei8zY1B3ZjJkN2hXWE1QTEI5Q0Q4NTRkbWx0MVo3SnhVM3o2emMrd2ZFQ3o3MjVWWm5JOFZWM1A0VzR2QnZXcndEZmVNa0FNa3p1WlRlUTlUNWZlU0FEQkRtcllFY2tNeXVyeEdxM3AxblRtRkNYOUJCcXRuclVxdUdFZkplaWdOdkN5VlVYcXdKZTZuS3lkVHREYk1sYVZURFFNQ0pVdkRKMDhhNHBzNTliVkQxdSs2azFXeWZjdmF4MXgxMkRoR2xuSmo4OGErRHVnaHVtMXc2ZVBpclFkOVFNdWZyMjRYM29MMmZFVnQ0dzRVZGZiMytSOW45dlllR2o0WnUvLzhkMSsrVUZUeTl1V0R5K1gvR05Nd2FOWE5WYUVSeS9BR2t6RldUNVM2Q05uZlE3UkxUMGZ0a3VXM1U2VUZoRXN0bWs3UkdiUm9mc2tSUmZSSDA0RTlGdTRUbE82eSszMjBGU1FlM3lYL3BhcHMrZWZJTVVzemZjT2pNNkxpUGVuOThrRGdvLys4N1hTcWZ5OTFVcnFaSFN6MS9kSHRnS0R5UVR1ajVqZXRGUEtrZ0RtU2dISzlmcmF0dnRvdE91ZzB3eTF4Y1hqKzYxWGlaT01UUjRjR2hIWlBEZ1FuTnU0ZlpJYm9iNWhoMFJzNVowK3lYSUVWaDE2eFpBYnhpWEdaYk9TN0JPQjJxU2dvS3JmUktuaXYwS0ZjRmxLc0lkMTV4UDZGVTNyYWJscnNHenQ5NTh5OWJaVlhkTnJKNWExMnZvc3VmdXVQM1plK3YzRlRiTUdnSXVScUJ3MU16YTZobWppMEw1UTI3dTMvOFd1U0JmdnFXMDdKYWFQTG9wUEMvYTVCN3d6TFFiNzU5YVVUbjEvakhUbmhuZ2Jvck9DMDkrN083cTZyc2ZtMTAzZTFSaDMxR3phNnRtTkJZSFJzL2lJcUZiaHVRWERMbWxkRUN6REhVemN0OWs0TDV6VjdqUFI5YnJYSkpVSGxndnUrd2wyeVBBZVFVaXNtR1c5anE1U1dJb0hPaWhlVVBkQmlZcE5INU5naFVUS0xxTys4Nk5lZWhVKzNkbkwxbzdaZnZNU21IU21Vazc1bFRYTC90UmRQWVA1MWJ0RFl5YVVUM285Z1pBd3F3aDRkc2FBcnovRjhySmQrOHUvWDVkNC9hUE5oOGFzbWpudEpteCs0YmQ4c092RGVQV1RTa0wzclNnZnRUaWNVV0JFZE1RTm1hZmhYUzIzNmlTMHpVa05sRWptZXl4aVNhSG5uZStrR3NOV2prcjdCVFFhY0FhblFack1JTTVEZmVjRG9kVlBnQXlYK1hhWDIvTmcyck5WNEpabDJVdzY1Mzd1ZzA4eHp5WUpyWU9LNWttcDF1dDFHcWlKakd4SG90czNTZnBYK0RWZFdBdDI5Q05NcUYvWTBML3hyVFNvcm8yRnRXMXNRUnRiSlhvMlVCMW1uazN1RktLeXF6bmNoM2c3WHdjSERJa1dGeGJXd1JPejVVbHhwOVArRDhjK1pSV0MxdjUyV3huRjVLdEd2R2xpSWJqNkVzUmpoSlJnSjNDQVhpMElFSUQxeUFHNFpFZ0FTU0lPNlBqcW1NRSt0c25iTzBjenorUEIvZHBXL3czYmFBQnFFVHVFMllMbytET2RiSnBNYmh1Nk50b1lRRDIvTExSUkViUDBWQ05oZ3JnVFg3MEUzVG9SRTU5RGhjTXZCSU1oRWd3Qk40WFBBODJCK0FGbGJFc3pPN2N5YlhGNytVbmNVR2xjUnV0MU5Eb1Ewb093SUpmeWRoQjQyZ0IxMi9KUmVDTDZEUlVMOEdET0ozZVlLUkdzOFhLQ3laZW9DWllIRTl4UkhBYnpYUVVyT2pUQTlnd3dkSll3NGhyREdQTFl0WWJCTkZvd2wyT1NiYW5EemRwWkoyVjQ2Mzg1Z2hZT2JCL09xdkp5SE1XdlJtY2swVWlCVWhGM0hOWkFNUlJ4TTFLWWhPRHRoQ1Fxd1gzUkNRWXJBR3pUaVQzSzlJcm1kSUhnY0FyZHJZRGd0MVBnRzJEMWg0N1pqbDJURm9MaFhqc0dPNkpmSDdleC90cHlNRVg5UFpydEx4b1AveEkvTWtIWCtRSzlqeHgybWdVRE9ZUDZSWUZqZVdEM0xTYzJzSCsrUGRSSHg0QmF4MEVuRmhCRG5MSkgyU1Qza3cxUnRpL0F3SUVYR1V4MEVUbnR0bmNteU0yV3dZbEdac2p4RTZselJISzZ6Tk1HZ1JhZzh5b1FXWmNuZzJPL243b1k3VXBVY3RCR01yT0ZuR2F1UHcrSjNYaS9pT3grM2I2YkJtSXVBenN5c0N1akJWQTdvdDRENmkvd1h2Z3VZejdkK0xEL1NveWRlQXpPRXJaM3J6bHMwQTQyV01MWDYrZTBVTW1pTEtXa00zSDJGN3JUSWRLOFBNMnRnbjNKZXNqOUpIRDc3Zk4zN3hIdVhqaTB2UHRqeXZuLytQTTFtZVVYZUtPZzF1V0hpZ1FiSWUyZHB3Uk9hWC9taVcvanUrSWQyNWNxcUFkbTl6MXFiQVJ0S1NUYkpldDlRWTZndENSUExXNnFJblhJNU9ZZ0l0NE55emNZQ1JPN0tpRHR0UHA0QnliSTV5REdHR2UwV2pXbVRkSGRBSXhsaUJMMVFBdkdsMFNJbGRDckVuTFJRbmFJaUpKZEJpWm5ER0ljUThOWW5ERldWRmJnWkF0eE5nRkFTZXdyOUg0dmJDWElyNkV2Y2RtcUxSQzJQakVlZVZYeWliNk9LMSs0LzRkaC84QkxuM3VaNmNlcnhwUDI2bE1tK251UWZ0dlZnNHE1NVJMeW9sVzFBYkFMV0sxS2tFUHl3V0VoNTBJbFVTaVoweWhRNllRa0p3Q3JsUkFjZ3JMelIxZFh5TVp6U3BybUZXeVFuMVdkc01VczltbVIxRDFDS29lK1VpL2d0RSt3UU9LeWdNS1JtWklrdFNKdUF4cmRxdGloSllnbWIwSUtwQVZZUWF5YnVTK1VTWXFUN3p6VzVwSkI4WVBpanZpOWNvQjVVNlJ1L3dRTGFaT3JqZFFFU0RqRHdCa1JqSkhIcUFCZURTd1o5NGNLTkVZT0dvQXVPeWNDT1FDNkFRZElXYU5BUmRzd0FVYmNNR0dGVlNGRHVwTHVHQld3d2p0eWEyaEVHN2F1amtVR2tGWXRnOFVwRk05K0FOeEhYY3EvaGFuaVYvaUdzVWRqeWoraHhXRHVyNnRiSmQ5aDF5RWE3Rnk0Szl5bkU0THZpdXdEaThJc0xNSDR3cHIwT0M2TkxndXpRcHRSOWRsWEpkV3hUcldhQ1cwUVdOaUE5eTlOblZsMEFRME1zM05sZ1RlTjc4MXNhRGQzQ2xnZituaCtCcjhiRERCK2VnZlpKQTlzcDRZcUJXVWhzaDRmaER3dk51MU9lSjI2MGlTMDYzR1hDTm51TUxyTHBkVE1ocUpnRlFXa01TNFlMSUNST1J6WENqV2NoN1RFWjZySlFHRmdJbURkTFVrcUxBd3IvZGFrUWpad3d6WGhHblBmSTN2VzhTQm1hbHpwNVNMeWtsbERmMEJyVHY3eEo3UC82YThRWFArdm51WmNweCtQSFVwM1VpSDBkSDB1VkdIN3dJT3VxaGNVRTdVMFMyUEpPZ2pmTW40WjRrOFhBZXFYNmNSZGNBLzFDN2FEYnlHMXhPRWdXaXVBSG9mQlNPREhHTkhkcUZtbllBekJKd2g0QXhoaGFncVFsR1ZJREY0amVJTG9PeERTaklTMEFyb2hWSFdrUERsN25qbTd0M2NKN3U1NzhibkFzdHY0SmpYRGV1a1VSWlBrQTZTRlJUNG1vZGIwT0JwZG5tSVJuZnZobEZLMHJvKzVRTFFNcEU3WlJlR255bTE2b0c4R28yT0J6bm5IVVplUk4yT3NWTlJKQ2owQklXZTZCaHdCamZLaDhwelVGOUNuak1ZTEdZMW9KcWdWSUQ1OTBpbnBQQzJnSU9vdW9jMlc0Z0xuUHJKK1BMeW0vKzBtK082bEQrN2QvV21xL2dkS3JhZmh0Vko1REU1YTdtRkZsckNGZzZnNlVzSGdoZmhOb0VPbFREd1pVbmFiVFRnTWpQbEJvdEVSUkhGaG9kTktKWG13TzF3TUFNaElIYURpRlJJMkNxa2dvZ1NkRUdWSURCREtFSTZKajlKS05Cc3Q4QUdOb2kwWUdZYWpUU0xVdnI4Rkl3eEkwbW92SUtHcVBEMDJmaHZjN1hDN3QyQ3hjMjVmeDNmem0zS044ZEJwY1lucDN1NGUrS05LbzM0blFDZFNPNlg5VlJnMm9kaGU3L0VtT0dDeWhUTXdyTGF5T3BQOXh0WS9kRitQYXVQeVc1RDduQlIxRjdIV1ZUbExLaS9aREJSc2FldVVwVXIwNjAxQ1EwRlRNWHZqTHQzYzdLNDQ1S2lybElEakVVODVMRHNYSnBKRnpob2dhUGN3YzFOcCtrTTArWWs4cG0zVTRHdDlFd3E2czBhdTgxdTU0WHJtQ1lUT3pKUkxwQjdLTldvZWhRamh6VGJnZmgzd1lERDNFTWZJRHpTQ2h2QWdmRFlWSTZ6b2VNTHl3K1hBaXpvQnJlRUdHRGhCSW1RUEN6ZUJ4U3lEYWdBZDRreVNxVTdrVlkwM2NXb3BabjdRNHZnZGlqcFRZckxtUzdvbnY0ajdRaFpOWUZNK2grLzRWK2UrNE1wZlMvdkU0YVZUTHY1NTUyQWxFNzN2UERDZ2Z5WkJHWkU2Q0VPOG1QWnZNaEU1eHJwWW80dXA5U0lFZ051d0dpclRzWExSWENPMEllMFUxSFFHM2c5dFY2dkoyelVodml3MlJCVk5yd21Bd1pzVHFPb3c3azZuS3ZEdWJvVmVoVVAraVN2SnN4cGtxN2hVaFViN0FUYzV3UXlXQkN4bTEydklLR2d6QllTNVYvRmM3THNHdDN1OTdsZjlUTUxodDNDb2tDdytPSExYNHM3TGo4NkxMTjZHLzlsWXEvNHFmZ3MyQUxjVDYyU2M0Z2RQQUtIeGdSMlZMald1QzkzcWl6c1ZIY3VXRE1uMGVzc2NYSk9aNFlWcjdEaUZWYTh3cnFjUjBYSm8rWlg0OVVaVjR3WDg0R3U4UVRFaEhwbkpWWDFPNWFjb3J5cGJLWUxhUzB0cExPVWpjbzdIeXVmVU1jSDU2aWtYSFRUTGRBL2dUNm16RkdPS2s4cDA4VlM1YkR5RDhoSDZRRHFwRm0wWFBXQmhFS2dyb0hZeVNhNWNKaUdjbFpxRWt4a2M4Ums0ams3YndUMXlHdVJsN1c2Ym5XeFhFTDVSTFpGWWNoQjFrVklKQ25OUkJIYUJMTWp0SFFGcDBvbjFGOHpLbklDQzFsZjVmZjJBQmpQd2JTeDJCL2FhL1J5aWVyZVNqNVE2YlQ5azdqeWx5K094dmI4VklseE9mR1B4UjBmdmZHRzBzbWRpUjk0WWpQTll2U3IwZVFEL2RKSUwxSXVaem9rd1dZeStUSUVoMFIwT2lmelRiTTNSK3pBMHpYSHV4MFlESDJBM3BPT3N5Mlk2TzFkWUpNcXluMWVWN3BOMG9KUStmSmhTNnpWMkNRWDZQT0tjcHZVdXdBbzhOYWhuNzU0aEE2aGZRNGVQRnhVU3I4SEpQbHk1dHlQSDNoZ2Zmc0g1OWF0YTJ0em56Z0JoSmg0OGxldnZvcUVlS08vWC9ud05aOVkrc3d6UUl1THp6eTFZd2RRSTN2SG8wbHFIQU5xWkpIZTVFVjVZTDJWOHJLRmduTmtFbDA1T2wwT3JGeG55RGJDMm8wOE5iajBOcVJMUXBLUUxyMlcyNVp3ZENtbDNGV1dvb0Mxc2ppYmdPYUI2YW5Dbk91Y1ZJTXFiUWJWNXpPb1BwK0J2VEpFU3NFV3VNVlZpc1pBZmVVRk85WnJkaWRBTmRweUsyN2ZpbmsvQzNZbUE5TE9ITjVGYmNuZ29uRHMxUXUrNmlFTndmYmQ5UG5KVHl5bzdUZHV3WWhlWlNYQjdQamVNeld6eGhSdGU0QnVxYnl4MUJWL1hOd1JiSDJ3dFdINTFIcUhJQlZXM2hEa3g4VXZGdHh3aHp4dkZVQ3pwT3RUL285QTZUTHlHOW5aVUVaSEZ0TmgrWFJvSmgzbXBBUGM0TGoxUlU2RnVnK3pNR1IwQm1Ma1ptalljRlJmNU1nVDNQMHo0VTRlMkxwNDNMSWJrT3NXd0VFQURQZnZyOWtjNmUvd2VJcnlFR3Q1aU9nOFJIVGVjb2VERm1GZkVmWVZZVi9SY2owcVJDdEt2cDdxOVJWVWw3QkNUS1RWZDRScXBiNTFaZjRjeVhSTEo2RUZ1TEdwKzJMVjRMWlVsTEhYZkJoRzY1MThINWdNY2VJYnZpc1J1Q1Y1dDg2WTJlL1I3YUVKeTI1bytFNXJ4YzBiOTdlOE0rVytYMWJjZFhONVllTzhodEh0MHdlUGU2RGo5cnpvOUphQngzTktmUFo1c3dmZWZNT1FYZ1ZqSmk5cW5McDVjbkhvYUxOclFOT2dpc2JhNnZ5QzhiZmYyemp6ZTVNS2pjNWN3RXdoY0tXSjdaTld5RVllbExzR1BIWU4ybkRHSU9Cd1hKTFoyeW1SV01DMDE3NHBvay9DSVhvNFJBK0hpT0JXOE9nYzg4azNaanl2MStsbEpBR1k5bjI0RXc3WXV0MWVoaklxZmV3T0ZqTzFnRjVWRFhQaS9jeXZOU2xUZHl2VCtEK0ozQ1ZGNU5CamZSYTg5M2RoaldheVZPN1BHZXdHMkV6WWRaeFI0UFRvcnB0NGtiL2VGc0hHRk4rekc0MElnUXNHakZZdFR0TGlKQzFPMHE0UVlLOG02OUhqUUxkZTZGNWcwdkNneTlxdHIvRDlFamdYaVVwNE4vNWgvSnZkZEQ2OVl6YzNOTDZUcStmdjdIeGN1WUUreTk4REs3WURWajloUHZhcnNtR1prYzRYMEs3Q1V0N2FiNktqamVqNG1CTTFiQnpvYUtFRWVnV3ZHUXM0RFJ0cHVVRG5hNm0yRDBvM3VuWE02YnVpcEkxYWp1YzVJMUlCYnRLSklvMDFDN2taKzZBaVFNY1MvL1VMa3NUYURTRnFad0hKOUZNYzc4MVRIbmZsR0k5QTE3QVVRUVpMR3c0SHV2Mk9RSkpqOGRWZDB1RVFQb21mUHhTLytDSjl3R0VRZEJsMEczaGF0NE9WZmJCaWVGVzljRGY2WEptRWFGdlI1NkpEWk84eUQxMlNTUmVtMFlWbU9zOUVGK2pwTW81NnZNQWdtVmlrb2RqcWdVMGNHSHd3czhnWkdXMUM3QmlnWWRCaDRFbWZDRVFSZkIxTVJyTUFITzVrd2VxUTBRVGpYeDRWdXg0VnV4Njh3QUhvTkNGMlRZaGRreHRPZ2JWZkJhd0QvSzVLTEsyc2RHRVliNVNWbFd6UDVsSk52eFVma28zY1JVV3J3NlV4R0hsRG1nTk1xVXR2c0xxODZDTGhBNkYyc2U4NFlDVldCTXFxY2ZGR1FyS053V3p3QUFDL0NXOE9NQjFLL0NWOW1rUlNmZkdyVTBzaTBZVFB4M3kvYnA5UHJiV3R5cXhmS084NUJFR1Rwdnp1NThxa1E3Uy9ReFRGVERyNEtWb2k2UVRCUmZPUlBJSzc3c2FSd3k0RFYxNCtVTjlRTmxFWWRmbjU4T2dCTnd1TktyKzJNZ203VGZiTjAxQkJUNm5JMjgwZ1dYb09wWVpEcWVFMENWbFhJeDFZeStsTTNFWHpja0tzR3VaTWEwU3ZGU0FPSVU5OVprdEtQZnF6YVA1UFltZ2RJQUpodjhKT3JVcnYzVXJvWjNTSUpwczNaTkZHOEZFWHh6L25MUHpHK0dMVHFMeHliaDJzMFFkcmpMSzR3aTdaWW9JMXdxYVVldGtURWZIOXNWVkc2Z2xzRXgzRVQvaUI0a2lSTTRsWllwSEl1M2lSQ2dMZEhCSHNSS2ZWYVRFTW9XR2VKem8wS0VhYXBBZERUU2IxTEExVnZBbmgwMnFwSmhHMkVQRGxEbjRMRWt6dU9oSTJzdWFLalVTQ0JRS29NU2krcGNXd3NoRHQ3T0FIWFA0MVB5VE9DVVNjZTduZ2thRHc5aVBvRlV3QUc3ZGFjSU0zazB1ZWxaczBFb1V0ckNSb1dMRFY2SHdvWXBTWUZzdXlVeWVmSldadGk0anBWbGpvY0t2VmJEZHZpOWdscjdYRXlsbU51ZGVxd0RiS0pmWk5YNnRSbnM5bEYwSkVmZGFNMVRxRVVvZnFJS2lqT25STFB3dGRjZFpnaTlpU2pFc0VWQTJkVU9ESnVJVFB6OTZJRkpSSitmbVNuNzJnOWRxMFdrM3lneUYrOVU1aDFsdmJmMHliYU9qdFE5c2UvZ1dkc2ZNZmMrZlBpaXg5NHNtT3ArK251Y0VBRlZmc2JsVytzelZQR250SHc2M1ByVVpzN0FKTlAxNDhCN3ZsYk5ndkI0aUJTaHJlU1oxVzU3YUlOVjNyMFh1MlJmU1NRSzZONXE1MnE0Nm9HeDBkRTZ2L0pHZkNrTnVkcStIc09OMk8wKzA0M2Q3R0xKVU5UUmFIakV5WnA1N2JJOHgwbGVlcVlxRGJVZ0VDOHYzT3hGNDVWR3AzU21DbStlNHZwZng1R2pwRzJMbFRXUExaTHo2ODlON3JzMzl3MzdZZlBiNzJ3VDFidDRybjRxMXZLT2Yvb25RcHIzTWpIcnh2NzVuWG4zdjVsOERicmNBRlU0RUxuR1NOUExHWnAzcHJocFV6RWllNExTeit1aTNDcGJOdzFMYUlUaUplMEdmQWkwaENJd2RMbndPMkR2dU0xKzQyVjR2NFdabUlFMFYvanhBVTJqZWdjakRRNHlXWUdvUHFYNEplWGo3UWxwUU5JS3BMa3FCcUJkKzY4T25mSzEvUnZDL1gzakgzTzk4L2NmU0oreGNHYjZEWmY0clRVT251eHRNL1BmQldCS2tJMEFpU1NzVkg1VXFyQnFpWXhSaWE4NGdlNUdEcXREaU5RRk9qWkNVMjg3WGI2ellxSmpqM29zcTVGK1MrakhOejNRaWdHd0YwSTREdTFUcVVEcDBGbVJtcHJldEp4Sjc4M0UxRVZvRWZoa1JVbVpoTEFBclU1QlBrUzVCU2tIWUtjei8vajc5UTh1N2JyVURQblNzZWV2NEhHOVkvdCtjNGRaeFhhT2t1YnVubFB6MTg3L04vZUhudnllTUpxUGtQZ0laMmtrRmUrSWxWQzBCck1MTFJ6MmdaanUrR3dFeEdNaklFcTE0QUhrNjNwZ05IUy9lQmpVOUhvNDdrMDJySmFnZDdhd09ZY3FqV3pLR2FJUWRhTTNURUhBNVBCdE5ZRkJHVzhFTlhteEFOSnR4MW1ySlJIcTdaZ0FVK0s4VXczUFd2SEZnd0R2MTZYem9TMk5tTkRidXpkd0dpUXN0L0VPOG54SGI4ZVBQYVA3NTNrVnBQblBqRGJycDI4ZnluSGZSM3p4MmV1Mk1xZGNXL29QMlV6citVZmZmeFhmZWo1UzhERm5oU3c0RkdhejlFSkVEQVFIeWo0SVJlblVrMG0wM2JJbWFyblFQTlJRRmdaTTBnWEdRaUp0R2lSN0QwQ0pZZXdkSzNHZFNkS0tzVDI1WlBaQU9MejZVN2crbTBwVWVNTGxTS01Xdndab0pYdml1d3NXQnFEWkliZ0hFNkU5OW8rTXRDN01XaWkzdXlaUER6Rnk0ODg4SUxoemMwRkltVFBPODl2ckZ6SXo5LzQ2Nm5YclFqUlpVY1FRS0t1a2srZVUyV0RBTGxyUllnYXkvR3l6cDhwY2pjaFE0R3BCWGpWNXdXUkRYTDREZjdBY3gwbDlXWjdjamVGb0U5cWpNai9Ub250VTB2cWhFUUJJN3RNQUlJdDc2MzRNV3BYcHpxeGFuZTFSSlNXRUpHbDVEUnBXRHZLNHplUTNPN1FzbUE4bFZhQzhtY2VNZENibTNKbDN3c2J1bTFxZXd2MlpIOXk2NWwvL2labDc3NzQrL1RwY0tDdi83c3M4dnZ2eGtGSWZqQnNrZWUvOEc2OWg4M3hkOFl2ck9WYnBuekNyVjlRa1U2WU5kMzQyOCt2SFRQQjc5ODd1UXJ5QVc3Q09FdmdnNndrWWZrUHB4RTRVOFNxRlB2TkFsV0FWbmZRSzQzV0ZkaWZVbkp2eWpuTU1sM21LNk5JTFhwdVFUeUZCVjV5a0VXUUhKYy9iTGdXaVZlazR6Zit2dzJDWUZWWTU2QURmN2l6czhYZzV3TEM5K25FN2d4VkQ2ME9YNEVWUGJNbDVWYmdSczJBVmkzaSsreDk5OWpaRC9SVEp0SUxGYXpmaXB2TnZGVHUwcXV0VWx0Wm5WdFpuVnRack5OU2pBczdoUmhDM1NhQUhNZXYrYk52QVBXYzZtb3VycW9YMDJOZitkT1VhZ3FMaDQ4dUxpbytsSW4vbWpCRmN5YVFMZEtTMDEwa1pFdTRlaHlBMTFCcVNucEVWUDBqOW0zalhtNERlTU1JbldLVG9OVlF3eEdJOFZRQVhvM1JNWXZJRTJvV2pBNmJyb3VzTjhtQ29rQWJ0ZEJaajRzRExrSkM0bHZOMXZVWUhJTnVnZHFQSm05eHNNSW5ScE9CamVQdi9pSlVvVW1rZTc1blpKUHp5bHA0cm5PR3ZxdVlrL0FRMGNDUER3WktJTmg0TDZWTHhTVkh4Z2l3VGNWcmlDU2ZZbkozZ2lNQkhTZFM5eFJNeDdrTnBkOGNIQ0VpWTRRYUE2QStGTjAxWDJVendMTktoZmhxL1IwYWhKRVo3cEhNTHZCc0dhN0pZZlZRTzMvMmVQUHlWbjRmQXZzUVd2VGJEalJoaE50T05IV1pzZXRabi8wTWl6b1pYaXVEY08wR1F5SVRvTU1XeEY0a29uMytneHRKUWxiRkFoSUxBenNWcUVxQmY2NG9BTG9Eb1pDTlRYNDNaa3J4RXcwWE5FU1NJU0VDMVFlN3VabDluMVV1Z3NaV2pOKzU0eDdaM3h2NTJlek53THU3L3oxak1leTUzNU1tN2hSeno1eTdQNTRCOWRLaTMreU9kNGhrS2NQTDdqMUhXRHlKSGN4SzRaeWE3c2l0d1pyVW5LL0RVSGYvQXU1VGZ1L2x0dTBmeUczcXRoK3E5d21ZSFdpNEM1N0NrQ2MvNGZkKzdqaGROaWhCeENxWjE5Kzc2VHFqVFFDUkJqdlhTLzdNMlFqTjVyWXQwVkl1Z1pza1VhNmxrcXJld1I5TDdBdFFTTFkyOUgxUithR1lOUVhEWlhWMEIzMVhaMkkrcUl4NHpPK0plcUwzdGJWNzM4REl2aFhMTmJyVENNOXY3UG5tdjZrL0kxbVh2Z3pwY3BmUDNpODQvQmpUenozbkp2bW5xY2N6Vk0rdWZSMzVUMSsxKytPSHZ6TnIxNDY5aFo2ekVxaGdMeCtsY2ZzU1hyTWdsV2orc3ovbnNkc3YzYlQ5Mjk2ekZkWm9LVEgzRTJ4LzhSalB2N0hTKy85Y2s2M3h4emZKdjd1d0xkNHpHaWJDNWx0UnJpM3lXVUo5NUo2ZU5YQmhOMlI2bUNhYlpickRlLy90SVBwQ2wwSGN3RDFYdy92c3V4NjczTFdWLy94R1NXbmZqTVpEZXQ5VzUvZnRYclRjMG9odC9aVmNEQzdhSDh3cVNlM3JkanorMS91UGZHTGhHUnlSMkQvS3BISUlXSUNsZDBiUWRZNmRWWkNESnlGdlI0a2RzTzE3OVhidEIxZFg4a1dEQjloQ0Vnclh2MUtNSXc3dlpPbHBjR2FwSnZVTFZyTVJUb1NHRHZqQVNDTmYxTkV6dU1uK0k0L0YvOUdJRy9QWG1KQmJURWRmRjRyVUtHWVBDVm5hQXNvbjA1NXZZbnE4ZTBRNkkyQWhFdTBJMzdMc0dXb1pQNVNIMnVPa05iUGxaR1dzUzJTSmhIY3hsUGV5Rk8rSDc4dDBpL2Q1ZXFUczlwcUpYMVc0eHRDRm1Id2lpVWlKNG9sQktsQnN0VFBLMndzK0lxUjErNnc2L0ZFMkJVYUdHOWxYZy9ia3QrS0FWZkErMzhaYnAxKy8xT244bXR1NmovMGpucC83VjBQTkt5WmNjLzNpa2VXWldkWE5vYUd6aDVWV0RkblMrUGorYkZwbXdyRFJYNkhwNksrZWREd3V4c0tpbmVOZEJhVWVmdVU5ODFMeTZ5b24xQTlhczdJWG9paFFOZFpicFVZQkcvNFhua1F6N2cwTGMzTzJYRkhaekJvTFJvajdKcTNSYlJBUkROK00yUUc4aGwxMTc1V2FoUFVBTDZndmtzVjhOc0RZeUptbVhSL1M0UEJRTkw5UThQYnZhMERMT0JuTlRibStWYXdieVhZZm81Yk5mQlc1YXRZYkNmbEZHWFkyT3ArQmk4dDRpWnZ2RlNtL0hwai9HZDNOT2V4ZjFjQU5QNFlYQThiMExoOGhJYkNIMjltaExYeTFLU2hUdDRrbWxEbUpLdk9TcThUdGZ1czFJckI1RVFvclZQOVNyR1RDWnpWNnJqMjg1UTJyYUU3U01zeFZuVmNLM0JYUGlkSXlGcTNTU1Rxamk0UnAwWGRBbHU2ajNjS3QvOVcyZkxNeGNXUDduejZNRDNBUmVNSGxTTjdIK1RHQUd6QXhQenJHTmNoeTJUekV1WklMYUowb1VCWmFOYUlJU1dCaFpqWUM2Nk1aRUJvSVd6YjJPZFBSaTNQT1htck1Sa3VNaElwOFpHY1dUQ3BvVmIyWW9JSHlyQVlhMm1BZlVjZVp0SFZaSWl2WjJpVmYxMlovcFJ5N3dFcVpHc0ZRem9JRWVra0FvbTdtd2FQcnViUXU4SGZ6b3JCbWoza04zTDZZZzlkbEVZWG11Z3lBNTFQYWFXZVZwaW9CeFdia2UwWjJhZElCdldjUS84RXYyTktROHlhMkI2THZjZkRGbXhuam1FVU00MVp2V1F3MXBUNG9nMWNTSFFvUGQxWU1TVURiMi9KZmhZK1plaXdzcExUV0YwT0Q5RWFqRlpEendCb2Q4Q3pPOVpKQXQxQnp5dWhUdldyUVB4QWtLSEVrYXpGbUhMeTJiZE5nc0RiLzd4VGVlMzVkd3lDanJlZWUrZ2RnNmpqckc4aG9yZ1ArcGIxQ3NkOTBGYjg0YUpTbm5SMjVsZjBMdU1GTlNiTmI0R1dnM3drTzVZNTZEd0xYV0tpOHcxMEdVOFh3QjRqK2ZXZUJmRmhTcDRaOEl4UG5qRmNtVlVwTktrMWUxdnVRR09KVzNDS0JaRlV5NEk0eFUyOGJHT3Z6eVgyWlFjcitjUTdkbWpaTUM2dFFUZmNDUTFlWTNNSVJyUFZTRGl6a2VQQWp1RmJGQk4rVHdoWVJNbnUrVHI4MjJQR2V1NEtIaE9JcFB3V1pUZHQrdGtKUjZZZzlqMTVsTFlvKzM1MlBOMHBVR1N2UzRxR2pzb042dXVWQS9RYnpxQTgzYnVRN2tHY1daUWMvbDNBV1Jyc05nem1ORXJNVk1QUk5HU0VJdmJwUkVJOHZDd21qOXhxTlZrbHhnWVMrQWo0Q2M2MkNKK2xZUkppU2NvUDFSaDVVMXBTYU5LU1FwTnV4a0d6U1JVYTB4V2hZZEIyZnlvRjduQ2dKaW4yNnN1SjVMYzRGVmRDNC95N1N1R0tNM0tnck9qZTZpWmx6a0hZQVVrYTBVcjlBcms4U1huWi9EMzcxcGQ1cGZPY3RjWTlnRThIbjJJMnY0cDdTSHlXZVlxVnNvL1lUMFdJQlV6cHFZaEc0UFcxemxONjZ5bmVxcWN1M3AzQjY3c0dNc2RkT2cyT2UvYy9zUHpYLzdpU3JwcjM5SlB6NWovejlMd2hreVlNR1RKNUVyL3FtZm56bm5oeTd2eG42SUZKUStwdWJhMnRuVWpZRGc4RS9QR09zbTlPYjd6Vld2VjM0dEd4bjBsNTRlOVZMMkI5NnU1aFdaZG5kUjYwS29acEJIL3BqNnEvb3dLMTd1bTRRb2oxNjh1ekx2M2FxblNQSk5NYXNTOTZFWkIrQ2I1RS8wUW43eWZQSkNkb05wSkd6UjFrRWJhNW1XUWpIT25KTVhxRTlPWkRaQlBVYy9pY3JqTkNJOEYzQjFqZkNjY3lPQ3h3N0lUamJqaW13akVCanNrNEg2L0ZlNGhMeUtmaUVpb2w3eWtXa25UaElYSkUrSnBNRmgrRDJrU084SitTSStKeU9OOURqbkErT0g1UDBvU2QwUDhLT2FJTndsZ25PYUxSa2NuQ01yVStBZGZKWkluUW54U0s5NUZuaFl2RXJsMkNzazZJTUp2WWhVMzQ1dURiRTNoVEU0UURaQmUvajdRS0IrRUlrbFp1RlNsajdiVmtGNzJBdTM3QTBTWFczcVU1UTNaaHZ4Q0RjYmdPNTNHdnd2VzNrZW5jUVJLQXNVMzh1OFFpdmtyYy9QTWtrLzhRTGN6L213bFU0bXlTU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbjB2NXQ4MStSWDZTdVFGYTZLNVR1NTlkeVB1Uk84a1IvQWJ4STB3aWpoZVRGVHZFbjhxeWFpK2I3bXZPYTgxcU1keC9JSHVoVzZyL1ZUOUh2MWx3MnJETzhhUGpOV0duOW92R1JhYTZibWhlYlRsc0dXMzFyWFdkK1hRdElCMndiSUg5aUhYNVhmZERRNDlxWDFTOXZyVEhjZVNNOU9ud0w1UlBxWHJrMnVmN3FudTg5a3RHVDhNTE15Yzd0SDY1bmlVYklleWJiOGorYXhxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6Sy8xdVpzTjhzVGZ1SVRDY2krNTZUSXhJSmt2c0pFUzJHU2RoeGlIaHA5UUc5bTQ3MGR0Q3FaR05Bc2xHYWJBU1RqZUprb3lqWk1DVWJRckxCSnh0VXZzeGFYYXhVV05uSnlxOVkrVGRXWG1EbEY2dzh6OHF6clB3REs5OW41U2xXdnMzS2s2eDhnNVd2c2ZJRUsxOWw1WEZXdnNMS2wxbDVqSlZIV1psWTJWNVd2c0RLamF6Y3dNcDJWcTVuWlNVcksxalp4c3JWckx5UGxTdFl1WnlWVTFuWnlNcmhyTFJnR1h4Sk9BL292MUhBbjVTV2hiL0tVL1RtOEljZnBidXkzbmtYaW1YM3BudVczWnZ4Njk5QWUrRWlLTzZjQThYc3U2R1lkVmU2WjlaZDk4M05uTDhnelpsMXgwd29icDhCeFczVDB6eTNUVjl6VDJiR3ZQU2xkUm0rSlhBTUNwUEFRRGpDMjRibkJvOEluNUNneUJOTzVQYzd1bkkvZWtuNEJ6ejdJMVo2aFF2N3piYXczQ0djM1dkTUN4L3FPaVo4c2QrVEY2NFpZaGEraHZFSGhhK2dMRkhMTDlpYVA5MXZsTUlsUitsTmNMWVNTenArLzdaZXVUVS9vN1hRWTZWRHlKTndjRjBmSGZoYllRQnVUZVg5ZytzU2RhOCtXTmZzTHdvbWFsY1cxb1BsOUlKQStKTy84QUg1TDBYRllma3ZIdWdlbjVzYnh2L2dKLzExdno4c3YxZllOenl1aVFzMGZjd0Z2REdqT1h5SWNzQklIaTRRN3pRRUxyOGdCcjZFa1ovL2dndkk3N3N5d3IrSEUveGQ3WTlMK3JPYjJEN096Z25MdjNXNXduOTlpUXU4dEFOR2FkdSs3UWFvVmlXcWxZbnFQdGtLOWFOd2JJZEpPN2FKY0p1UGZ2cDVXbnA0eTJZZTI3THBhMGQ2K053MkliQVpZR2EveXozTm5SRytmUnA5YUJ1WG1MQXR2MCs0c29JRUt0cTZjb0hiRHk3bkFwMi9Od1FPMFdwYXRROFdDQ0sxTDdkWEdNUm4zM0s0SnkzZTM4WUgzZ0xaK1FtVlQ4SGljY0g2Vi9MeXcvTExzR0FFNDFpbUIrdWZIcFBzNFpOdjREcU8vZlFFb09XMVYxbGJUcjhBR0RtN2dndVVURFdaTkhWN1grQUNMNnhJWU9CdHE1M2Q0bWp2UHVFajlINnlIa1EvUU5mc2F6ZXdLN00yNXVTRTE3Y0xnZlkyUTJBRHJHUFZmVFN3ZklVUVdOR1dBSGZJVklCdWFoc05ySU5qTFJ4cjRGamRKZ1ErYS90bkd6ZWpqZlp1bzU0S3A3dmM2U3h6MmdjNHJTR25xZFNwNysvVWxEajVvSk1VTzRjVTBKRzBnVGhKSXgwRi9ER0hqZ1NPR1VnSEFhZFUwakN4MEhKYVFTekVTQ3ZKSURnYTRIZ2REZ0Y2eXFHbm5FeUVneWNTSFFqWGFmYnhYYmxEZk5SQWpYQzlqdXJoZWczVnd2V3pxQTd1Ym9SeUVCd05jTHdJeDEvaHVBeUhCa1lNY0NjRDJRQUhUelZ5SHR5b29MZWxUMjlyV2JrbFZHN3RHN0FVQmF4NWZrc3Z2elVuMStMTnRaS2YwZjd3MlA2Z0RQdkRBZ2d0a1ZmU09YMC82c3VSS2lyMWtudk42ZlZrTDhFcTJVeDZnOUdrMGVwTXZDQ2FDT1ZNQlpxc1hBM3Z6clh5TmZ5SFBQOEUrWkJ3VmxldUsramlyV201YWNFMDNrT3p6VzV0cHRrcHVjeDJJYzBjOU5DaXFyNVZmYW9LcW5wVjVWVjVxM0txUEZYdUttZVZ2Y3BhcGEvU1ZQRlZwS294Tko3RzdBMmtZWHh0ekFFb2JSaFhHd3NGR2pwNGIxT3NOTkFRMHpkT2JONUw2WGNqMEJ2ajFuVlFNajRtck92Z29MTFhUWmpZM0VFemNIaU41eEJna3NRYVd0YzhFQWtFc21QUmhuSE5zWlhaa1ZncE5qWmxSMGhEckhSc3pPT3Z2ZTVYenVleEFsTHl2RWM3c0xkUFFYMnNiLzJVV0ZGOTYxQTJPTCtEYXVwbmRGQkQvWXdwVVBxSGRsQmQ0cndWV3Y2aDZpMDY2RURzcmF5ZkFkMlZPSXVkbDdQemNuL2lYajFXUWVmTlh4RDRUMVAzYk5Lai9WOGxlTWE4K1Vub3NNVjZZKzVZRFdENlcyYnYxU1BXRzV0cUcySzZKamdhSjhZeS9YRHlLcHlVdzRuSlg3dVhjSFhqOTNKWWFLQ1lPTEY1aUpOV2t5aXRnbU1BSEtWd0JPRW9ocU1JRGhNY0FodzhIRlMrTWRvVlZhS2QwYStpZjR0ZWlINFJQUjg5Ry8xRDlQM29xZWpiMFpQUk42S3ZSVTlFWDQwZWo3NFNmVGw2TEhvMGVpQzZOL3BDZEdOMFE3UTl1ajdhRmwwZHZTKzZJcm84T2pYYUdCMGV0VVFELzNhS0JQNGI2ZjhBNmJwc1h3cGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqa3lJREFnYjJKcUNqdzhDaTlNWlc1bmRHZ3hJRE13TnpZNENpOUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVUtMMHhsYm1kMGFDQTFOVEExQ2o0K0NuTjBjbVZoYlFwNG5PMDlDM1JVMWJYNzNNLzhKL1BQVERLRTNNbVFEMXhra2d3SmlRUnpTVElCTW55U0VId3orY0FrQkVqNENEWW8vb0Q0VEpRTzJJb3hmaEF0ZFZtZldwZTlnVmNOdExUMGxWcjF5YXZhMnNwcSs2VGFnbFVTbzBWbFFiaDUrOTZaaEFEMnRYMXJ2YmZXVyt2dW5YcytlNTl6OWo3N2Q2L0NDa0FBUUEvZFFJTjE5YTFidWUxek85Y2laVCtBWWRiYUxlczJMYXAvZHgyTzM4Q25lZDNHMjllNlQrLy9BTUNWQjJDczZWalQydjRYc21rckFJY1BGSGNnd1ptaVQ4UDVDemlmMXJGcDYyMmRVM1J4bkw4Sk1QM1V4czJyV3pmOHRQTjJnQm9SNTdNMnRkNjJ4VU1NeHdDNlR1RjZic3ZYMW16WjhPa1VIWUI4SEhNZGV4WThBT3crU0ZOYUhFOEdCbVE2d05pWlJEdjJJTFlmQWtqVHh6NVgxb04wNVBKcW5EdW9oV05EZEQwNGNOMFEvRjJnU3o2TVBQaysvQW5lVXNnSGsrekg0V0Y0Q3Q2Qk8vL3FBU05rSXduQlB3eWtnVlNTQXVKWHh2TkpHZUVueHFXRWd3Y24xcmxKQ3RHQUJKL0JuK0VVL0FiN0N6ai9BNXlIZjRPUHZ1SmdjWktNTGxKRC9PUUNqTUlYMTZ4N0hSRklJYkhDTDJFWDdJSHQwQXMzNC9nek9EMzVET1djVktWTlZ5YmI0R1Y0QWU2QXU1UE1aNkU5T1hvQW5vRWY0Ym9VTWdOOVlhT21nWTJHc1UvQUJtZmhDTWJiKzhoL0VQN3ZvUjB4L05lWTJrNnBnTXhGaTA0QWN3SnNtZ055QkYwYUl6ZWd6Ui9DT3pIWWQ4TUhhTWxKSUsyVmxqSkJzSS9QeDRiSURXUUptWUxyVHNKL3dIRnM3NWMrazNaZDJuVHB3Tmc5WXplencrenZtRGZZRlBweEpnM3VnMWZRbS9lZ3JkK0hFUmdERlZSUVFRVVZWUGovQ3ZmQUQvRnQrZEJZNzlpTFVBL1ROVTU0RWFxaFdvcXdNZmdtZmwvMFFqTTBRRFd4RWpOMGsweDhxNGFoRS83MXFsUGVnWFpTQVRkQkY5UWx2dndRRHNQTDdGSUFZVVZ2ZTFOanRLRisyZElsaThNMWl4WXVxSzZzbUMrVTN6Q3ZiTzcxcFNWemlvdG1Cd3NMOGdPenJwdkp6NWllbDV1VFBjMmY1ZU15cDJaTThhYW5lZHlwTHFmRGJyTmFVc3dtbzBHdjAycFlocVlJekNRZTBWTVpDYTBYMHlwam9zbGY1YmR5b21ucHlKS0FDSGF2ejIvamdvSG9kY2xWSXN1TDRBaUx6dHJJQUFnbFVWSERYNzFrcVVobld6L3o0ZVlsWGk0a010bjQ0NjlwYlJmejZpTSt2L1hYM2dsK0ZQZUk2WlVSbjg4clV0bjRzd2haK0ZQVHlyV0wxbHFrKzd3SnlpSVJhaVB5TXpqMmZna1NvY1FYeGJZK0lrNGRuMGFqWDZYa1lmd3dPWGFWbWt0SjNEcGdTcXVzRXNFNUFLYjNSWERKeTBaSzhIT2tUTXpqVVJFcmpwVFRJQ0FTNTJjaWNZakV0UVJWdmxLRXZPMVV5VmZZSU5TKzNoOXE3MFNMdHNjdTIzUWtZVkVmRitmaTlSRmJFSWVLMG1IeDFicklnTkZRNmE5Y1kwQUNLQVFZTUJpUllwUUplTVNXQVdLNmdTZ0R5aFM2Zm9BQ25Sbk5aNWZWRGNuUGVsSFlIY09CdndydGhoekhaYzdnMkxFOWsxbUEyOFpIanNRb29ZU29xUlMxQ1NXNFRsRm9GV0UzTnpEeldIelBvQlhhWXJ5cDNkL2UyaHdSNlZaY01BQjBkcWlqUVp3U3JtMUVFb3JDSjliQnllNnVVaHJaZVZ5b2c0dmpYRjRidzlaZkpUdjlDbnA3eDVxWUhDWWs1cTlDbnI0eWNwL3ZtRmUwWXg4U2JieG94bVhtTy83b3BlTWhUeWNuVCtQeCt6anhBS283aWV1VFd3d0NENm9lRC9sUkdoNFdXbDhodXlRdzRUWWxHaGUxSzg0UmRyZHlZbmZiK2tUc3RlNFpqMzlmM0NxYXZ2Q2hkOUEvdUZQWm1EUmxlMnk5clBMNlZ2bWFvZlZjZlBjYTVhcDdsS3RodkhLaDlWWHlJMi9FNkljVnVMc3hFdXJ3aHk0THhJdmpnTTYrZXEvUEo2Yng4c1o0UENTcjJOcU8yaWRVUnNabC9lV2M4UElFOWFrVWhRYWxnd2JGQnloUmFLMktKa25KQlkzeU5wa1RxNHBHZlFtLzQxSlJtMzBmTzh2UHhlVVR0ZG1pazdmNmppUHYySFV6dy9XUlVKVlh1YjFJVlVibURYbThRemdPMTA2UWlRZlh4QU5EM29TTndzdjk0YnBFRkhTTU43R0dSQUpURTU3SHBjbjF5cWtuUE40VE9LNzJWOGZpOFdvL1Z4MlB4VnNIeDdyYi9KelZIeDh3bWVKYlFqRk95WHlDOUNPN3ZXTDFucWhvalhXUTY5SEpjcnhWMTRkRlIxMlQ3SjVxcnFNMVVTeksvYjRTcjg4V0hWOVQrOWZZeVR6RGlNZTRsL01zYmoyTHVwbXdJbm01YXJtOERHSlY4SXJXRWpsTlVaTVZFY3lEMVVyTUtnM214M0k4M0N0bkNoM05EblV1VHhvSW96RVpNSExkcTB0UzhSQ2ZUODZoM1lNQ3RPRkU3SzZMSk9ZY3RIa1BnaERnMFhjeG1YTnNuT05hSVhPNnh6a1QyMk4rOUpVbnZQeHZ4UFRrZUk3Yi9IYXVOS0RZWHltMzdlS3hCcnpqK1JKUlY1SjB0Nk15UW51cDVJankwdkxJd0dQNUtoUGR2TEpSdGdsV3lialZ6NzNwRjYyOHlGWkdqbm5Mb3B6Vmh1V040SnFGdkp3MVdFWGY5TDlHNU5vSlRxdEl5a1NTS3RNQmE2bFMwbWwzQ1RJbmdvY0x4V1BKNkpwOHJlUUxvTDNqcSsrR2E2eCt2SjQzc2Q1bTk4czNmRU1wYWNsS25WMHQ1NUxYbDFoUkV4VlQ1SG9zcHB4Vkd0VFhXeG5oc1BwZ3R0WXBBeTdFZGNqT0ZybFlsVklHb3Q3SjVNR3hVN0VxdWV5aHl2SVNiektzc1UyWTlzcFkrL3NqdkJzai9PNDkwUTZNYmxHWWdUZmdpbENza2kwTmthU1ZTcnpKTEpKbExaS3ZjaVYvd29yamE2NjFicmpoaXRta2MrVVhnZy9aSlJPNTN4QVJxL254b3hMekJieDM4blRoVmV4RjQyeEFTM0MyUmJKUjhmMVQ0cjJDaHY0VkVpU3NJOXU5ZDhqdkU0cFVEUGpKcnJvQmdleGEzaGpCTjF6RllTc0F0NnNoY3BBaVZHV3NJam93RGZtUnd4eCtEQ2xVU3FiS1JIbkN5Uk1JRXp6eElLVlQxbnNQQ3dEZENwZFJDTXA4OVNBQmhhWWJweEZZUFVnbGFOYUVvQnhGa0FBVWNwZ0VSeGhmelNCTmw2QjFLelFGQmtDK3YyQmdCWjJnRjB5VW1mSU9FSmwwRUNsSENJQ2V3Q0VUTVJQdkFPNnFWOGlEcEh0QUwzZ1RLN3B4aFpEUWNOZUt5NkpYTkVZT21RQzNLUzBLcXBBQnpkMk5CcS9GWEVJWlRlSlUyWW40ZVNWeTZhOTU0MWE1WEl0UlhpNXBmNUxyWUNlR3lVQTIyVlU3K1U3Tm9qTmMzK1FWU2ZRNnBEMER3UFN3dHdJTldrZ1hqRnBDTTBDenJKNkJ3QWw3YWVBRWR1VW5DdktETnA4dDIyZnpQVVAvNStoTDFFdVhhdGhiTDhRZllwYmlDYzFqWjhndkdCTVl3UTB6QlkvSkxqYVpIQm9RbXpRdVBXM1I2OU00Uzc2RnNnUmE4RGhiMEJhRUFBK2VjcjRnbjJUbEZNMHVEaGJpRjZxR25qUW05cVVkRzJycjFuVTJKSHZxcDZ1cUZ6YTNMRmpVZkdsYUxERnFBZlJlemRnWjVsbjJJTGlnUXhCb2c4TkFtV0FLVURUamREb3B4dVEwVWFDMzZpa2o2M0k1S01mZUtPVUFJekhTUnFOWlo5NGIxVEVZWmNaOEkyVTB1cTNiMmNBUTZ0Y1NERUE1YjRPZ0o3QnFaVXR5aEpyaXBLVUZWclcwWkd2OEhOaXM0Q3QwMjNMOFdScVhNelZZT0lkNTlvbEwwa3ZTdmVRNXN2enRCeDRZZlAzOFI2OGNmU0s0bVBTUVNoSWhMeFJKcjkwb25Yenp5MlpBZXowTndPNW45Nkc5clJBUXBvQytMNG9GVk5jWFJkTnY1OHpFYkxicmQzQ1FqMHNETFlwU1E2aFR3bVRvQms2V1R0dUNoZmpobitOL21veFNvOUlxNlR1SEQ3ejl5ZEN2MlgyWFF0S0F0SVhwRyswYVBYbmlZOWxLS0kvK0E4clR3L1ZDRnNYMlJTbEtwN1hyU0Y5VVJ6Tk1RaEFZS2MwT1RwdXZwYlFvcm5EQ0VpZ1Z4N0t2MFBjSnBQOGdhY2hiVWtBNlNzOWorcVFEMG9WTHY4VFRFM0l1NElpRkxrRlBHTHlQbmFJQjN4dUhiSm9sU205VitnOFBwU1I3YzdJM0tmMnBROFprYjBqMmVxVS9KcVRvcHkwRTBESTdPSkpQS0pLd0NqOE9VQzVieHBkUTdzTG84NlNTY3JEN0xtNU0zaDMvZzJjZmVLRlk0SEtjeFU0cTEwRHl0TVJtdDlOTU91d2dKTU5odG5aenRud2JaY056UytXckR3Vkw4VXk4TS9wOE9ySE5udVBYYUltUDVPVDZVMTJ5RUpMcURoYlBJVDZ0UnZxSlNaZm1sRVRwdlBSOFNxYmVMUDJlbkNUWmZxdkdPNVZra3hOMDQrNW5lNjRmTGFCL2x2dnRYeDBZUGNQdUczMXg3YnB0RWJwV2pnT01YdmJuR0wxeTNrd1gzR0RmR3dXSHhyUTNxbUgwMnprWGNiblNMTnZwd0ZVUndDYkNUMmxKTXY3a1NLQXA2UTNwTGhJbklSSWtkMHJicExlZmYvWFZwLzdsK0kvU3lGNVNRUnJJMDlKTjBzdlNpMUliOC8yeHQ5ODUvK212M3pzdld5Z1Q4NzlQaWNickJEZHRKNndHSTBSRG94ZFpha2MrVFdoYXI3TXBLZ1FMQStQSlVYNDVJREFFMWtrL2xEcVpyVXpmeFUxTUg5SEtweG93eHBmaXFVWW9FREp5aldRT1RVcUFHTFVVVFZOWlVBaFVEbDFNWTlpWmFTd0pBVXl0QU1aWmFjTGtlclQxdUkzWnBaSmRlbER5a0diQ2UxaU4xa09tcy9zdXJFVkRwdGZkVUZsTHY0K3k3T2pqODRxUEZ3a0Z4VjVTN0NTNStHTW1PVWFTWnlneFVFVjZrcXNqSlJUSkpYTUlOUjMxb0EzSnNNOHdLdkpSZkVMMk9LQU9OUHBibzZWUkYwZlMzNG5lb1QwdjlVcjdoaDBNbzdlZGszWkw5NUhXMTgwYURaTkdHTkw0c2RuQU1MWlhaQ1hwUnhkRzI4cEhPMURaMEx4MVM1cm9sMGZuRmExWlZrY2ZsYjFmT25hR1BzbWtZZTNLaEwxQ3RVN3IwVko2VFpxR01xYTdDZTBtRnRyb1hoQUZvOVZJbVZsamhvTzQ2QXcyNDVFb205cHJzWmdkNWtlakRxdkZtQXE5aVp3Z1BrdjZ2YnJBVUduQ1ZaZkxHQjhSSEptV2dLWGNzc3l5eXJMWnN0UHlUY3UzTFBvV2IxU09KOFdaNkY2c2J6eklSUzYvZ0t4c2dSYWZyOGl2OFdOTnRtWm56L1puYVl1S2k0T2NqUzNTSmdPT1BpbTl3Nng3dmYrN3BKV2t2dlR5ZHlyK3RKSzhKUDNteUw2d0VOM1M5OEp6OTVNWnM3S2YzVFNjTlZzS0h3OTVuTnVLUTNmS3QxNklGVHNEYjIzRG1HOFI1Z0JMZ0NJbWxtVnA0aVpQUnQwcE92ZVRDL04xOUNOUlhXcUs4OUZvaXJWY1F6UWFZcnVYcytmYkticzl6VTE2aklGRWhScXlZWk5NREd3Q3ZNME9wWEs1bGk5Q2ZLbSt3amt1dkFRVXpZWmdvZDBsWDBTalpUSXV0VnVKL3JudWIzeHdYaG9tZWUrZStsejY3Y0hGbTAza21mZHEvN2lZT0w0WUl6T2tMLzQ0NzNjN1Zpb2FTNW5NemFoeE91U2l4ak42TlJvZHJYczRTazh4WjF1eSs2T1cxRFNMTzlPVjJSOTFXVm0zeDB0RGo5RTRuYzI2eDQ1bFJLNGw3Z2xYbENlN0NiL284eldDcGxZVDB6RG9qZnlDYkV6cnJGeWJrcytLOWFraUt5cnVEaGI1aUZ6cXg1T2R1UmxmTlQvL3hlMVBmdnVBeUd6ODVmSFRCTjc2UVF0RHlxUlh1NW83Yi92YTZyYmJiNUUra0g0K2x4aWFuOXRiOXdKeGZvaVJXZmpBdGt0bjYxcS8vblIvZC84amVLL05tS2EvWmM5Z2hsb2dUMGcxdTFJc0dsamRwQUU5cmFkTlBadzUzMHlaTDJjOTJyajh5amUyUTY2RTJiVnIxOWJXclZrVGxvNlRNdWFwVmFFRmpZMExGalpmWE1uSVZhQVhhMHViNHUwQ3dVdjBMb1BGeEZnWU5Kb1ZlZ2h4bUhROW5ENWZUK21UcjV5aENVTUZsWG91KzBzcHVLNmdISDFNbS9TejUrdlhLNUp1ZnBjMFVLWERPMW92NFNmTlV6K1FHaFBTYUI5angvdmdXMVhyMGxrTTVmajlhTFltVTkxbTBQUmNmc01sUXVkRVM2RnlyWnpKa2dyZHRLOTA4YnF0aXFEd1R3dW5VQjlrUHZMUGtwdUJINzFwUWprVm1Ma05lS3RDdUUyWXFaMXB5MkpTQzNvSllRcVlSNk1GcWIzcDZSbXBHWTlHVTYzcDZWa3pleE1TdGJOSlZvOHRNSFI4UEd3blphZHhjL3JPZENwZFFLTXM1aWVscGN3enk4a3RrRm9TSTF1SUJwa1k0ZTdTL0lJNXR0UkUyWjlGNWM2aWkyYmZRS0ZQM0s0Y3ZFY0s1WEpPcGR4VGFaY3poZkpuVlN4OVBOVFFPak5VbnpPdnBkd1gzdjd0ZjZyYVUxWDI5WXJNT1RNODA2NWY0QzlmdXloMzJUM2ZiWDdPU3lBd2ExWmdhdDVVajhWZFZOMWNmdU5keTdKZHpuTit2OUhsYzAzSnkzQ2JVbWRYcjV6ZmRIZGR0dXpiNldObnFCRjJEamlnVFNpeDBKazBaZFE0NE9Hb3cySFRVcmIrS0pWcU1HaFRORWF0VnZOd1ZHdkJVaC9BVERacmpEcExEOGVRR0xPRm9SaXMvQmhnR0dJdGdmRTBrYjhRUFlIeVpDN3ppVzh2K2F2TFp2TVhCWXV5YlVHWDMrYkVieTVxcFBwKzZlQXp6NUM1cDAvdkxDd3laWk1tOHM2ZmY5OG92ZlpucWUxQWhxempMVmh0NmpFU0UvSG5vazJzcVI4THFGVm5zU2dCYUxnY0VNcHJIOHFERSsrM1JBVkVxVDVaV25FUnZ1bnFwWit4dHh5WDlwTzVMNnhZUytidS96NzVIclgrMHNHVDI5WlNOUURLM3psZ254eDhaZVBzZ2xXV3NzL0JxMVArTis3M1BpLzdudHkvdTdsNjZzVU5vOSt3U0liVnVGYXZySWZFUHQxVGx5UUF5N21MR3k2OFlaRW1PT1BReU02UXY5TkIvbk5kb0lvU1JQb3orREg4THdMRlEvUGZXc05JVU1PZWxyK3ljRHc5MFYrenhnMVBhNTlOOERRMnFMbUdMOHJmSUdpNkc4R2dNMXoraytYL1Z1NVNLSjBZbjRPRlRBTXNIQjhydWxmTDllMnFQYitSSzhSbG9BUFFTL2RDQlowQjA1RjNDNmlnZ2dvcXFLQ0NDaXFvb0lJS0txaWdnZ29xcUtDQ0NpcW9vSUlLS3FpZ2dnb3FxS0NDQ2lxb29JSUtLcWlnZ2dvcS9HUGcreC9qeW12d01Id0tuNUxzU2JpWkhDVkhLWmhBSHJHVit1RzFTTTlKNGdPSW8vUW9NMnNDMXlUeE1YWUtleFA3SFJWVlZGRkZGVlZVVVVVVlZWUlJSUlZWVkZGRkZWVlVVVVVWVlZSUlJSVlZWRkZGRlZWVVVVVVZWVlJSUlJWVlZGSEZ2eDlCK1oyWnpvY2hLUDllVjVCL1M2OFZBbkF2RHQ0MktMK3o4c2NRWUladzBUTG1MTFlDODdHd1FtOHVmZTlVcW52S3I5N0I1czY3VXIxMzNwWDIxdHM0dm5VYk5wdTJZTE54TXpZYmJrcjFicmhwNTlmU3Q5N2lkRTFadHg2YnRaM1lyT2x3ZXRkMDlONmNudGFWZWtkbG11OTJmQUx6VGN4cENMQlcxT0FVOHlXS1NyUWNNM0xJYkNzVkJwbVBEaHFkcFlmSGpqR2ZIUEptbFpiUE56UG5rUDlONWkvWTVpZmJUeFFWUHp4a3RKYVdIeVVWT0xPUStYQ0F6QmZNMVBrdktmN3pjeXgvN2t1R0h4dzdkdWhMdjc5VS9vM29HVjg2VWtzL1BFUHpaMDVUdkhEYTRTcWQvUk95L044cHZoNmZxcU5rTXpUZ1E1SE5aT1BCc2N3TlB5WTNBU0dieUFaVWxDY2J5WWFETkI4K2dsTkNkZ3BWK3huK1c0K3gvUDdIR1A3eHh5aCszMk1hL3JGK0E5LzZCTU0vMFVmeEQvVXgvSU43V1g1dkg4MzM5YnN5cmF1NTFkU0NKeW4rMFg1TDVpUDlOUDl3UDRYS25SSlMrclB6U20vc0o2LzFrNzk4b1ZYMC9jTHRMVlg2RkV2cFlkSkpPb1FaTlA5eG5PRS9pdFA4YnV5L0h0Znc4UjQ5Zi9kT3duZnZZUGlkK0d6Zm9lVjM5TkRLbVhQYlBHbWxiVDJFMzRYUGZmamMyOFB5dlQwYS9wNGVMZStkNC9JVXUxeEZMdnRzbHlYb01oVzY5QVV1VGI2TERyaGdsaXR6dm9rc2d3QStGS2toWVhCQkxWbU0xdDFDYW9RQUdmblVNdnhKeXRtaGxBM0R4RGc4ZHpnOC9JUGhpOE9zY2FScFpQZkl4UkhtTEQyV21aT2JrcGRyeWRGNCtNTmtMVmtuT0N3eitKU1p2Q1hMbnpMTmI1bWFtY0psV282UVZ0Skd0Z2lyVEJhcnphUTNHRTBhcmM1RU02d0pDR1hTMEo1TUMxMU9MNlBmbzVsdndYdEFlVW1HMmFOTk43dXNick9kY1pvRFhqS3piRVpaWGxsTzJiU3lyREt1YkdxWnQ4eFQ1aXF6bDFuSzlHV2FNcm9NeW1xRERVUzBoeUhjVUNFNjhDcmg1UlZpa0E4UDBseTlXTWlIUlgxdFUyU0FrRzlFa1NwU3V3WUpOSWpNcmtFS08zdGxZMU5ra0tUSjdGN3ZZZlE0aU9GWTcvMVJuczhRMitWL2NhVTdJeW9XeW9NSE1xSVFGZ3ZyUksrL2dyOGF1cFNtNnlycVFGNU9TSndSYWhWbmhtSlZ5b0t0NHRtUU9CTHFiQlZIL0ZYaWNLZ1RKekZ4MkovZzhwTU9JUHhYQVhSdHZTeHZrdkN1UkROT3dHbVhvazNYVm14RmoxaU9OcmxXNmE0QnZXeWYydnFLc0tpcng2ZTJTVXozNCtSVm5CVGp4T1N2d0hyeFg3Rk1NODhLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ281TXlBd0lHOWlhZ284UEFvdlRHVnVaM1JvTVNBek1Ea3hOZ292Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsQ2k5TVpXNW5kR2dnTnpBMU5BbytQZ3B6ZEhKbFlXMEtlSnp0ZlhsOFZGV1c4TGx2cTMxUEpaVlVTS3BTU1lBVVVKREtWbEFrajJ3c1lVbENnaWtpa29RQUlhd0s3VTVBUUlXQ3Roc2F0SWtPVGJmZGpqTitEaStvVEtDbkZSUjM2VUZiSGJ0MVdseEFVSU0wbzZLU2V2V2QrNnJDcG43eitmODdKM2M3ZHp2M2JQYytrNThBQVFBZHJBY1dyQXR1WHVOWjhPTENzVWg1Q0lBNXZtalY0dVVQMXMzNUFJQmRCcUF2WHJ6c3RrVjl1aHdyZ09uM0FQYWRYUXZiTzFudGg4VUFuaktjVTlLRmhCU3pialMyVjJFN3QydjVtbHNmK2NyYWdPMmRBQ05QTEZ1NW9QMmp1ei9aQWpCdERiYkhMbSsvZFpYck92MStnTlc0SGs2NmFlR3ExbnNQL0EzYlJ3RzRPUDg1cEFMd3ZlQWF5cmtnMk9FM29BQUhsQUlRUHgzZmNqa0hrRWZHdjFMR2czd29NWkk1RmgvZ2Z3c21aa3I4TXpZQ0poejNHZll1a21kaWJRQytCL0svRGRXMHljUWxtdnVUNU8yd1RTblhZZG9HajhCTjhLTkEwb2dXZmpwOEIyZmhYNUwxczNBYTNvQy9LL1VCckw4RzBVdmpqc0V6MlBkN09BaDltRDhITDJDTndtclkvYjl0UVhLSUdZc3Z5Tk1rL0wzT1B5QUNYSUJUOERCY2o2c3Q1Ti9sMzRWSFlSa2NnQVd3RC83MWlyRmZLUG1YbU82R1crQmV1UCtxbFhxUzViWmsrYnlTUDQzcFBjWUUwMkVOMnQ2bmw0Y0xQanpQWmxpcm5HRUpuTVQ5OXNBT1JaODJKaGRzTE1TL2dNZmhIdmpGcFpWL09yeUY2Vm40V3Y0UCtUeDBJbTZITzVtdjBUN1FzTG43NC8rRFBMWEF6MkVUTE5Zc2tjZWhsTjZEZjhBZ1BJbWFmaEUrZ3FmUUFyZkFDdmdLUGtQNVB3RzljRE4zREd6Q1htcE5zVGljZ3hPd0U5Yy9nU2Y3STd4T1ZwTnA4RHU0azU4cE5uVzJ6bzAwTmM2YU9XTjYzYlNwVXliWFZsVk9FaXZLSjRZbmpBK1ZsWllVRndVTHg0ME5qQms5eWw4d2NzVHcvTHhjWDQ3WGs1MDFMTk9ka2U1S1MzV21PT3cycThWc01ocjBPcTFHNERtV0lUQ0t1Q1JYVlV0TnQ1UmUxU1laZmRVK3EwY3l6anczSXlDQjNlMzEyVHpCUUdSMGNwVEUreVZ3MUVrcDlTMTlJSlpGSk1GLzdaQ1pFcHRuUGUvRnlUUGNuaHFKeThNZjM3VDJUbWxFWTR2WFozM2JmYWsvZ25Pa2pLb1dyOWN0TVhuNE14Vzc4R2RhdTZkVHN0WWozZXRPVUtaS1VOOUNVMy84d3pJa1FwazNnbmxqaTVRMTFJeEVmb2hKdE9iNDRXdlluRW1pMWo1amVsVzFCQ2w5WVB4UUFpY2RkcTRNSkFoTEkveklpQlZyeW1vUWtFaktlWWs0Sk9LY2dTeGZ2UVdkZHFMc0IyUlEwOW50cStsY2doTHRiTHNzMDNNSmlYbzlVVSswc2NVV3hLckNkSjMwVWtOTG4wRmY1YXRhcUVjQ0tBVG8weHVRWXFBRVhHSlZIekdXRTZYQ0dHdkc5ekdnTmFINDdKVGRHcHE2SlhGckcxWjgxU2czN0hGYzd1bVBIOTUyWlJmZ3RLR2FJMUZMTUNFSlZaSW13WVJuaVNTMlM3RFYwemZxY0hSYnZ4VTYydnpHVGw5bisvVXRFdHVPQS9xQXphdnBhcEl5NitybklnbTN3dFRXNWFIcXJsWXlxanhQVFpjbmltMDZ0ZzF6WHpWVitsWDB6cTZGYmRSTVNKdXZHdnQwVlMzM2VnKzdKVHVXTlpMTkw1bHdtT24yajkxc3RNYTF4RU9iMGVpOUhta3ZzbnRGcjVmbWFBUXVaRDFhNDhQZGNMR2E3a3Fxa3NBbHRTbldPTFZUVVk2NHRkMGpyZS9vVHRoZSs3WWgrL2RHclpMeGF5OXFCL1dETTVXSlNWRjJ0blZUbHJ2YjZURnJ1ajNSclF1Vm8yNVRqb2IyNnFucHJxYUpUa1RyaDJhY1BiZWxwc3RYYzNsRFBEaFcyTHhyNTNxOVVycWZUb3hHYXlpTDdaM0lmWUpsN0xqTVAvVUp0NThnUDFXUzJLUVUwS1RvQUhjVTI2c2pTVkp5d0Z3NmpmYTBWVWNpM29UZWNhaWt5YnVYSCtQelJPbUttandweFcvMUhzVyt3Nk5IMVRXMjFGUzdsZE5MVEZYTHhBR1hld0RyZGZXWHlNU0ZZNktCQVhkQ1JuV3pmWFVOQ1N2b0dzcmFtaElPekZ6U1BBNU5qbGRXUGVaeUg4TjZyYSsyTFJxdDlYbHFvMjNSOXY3NCtnNmZ4K3FMOWhtTjBWVTFiUjdGOHduU0QyMTFTN1hiSXBLMXJZdU1SeVZUZTZ0dHJKTWNEYTFVUGJXZXJ2WkVzS2p3ZWN2Y1hsdGthRXo5ajNVbi9Rd3RIdTJlK2xuVStqbnlac1NJNVBiVTB2RFNqMUhCTFZuTHFKc2lKODB0NkFjTEZKdFZNdlNQMmJpNG0zb0tHOG1yV1RJN0tTQzB4cVRCMExqWGtLVGlJbDR2OWFHdC9TSjBZRU5hMzlDU2FIdWd3NzBmeElBZmRkZEdldzRQOVRpYmFjLzZvWjVMMDl0OHFDdFgzZXoveGFhdnRPZW96V2YzaEFLSy9KVncyeWtkYnNJemZsTW1hY3VTNm5aVXRiQnVKbGxqM0N5dDZmMFl2c0pTbWwrWlNHV0NVVEpxOVhtTyt5U3JYK0tyV2c2N3d4R1AxWWJoamVDWUtYN3FOUmhGai90ZUpqUjJRb3BWSW1HSnBGSTZZQ3hWUWpxYlZvYWRsNHpIVXhOdFMxclhsY2RLWGdDZFhUOThOaHhqOWVIeDNJbnhOcnVQbnZBMUphUWxJM1ZlTGZVbHR6Y3hZbHBFTXRONExKay9WekxrMTEzVjRzSG9nOTdhb0ZROE5aNHVxbXpKMDFhdGhJR0krMHB5Zi94RVd6VU5lOGd5SGVKT21qWG1DZEZlYld2Ly94YStIaTM4cm0yUkxyUnVTU3pBRTNpS2NWdkZXNXBha2xJcWN5ZTlpTzQxbFI3bDZ2NUxVaHdhODMzcDFqVmQxYnBpWFhvaGVMRzc3Skx2TjdWSXRmNmhwUkx0eVg3M2xjMHAxM1JQSGVvR2xJVEhOcFVLRmUrZk12ZFZOTlN2bUNCaEhGbnJ2cDNlSnd4VTl2bkk1b1kra1d5ZVBiZmxJSDRuZURZM3RleG5DRlBWVmhucHk4Vytsb01lQUZHaE1wUktpYlRob1Eyb0k3amFma2FyakhjZkZBSFdLNzJjUWxEYUMvb0pLRFR0RUkzQWduNG1RYk1tTnNwWE5oS0J3UjR1MFNNT2plYVFwazNRMWlzMEJmcUFubDNVODZKVzFJbEd4c1M0K3dnbDdVZktJZnhFMGhGNHdraE14TjJIc3hvVmNqOVozNmNUM1lrUjYzR0VtT0J3Yy9QbHJadm50anhoQkp5bTVMaFJKUVVVOVhvVWRqMzZFZTdSU2w5VmtpZmpaWGZVU3FPMEZQSFRTSGFTaHI4bDFhUHBlNVhCbHlkd20vaWI4U3ROQXhtaVFVTllEbGllMTNFUU9HWVBCWTVoVVhGczNOaWd6V3ZMODlxOGo3Qi9IenpBSEloTjQyLytMcnFUbTRsQ21zbzh4eGJpSzlvTTh3L2l0OVZ4c2RCb204THlXcjNKREp4V3A5UE9qbGgwMlRyR3l1cU1MTU9BMFFqbVZrRXdhQTNhU2kybk43SEdLWWJBUUZyb3FOOW1KeUZYSUZsQXhkSDVOOHpEQnFTRlhOWTNqNDRiNnlkOG1vWmxoNWZtbGZKc2tNMWpDK1d6aCsvYnVmTVhSK1NCRUNHZUF4NUN1RkRnWkFmaDVNR09rNEc5aThrSStaM0YrRUVDaStPZmtpM3dEUmpBTHVwQWtGckJvZHZIQmdhZ3dqOXViRnBPZm5GUlNiQVFuOEhDaFhCVFUzaGljM1Bxck5LeSt2cXkwbGs0Ty81dTNNNHV3Qk95WUhxU1lNNEVrTHZBdUxHRStBaTdJRmIzRjJZLzMvdnRyY0ptbE9mTStHa3VsOThQZXZ5ZXpCTWQyaTAyMHhhUkZReTlFVUVEbHQ0SXBPT2U0S3J3NCtNall5QXdNRzRzbjhQWXJCRDBZTVppNWkyMFdabVJKeTRTNFFMNXEvelZYK1dMQkFaZFpBV1pTKzRrOThTODhrNzVMdDRXT3hJN3hmaVlFanhiSTZweE1YOElqSkF2MmdVU0ZSbFdNQXFhM1JGQk1Hb1lGMVJVQktsTUlaVFlFZG0yK1d5Q29Da3VaMHVaeGFjcnRzOGJ2MnpKMGhCLzZMdGFicy9vQ3RjTGpvSWljU1NWV2dkK241L0NzNHlHTWpFVHZGdk1vN2FJcVNTVm1FZGxaanA2STVrYWRoUVp0VHRDY0ErL0RZSjRLTHFOblc1MEZIZUtvYzY4M3VLaWNxNjBuQzB1R3NQNGNwUmRnNFZaakRQRnpHak1yTlBwWlU4TjNwa3Z6dWxZTkc3TTlKSXNYOFdjWU11QnBsRnoyN3JEN1h0V1RmVFBXbFV6ZnZYMUllYmVsZFczTEpsM1hjUEk0WFgxa2FKUWMyaFlZK1A3M25GZWEzREJ6cmJydHQ2NkRJTjdjN09mcDN6ZkVUL04vaDM1OXNJTllqQTlJMjJMeWFZem1YVDRpVGRzaXloQXVsNm4xL1ZHaU1lV29uZFpyQnVtNi9XZUZBL2JHL0drcDZDR1VqUkpEZEhEb0RuYThVUkQ4a01CMnROQ2dVREFPbkFVdjZoS2kxT0RoZmgxNWZVVkJ6MVk1R2lLRlR1eThzNVV0Q2JPbDNQSE51a1hqOGxiVjNhVE9sbis1Ym9kTHo1elNqN3g0SlB5M3dmZUt2N2J5ZzBydnp4MDZzM0ZmMjQ4Zkw5OHNvR3ovSEhia1FHMG9TTDB5ZFdLUnptZ1ZIUTdvbHFXOEZIUkluQmFoM1ozUkVlc1pvZERNQXNDVlM0NnFUMFVERklGSUlQQmpGamhDOVNxaUMzbzlLR2l2VlRORHB2QWFOZzliNzMxUWV5V2xvT1A3U2pVTFg5ckh0ODcySEZFZnA1TWVHN0JKLzg0djNLd2c1bDdWSDd2SnBUZmcvRlQ3S2U0ZnpxTUY3T3NVVENZblNnM081V1ozZTR5dWxCVXJuU2paWGZFS0Z3bHFwQmkxTEdqZ2FNRGwyV1Q3OHZST0x5bzU0U0hnUy9ud1o5djM3SC9xWDhaM3hka25vM0ZYVFZsSDM4cmYvVHRHOTczNSsrNjgvYk5SdWI4Qy9KdTd0TlgzNUxqS0l0RjhVKzRrYWhMSDVUQ0pESEhBZEhjTVZ2Y1cwUjk5c2plaUp0M1dMS3plWXNsdFRkaTBmREIzZ2lmZmhWSGl1NFV1MCtZSTBHejgrV01ZWXFMN0NXVW56Um5QdktIcGhpa3pTeEdvMWlwR2Mweml3a1dsalBjeU1rOWp5OWM5dFRHS2ZNZk9iR2g0ZTRSd1RWMVRmY3Rua0NFTWYvVWZjTURTOGQvT214Q0pCeHVMYzhlRnA0bmhsb21aSk5qeS9iZk5ibnBrUXNQdjBpS2ppOUxkYnlla1Z1OThValA1TWFKcS85d2UvbWlxU1A4dFhNRHdhVXRvWUpwQzFIV3RhaHJUdEYxbm1nVERJSUIvUmlNSnVQdWlDbWgzNlJpOFNob2QzZ0NRYzlvZkNVWlRLbTMyTXR4Yy9kdWFNdjRIMWZrMWwxTnNRajdOSi8vQi9sUDhpSDVxY2Q3U1JDeFpNOExHSzlhNDJlNHRLUU02NkJaSEZVVzFUcnQwVXFNdjVXUUVSM0Q1MFpGY1BMQmlSTlJnaE1uWnB1b2JMUFRUWk43STZacm5JRVdvYVNXQnhTV3JBUFBXMUhkanFKeXBqUWZBMms1ay9CdlFaUEZPcFBpTGsyS3N6Z3BYc2MxN2Riczhoc3E1cTJZdFBxaDYrZjkwMnB4Uld2NWZORlQyeU4xTDltM2J2S0h1Wlh6UXFYWFYrWFRzbVJlVmY0NFQ4blVnb0twcFo3c2ttbiswZE9LaDVGZmxxL3BtT2txZW5qQnJIczZTc3M2N3BtNTRPRWkxNHlPTlJVM1BMU3l2SHpsUXpkTjdLak94U2QzdUxSOVNzSHd5UjNNek5FelFoNXZhTWFvMFRQTFBON3hNK2hOT0FjdGpVcHBKRXlFS1dKZVFZR3pLS3IzUUZSMHVrTzlFV2VxZ1UvTmM3djV2THhBYnlSUHcxdC8wTmhzd1dSZ1A0clNvZXBLWVFTQmltQjRjUmFySE5sblpoTVdtQkRVOXl3dWJkN0Q3L2FNbkYwM01jVlpQblZXWHZQV2ptTE9QbUg2dk9LNUQ5NDBhZG9HYVhINzR4dG5uTStyYkMwWmU5MmsvTHpLZVdXRnpSVzVyUHUvNUZkZW1xKzNPblN2bTl4T1UrV0dJK3M4SVg5R3hacEhGcTE2YWwzTjFOOE1aa3k1dVduTThDbUx5cXU3SnVmbFZjeWhaMWJ1UmM2QzkySWFlRVNiM1NpMTJxM0orNUYxN3JNRUJrS2g1Qm12dmlmWkg3Z3pKMTU3ZDdKcGwyOVJCbXdBZkIxYU9sNkRNRWNjeTFyTUpzN0k2WFZhaGlNR2d4RWp0NDNuaUlYZEViRllCSjFaYitKNHcxTGpIVWJHS0xEWUFSaDFLLzU3M2xHTXY3WlFnRW81RUxBRnFWdllLQWtUdlcxWVJPSjFzUG5EZllLRzVldmtpM2ZGWHJ0VEhtVFNpYkgrUloyZTB4bWVKOHZsWDJIdzI4V0VNOHREM3RoUjlNSTVlR3Z2UnQwN29WTDBnWk1ZOEdaeU1JN3RFY1lCQm1Ka0RRYVQxclE5b3VYQVlFaXpydVdwN1FlQ3lXc3ZnTytVeTdWeFkvTUVud2Z3TnZjV1luang1UUFHdldCaEtiZjdkLytRWDVJM2szOG1WY2UzYk45M1JuNmZtTjk3ZFZlNGlVU0pTRnJJb3hNK255Ty8vZTJBL0VrYlNxc1BwZFdWbEZhZW1BSzY3Ukg4aHRKdWorQURiYTBKTDdRZVVKZ1l1S1FlZktMUk40U1h0UVVMb2RqcTdTTjcySFI1aW56ZjNxY3ZrclRZQmI0M1ZpTS9LUy9uamwvOGxxUU1rZ3Q0YnR5RmZSdDNNVUNkT0VLcnhWQUVZQkwwUFNJUmNFT0xrQzB3ZGxZUUNNUHdLQXVXNkhGLysxVkdUOTlvaXNVWFVvbFFqVkExMkREZ0p4TDc5dUM3TEI4N1F3WmtCMVBLOTc0aWQ3OHN0MEJ5NzMvSHZYVlFJZzZqNjFzWWxEdkRhRFYyTFVGWnM1UVpBeVAwYUFMSnhSTWJZNVZ1aXI2VjJBTHZPUGJmWTZmSldkbCtsaFc0NDNMRHk3RkhjVjBDemZIVHZCVzFtZzV6eGFBcmJYdkU1ZExDa0Y0dGhtd0RvNytzMmJRMHA5VmdnQjZuMDQwS3RocUZHWHpBcjBpNE1HREQ0bHBsQiswMEhsSnRlNi9SdGgyMWpmZXVsN2Vla0Fma1orV2J5VDR5L1l1SC8vRHhTZm5kd1hkMkxwUGZZTndkdDVOdHBKYk1JSS9WZnJWQ2Z1UGNCZmxraURTL2xKUUxkeGI1dDhJb01VMXZ0aEtlcHlKaHpSWUx3UzhmdTU1WEpJS1N4bXVmR21GRjB2WUpHajFLSTJnTGxwUVNMK0hPeXEvSXBreUJPM3VXTTZhU0Q4aXcyREhtbDNtbVdEbGF3ZzJwYnViR1dQMlFIbDdGL1hod2kyYkNVUTB6K0FXZzRYcUlZbUgwRGxKMGlnYkd2anA0Nml3eml1KzlHRWpNNUcvRW1RNFlLVHJOZHNKek9qMnJJeGJvc2RtY0JsN2JvOFA0UVZVM0VBcEM0RW8yVTUxVWJTUTFMWmhmYkF2eU44cURzZGtaTmtGN2lqaVord3N3S3B6a3NrYjR4end3MklSYlhSUmRvYzBzL2NXUm90RURxRkVhcjZoWDJORXJISUp4ZTBUZ2RHdWR6blRMV3ZZYXIrQVR5bEZ5a3NNbzJyRVhXeGtXVURwYjhVbGRTOGFRRytWNzVQOTgvc0s1Wi85ODloTVgyVUVxOGJIOWtMd0tyOUxmeWwzY3QvTGZ6bjBodjBkU3Z5TUUzN3FLYjNKTDhkejBqVDlhZEJsaFI4U0lueloyMXJBandyS2F0VlpyaXBIME1BbXpIYmhrdGY3RTA5dGJ5TkZuRUhWVCtuUWtld2JJRXhlSVZmNzQvRE85dS9mS2YyTzBzVy80M2xPdnZ5NS96Znc1OXVWOWQ4VWdHUTk0M0RNVGh0TVlsWmFsMVdidGlHaTErbUdHWVRzaUJuVE5ORjN1V2h2SlpHd2NqTXpTOWVoeGUrdnphWVZVSGhBSVhuV0RLNUZ5RE90VEhvaERyM0ZuRnB1R3IwYmxXczczOGJ6ODZjbnNDUk9uakc0YklPOHMvTmVleWFObi8yenE4UEZGd2V6WXIxOG9uVmVkditGMnNyNjRibXhxN0JEZk83WjllL3YwZFF0cUhWeHFjZG5rQUZzcmo4a1Jydzh0WG9OV2tvdlNtcXBFc2hJeGswVXJFZERYQlJaNEJyOERXYjRTelp2cFlWbWRsbm9aVlo1ZkNlNUQzeFNLbjlOM3JKZWJLbmVlbFJkeWVSakJ4bkxIWDhHMTk2STkwTi9nbU1BcjJoa2Q5V3NqeTdQUVl6QllORDNja0Mwb0ZreXNHQi9SaUJNRkQ3R2pzZmZPa2lra2ZKYXBqdjJlcVdHWER4NlY1NUlIMkRycUZXYVV0MU9KakptaTBhQmhXSll4ME4vaXNBSDByMEFoTmVkUWlINEM0blZEN1JoZGpuZkdZdkxYc2tBNDBtSFRjWnBVMHMzM2ZyY0lMZmh3VVUyb2tpdUhSRXhpZjhhNThLWXBFNGNwZDR0eTAreUtNS2xLS05vVjBhS1RHNndiOFk1SmhEd2w2bHh6ditSQWNSRmVLa3JFRVp3cCtOSXVaZGZjOGVqSDhta3llbkRiMHFXMy9lby8rbmF0WFJtWVRJWjlGQ1BCY2UvVXYvamIzL1JIRWg3RWplYy94K2d5RERuSVl0eThlMWVFVHlWT3M5UGczQlV4V0MxZ004RW1RckpkRzdVSitRV0R5V2VvSzFHZzlmaUtmY2dFZlVZakV5Z1FWbm5uSnpncDRjYWY1bGFkK2ROSEYxLy96eHU0MHlmdlc3RmgxeTl1dTJYbnY3MUFIQU15S1h5RXVmM2k2WHVXLy9yWi8vUFFVL3NTSExIZm9VVHNHS2ZiUlRNSWVBdmdsY09sa3djaTZmM3hkOFI4bTMzRGRFdDZkanBqWTlQVGRSWWRkMzlFbDJwSnZUOWlzV28wc05IaGNLZVRqY2FrdXhVR3ZuYy9YYTVTWTBxbDBuSmVrcUhkT1p4K0ErQnI0YnRZTGZmUE8zNi9aZHVwRCtVNGNiL3h4cWtUWk0yaXpxMVdjdVMrM280L3R1QWwrZ1VaTFo4L1Y3ZDI2NDZia2ZNTnFORGQvUHRvSXhZb1FtMEtDeUpJc2JCZ3RwaDBIYXhvTXJJZDhiSEdUWGhkV3hYajlwTU1sM1VBYmVlRjVBMTJ4U3ZLZ1pHYkdFTU5EYUVKalkxbHAwOXovelV0RkpvK1BWUXk0K0pJamxyT0F4Z0d6bkIyMU54SU1WWGoxRm9BOUN1WmRRekRtSlZyUWRpa1hBczBZQitiVjFnWXFLQ3VvMmlGWGdwTzVRc25qVGxUTUd0eEZGZlArZmwxRlY3VzV6MjBWMDdsNEMvTGJuUFFQZnp4TTh3VGZBQlNNTVo0VTFMc2pKMGFwbDZ2TVFzR2pVYllGZEZZNkFQQkpCaTBsazNvWHNIQ1lHSGdrcG5TcStlU3FTYmVRVFliZmhvWGx5b2ZvNHFaTWs5VXI1VGZmdXl4MDE5OVZUbGpndCtRUTdLWXFnTURsZkxyQjJSb25aa0R5dDhOOEh2NjNmY1d6WnR2Q1g4RjdzU3Z1WitKUFVML0ZnRGVXZGt3OCtMU3dmc3RzbjRCMEw4d0lNbmZ2V0twL1YxTUJyQjhlWEhwZHg5WTVFczlReERoQytoLzcwTG92VXhrMTlQWSt1UEEzZ1pUcjJ5VHM3Q1luUlYvbDdzUlpySmwwSWhsQjZZN3VJZWdDTXNIdVZ0Z0VUY05hckhlaXZVNWRQeVByYzNQcDY5aWpJL2Z3QnorVDlESDVXTGlvWS9mQ2MxWGp1TStnajcyRFBScEZrS2Y0TU5raEdidThRVGYzTVZrMlEyNS9GN1l5K2ZRMlBYVGdIME8xM3NEazNqMXZrd2F0ZkgvTnpCZlU4dkU4bVB3Z3dvcXFLQ0NDaXFvb0lJS0txaWdnZ29xcUtDQ0NpcW9vSUlLS3FpZ2dnb3FxS0NDQ2lxb29JSUtLcWlnZ2dvcXFLRENUd2Z2aitMcUpPNkFSK0VEWWliZDVCVkd6OVF6aDVuejdOMXNuQ3UrQ2pjaXZzYkYrWW44Q3Y3bEJBcEV5RUs4VHVnVjNoVGUxSXhEbksvWnB1bi9VZnhHTzBtN0o0bHZYWXM2RGVJMEZWVlVVVVVWVlZSUlJSVlZWRkZGRlZWVVVVVVZWVlJSUlJWVlZGRkZGVlZVVVVVVlZWUlJSUlZWVkZGRkZWVlVVY1dmaHZUL2tKbnlBRXdIVnZuYlNRYXNFSUNGQU94a2ZURWxpQTN2bjBoTnkzenpMY3p1dURQVmZjZWQ2YSsvZ2ZXYmI4RnMrU3JNbHEzRWJPbUtWUGZTRmV0dXlsanpzeFJuNXVKdXpCWXR3V3hoVjRwN1lkZmROMmFrcjA2OXZTcmRleHVtZzZTZXpOcHZ6ZTZjbEVvYVlBMG1CcXJKTEdqQzFJbnBLQ1lPS2tnbDhtWWhrMkF2SmlaKzRvbC9qUFNIRGhLUlROelArc1YrTXZGQXZqOTBxbEhyNzQ4ZkZ2MU5ibmZvMVpkNXYvalhrUVdoMlkyTXYvRkR4dStSREliUWVhdzg5enpqRjQ4WVRLRWpoM2xsdk92RGRIZm83Yi93L3MrZVp2eFA5ekwrM1poNmQ5SE9FNkx4YkVwcTZGZmJCZjhPVEpUZy90SnNEZTM1TmVOL0FOTmplOGoyWGJuWnY5Nmw5ZCsvUy9BblRtUExYalBKaG53VFBNVTBQTVUwUE5jMGxPa2FjZ01RTW9WTUJnZGtFN0ovTFlNVHlrazRjWVR3L3V6Y1VEOEo3Ri9MK2Z2Sm1QMmJXTXJjRTBkejhrS1VTZHRoa3lsMDdEVWMrbkptWnVpVmw1UmVNZjBjbnVQVEhzWS90c05vRktwMFQ1SytmWXgvSHhMbzNML2dGRnIrYWZnSVpRM1B0cXlzMEpZbzU0OXUwdnUzNGdaM3JTUCt0VDJjdndmckE1c1M1eHZmNFVvUGRXd2kvczJZN3NWMHp5Yk9memVXRzdFOHMrbmJUY3lTVFdUNEp1SXVkYnBLbk01aXA3M0lhUWs2WVl3emUxSUJtUXNCVEF4cEpuUEFDZlhrT3BUQ0t0S001eDVQSnFBR3kwZ0l6S1NFbElJWkRLUU1KbUNxdy9RcUpnNHBKVWdwZ1ZaTUxGakplSnduN0dmajJaTzhSRThNT0Y5TGREaGZJQnFjdjVSb2NYVUQ1aE13MVdINkk2YlBNRjNFSkdDUEhsZlN3MVpNTEJIRVRGd29mN2g1eEhCTGdkODh5bS9KOFpsemZaYXNiTE1uMndMUGtIRzQ0VGp3WUVMekoyUEZUV1JWd1lrQ0JzTEVtaXZtcnNyZG04dFpyRGFqVG04d0NocXRrZVY0SXhER21DOWtaZ3VzSzl2Q1ZyRHZzK3h2NEgxZ0xHblphWUUwMXBLU25SSklZY2ZwZ3lZM0dXWnlhVEpNVG11YXljNmxtQUp1TWlwY0VCNFJ6Zy9uaG5QQ25uQlcyQjEyaFoxaGU5Z1Mxb1dGTUJ1R2NIMndpVWoyT3FocnFwUWNCTXZabFZMUVg5ZlBlaHFsUW4rZHBLdHZiZWtqNUw0SVVpVm1jejhhbk1SdDdtZXdzRmZOYlczcEorbTArMjczUVpRalNIVnRkLzg4NHZjUGt6cnBQNXUyZmxoRUtxU1ZYdzZMUUoxVTJDQzVmWlgrYTJGMUlrY1lJbHl1OTQzSXI1RUthdHFsVVRWdDFVclhtbjRpMUN6cEovcWFKZTJZKzZyN2lUYlJic09hcnpxNVFEOFpUNmxsTlV1UVhFWkhLZTBTcFYzaVM2eVYzTnBQVnEvNW1mLzdzUHFhSms2QTc1T3ZHVUo3SlpkVWdZSzh0cmRQUnlWYTMxaFpKMmtiTWRXM1NoaytiTHlFalJKc0dIMlY4SDhCNmx4bUZncGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNuaHlaV1lLTUNBNU5Bb3dNREF3TURBd01EQXdJRFkxTlRNMUlHWWdDakF3TURBd01EQXdNVFVnTURBd01EQWdiaUFLTURBd01EQXdNREU0TUNBd01EQXdNQ0J1SUFvd01EQXdNREF3TWpJNElEQXdNREF3SUc0Z0NqQXdNREF3TURBek1EUWdNREF3TURBZ2JpQUtNREF3TURBd01Ea3lPQ0F3TURBd01DQnVJQW93TURBd01ERTRPVGN4SURBd01EQXdJRzRnQ2pBd01EQXdNVGt3TVRRZ01EQXdNREFnYmlBS01EQXdNREF4T1RJeU55QXdNREF3TUNCdUlBb3dNREF3TURFNU9UUTJJREF3TURBd0lHNGdDakF3TURBd01qQTJORElnTURBd01EQWdiaUFLTURBd01EQXlNRGM0TlNBd01EQXdNQ0J1SUFvd01EQXdNREl3T0RrNElEQXdNREF3SUc0Z0NqQXdNREF3TWpFeU56Z2dNREF3TURBZ2JpQUtNREF3TURBeU1UTTVNU0F3TURBd01DQnVJQW93TURBd01ESXhPRFF6SURBd01EQXdJRzRnQ2pBd01EQXdNakU1TlRZZ01EQXdNREFnYmlBS01EQXdNREF5TWpNek5pQXdNREF3TUNCdUlBb3dNREF3TURJeU5EUTVJREF3TURBd0lHNGdDakF3TURBd01qSTROemtnTURBd01EQWdiaUFLTURBd01EQXlNams1TWlBd01EQXdNQ0J1SUFvd01EQXdNREl6TXpjeUlEQXdNREF3SUc0Z0NqQXdNREF3TWpNME9EVWdNREF3TURBZ2JpQUtNREF3TURBeU16a3hOU0F3TURBd01DQnVJQW93TURBd01ESTBNREk0SURBd01EQXdJRzRnQ2pBd01EQXdNalEwTURnZ01EQXdNREFnYmlBS01EQXdNREF5TkRVeU1TQXdNREF3TUNCdUlBb3dNREF3TURJME9UY3pJREF3TURBd0lHNGdDakF3TURBd01qVXhPRFFnTURBd01EQWdiaUFLTURBd01EQXlOVFl3TXlBd01EQXdNQ0J1SUFvd01EQXdNREkxT1RJNUlEQXdNREF3SUc0Z0NqQXdNREF3TWpZd056RWdNREF3TURBZ2JpQUtNREF3TURBeU5qSTVNeUF3TURBd01DQnVJQW93TURBd01ESTJOemswSURBd01EQXdJRzRnQ2pBd01EQXdNamN5TXpZZ01EQXdNREFnYmlBS01EQXdNREF5TnpNNE9TQXdNREF3TUNCdUlBb3dNREF3TURJM05UQXlJREF3TURBd0lHNGdDakF3TURBd01qYzRPRE1nTURBd01EQWdiaUFLTURBd01EQXlOems1TmlBd01EQXdNQ0J1SUFvd01EQXdNREk0TkRJMklEQXdNREF3SUc0Z0NqQXdNREF3TWpnMU16a2dNREF3TURBZ2JpQUtNREF3TURBeU9Ea3lNQ0F3TURBd01DQnVJQW93TURBd01ESTVNRE16SURBd01EQXdJRzRnQ2pBd01EQXdNamswTmpNZ01EQXdNREFnYmlBS01EQXdNREF5T1RVM05pQXdNREF3TUNCdUlBb3dNREF3TURNd01UTTRJREF3TURBd0lHNGdDakF3TURBd016QXlOVEVnTURBd01EQWdiaUFLTURBd01EQXpNRGd4TXlBd01EQXdNQ0J1SUFvd01EQXdNRE13T1RJMklEQXdNREF3SUc0Z0NqQXdNREF3TXpFME9EZ2dNREF3TURBZ2JpQUtNREF3TURBek1UWXdNU0F3TURBd01DQnVJQW93TURBd01ETXlNVFl6SURBd01EQXdJRzRnQ2pBd01EQXdNekl5TnpZZ01EQXdNREFnYmlBS01EQXdNREF6TWpnek9DQXdNREF3TUNCdUlBb3dNREF3TURNeU9UVXhJREF3TURBd0lHNGdDakF3TURBd016TTFNVE1nTURBd01EQWdiaUFLTURBd01EQXpNell5TmlBd01EQXdNQ0J1SUFvd01EQXdNRE0wTURBd0lEQXdNREF3SUc0Z0NqQXdNREF3TXpReE1UTWdNREF3TURBZ2JpQUtNREF3TURBek9EWTRNQ0F3TURBd01DQnVJQW93TURBd01ETTVNVEV3SURBd01EQXdJRzRnQ2pBd01EQXdOVGsyTVRBZ01EQXdNREFnYmlBS01EQXdNREExT1RjeU15QXdNREF3TUNCdUlBb3dNREF3TURZd01qZzFJREF3TURBd0lHNGdDakF3TURBd05qQXpPVGdnTURBd01EQWdiaUFLTURBd01EQTJNRGsyTUNBd01EQXdNQ0J1SUFvd01EQXdNRFl4TURjeklEQXdNREF3SUc0Z0NqQXdNREF3TmpFMk16VWdNREF3TURBZ2JpQUtNREF3TURBMk1UYzBPQ0F3TURBd01DQnVJQW93TURBd01EWXlNekV3SURBd01EQXdJRzRnQ2pBd01EQXdOakkwTWpNZ01EQXdNREFnYmlBS01EQXdNREEyTWpjNU55QXdNREF3TUNCdUlBb3dNREF3TURZeU9URXdJREF3TURBd0lHNGdDakF3TURBd05qYzBOemNnTURBd01EQWdiaUFLTURBd01EQTJOemc0TXlBd01EQXdNQ0J1SUFvd01EQXdNRFk1T0RZeUlEQXdNREF3SUc0Z0NqQXdNREF3TmprNU56VWdNREF3TURBZ2JpQUtNREF3TURBM01EVXpOeUF3TURBd01DQnVJQW93TURBd01EY3dOalV3SURBd01EQXdJRzRnQ2pBd01EQXdOekV5TVRJZ01EQXdNREFnYmlBS01EQXdNREEzTVRNeU5TQXdNREF3TUNCdUlBb3dNREF3TURjeE9EZzNJREF3TURBd0lHNGdDakF3TURBd056SXdNREFnTURBd01EQWdiaUFLTURBd01EQTNNak0zTkNBd01EQXdNQ0J1SUFvd01EQXdNRGN5TkRnM0lEQXdNREF3SUc0Z0NqQXdNREF3Tnpjd05UUWdNREF3TURBZ2JpQUtNREF3TURBM056TTFNU0F3TURBd01DQnVJQW93TURBd01EZ3pNVGt6SURBd01EQXdJRzRnQ2pBd01EQXdPRE16TURZZ01EQXdNREFnYmlBS01EQXdNREE0TXpZNE1DQXdNREF3TUNCdUlBb3dNREF3TURnek56a3pJREF3TURBd0lHNGdDakF3TURBd09EZ3pOakFnTURBd01EQWdiaUFLTURBd01ERXdNak01TnlBd01EQXdNQ0J1SUFvd01EQXdNVEEzT1Rrd0lEQXdNREF3SUc0Z0NuUnlZV2xzWlhJS1BEd0tMMGxFV3p4RE9Ua3pNelV3UWtSR1FVSkRRelEyT0RKRk1VWkdSREJHTmpZMk5VUkdNVDQ4UXprNU16TTFNRUpFUmtGQ1EwTTBOamd5UlRGR1JrUXdSalkyTmpWRVJqRStYUW92U1c1bWJ5QXhJREFnVWdvdlVtOXZkQ0F5SURBZ1Vnb3ZVMmw2WlNBNU5BbytQZ3B6ZEdGeWRIaHlaV1lLTVRFMU1UTXlDaVVsUlU5R0NnPT18RW5jb2RlZCBEYXRhfHx8fHxGfHx8fHx8IA0K</inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>HL7V2</inboundDataType>
      <outboundDataType>HL7V2</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="4.0.0">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="4.0.0">
          <handleRepetitions>true</handleRepetitions>
          <handleSubcomponents>true</handleSubcomponents>
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <stripNamespaces>false</stripNamespaces>
          <segmentDelimiter>\r</segmentDelimiter>
          <convertLineBreaks>true</convertLineBreaks>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="4.0.0">
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <segmentDelimiter>\r</segmentDelimiter>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="4.0.0">
          <splitType>MSH_Segment</splitType>
          <batchScript></batchScript>
        </batchProperties>
        <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="4.0.0">
          <segmentDelimiter>\r</segmentDelimiter>
          <successfulACKCode>AA</successfulACKCode>
          <successfulACKMessage></successfulACKMessage>
          <errorACKCode>AE</errorACKCode>
          <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
          <rejectedACKCode>AR</rejectedACKCode>
          <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
          <msh15ACKAccept>false</msh15ACKAccept>
          <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
        </responseGenerationProperties>
        <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="4.0.0">
          <successfulACKCode>AA,CA</successfulACKCode>
          <errorACKCode>AE,CE</errorACKCode>
          <rejectedACKCode>AR,CR</rejectedACKCode>
          <validateMessageControlId>true</validateMessageControlId>
          <originalMessageControlId>Destination_Encoded</originalMessageControlId>
          <originalIdMapVariable></originalIdMapVariable>
        </responseValidationProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="4.0.0">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="4.0.0">
          <handleRepetitions>true</handleRepetitions>
          <handleSubcomponents>true</handleSubcomponents>
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <stripNamespaces>false</stripNamespaces>
          <segmentDelimiter>\r</segmentDelimiter>
          <convertLineBreaks>true</convertLineBreaks>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="4.0.0">
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <segmentDelimiter>\r</segmentDelimiter>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="4.0.0">
          <splitType>MSH_Segment</splitType>
          <batchScript></batchScript>
        </batchProperties>
        <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="4.0.0">
          <segmentDelimiter>\r</segmentDelimiter>
          <successfulACKCode>AA</successfulACKCode>
          <successfulACKMessage></successfulACKMessage>
          <errorACKCode>AE</errorACKCode>
          <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
          <rejectedACKCode>AR</rejectedACKCode>
          <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
          <msh15ACKAccept>false</msh15ACKAccept>
          <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
        </responseGenerationProperties>
        <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="4.0.0">
          <successfulACKCode>AA,CA</successfulACKCode>
          <errorACKCode>AE,CE</errorACKCode>
          <rejectedACKCode>AR,CR</rejectedACKCode>
          <validateMessageControlId>true</validateMessageControlId>
          <originalMessageControlId>Destination_Encoded</originalMessageControlId>
          <originalIdMapVariable></originalIdMapVariable>
        </responseValidationProperties>
      </outboundProperties>
    </transformer>
    <filter version="4.0.0">
      <elements/>
    </filter>
    <transportName>File Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="4.0.0">
      <metaDataId>4</metaDataId>
      <name>DICOM Sender - 127.0.0.1:104</name>
      <properties class="com.mirth.connect.connectors.dimse.DICOMDispatcherProperties" version="4.0.0">
        <pluginProperties/>
        <destinationConnectorProperties version="4.0.0">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>30000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>3</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <host>127.0.0.1</host>
        <port>104</port>
        <applicationEntity>RPRS</applicationEntity>
        <localHost>127.0.0.1</localHost>
        <localPort>104</localPort>
        <localApplicationEntity>RPRS</localApplicationEntity>
        <template>${dicom_msg}</template>
        <acceptTo>5000</acceptTo>
        <async>0</async>
        <bufSize>1</bufSize>
        <connectTo>0</connectTo>
        <priority>med</priority>
        <passcode></passcode>
        <pdv1>false</pdv1>
        <rcvpdulen>16</rcvpdulen>
        <reaper>10</reaper>
        <releaseTo>5</releaseTo>
        <rspTo>60</rspTo>
        <shutdownDelay>1000</shutdownDelay>
        <sndpdulen>16</sndpdulen>
        <soCloseDelay>50</soCloseDelay>
        <sorcvbuf>0</sorcvbuf>
        <sosndbuf>0</sosndbuf>
        <stgcmt>false</stgcmt>
        <tcpDelay>true</tcpDelay>
        <ts1>false</ts1>
        <uidnegrsp>false</uidnegrsp>
        <username></username>
        <keyPW></keyPW>
        <keyStore></keyStore>
        <keyStorePW></keyStorePW>
        <noClientAuth>true</noClientAuth>
        <nossl2>true</nossl2>
        <tls>notls</tls>
        <trustStore></trustStore>
        <trustStorePW></trustStorePW>
      </properties>
      <transformer version="4.0.0">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
            <name>Modification HL7 ORU to DICOM - MSH Segment</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>/*
	fileName:		modification_hl7_oru_dicom_msg_segment.js
	Name:		Modification HL7 ORU to DICOM - MSH Segment
	authored:		Jeffrey Ritz
	created:		2023-08-17 
	description:	Evaluate source message (msg) transform to desired destination message (tmp) schema changes
	History:
*/

var scriptName= &apos;Modification HL7 ORU to DICOM - MSH Segment&apos;;
var debug= 0;
// tmp= msg;

// if(debug&gt;0)  {
	logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; msg typeof: &apos;+typeof(msg)+&apos; msg: &apos;+msg);
	logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; tmp typeof: &apos;+typeof(tmp)+&apos; tmp: &apos;+tmp);
// }

// Get HL7 ORU fields
// PID Segment
var patientId= msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
var patientLastName= msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
var patientFirstName= msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
var patientName= patientFirstName+&apos; &apos;+patientLastName
var patientDateOfBirth= msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();
var patientGender= msg[&apos;PID&apos;][&apos;PID.8&apos;][&apos;PID.8.1&apos;].toString();
// PV1 Segment
var patientUnit= msg[&apos;PV1&apos;][&apos;PV1.3&apos;][&apos;PV1.3.1&apos;].toString();
// ORC Segment 
var fillerOrderNumber= msg[&apos;ORC&apos;][0][&apos;ORC.3&apos;][&apos;ORC.3.2&apos;].toString();
// OBR Segment
var observationDate= msg[&apos;OBR&apos;][0][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString().substring(0,8);
var observationTime= msg[&apos;OBR&apos;][0][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString().substring(8,14);
// OBX Segment
var procedureCode= new String();
var procedureCodeDescription= new String();
var procedureCodeValue= new String();
for each(obx in msg[&apos;OBX&apos;]) {
	if(obx[&apos;OBX.5&apos;][&apos;OBX.5.3&apos;].toString().indexOf(&apos;PDF&apos;)&gt;-1) {
		if(procedureCode.indexOf(obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString())&lt;0) {
			procedureCode= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			procedureCodeDescription= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			procedureCodeValue=   obx[&apos;OBX.3&apos;][&apos;OBX.3.3&apos;].toString();
		} // end if 
	} // end if 
} // end for each


// miscellaneous setup
var random = new java.util.Random();
var now = new java.util.Date();

//  UID prefixes
var UID_PREFIX = &quot;9.8.7.6.5.&quot;; // get your own unique UID root to use here
var STUDY_SUB = &quot;1.&quot;;
var SERIES_SUB = &quot;2.&quot;;
var INSTANCE_SUB = &quot;3.&quot;;
var prefixUID= UID_PREFIX + INSTANCE_SUB + DateUtil.formatDate(&quot;yyyyMMddHHmmssSSS&quot;, new java.util.Date())
// create SOP instance UID for the new object and insert it into the object
var instanceUID = prefixUID + &quot;.&quot; + random.nextInt(100000);
// Copia^2.16.840.1.113883.3.1833.3^ISO|Copia DB^2.16.840.1.113883.3.1833.3.1.1167.2095802080^ISO|State Reporting^^ISO|State Reporting^^ISO
// MSH Segment

// (0010, 0020) - Patient Id
tmp[&apos;tag00100020&apos;]= patientId;
tmp[&apos;tag00100020&apos;][&apos;@len&apos;]= patientId.toString().length;
tmp[&apos;tag00100020&apos;][&apos;@tag&apos;]= &apos;00100020&apos;;
tmp[&apos;tag00100020&apos;][&apos;@vr&apos;]= &apos;LO&apos;;

// (0010,0021) - Issuer of Patient ID 

// (0010, 0010) - Patient Name
tmp[&apos;tag00100010&apos;]= patientName;
tmp[&apos;tag00100010&apos;][&apos;@len&apos;]= patientName.toString().length;
tmp[&apos;tag00100010&apos;][&apos;@tag&apos;]= &apos;00100010&apos;;
tmp[&apos;tag00100010&apos;][&apos;@vr&apos;]= &apos;PN&apos;;

// (0038,0300) Current Patient Location - PV1.3
if(patientUnit.toString().length&gt;0) {
	tmp[&apos;tag00380300&apos;]= patientUnit;
	tmp[&apos;tag00380300&apos;][&apos;@len&apos;]= patientUnit.toString().length;
	tmp[&apos;tag00380300&apos;][&apos;@tag&apos;]= &apos;00380300&apos;;
	tmp[&apos;tag00380300&apos;][&apos;@vr&apos;]= &apos;LO&apos;;
}

// (0008, 0023) Content Date - Observation Date/Time
tmp[&apos;tag00080023&apos;]= observationDate;
tmp[&apos;tag00080023&apos;][&apos;@len&apos;]= observationDate.toString().length;
tmp[&apos;tag00080023&apos;][&apos;@tag&apos;]= &apos;00080023&apos;;
tmp[&apos;tag00080023&apos;][&apos;@vr&apos;]= &apos;DA&apos;;

// (0008, 0033) Content Time - Observation Date/Time
tmp[&apos;tag00080033&apos;]= observationTime;
tmp[&apos;tag00080033&apos;][&apos;@len&apos;]= observationTime.toString().length;
tmp[&apos;tag00080033&apos;][&apos;@tag&apos;]= &apos;00080033&apos;;
tmp[&apos;tag00080033&apos;][&apos;@vr&apos;]= &apos;DA&apos;;

// (0008, 0050) - Accession Number
tmp[&apos;tag00080050&apos;]= fillerOrderNumber;
tmp[&apos;tag00080050&apos;][&apos;@len&apos;]= fillerOrderNumber.toString().length;
tmp[&apos;tag00080050&apos;][&apos;@tag&apos;]= &apos;00080050&apos;;
tmp[&apos;tag00080050&apos;][&apos;@vr&apos;]= &apos;SH&apos;;

// (0002,0003) = Media Storage SOP Instance UID
tmp[&apos;tag00020003&apos;]= instanceUID;
tmp[&apos;tag00020003&apos;][&apos;@len&apos;]= instanceUID.toString().length;
tmp[&apos;tag00020003&apos;][&apos;@tag&apos;]= &apos;00020003&apos;;
tmp[&apos;tag00020003&apos;][&apos;@vr&apos;]= &apos;UI&apos;;

// (0008,1032)(0008,0100) - Procedure Code Sequence - Code
if(procedureCode.toString().length&gt;0) {
	tmp[&apos;tag00081032&apos;][&apos;@tag&apos;]= &apos;00081032&apos;;
	tmp[&apos;tag00081032&apos;][&apos;@vr&apos;]= &apos;SQ&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;]= procedureCode;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;][&apos;@len&apos;]= procedureCode.toString().length;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;][&apos;@tag&apos;]= &apos;00080100&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;][&apos;@vr&apos;]= &apos;SH&apos;;
}
// (0008,1032)(0008,0102) - Procedure Code Sequence - Description
if(procedureCodeDescription.toString().length&gt;0) {
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;]= procedureCodeDescription;
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;][&apos;@len&apos;]= procedureCodeDescription.toString().length;
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;][&apos;@tag&apos;]= &apos;00080102&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;][&apos;@vr&apos;]= &apos;SH&apos;;
}
// (0008,1032)(0008,0104) - Procedure Code Sequence - Value
if(procedureCodeValue.toString().length&gt;0) {
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;]= procedureCodeValue;
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;][&apos;@len&apos;]= procedureCodeValue.toString().length;
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;][&apos;@tag&apos;]= &apos;00080104&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;][&apos;@vr&apos;]= &apos;LO&apos;;
}

// (0008,0018)	- SOP Instance UID
var SOPInstanceUID = prefixUID + &quot;.&quot; + fillerOrderNumber;
tmp[&apos;tag00080018&apos;]= msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString();
tmp[&apos;tag00080018&apos;][&apos;@len&apos;]= SOPInstanceUID.toString().length;
tmp[&apos;tag00080018&apos;][&apos;@tag&apos;]= &apos;00080018&apos;;
tmp[&apos;tag00080018&apos;][&apos;@vr&apos;]= &apos;UI&apos;;

// (0020, 000D) - Study Instance UID 
var StudyInstanceUID = prefixUID + &quot;.&quot; + fillerOrderNumber+&apos;.1&apos;;
tmp[&apos;tag0020000D&apos;]= StudyInstanceUID;
tmp[&apos;tag0020000D&apos;][&apos;@len&apos;]= StudyInstanceUID.toString().length;
tmp[&apos;tag0020000D&apos;][&apos;@tag&apos;]= &apos;0020000D&apos;;
tmp[&apos;tag0020000D&apos;][&apos;@vr&apos;]= &apos;UI&apos;;

// (0020, 000E) - Series Instance UID 
var SeriesInstanceUID = prefixUID + &quot;.&quot; + fillerOrderNumber+&quot;.1.1&quot;;
tmp[&apos;tag0020000E&apos;]= SeriesInstanceUID;
tmp[&apos;tag0020000E&apos;][&apos;@len&apos;]= SeriesInstanceUID.toString().length;
tmp[&apos;tag0020000E&apos;][&apos;@tag&apos;]= &apos;0020000E&apos;;
tmp[&apos;tag0020000E&apos;][&apos;@vr&apos;]= &apos;UI&apos;;
/*
File Meta Information Group Length (0002,0000)
Number of bytes following this File Meta Element (end of the Value field) up to and including the last File Meta Element of the Group 2 File Meta Information

File Meta Information Version (0002,0001)
This is a two byte field where each bit identifies a version of this File Meta Information header. In version 1 the first byte value is 00H and the second value byte value is 01H.

Source Application Entity Title (0002,0016)
The DICOM Application Entity (AE) Title of the AE that wrote this file&apos;s content (or last updated it). 
*/


// Institution Name MSH-4.1 -&gt; (0008,0080)
tmp[&apos;tag00080080&apos;]= msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString();
tmp[&apos;tag00080080&apos;][&apos;@len&apos;]= &apos;40&apos;;
tmp[&apos;tag00080080&apos;][&apos;@tag&apos;]= &apos;00080080&apos;;
tmp[&apos;tag00080080&apos;][&apos;@vr&apos;]= &apos;SH&apos;;

/*
// Specific Character Set MSH.18 -&gt; DICOM (00008,0005)
if((typeof(msg[&apos;MSH&apos;][&apos;MSH.18&apos;])!== undefined) &amp;&amp; (msg[&apos;MSH&apos;][&apos;MSH.18&apos;].toString().length&gt;1)) {
	tmp[&apos;tag00080005&apos;][&apos;@len&apos;]= &apos;10&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@tag&apos;]= &apos;00080005&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@vr&apos;]= &apos;CS&apos;;
	tmp[&apos;tag00080005&apos;]= msg[&apos;MSH&apos;][&apos;MSH.18&apos;].toString();	
} else {
	tmp[&apos;tag00080005&apos;][&apos;@len&apos;]= &apos;10&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@tag&apos;]= &apos;00080005&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@vr&apos;]= &apos;CS&apos;;
	tmp[&apos;tag00080005&apos;]= &apos;8859/1&apos;;	
} // end if

// if(debug&gt;0) 
logger.debug(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; tmp[tag00080005] len: &apos;+tmp[&apos;tag00080005&apos;][&apos;@len&apos;]+&apos; tag: &apos;+tmp[&apos;tag00080005&apos;][&apos;@tag&apos;]+&apos; vr: &apos;+tmp[&apos;tag00080005&apos;][&apos;@vr&apos;]+&apos; value: &apos;+tmp[&apos;tag00080005&apos;]);
*/
channelMap.put(&apos;dicom_msg&apos;,tmp);</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <com.mirth.connect.plugins.messagebuilder.MessageBuilderStep version="4.0.0">
            <name>DICOM Tag Set pdfAttachment</name>
            <sequenceNumber>1</sequenceNumber>
            <enabled>true</enabled>
            <messageSegment>tmp[&apos;tag00420011&apos;]</messageSegment>
            <mapping></mapping>
            <defaultValue>$(&apos;pdfAttachment&apos;)</defaultValue>
            <replacements/>
          </com.mirth.connect.plugins.messagebuilder.MessageBuilderStep>
        </elements>
        <inboundTemplate encoding="base64">TVNIfF5+XCZ8TWluaUJveHxQdWxtT25lfHx8MjAyMzAyMTIxNDU0fDB8T1JVXlIwMXwzNF8xMDAyMjAyM18xMDM1MzR8fDI1Mnx8fHx8fHx8fExSSV9OR19STl9Qcm9maWxlXkhMN14yLjE2Ljg0MC4xLjExMzg4My45LjIwXklTTyANClBJRHx8fEdFMTQ3Mzg4MDl8fERvZV5Kb2hufHwxOTU2MTEyOXxNYWxlfHxDYXVjYXNpYW58fHx8fHx8fHx8IA0KUFYxfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCANCk9SQ3xSRXx8T0JSXjM0XzEwMDIyMDIzXzEwMzUzNF5GVkN8fHx8fHx8fHx8fHx8fHx8IA0KT0JSfDF8fE9CUl4zNF8xMDAyMjAyM18xMDM1MzReRlZDfEZWQ3x8fDIwMjMwMjEwMTAzNTM0fHx8fHx8fHx8fHx8fHx8MjAyMzAyMTAxNDAwMTV8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwxfFNUfDE5ODY4LTlfQmVzdF9QcmVeRlZDX0Jlc3RfUHJlXkxOfHwzLjgzfEx8fHx8fEZ8fHx8fHwgDQpPQlh8MnxTVHwxOTg2OC05X1ByZWReRlZDX1ByZWReTE58fDMuODV8THx8fHx8Rnx8fHx8fCANCk9CWHwzfFNUfDE5ODY4LTlfJVByZWRfUHJlXkZWQ18lUHJlZF9QcmVeTE58fDk5LjI4fCV8fHx8fEZ8fHx8fHwgDQpPQlh8NHxTVHwyMDE1MC05X0Jlc3RfUHJlXkZFVjFfQmVzdF9QcmVeTE58fDMuMTd8THx8fHx8Rnx8fHx8fCANCk9CWHw1fFNUfDIwMTUwLTlfUHJlZF5GRVYxX1ByZWReTE58fDIuOTh8THx8fHx8Rnx8fHx8fCANCk9CWHw2fFNUfDIwMTUwLTlfJVByZWRfUHJlXkZFVjFfJVByZWRfUHJlXkxOfHwxMDYuNTN8JXx8fHx8Rnx8fHx8fCANCk9CWHw3fFNUfDE5OTI2LTVfQmVzdF9QcmVeRkVWMS9GVkNfQmVzdF9QcmVeTE58fDgzLjB8JXx8fHx8Rnx8fHx8fCANCk9CWHw4fFNUfDE5OTI2LTVfUHJlZF5GRVYxL0ZWQ19QcmVkXkxOfHw3Ny40M3wlfHx8fHxGfHx8fHx8IA0KT0JYfDl8U1R8MTk5MjYtNV8lUHJlZF9QcmVeRkVWMS9GVkNfJVByZWRfUHJlXkxOfHwxMDcuMnwlfHx8fHxGfHx8fHx8IA0KT0JYfDEwfFNUfDY5OTcyLThfQmVzdF9QcmVeRkVGIDI1LTc1X0Jlc3RfUHJlXkxOfHwzLjU0fEwvc2VjfHx8fHxGfHx8fHx8IA0KT0JYfDExfFNUfDY5OTcyLThfUHJlZF5GRUYgMjUtNzVfUHJlZF5MTnx8Mi40NXxML3NlY3x8fHx8Rnx8fHx8fCANCk9CWHwxMnxTVHw2OTk3Mi04XyVQcmVkX1ByZV5GRUYgMjUtNzVfJVByZWRfUHJlXkxOfHwxNDQuODN8JXx8fHx8Rnx8fHx8fCANCk9CWHwxM3xTVHwxOTg2OC05X0Jlc3RfUG9zdF5GVkNfQmVzdF9Qb3N0XkxOfHwzLjQ5fEx8fHx8fEZ8fHx8fHwgDQpPQlh8MTR8U1R8MTk4NjgtOV8lUHJlZF9Qb3N0XkZWQ18lUHJlZF9Qb3N0XkxOfHw5OS4yOHwlfHx8fHxGfHx8fHx8IA0KT0JYfDE1fFNUfDIwMTUwLTlfQmVzdF9Qb3N0XkZFVjFfQmVzdF9Qb3N0XkxOfHwzLjF8THx8fHx8Rnx8fHx8fCANCk9CWHwxNnxTVHwyMDE1MC05XyVQcmVkX1Bvc3ReRkVWMV8lUHJlZF9Qb3N0XkxOfHwxMDYuNTN8JXx8fHx8Rnx8fHx8fCANCk9CWHwxN3xTVHwxOTkyNi01X0Jlc3RfUG9zdF5GRVYxL0ZWQ19CZXN0X1Bvc3ReTE58fDg4LjY4fCV8fHx8fEZ8fHx8fHwgDQpPQlh8MTh8U1R8MTk5MjYtNV8lUHJlZF9Qb3N0XkZFVjEvRlZDXyVQcmVkX1Bvc3ReTE58fDEwNy4yfCV8fHx8fEZ8fHx8fHwgDQpPQlh8MTl8U1R8Njk5NzItOF9CZXN0X1Bvc3ReRkVGIDI1LTc1X0Jlc3RfUG9zdF5MTnx8NC43MnxML3NlY3x8fHx8Rnx8fHx8fCANCk9CWHwyMHxTVHw2OTk3Mi04XyVQcmVkX1Bvc3ReRkVGIDI1LTc1XyVQcmVkX1Bvc3ReTE58fDE0NC44M3wlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XkxWTXx8fHx8fHx8fHx8fHx8fHwgDQpPQlJ8Mnx8T0JSXjM0XzEwMDIyMDIzXzEwMzUzNF5MVk18TFZNfHx8MjAyMzAyMTAxMDM1MzR8fHx8fHx8fHx8fHx8fHx8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwyMXxTVHxSVl9CZXN0XlJWX0Jlc3ReTHx8MS4yNnxMfHx8fHxGfHx8fHx8IA0KT0JYfDIyfFNUfFJWX1ByZWReUlZfUHJlZF5MfHwyLjA4fEx8fHx8fEZ8fHx8fHwgDQpPQlh8MjN8U1R8UlZfJVByZWReUlZfJVByZWReTHx8NjAuNjZ8JXx8fHx8Rnx8fHx8fCANCk9CWHwyNHxTVHwxOTg2Mi0yX0Jlc3ReVExDX0Jlc3ReTE58fDUuMDl8THx8fHx8Rnx8fHx8fCANCk9CWHwyNXxTVHwxOTg2Mi0yX1ByZWReVExDX1ByZWReTE58fDYuMjd8THx8fHx8Rnx8fHx8fCANCk9CWHwyNnxTVHwxOTg2Mi0yXyVQcmVkXlRMQ18lUHJlZF5MTnx8ODEuMTZ8JXx8fHx8Rnx8fHx8fCANCk9CWHwyN3xTVHxSVi9UTENfQmVzdF5SVi9UTENfQmVzdF5MfHwyNC44M3wlfHx8fHxGfHx8fHx8IA0KT0JYfDI4fFNUfFJWL1RMQ19QcmVkXlJWL1RMQ19QcmVkXkx8fDMyLjY0fCV8fHx8fEZ8fHx8fHwgDQpPQlh8Mjl8U1R8UlYvVExDXyVQcmVkXlJWL1RMQ18lUHJlZF5MfHw3Ni4wN3wlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XkRMQ098fHx8fHx8fHx8fHx8fHx8IA0KT0JSfDN8fE9CUl4zNF8xMDAyMjAyM18xMDM1MzReRExDT3xETENPfHx8MjAyMzAyMTAxMDM1MzR8fHx8fHx8fHx8fHx8fHx8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwzMHxTVHxCSFRfQmVzdF5Ib2xkVGltZV9CZXN0Xkx8fDExLjIxfHNlY3x8fHx8Rnx8fHx8fCANCk9CWHwzMXxTVHxCSFRfUHJlZF5Ib2xkVGltZV9QcmVkXkx8fDAuMHxzZWN8fHx8fEZ8fHx8fHwgDQpPQlh8MzJ8U1R8QkhUXyVQcmVkXkhvbGRUaW1lXyVQcmVkXkx8fDAuMHwlfHx8fHxGfHx8fHx8IA0KT0JYfDMzfFNUfERMY29fQmVzdF5ETGNvX0Jlc3ReTHx8MjAuNzZ8bUwvbWluL21tSGd8fHx8fEZ8fHx8fHwgDQpPQlh8MzR8U1R8RExjb19QcmVkXkRMY29fUHJlZF5MfHwyMy43MnxtTC9taW4vbW1IZ3x8fHx8Rnx8fHx8fCANCk9CWHwzNXxTVHxETGNvXyVQcmVkXkRMY29fJVByZWReTHx8ODcuNTF8JXx8fHx8Rnx8fHx8fCANCk9CWHwzNnxTVHxWQV9CZXN0XlZBX0Jlc3ReTHx8NS4yM3xMfHx8fHxGfHx8fHx8IA0KT0JYfDM3fFNUfFZBX1ByZWReVkFfUHJlZF5MfHw1LjYyfEx8fHx8fEZ8fHx8fHwgDQpPQlh8Mzh8U1R8VkFfJVByZWReVkFfJVByZWReTHx8OTMuMDJ8JXx8fHx8Rnx8fHx8fCANCk9CWHwzOXxTVHxETGNvL1ZBX0Jlc3ReRExjby9WQV9CZXN0Xkx8fDMuOTd8bUwvbWluL21tSGcvTHx8fHx8Rnx8fHx8fCANCk9CWHw0MHxTVHxETGNvL1ZBX1ByZWReRExjby9WQV9QcmVkXkx8fDQuMjV8bUwvbWluL21tSGcvTHx8fHx8Rnx8fHx8fCANCk9CWHw0MXxTVHxETGNvL1ZBXyVQcmVkXkRMY28vVkFfJVByZWReTHx8OTMuNDF8JXx8fHx8Rnx8fHx8fCANCk9CWHw0MnxTVHxWSV9CZXN0XlZJX0Jlc3ReTHx8My4xNHxMfHx8fHxGfHx8fHx8IA0KT0JYfDQzfFNUfFZJX1ByZWReVklfUHJlZF5MfHwwLjB8THx8fHx8Rnx8fHx8fCANCk9CWHw0NHxTVHxWSV8lUHJlZF5WSV8lUHJlZF5MfHwwLjB8JXx8fHx8Rnx8fHx8fCANCk9CWHw0NXxTVHxETFFBX0Jlc3ReREwgUUFfQmVzdF5MfHxDfEx8fHx8fEZ8fHx8fHwgDQpPQlh8NDZ8U1R8RExRQV9QcmVkXkRMIFFBX1ByZWReTHx8QXxMfHx8fHxGfHx8fHx8IA0KT0JYfDQ3fFNUfERMUUFfJVByZWReREwgUUFfJVByZWReTHx8NzUuMHwlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XlN1bW1hcnkgUmVwb3J0fHx8fHx8fHx8fHx8fHx8fCANCk9CUnw0fHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XlN1bW1hcnkgUmVwb3J0fERMQ098fHwyMDIzMDIxMDEwMzUzNHx8fHx8fHx8fHx8fHx8fHx8UEZ8Rnx8fHx8fHx8fHx8IA0KT0JYfDQ4fEVEfDU4NDc3LTFeUHVsbW9uYXJ5IEZ1bmN0aW9uIFRlc3QgUmVwb3J0XlZTUFVMUnx8XkFQXlBERl5CYXNlNjReSlZCRVJpMHhMalFLSmRQMHpPRUtNU0F3SUc5aWFnbzhQQW92UTNKbFlYUnBiMjVFWVhSbEtFUTZNakF5TXpBeU1USXhORFUwTWpRdE1EVW5NREFuS1FvdlEzSmxZWFJ2Y2loUVJFWnphR0Z5Y0NBeExqTXlMakkyTURndGR5QmNLSGQzZHk1d1pHWnphR0Z5Y0M1dVpYUmNLU2tLTDFCeWIyUjFZMlZ5S0ZCRVJuTm9ZWEp3SURFdU16SXVNall3T0MxM0lGd29kM2QzTG5Ca1puTm9ZWEp3TG01bGRGd3BLUW8rUGdwbGJtUnZZbW9LTWlBd0lHOWlhZ284UEFvdlZIbHdaUzlEWVhSaGJHOW5DaTlRWVdkbGN5QXpJREFnVWdvK1BncGxibVJ2WW1vS015QXdJRzlpYWdvOFBBb3ZWSGx3WlM5UVlXZGxjd292UTI5MWJuUWdOQW92UzJsa2MxczBJREFnVWlBMU9TQXdJRklnTnpNZ01DQlNJRGcxSURBZ1VsMEtQajRLWlc1a2IySnFDalFnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0ZuWlFvdlRXVmthV0ZDYjNoYk1DQXdJRFl4TWlBM09USmRDaTlRWVhKbGJuUWdNeUF3SUZJS0wwTnZiblJsYm5SeklEVWdNQ0JTQ2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEWWdNQ0JTQ2k5SFV6RWdNVEVnTUNCU0NpOUhVeklnTVRVZ01DQlNDaTlIVXpNZ01Ua2dNQ0JTQ2k5SFV6UWdNak1nTUNCU0NpOUhVelVnTXpVZ01DQlNDaTlIVXpZZ016a2dNQ0JTQ2k5SFV6Y2dORE1nTUNCU0NpOUhVemdnTkRVZ01DQlNDaTlIVXprZ05EY2dNQ0JTQ2k5SFV6RXdJRFE1SURBZ1Vnb3ZSMU14TVNBMU1TQXdJRklLTDBkVE1USWdOVE1nTUNCU0NpOUhVekV6SURVMUlEQWdVZ28rUGdvdlJtOXVkQW84UEFvdlJqQWdNVEFnTUNCU0NpOUdNU0F6TUNBd0lGSUtMMFl5SURNMElEQWdVZ28rUGdvdlVHRjBkR1Z5YmdvOFBBb3ZVR0V3SURFeUlEQWdVZ292VUdFeElERTJJREFnVWdvdlVHRXlJREl3SURBZ1Vnb3ZVR0V6SURJMElEQWdVZ292VUdFMElETTJJREFnVWdvdlVHRTFJRFF3SURBZ1Vnb3ZVR0UySURVMklEQWdVZ28rUGdvdlUyaGhaR2x1WndvOFBBb3ZVMmd3SURRMElEQWdVZ292VTJneElEUTJJREFnVWdvdlUyZ3lJRFE0SURBZ1Vnb3ZVMmd6SURVd0lEQWdVZ292VTJnMElEVXlJREFnVWdvdlUyZzFJRFUwSURBZ1VnbytQZ28rUGdvdlIzSnZkWEFLUER3S0wwTlRMMFJsZG1salpWSkhRZ292VXk5VWNtRnVjM0JoY21WdVkza0tMMGtnWm1Gc2MyVUtMMHNnWm1Gc2MyVUtQajRLUGo0S1pXNWtiMkpxQ2pVZ01DQnZZbW9LUER3S0wweGxibWQwYUNBeE56azNNQW92Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsQ2o0K0NuTjBjbVZoYlFwNG5PMTlXNDlrdVkzbXUzOUZ2Q3dHR0tDUGRiOE1CZ2FxeXQwTkREREF6bllETThCaUg3enQydzdhUFdPN3NjYnNyMStSbENMamN2anBSR1ZtWlVibUNUc3JzeU1ZT2hJbFVTUkZmdnp6NGI4ZHZ2cnE4UEYzZi9nL1AzMzZqNTkrL3QxUFAvL2ljREJMamdmVC92ZFYveXRYZC9qaFQrMlRyNnd4aCsvL1gvdXJmL04vMHpjUG4zN3owLy85elYvYnU0ZUQ1Uy9hZzB0TGlDa2ZmL1BYTDc3MjdZLy85WjkvbEs4ZDZHdExLcTc5VzMwK0hQN3loLzcrTDcvOXpoeitNS2crZmovZS9xWjF6eDYrLzMzL2IxY1g3L25aOHBmTmNTblZwb04xWWZHMTllRDdQejA4NmZEOWJ3Ly9hSXozeHNSaVRQaW0vVGJ0eDdXZk5zUVEydS8yUnZ6VTNtdzByZ29kZjViYTc5eCtmM3FnTi81WDMvOTdiNzB1SnR1SEorU0hUOHdTL1BHRFFNMzFwazYvYnBjWTg4UFg0K25YVHo3Z3IvdmVBK3JweVhPK0ZoNzlpN0Q2ZHovOTlwVFIycnc5ekZ6NzhXV3g5V0hTMExjZXZwZmF2OGN2WEh6bHYvL201ejhlUDZGQnRobjYyOGtiNXZCUFovLzE3NmZFNXZEUHB4OHVPYWV6ZncvLzQ5dXpMNXZEbjA3K081clVCdFBlL1BIa3plK09mNTl3NmFTVEorK2VqWFlMSDB6anhDdmtRK3VhZTNvZW5BM29ZamluZzdFblE4RTliOUxtcE4vRXpCOVAvc3MxR1pIOCtHVmswUjAvejJmVC9OMzFRRTY2cTBzaTRaMDVrVUdYVXVoRURsMUxvZ014MmdpLzI1elp0dndlWk0rNTlIbllzN3k5VDZSRGVCQXlvUXNla1JSTkdPWCtYaFk2cGlFQmxrNmIrL3I3NjlHZmpYTGJVbmI2bnI3Z0djczNsMW5LV2ZxM0NidFREbDd6OEl5TGEzeTg1S1JmMGlrblQzbnBQZ2xqN0svUHhla1pLM1JtVElkMnRTQWVPWndjMmdxbVl3cU42VVA3YVJOdDJ5UmJHbHY3Yjl1T0RQdXgvN1RGWUQ4OS9WaWZlUm85R25MdEIyczhQUjNiLzhlaGJHVHQyMS9menhTajhmb1A1K05veXMrWkRPQjlQZlo3dkx1cGptaXF2K2xUK2thbUdZNzExeWRpM1BZbFRyOC9YSXJ0dTVqV2pGWjBlbENsdzlkajVkN1hWTUx4ZmJyY3NlRkNLMy8wZkY0cWlmMHd0aWtzMGJweXJtYXZxbE5uTENIREtsNm9nbVp4cnYvRG41NHFVWWYrem8vbnp5aWlFZEIzTEZQOGNOYkhYTnRiUDE2K1JkK2lmNG84cGx3L3AxdytxTFZQMU9QYjB2RHB0MDU1OC91L255aXhMN3RWYWwxY0xoV2Y4dkhreUNOUi8vRkV6UXNQNHY4ZU5wQ0xkU2toUmp6Z1BpQXlwR21nck5MNC9qZXBPbzBabGdiODRjNEU0NWh0cU9DRVMvR1J3b1A0K0hDSFU0MUdheXRONVoxT1k1eW81dU5BRC9tK1Rybmp6S0VCMG40Y0NtaTQxeGxFNTdnckQrSjJxR1Fra1ZnVVozSDkzZFZzd3NHbWZwWjBzVHYwYmg0MC9XMmZTV2Z4b1UyRkwzN1hXUjcrZnQwNml5OWhvVVdCai9DUC9Rai8xQSt0ajdKcEhyOWhMaHhSRHlzcHVMQ0VhQzhYRXViVStuNWI0OUFGajlhNWRNcW5OUjNuN09pN0VKcG56RURzMkRDbXlmdy95ZmljSmNNR2o1RzlOV1Y0STU5dnZNODFoNkVzZFRxUDliN25NY1gybE5rOERuY0VIUWtmUDNPODJuWEI2NUJtbisyRWV4a3A1KzVHekEyRDdlTjlieFBmK0c0blkyVmRPRjU3ZU43SUZva1RKd1daQk81T3RPTGdLdThqTkNiMk85RHl0WDBKMS9zeWM0NFRsMmVhV3Z3aU1pdmRqY3d5NCtlK1pSYXQ4Wm5Jb2l0REp6NEs5ODJiRkZzVm5leHQ2Slp1SThwVDNReFBkMEhaZDhIRHcxN0pMakRsaVZmK1k4S0RvcTJMTFRrZjlNZ0tkWkZkaEZoaEg4eEtlTkZsZ05GbGlORlZrTkU4ek9nNjBPaHdjRDR2bHhGWHAvRkd1dU5qbzZoUkdYUVJlL1ZhR1hRVmkvV2szTGt0eU13ZXptMmZXVlJadm5ETHBYTmYyQ1JDNnpKRzY0bkMwSjRyZml1NnZsbEJGRmM2Q2VZY0R1UmpYT2dYRGRjNmlwWjdpZHJheExzN3V3TXRjZkYyRnRrMUhHZng1TnFUN0t0dituL0hIdDFGdis4dlBnUTZXOUtsc3lVZVB4dGJaRnlGYzBqUUNMVTI5N2NFNE5Wb24zSlNTOWtTTGRmcWFaT2g0WUU3OE9yWW03dGJKZkQ2TVYrTzlTSjBYbHlWMTFkM2NwdDFKOHNreXpLWk9WNWlQQjhiL2VhdGNYOXpEaU9yZkovU1R5ZVhrM2M4cmZtencwQytPYmxXdVgyT0g1ZTdZQVByaTIvVk5Gbk5CdGx0azdOM2R0dmtldUNQc0UwK2Q2dDllVTM5d3NhNWlnY3FQZGhwQ09ZZUg4U2FlanJKbmhzcTIwV1czRDBJYjB1dWk1TFk0Q3VxN3FhNHp1N2dBSTVvanVPVmFuNGUybnpVdzJOUGgreFpHbkpRcldRcTlVVnhqSkJMZDdZSTR0dGNCTWhsVG1rWjlPUHZiY09pUVhIbWxMOTJCRCt6Tm5YMHg3eHhwV3IzOSs0NjFaUHBWSWZYckFYNWJvMWZhRUxubXM0ZENFM3ppQ1NGZklLWmtPVlF2M1pjbmJocm9NZnYwME1DNE5BaVRwM21vWjRFTG45ekhXWDQyUUo4L1YxZDZEd0lITHA0anU1V2NJU21lYjFaOFo5alhzd3Uvd0dIZHZtL052RFBsUDlQSkF6OXdJdVJ2NnhMUzJXbmZWMXFMWDdyRVdEdHM0V1UyQlNYNUZPR1V1RHEyMmNlaG5MK3pmbDNnZkM1K3ZyVjlwS3YvKzNxdmNzOUp1LzkrL1YzTC9jYUUwNzNtelIzdWVmb1JZZGN1UkpNOVBydTRoMXRMVjU4dHNLeDdSeTlFbFpYWDMvOUhGMlJaUFI2Sm5hdThPT2FHOWU4c0ZlYzJETGtTMUVuNzZXcjBjNUZIcjN5eXJMN1R1UER4VGdSaDJiTDdhdWo5R2lLYk1vazJYWWhzQXVCWFFpOEp5RndUTCtzVFFSY0t4QzNyVmRyRnNJZm1xemFsZkJQNGROYWVDdTkxa0kvNlhVUi9zbWtxeUdnM010TExTNDBxOWJhcHNHZEF2NmRkK2RhajdzMFgrWDE5ZmY2ZWw0Wkxab3YvYk9OS3Y2S0Y0UXdHYzNpYXJQTWwyYXhQNE5Hbk9waTBsd2pkdkVraUN1L1d1Zkh4ZWljaVl2TEcwYjNvV2YyMjdzWm1Xc2pDck54bWRLRFNKN2NubGxacTAxRTBpcmx6R3B2MGpPTXVmb2xrNm4wSnRlcTV4bmRNTHE3VzZzK05vRzl3ZXArdnRXcVd0K3V0cldLODgxMzI3czN0NnAydHkrRVhlMitKTnpWN3JUYjNyc1EySVhBTGdUZXBoQTQydDZwYWFSeE43MVB1N09HZTMzOGZJbnVTTUlYNlN2bytBK3YxMjJkUDQrMkhCcVBhOW11TGJ1ZUpIRk1IUGp3RkdCdTRESTJsTS9WbGlQY0pxdGlhSHpWTERiRjZ5MHlneGpyTEx1QUdSdnZJcWd4ZW9YczJ4U3NpSmlRdytKSUh0RWZvVW9yeDcvalNrUEhqMzdVUG1wMmMyL1dqZ2ZicTRhb0JYc3RLenYyMmFHam9hMTE0WksxSndCbDlFSkh5VTFuNzBVSTNFb0xyME9TbVcxaWpKTDRDRVhRMTU3TjVlaTlOVm5sRjNNU0RsUFhwVjk2YURnOWdjRGJ5TmxwaGo2ejdqbTRYTU1TUTl6RzZ1c0UvdWZqeUJjK05kM0dRNU5EV0Q5MHRKcDhuUmI2bkN5WitKcWZrejBqQkdJYmp6NzJYRXJiY3l2OVcxMDJMdGlsaEkxY0dabW1INzdzUnBwNGZaK1RPK0s2Mjc1bVB2WTFVOWVBeko2UFExOTJ6ZmlVbHNpWjZadFhUZWg1eWMrd2FoUkxXNVNGWUhOWGRKc0NWRmEwQm1hUlhXUFJMMXZEUC8vdUx6OGRmdmdyL1cwT2YvM2hwOVZoMm5Db2g3Lzg3bkQxNFlYNmd4V2dWem5USWJqRjV1M255cFBNNzlNNWFaeGIvRm1BN1dvamNBR3BWc0UydTBDekRMYlpCc0E2dU4wK2dCYkNyVGFDWmlWc3N4T3VMWVhIYlpiVlpUQzNHTFp0T2JUcDlHMjN1dkhRMXJ2UmVqaTNIOVoySGV2a3BVek1oUzBHdzhvT25zdm96Y3pkWkRnOEs2TnJXa3JDeDlrWnU3LzU4a3g2bVJYWXp2akZGcXcwbngwQlEyWCt1QVpiTGE5blhVcGJ6SXZuNVZoMlMzSGIxOUlaeDlKN1dWZk9SaWtMdW5YSGxYZkRtVkRid3IxaHgzMlNIL01TdTIyTFdmYTgzS3E1NlN5ZklaL3lkYjNEOFhwN2E4cjdzdFI4dy9rVzN3MW5tbnA3MjFZTHo3blZWZzJSbTJ4WjVwWmI1OWFGUFd0WDdkbUpSYnVpcHM4VTlXMnErc2tvZlNLSGxGa2YzcmJsaEJjVVdsTEtvc0xMNm1iVi9XeFptZlhsdExxZ3RpeXB1MkZTWEdZeTZYTDdhVnZ2czNtRlhRMnp6NS9PVVJIQ2t1TDBVbXQzVkp4OXVEc3Fyb2IwNmgwVnB4ZWR1NnRoZHpWOHZxc2hudFRiK0xpN0dtNHdmc0oxUmRUeCt2b051aHJhcjNERGpndnZoalBUbTkvYjduNTNad04zZEgyLytWL3R6b2FMenIwN1o4T0dXL1BWSFpmdndPZmdOL2tjM081emVENXpldmM1ckx3ZTZYT0liOWpuME1SUkxidkg0ZUVidThkQmJlWGJlL2M0ME85alBaVHlmdTQzMmtLN1FXTTE3NFV4d1MvVzNzQ1lEeThVei9EaS9xb1NscExqZG5lVkpDOE1LTytRZHZmVlplY3UzRmQ1ajVTNTBaeW0wazM1Vjd1VDVxeHJKeVpqUnFIV3U1T0dPL3JBc2R4WEZVbjQzUlZ4MWJtTDJ1enBEbHdSWVpNcndyK01LK0xiVjZjSTlVVGdXNlR3MDY2Q3o3ZDNYMG02dGIxT3R5NExZK1daL2xkVG9PcFNqTmZ4bGk1aXM4OVMyUDNWaCtta2x0K2ppenFDTEd3YkhJbnhESEt4VjZiMGlZbzEyNVZGL0FBOHZ3YXZmd1lOY0hYRFpaWjZVb1JtRklmc1ZmOUdVcnRnMEF0cy9DaE1jL3I1TllSQVh0eEpqSDIrZnVyRFhEM2doVjFYUlBuY1l0a3dGOTVoeklqVjdhZ0pvblVoZENXQU5PRnpObk51cWZGYTBweE0zZ2s0bDFSYkZ5dCsxSVNpLytaeVFIVWQxQ0V1aGt1emFaUENhOVN2emdzMXpZVVl4c1NQZWdJbnBST05QMEZENkF1R3F4VzVrellHdGxoNUtFSkwzV1dhNDFDdU8zWWhRTEh3dk1YZForTlMwK3ZNbXA4dmpVZUFmbnpPK2prYzJxbm9NMXhCcjNnTnZTNU1FM1MrMUxBNEI4OFhJTitzV3dHMnVtbEx6TnpmRStmcEtxN1dWcVgyYnl2dnJtRkIwYnRybXRZcUh0U3E1MzBGRVVyMjA1cXFWL0phVlV0NWZYZWo3anU3NmJqUlVmM21lSzBnY0Qwem94K0ZUR1lQYTNKd0d3aFpYcjNxU1dzWEpadHd1ZGFSdWI0c0lOd1JxTSsxazRzY3BidEl1WHJ0SW1VWEtjZnU3U0pscTM1U3ZXeWJSOGtUZ1B6M3lqMVRucndjRzcxU2N3aitWK09aMnVBK1dlWDNKcGZKR25ldmI2cmFnckFhQlBoNWFKNE9jZjY1N29vWEdHKzJpOCtieG5zc1dIdXZZM1dtTGpIYkRXUDE1V25IaXVCTGd5SE5hTGZVTG9rZmVkUzM4Nkd1SXlMdmF0VVY4YTVXTWQyeVcyb0g1OTFpL1NxaytpNVVkcUd5QzVWajkzYWhzdGxXcTdKdGRsdHRnNjJtd1pEZGhOcStHM1FQSVdLSmltYlBWZjVmOThETTFQa2JyekhjNzhqVXFXNnBiajVxUXJBL3IvVjByeVAyMFVrMDl6c3gzSDJwU3pKYnh2dTJWallsb3dXL1pkeHZaMjJINGhhWE5xM3RYb2xDQW5MdWRielJOUnRrby9SNmpoSERxS0ZRSHVPcWlYZWNVaGF6Vy94NmhXZjZLSkVhU244UXFpcTFkUHc3S28zMUQzL1VQOHhsTkczSDQvZVVzc1ByVGluYjBYYXZ5SGNJSEkweDdxWWNvbkJ6T3N5N0FvNjFPU3lrODN3V1N0Qzd3ZUFnekpzVWJrNkIrZmljS1RCVERBWVg0MkozREliRGpzRXd1dGo1NUUvSzhIeHBMSVpYdnRHOWlVdEk5NEVXL1RKbnFtOVNwYnd5Zk9pcEtQUzFMQ2x5QnRFdURIZGh1Q1lNcTM1V3YxZGhHRUs1TFpYeDJmRzg1N2hUcFNscWVkL285Tm8zK3VwR1Q3cDU5NlUyK2lRdk83cXdCRHF0Sm5uWmNWTmVkbmlsRUhFeFdCbmx2bFgzclhxNFBFZGVHVWpjclE1YnRVN2ViWklBZU8rMyt1OTFELzVXSHo3MDRuK09IMy9peWIvZGw2OTc4N2Y2ODljOCtsOUFCdXFlL2NNYmxIOWJ3T3EvaEN6YzZMSC9Bc3piNUxuZjRydS96eVBFM2NBcTYrT1M2ZzJIeUFadzlzT2JQM2kzdWZkWEhmeFJkL0MvZmI1dGNmaXZycllQTHl2YVhwaHJxY25UL0JrMldYNEdtK3grdUZZTElkNXM1OXFHd2dHSE4zOGUrRmdFNmVMelRvUjNLOW1DOFVzdDZYTjJLWjBJOWQzeUxkZ2wxNXY0dHFIY3dGUHhUYlUwdHJ0R3Q4L0ViQzd3Yktqek1adVJ6N0E5dG5sZmxFbllOZzEzeUxZdDNoajF3dmpqczNCeDdrRGQ1amk1MFluS0xFOGF5eThjcVZGeHBFNWRxYXVPaExrcjRmWXRQbk9wSHZZdGZ2bmF0L2lHdWh6UHZMVy9yR3RXclF5NnUyYkhkM2JYN1B0MnpVck5BYWZxK240eER6aU5YaVhiRXBuOXp2eTlZWWtoYnArVzkydmVFeFRsZGt2cjQ0bDE3OSt6ZFc5VFdvcTl5VXF0SndITEwzd3g4OEorT0pPYTlueVRyL3hqL3htOCs3QjdmbS8wS1gzUTQwTGZQdGU4RFV1K1JjNlo4Zk9yZDNvcytGQ1dIQit4UXovKzZ2dmQ3M3VELzNMd3JieGJ2dEU5UTc2SmIyOXlsOTdFTTZvWmxIYWUzUlFpMXlSYnFUZHBIOC9Gc3kvcmoxR3FwdTdlbVBHZDNSdnpicjB4ZVhlYStFTTFTekxsQnNFNEs1WjVPTHo5WURsUGFDamJqNUxUak9WM3Erclo0cHJhOGlxTzRMdmhtU1BjbloxaHQzaEt5bEwzSmJaN1NaNDFOaTQzVmZBbSsyc2NBRnp2OWxmdmRLVUYydzZBc051dHUzOWs5NCtzZG1iM2oxeFFmSVovQkgycWY2Wi9nZzNwQndQYSs3UkVmMmxFWXllTDVmOWR6cmxoSDRZbmpGeHIwMVhRMjVrelFIY0R6QndBbytmbDhDajBSRGZEa0ZZbVdWL3VONVhvMUk1dEsrMjNYeTZRUzZySmdvU3JkSzZIWTVnbEdyMnc4YUJKRHlUcmdSZzNscmU4emNjWDJiWDBDdUhtWllvMWlIbkZGeGhOSWdBY3pTWDNIUklYYzAvWTYrSkJFNzJRQ2Z6NWwrTkMyM2w1L1pENTgzcjNqLzEwU21qdXYvNzlZUzJrOStPL0hYNzUzUi9ONGE5L1BIejliNGQvdVhFd1Qra2YzN3AzRUhaTTA4OGlDUUVUbmg4dXlzdUM4dlIvS3VUZERGNi9mbFNmUkRuOWV2MkFmanhlek9UV3dEVmR3cVJNd3ZHSFArbWJRN3NzT0hpSytuNGUrSXhKejcyTmk2czIzVi9QZzYxTHRNbStocDYveEVhZFhuVjgxYStYcGxjZGFnb0UxdFRsS1NvVFB6TlpZUjdsZlJzWGtsdEtMSDVuaEhWcGNYWWpUTTdiNWtTaFduejczamk0NkpicS9iNDUyakdZNERINGpqaVJLNVVNZXZkOENNRXZ4dXdIaDVnK1BxVTN1RGVlTnY3SW1VY1pWeXAzbmhLRDk4RlpaSmRZRkZmUnJWQkxYd0NPRXlqRjIvTjUvNllzdlg5UzNsLzM5U3IrRCt3QlFYNmdxU2RvelF0eWM5YnY2K1dMNmh1YWU0ZWVsek50NHhYdEt1TFAybUNtbmlMVlZ6UzhSVmIxRnIyRTdOKzY3L0NGejlSejlBeVgyU2NlSko4WFg1UHVRdHJpUkhxcW03RXA0TURNbWJUbExQVlBmcGJlT29xWlkraytSakZ6TXIzTUtGNXVsMi9BamtCdXA2M3NuOE1mVEJWR2hiVmJsc2ljdmJkelplS0dlcitNbWJtbDNqRm5zSnZxL1RKbTVyWjZ2NXladWJIZU1XZWdXK3Y5OG1YbTVucS9uSm01dmQ0S1o3NnNreXpjazVQTTNPd2d3NEEzN2RqSytURER1OWtRWmJYNzNJNWYySDF1NjErNFg1OWJmUUdmbTl0OWJwZXZ4L3JjR01pbDdqNDNlZTArdDkzbmRqYkszZWVtVWV3K040Vmk5N2xwRkx2UFRhSFlmVzRheGU1ejB5aDJuOXM2eGU1ejB5aDJuNXRHOFN3K04venAzRUxVZUxOdURWN1pnVnE2cmUyelNMK2FURnhKckgwdytMdzNKa1pCMXpIdGJ4Zmx2Nk5yUDVZUWQ5clBSL252a052UHAvYnpUZnNKN2IzYzZhaU16SXJoZUdFeVltTnh2a0xQRmZZeXl3S2RlRUMvQ2t1cWlremNzcmFQTW1TeFZSV3RhUEYzMWZpbGl2V2FRM20wWXdOczdLZlBIajl4QnRlOU11L0Q2NEV4WVJOajdya01ieXhMU3BydXUrL2FyL1pkZS9YNjg5dll0Zm1PZDYxMWJqSE81bjNiSG1BejMrN2I5dmo2ODl2WXR1bWV0MjJKQW4yN2IxclF6TGY3cGoyKy92dzJObTI4NDAzcnFKeUNMN3VLZkUzdzUzM2J2dWx0Rys1NDJ4SWlxcW1hdi9XV2JldGU1N2I5TXJHRVpsc3NZWjdGRW1ybHhqNGoyTzlKVjBuT1M0aHhYeVNucjVkYkpPRlZMcElRekZMc1V6ako5bFh5Rktza3ZzcFZFazNUNzdMZEQ1eXoxOHV0a3ZTRlZza05WNVliTHVFZWVRZm5qRnVTTDNYRElueFZ1UWpUNlhUZnlJKzM2emVqOUhwaEFlQnFYRnpaWkNqZUYrKzkxN0k1WWdsSHFoZzFLdjlRNHBoTHpveEw3eVFYM3ZMZXE1elNZRzNibEM2L3ZTa3RZenU5QWltcGY2Wi9nbWZ4SkNrcnVoM1JlK1g3TzZMM1lVZjBYdnRzUi9SK2hZamUxbnhCU0crL1Ezby9BdExiWmR1T0NGdDNUTytWdnUrWTNqdW10OWJRanVtOUliSHIvVEJpeC9UZU1iMzdhOGYwSHE4ZDAzdThka3h2ZWUyWTN1TzFZM3Jmb3JidG1ONm5yeHZOcXgxZmFNY1hXdnZ3eGZHRnJIMEJnS0d3QXd4ZHZoNExNTlJzbitoTTJnR0crTFVERE8wQVEyZWozQUdHTklvZFlFaWgyQUdHTklvZFlFaWgyQUdHTklvZFlFaWoyQUdHMWlsMmdDR05ZZ2NZMGloMlVPOFQ4aDNVZTNlNjdVNjN0UTlmM3VubVhzRHBGbmVuMitYcmtVNjNZRVBUdUtyZG5XNzgycDF1dTlQdGJKUzcwMDJqMkoxdUNzWHVkTk1vZHFlYlFyRTczVFNLM2VtbVVleE90M1dLM2VtbVVleE9ONDFpUi9XK2ZMQ2VBOTEwMkFmSEY4TjI5NHptSGZaN3JaMGRIVTMxZklDZHY2T2p2VlowdEIzMmU5KzErNjVkN2NRcjNyVTc3UGUrYmZkdHU5NkpWN3h0ZDlqdmZkUHVtM2F0RTY5NDArNnczL3UyM2JmdGVpZGU4YmJkWWI5WkFDdzdDdXNhZTA1MjJRNzd2UytTSGZaN1h5WHkybUcvOTFVeVhqdnM5MjJYY0R2czkyVlhkdGp2L3RwaHYvbjFSVS8rSGZiNytIbytLYWwvcG4rQ1ovRW9Vd21tdTF3YmdiTTFjUHorOWNUUGw0OVpVbkJWV2xpTXovelhGcW4rRDRlLysrR1B2L25MejM5M3hYdHE0WHBDWGFIM2YxeDkzK1cxVC9UMzE5NjkxZ2YrZFNVVlpac3ZLWGpLY1hHRWkzc3JHUEcyd0trSFp4VkZsQ3N4V00rZXZ2US8vU0g4TDNQNDdYcHJTNm5oN0Y4dHo2bHh5em12NURtNUxKKytSUGJYRytPeE1Zakh4dXc4WG0zdEZoN2JuQUdQNmRPZHgydXQzY1RqaUdRRmZicnplSzIxbTNqc2theWdUM2NlcjdWMkU0OU5Ranh1bis0OFhtdnRGaDRYSkNyS0xpa2V6K0ZZQVlmYmh6dUgxMXE3aGNNZWlRbS9TNGtua01RT0NXTDNoQnllcDV5OEVnT3o4WXdjUVNmL2F2ZjJvcEV0WHBPMHdTOHVOUks3V0t0d3NwRkV5Z1F2U3dBa3hUV1N1RGhOaHc1aHNkU0tYWExRU1VMcmk4OUxTVHBKc1kzRUwwa1RYcTBUdGpUK1Y5Q1h1RVRDdVNCc0JaMmtVazIxdXBTaWthUWx0RUhiUUpRcVNmdTZ0V1l4Nm9NeStTU3RpVlREVFNVaFdBNWpGcXZ5cFUzT29jYkZPNTJncGtNMWk5cENYV0k0bEtUM05MYm54ME5wRStoMWlsd1BPUzlKNDN4YloyMktzMStxMm9halVlWW11cUpPMFppYU1vRnZLeFJ0ZVlSRGFpeFYreEZvN3BJSG81MVRSQnB0YWl4Vng1SVhSOGZzWXJScGlXWEprZjYxMmxOYSt6NVNTeXJIRXNWZlV4dE80MGNiUmJOdFd6OVVhZGw0MWJncHoxSW9NczFjc291MlNsTnRTN0E5U1ozN2JCZGY2VW5hRW16TElrU2VXTzBadVhVejBaUFV4ZEVXWDNiMEtGVlc1YnBVUjg5U0Y4ZWNvbTJDSm45eUlMbXFVSGpLdzJ2OXpWby9TcVFGMXZwcnRkRVdGZzI1TFJGdFlrdWxDU3VHK0xaT1VTMUYrUmEzYUROZm1la2w2R3UwaVpYRzd0YmRxZzJsOG81djNTMmFhSytWNUhicnJxclZXMk5aUXRtbFJKVWswQ25WZWx5cVNwSkk3TGN1MTZTU0ZHSjhMWXRSKzlJRWRrd2ljVlVTdDZRbTJrMFRWMW1sQ1RSMTFHM25WSnBFQStaK2gwZlJGSkpHTkRoMVBWbG5TSGJUNkp6S1l5Zmphc1B6ZWp1QjBOVm9lRW5sRDZHRkorbTZ5aDlYbG1qNWtMWGFDcmVlRjdlbFdnc3FDZmZWT3ErdlArdmJYZzNjSy9VTXRUNlJDS1ZlQmYxWmhlYVNlcVdPS2hoYUV0UXJmWmtHUnl2WituWkVxUnhzdWs0N2UwZ2RNdXF3V0Y4cVlMRTMzYUZwMTlTbnJJNHBzSkpEZlZLRkppbUloZFEzcjBzQjBqUGJNY05hWUhnVVRac2s2bk1DeTR0eUJRTVBMNnRNVHBibktoUkU0MG5aSkJhb3A3aE5pUVNnYmRxTjEya3FEWWhvMUVlMVE2bnhqamlwbW9XMkhTa3hNSTJxWk5sMlpGQzUzK2gwa1cxemxTNDdzTlBiSVViVDNtaUNPaFYwTGlTbVVic3NLaU9SWkoyR2p3YWlxV3FYQytrUHRENVVROFNTK2xxSFBUT2pVVTBWOE9HNnRmV2lTRmZQYmt1Nkd6MEJUdkVFOVBMSEovL2lXd0xkSnUwWEJmb2tUd20rMnlmc2xGNmJzTlJFWHpOTm00N1NSRnZiNS9xRWtTck1Ub0tvK3hGc1l2bW5tOVNlaEJHVEJKM0VpeFNOb0JYU0I1ckExcTF1VHhZRXlmMmlVNUFib1owd0dYZ2ErQkR5K2tIVlNKTG44OWNBVDRPbk05d3U2aVY1NjRUM3JMMVk5VUdaRHp2cmRUT3g4WU9VanFZaUJ0VXFibWRUSkwxWGV3ekpYazh1Z0toSjRNajJWN05JZE5PNzBLblVqaWpWRmpWc3ZVZTFGNG5WKzZRZnBPMDRibXNzRVZpQWJvcTJCVURBZFpxRjU5amN0Y0JZcGZnNWNrTjRZR21TbGVoMERhN1paZTBoUWZjZ05TT1J2Q0dXRnFOQ2tiZ25xaDFhU0JIUHJMS3I5aCtOd3dJSzl0MjFwNmgyVEUyMGNkdXNWOVc4YXlvV0VlaktiTFB1MmtQQTZyU0dYUWVVQTZFM2trZ1ZMa0E2c0hGSEZLb1cxb3lmN01nZ1Z2MDZ0TTlNb1VhU2JyVkZNamxhSzE0My9qTHRsWkowUTZIWlBXMWJsNnI3Tzhqc2FUcHdCZXBYa3h1TkcyMFNkZjNlUmVwbU05S0RPaDZYV1lscnM2VGJMTTB1YW4waFR5VXdqd3pOa0RVVmFIR2UvVUJrWVFJYUo1YXEweVVlT1lIWlJSdUl6eHBOVzliTWFLOWJoa244eFVaM3dKSU41aXpQUnRBZlZVakdrLzJzV3paZXJJUkdveXV3Z2Qyc05Ha3VBWnFhZVViMFZVeWVkcUdwK3JNY3UvWmQxZmRMdnlEdzBJQnNNMUZrWXRYdFRZZGxFS3RZcDJGUnh4T2JBQTFaTGMyZVQzbzdTUzRTZEZjakdZN0c4ZVRyWHFEQU81aG9zbTZrRjVJVnRFQUNJQ0YxaEs0MTFQM1hqbTl1cGlCYlgydzZEOXk0VFhOaUFuMTFOU1VnaUQ5QWYxQ2pvZnNHVE5Qa2VXVWE2RE5JZFN4V2pjYnh3TnRpMVhjb1dhaUphUW9nS1hLN3BEc1ltM3JqbUFUMHh2T01COTFkU2lSa3hkUE8wVHNjV05NTnlBUFVhS2g0YUVDMmJLTXBsV25BcUNLUEN0eW9FRWtVa2doSUN1OVJpN3d5NUhhZ1N6b0xhTHkwRXoyZ1NaRnBDbXFuZXQ3cnVvc2pzdWQ4NGtuS1lpeEU0SEpwTk5rS2pRYzBOVEZOMU5kTzRUT2kwYVFLYUlLMGt3Q0orTWQwVDBrczR0TkxRTitLN0ZObG1nSm9nbGhCSmdFYW5pMXdMMGcwUlo2bHU4S2JQbS9sV2FwQ1RUUmV4cVVmSTQyR3JtNUQwbSs3aUlaYzRkUU84ZzJTL0plVEF2Z1BwVCtxUVVRMFBLTkpsLytKbFc5dUpnTWE2WEhTU1J6SmZhWkpnSVpzeVVaVEE2RGg2L3lzMzIwazBiN29haHFRVkNja09vMlhPYzlBWDI4MDhpUmQxMjRrb1FoTkJqUXBpYmNidFZNa2prSGZOdXhUQnJleGpZRDlIS0hvQmozUmVIbVFSelE4cUNZUUtxRHAvVW1ndzdMV0MzQVlONW9xL2RHdjF1aXlYUHBUQzZCaENWZnBsMDdEZTdpU2VxRFRoTXcwSHBDSVYxNlgyNDJFRjJrRk95OE81MzVBSFNiZGxXalFCWUNWZ2V1V1JxUGh5NFlLanJVa3JoNEtwQ2lBSmdnREt5Q0o0aVhUWmJJNFNaZ0dkVG1Mejg2aUxoZWhjWUNrZGhLOU8xbnVFUXd3YWhxTjdkY3NCZEIwSHlKWWdoSlJROE9xZ0NiMC9qaEFFemYwT1FtTlIyUFB2YytvUDBWb0F1cFBsV25YblNpSkRZaEpPNFVqc1hDZjVacVRmTFVKMEhnck5JQkVlZ01FV0dGQktNNUpuYVpmd09tcU8va0QvYkJkZEpvc1BkYjE2VVJlNHptSjBJQjd4VEkyQlRpSjY1Z3NJSmZaazBLbWxJRTBSZHp6OEg1UzR2d01vdW5pQ1p3Qm9qTlNPeFhSRkJ4VFNEU3g5d2ZSOEpST25pVTNFd2F4T2ZjcFJjMlF5VXRUaXRxcGNUS2wyUkIvK1ZrSjBIUU9Pa1RTTDF3UWpaT3JZbys2NCsyRVBVUlRKeXVzMFFSaFQwWDk2VmZYRmcwOXlRYXNGZEdVY2RtazArUTBXUm1adHpCZVlZMm1YOG5yVmxMbTdUQ1pDeXQzNEdqRloyNWd3aDg3ZG5MSWdLYlBlMER0OUhsM3FNOWVucVhienhSSEorUFNyYTFHRS91elBLS1JaM2swcmhSbis4S1M4NTU1aVBxY1pUMEgxRTZSWjNsRVU5MmNoMVdlcGFzSTJZMjFBY2J1dWtnb2lDSk9TWnkwb29leUVJMXNITjJsMldpOEREd0ZSTk1YYWdVMFFUWmdSTzJFT20rbkh4VWUwU1RwczY3VHlEVVpqd3VRWk5sYkVUWFRsekxpY3Nsem10ckZwVDZqZnJhT3ZhalZVQmI0SVhjZ2lmUTNvVWM1YVFaRUpubjIzOU1pRFlDbXI2NWFFSTIwb3l0WUZDemNoNFhhQ2IwZE5LN1krNU1SVFc4SDBTVFpmZW9SdVVlbG5ORS9OaXFGV2Q2RDNJb1Nsc0kwRXVTR1ZpMWJCVzVCaTVaYkNRdGFSK1NzaVFIdm9kRVppMmk4dVA0am9zbmNqazB6R25TL2tMM0V5cmtsenB1cGlEdERVdmtaZXhMa0lNdjVDRzRJSDNaWmdmTlp4VitJcEVmdFBrVVVpMm5LeEkvUWFGaTRvaWp3MFU1QWg0ckUrdElDczRoRzR0NXFtdE9BV1E4am1xdkFjY21VSmpRdUs3R2hMczVvSnYzWlJDTXJGVWo3SUNwU0lJRU9hR1NUbHRuUTBRWGZvSmwxbVI4MW5ZaUFOUEFnUGdMWWpBemF6dHF3NEk1d0xHUm9LUVpSTUEzYTU5UlJEdUJERFBZU0RBd2Y1Y09jd2QyTmpMc1RXZXhVMUo4ZWNwMW16UVJrMWdkUmZ1SlNaNnM0SWowaWlNTW40dTdRNVJYRnlTTnBXbVZ4d1YzdTVBNGE2ajRrS2VuV2FDcVpKdm9SZTA4aXNrNjhPTllpVm1lTG4wMkZCUFhUaVY1bU5KUHpzZlR6TWM3YUNjaDk0aVg4UGVEenVvaThNSkJHRGdCMDlzbXNHemVqbVkzY1Rjek56aHlMeEg5ZmhBWWQ2V0ZjRFNSNGpFZzdXRG9KalVVTGxYeGRsTzJCK2hQN1pROTZWdkx6ZHZMVXp4Zmthc0FoSDFXUTZYTEFOVGxvSnVJeXk4YUJ3Nm96SGJZMzQ1RGRHc1E5NStDalJCTzJhTko3MG9pRnpRaHpIQnA0MzhSNTFzeEUvZXFDSjgrbUllSmxta1crdzBleHNoeVJuUkE0cWd5cWxIVFBIeU5XVFl1RUJ1a1hOTG5mREtjRjlZVzNlVUwyZWhCWG1RTnhoS09kQUM0cE1xZk1zV1FxczJjRjVCNk9ReWtDR202VVRDdUwzTjV4T09hQXVJakRNK2NSbXltZ0R0NkQ1U2hlTjVCOG1PUHcyRnJVbmVoblVqbU82elNQdXBPRnhxRCtsSDZSaVByVFR4TFlUcFZ4VFVtZ0VJeUxMQXcwOENyeURRNjh1MzNCdGtuRDdRdXNrU1JyR1VVd2ovNUVFQ1ZPREJUajJxQjJ1bXlDejJMM2VrRDZZSlFiYnloV1lwZE5LTk14eW5WUldOQ3dvckRIUXBydUEwTHJxenNOSXRyR3FidHNFVTMzRHNOdFhQcHRDRnBpWlhyRGRWenZGaTZ4NlcxSWtwc0Y5SG0vUUUyQVp1NzZUUktZNFJEL2ttaG9EcmZUamU4WkNkem0yMGlFd1JVeGo2OUcwWWlDZEJmY0g2WnhHMTdRTExBVEdqMG9kbDlMbmRGTVJoM0ZycTUxL3F5SWxrU2NlUTQ3eWF3N1lqeFp4TDlZNXFzbWxvM1BRcEhTamFaekdVMVZ2NllzYU4zaytZeDNXWUxtb1Y5a1ZzU2Mwclh4R2NtRU43bk92RWhwMkJnRmRiblltY3FlaGxvZnB1MGdyMWNhbGk2VUZQMDh5MmdsOS9NTUtCOUpEcENJaFdTTUcyajZlUjltNGdJZWVrbVV2TWwwaGM1Q3RFVjludk5IMUErUHV1TzZpZ0xQSVdFejdMSVI5MDlHWnpDclhnbWZuVVZvb1ByQlFVRUpxLys4TkJKVy8xbWdnbWhxVXNrdGsyRHR2ekFOVkZIWTZaeDFQS0NqQlZXUVoxQXcxQnFOUjlZYXEvOG9ySmo4cHJRS0s3S3lKQk1tVG55MGJJbFZmS2REWmdSbEVjRDdvOEkwQ1RtazZQWTV3VmdDejk3TWhQSVRLVkRBTVUyQmNSUkZRdE5SM0FKWkFLRERscStlRThKQ3lSd0d4VEdiS01xTDFpa0ZqYUhZUG9xR29qZ0pGQVJIcHF4NE1UUWFCdERwQjQ5R2sxbWs1Z3F5RUVSNkZ4Zzl5bTV5V3h6cVR1Q2p0Z1FVMnlmWG5BWEJBeVcrRWJJRjVlZ2xCbmNoTEJPUXp5Q3BNQlZwRUczajBTRlpIWml1S1BISkZZMDlDcVFSMGFCTU5CS3BqVWJYQ2FQd3Azcmc4SXljRFUwMCt0NlNLRU9pMFdHRVFtVVBXUTNBNHFYY2lzUTArdGJwS1o0MWdIeGx5c1NpL2tTUXZpbVhKRFdpUjNHbUg5SG9MQXdTUzBkWWFYbzdScnFjZ1UvZFN6cHB6VUJKOVJKS1R5bmZlazZ6R1B2VWpycFVmZUJ3c1ZxQVZlYzVIcXFSNkJRU2pWZ0JEaUtsSUpPV1duWE1Ec3BrOXRJWmtDOHZnSnVFUjZCT3FHTzNoRE1vTlVLd3hKaEdiMGZpNUNwQUltSEV0Y3J0NkF5MGpGUktOTG9SWkRNTmlOdFJTZGlTZHdiRmpncGlHOUhvOFlxV1k4cm9VYm9UeUZwU1Vxa2RmZWlHUTZxNUNCaUM0bk0wTEE4dUJRM2JrVVFEVVA4WVpNT1pDSnpMaGhGcW5Fa2dEdE53Q0F2VGFNK3FuQkRwRE1nMHE1ek00VXpSQlhObEpBdW5LazZWTDd5Y05icCtVZGxEMlpvQWZUVzAvNmtWMVd0UU9HMkNTTlJEbGlBc0NwT29lNkdkclRWSlgxU29FZzVESkJKVnVTOHNKNGhFZlZEbVd6bml2c3FYekovUkhLcXFORHZGYUxXb3FTS2syOUpDQ1BxbFVYYXl0YjBlNnBBNUpocHVTY3B4RUFHaFJua21TU3dtMFFnZ2NjaWFhUXRQRlRNcHl1bWM5T01uaGVQaHJGSHdtRWxWVUMrN0U0Y2Zrd2FrdXNRb2g5Y3hLSnlhdVVBR0ErbGpFY0FBRjhwcUx3QTJxU3RJQlFSbmtmMVhXTWZVWVpQRVcwdW94b0NFakZ1RTlpcFJTVDNxVnlHUkNJa005bndVOEtzRUlHSHBab2N5OHRRUk8xYThLUWNUUUREVHFVK3ByaG9GWTdWeXVuSFNTZkpJajFZcEtBY1AyV3NTWEFCTnc2NVIwb0pSUVphTitBT0s3Z3FKUmk3aU0raXVHZDRBRHg3VXIwYXFUaEhGYzZNRFlCdHhBRVU0b0NEK0tGWGNTaFlsaWxpTlp0d1VJcTcwaThLTWh0enY5d0R1V0krNzk0aTNBVitFUlVuOFIwNG1JdWxzOFpNUk9RaGlIc1h0Q3RqU1hjQ0FLejFQQmZXa3gwZ1kxRW9QR3dKRDdoRWJlZExab0J2MWcyUUhWRHgvM1I2Nm5pdGhYenF1YW1GY2dJQ0tjdG1mQUo2aVVPaVkvMzVFREtnK2d1RGxBZ3NBaEJPZVltOUZwK2pCVGdZMFVqcW1oQXB6S0FHbUllaW1Sd2lDdDZTbnZnY1dyV1NXcXZGU2duaENScDdxWVdqZHBCVDdac1NvcDJoZ202enBVd2FjTzRrMFZ2WDJnUUt0S3VsVXF2ZVBVR1VpZFZnMW9oTGJJd2pJSlBGZFFnVFE2NVEyZmtBSjg1bFBBSVRrUVY3Y3lyVVFnTktkTXRlUTBIUjdGbmQwQktzMkJLZGhKSEF0eEZoNkNkeENGell1a2dFV0VXcy9TWStCcXh4emxZMk9pZHdXUlZPdU1zb3BNbnljWlpUcDJjeUc5Z1NDR0FCMmI5dHZrbmFsbTgvTjlzZ0l1YWhaYlUxVEkvMFcyUHROVThnVkFTSnlQRWVCejJIMW1MUitCSGZZV3Frb0RjSnhNbk5GT0J1RWswb1Vlcnlma3lnODQ0Q1R3NGxmMUFCMFJzY3VGK0l4Y0NVeEZoc3pXZmQraVo1bFFUQ2t0NEoyR0VBWWdYZXNjbHMwQ1Y0U0NzaWhwSkxJSlpJekFJek9DLzQ2SVJtcTNDRVBJMCtHN2w4VUthemZWWG54Y1R0UXlJWE9BbEpOeVBXbmtRUkJ0SE1JY2pKWXdXOUU4YnFCSTBGb3VoQnFQNWtBSHFYYzA1RXJpTC9Bd3kzeDhtMUs5ZFJPd2tzVUxFUTl6ajJ3c0NJYS9WSTFTQ0NSOThBTkZ5UTB3Z2R3MjBkbmV4YmNSUWRvc3VBdTZpVHNTdVlsaG1nb0d0Y0RTNHV6UHFTZGlDNFNlRVl6dUFBZzFVaHFUdWxpVm5CSGlBYlVJMkFmRDlFQWRFR3htajF3bFZOVVJHUVMzWEV2S1BxOGZYVFlOaGJxakJWWkFBMHBiYjVPa0F5N1NwWUJUWWQ1Qk05aUhOWUFBbGM3U0NHS1pZdHlyeDlRSm4yLzhBcW95RUtVa0krQUV1VWpWOTFnRU5VS2FCZy9ENlc5eUcwOVNRNkFuMWNFYWh5RjFJdTNLeUNKRVlzRWN6dTBUS3VBSmpwZHlEV1NLSWlTRUYyd3g0MTdlTTJabUNZakdrYlBRd1Z5a2xqQkFRWE5ERFEvSk1Eb2FsWmdKeDBnaVFKZnFlK3N4TmUyREUySmJvcXRsTU1EWURzU0hVRHdsWWdteWJNQWNwUmJCQVVUd3ZBSjZDUzYvZzdTWVFDVUpzbkxJU0pvS1Q5d093RlFXaEJreW9pdjdIdC85Q3R5c3F4a1dBQVVLblJZUlRBUG9oQ0ZoRUNHeEhjZTBLSFZFZXNTQWtHTFlpV2pHNmdrWWVNUVQ3S0x1QVRxdGhCRW5KenJnQ0s3R1NwbEdrQ2pJQ0JFcnBwRFF0RVZnc2hHMVJBaDJscWVRVmQyWVpyQlJYTGlFNWhvUUtCTFlWMG1BTkRtSkpmTlJJSnd3TWlaSys0RW5TWkxuU0lFa3RhaE5NR0dxSXVkd1Z1eXk0TFJLMUgwVGhBa1NJZmFTWE9TTEkrQ3dGeFZtQU9pMVl6c3ZReVNPZ1RCU2pSTG5hWS9DWUpLeVl3RFZBVWpoMXBHK2ZYOW9Da0FhcTJET0FVWVgyY0ZKck9BcFVPaFh6SVJxSmtrRTZGYmF0a08yRk9QSGxVRlJWU0hYdXdJUklSR0NramtTUW0xRW1UZ0lNM0p5VEZjRVpQZDBpRkVFYWhTNlFDaHFEdFZxc21neEdVamp3SlFFZUt0RFJWRFRuakpLNFhoaVVGQVJDSHdUUlNBVUYyWWRtUVVhZ2ZDWk9RNVRaRnh3WVIxWTJmODZjVi9LMDRzZGRKbkVOQWQ1Q0N1T0plek40TzZrNFRORUtVZ2g4bks2Tm1UY0NhQ0lJZWpJS0VjeHdyRGFZYXlKM0I2b0hRSDViOEZtYXlLYUtLYmQ2ZmZDWUFzQ0k3R21TeWVJMEp2UnJIUkhhRVhScWtiV2FnVjBjaE5KUWdoVHVOS3hhTmtnSjZFR2FZNVA1TjJZbThIa0NSSmFkZlY4cEVIWVhCNlIwZTM5SWc3UFZVZlpGSm5BU3dCWU1BNWoweDlrTkdUSmRnZHprUWVYQWFaOFhsY1hZRnNrN3dJdUlCQkpCMWJJQUdTSXNnbkZqR24ydG1qaW1Uc3dYYUtJTEZNMm5FOTh6WUNtbzdFRFpJNXk3R1lHcUxwTU1qd1dSMEcyYUUrZDdScGo4WmVaaERRdVF3WVZyQ1lqOGk2QVpEWUdWSnlyb1BOWUtzZlFYTjFKMk1XWnlWRkZnQ1NLS3NIbkd5MXIyVk1JbHNpb2xGMVBOeUl1Tk1sQmtnN09PTGg2a0dYeFl5SjBKMUF4WXdGWDFFN1ZvSXlMQ0J4SFhHNUFob3ZXWGNHdGRNblMwKzdLMmJBVmxvMHJOZ3hjOUd6VXBnL3E4ZVNHTVFlU1JVRUJHVUdhMTNNZ0t6V2MxcUtQVUpXSjBEVDUxT0hGeWgyMlVKUzVqUitockpkck9Ub29qdTZZc2Z1ZzhPS21NZDJuTllWZFRpSGNhT2cwM1RJQkV6VEYyQUZORlhBUWZWN1VLcURKOGhOdXVBbW1nNzBZd0dOVGZOMm5EeExGKzdGaVFLR1hQekZqY3p0Z0o3Vlljb0RhaWRNNHRLSXBvTmE2MW1VeFMwZGd4V1NTRWF3N2swcTdvaWlpRWpxL0ZFRDJyZ0NtZzU3RGR1cHZjdDZPMzVncUFSQVltZHo3c2ZhQVR6MlkrMkErZlJqN2VnbmV2SEh0WVA2MDllT2JvaVdJN0lza0FkSFpObUUyQk1ubU1URkR4UjhOUExVOFVqUXlQTU1qNlQ0QVY2Qk90eWhqZUZFMUEwRDc2anF1cGxld2h5aXA0UWhuRkF6SGFFSHJQWXdFSG9pZXBTYnpybVUvc0hyS3d6QWZUajBIcHlMU3JOMzNQVUlhZko4NkgxOUFZRVJscW40Q2dPUzM2TkhkVlE1c0FiRFdHQUp0ZE1YV0VHelZXZVl6U1dPMDArL0NDNENmeFV0eURwck5EYk1aQ1hYNllPUVFVVFNvU1VLb3VtZ0VLaWRydVhxenBEU29hUWNJQmpRSmdIUjVIbG51aFFza0NaTk9qUEF0ZEdJa2l4QU5BZDVQcVRjd1VuUms3SWdrZ0NOdk9OZUlXUy9FZ2RNcFVGZEZwd1ZoNXJwVUVFRmRibWpyNEV1SjlrTkR0eVdsalIyZys3eXBDUnEyVlhBRUR2Q0RsWFVIemREWmk5SDJDSGRCVlFHcEJBYzFvQ2tSZDN4TTZqQjBrRTNIUER2bEE3ZU1hT1I2YktBSlBvNVNlOHhZazZTSGhzMG9SMW5YUTlQTEdsQW13ZjByTnpCc2hHWGUxb0U3SE1XN25qRXdiNy9nUEdUanZzUExiQ3VLc09GV2pjc3d2a0d6R01ENnI3VDBndXBPWENiUnpUeUxLQ2o1UUZjcnQ4dUVzME1EcW5rQWN6dFVUdE9udVhSMkozc3dBamJrZlVjVVRzZHZTOGhFbm1VUSt6cG16MmdvVXN6SGxHRTJZTFBjb1pPSmxUV1Y0UWt3dU9FQnQ2eDhqd2FlRWZiZ2pSZFp1alJYeVVmYXpPZy92VHlBdzZOYThnTXRDYzZpbTVFazlYUGJMZ25PbnFWUTg4cWNiNG5panpMSWY3VXZ2L1EwcWhwSm5mTGxFQ01LSGhzRmJuWGdSTlJCSmNjQ2wwSlpJUmJRa0p2OE9hVGhPZUlBSGlJSnM2SDd1cHM3UlF4Mk9DY1N5d1FYdStsUXdVdWlJUEJ6UjhWMG16YmxLRWN3TzUwN1FDMjAzSCswR3dObUQ4MEUxMGFBS2xjeE0rTndsZExtVlpxS2FYcjcraEJYWDMzYU53ZFVOdm5HWTNIcTczTWpvZ3k0UG5nNWhzUTFtaFl0ZThJeEw4YVpnZEpFYVBZSVg5QXA1a01mUk5OWHp2NlZOU2g4UUJKV1k4YUR5Q3hjd28vVTFQcVVIY0NwSm1xbm5Xb093SFNpUGdLaURsRDNiR0labFlYcGRGNE4zK1dqM1ArK0RMYlczWElPRFQwTUVQc0xiMkM2R1R0aEJubTV4UFNTSmNUSkptVmpTbDFqdUphNmhDNVFGR3BjMmpWdDB3am1KV3FjckFucTUvUlB6WlovY2h5bnBZL2JhRDU4WEUwZ25sZ0lJMUFtMEtCRmpvOGJKd0pxekFSbnIxNEY5cld2cGQrU3pOQkhVQTRkS2tEUjlXanJXOW5aWFQ2Y1JpUnE2R09lbU1KRGN0SXdRdGJaalNUS1dXVWU0OHU0SXRjQndXc3p0Y1pnUE1EelNiRkJDb2RVMTI5ODlDaDY2azZMQ3VvQzNUTHlzMW1IWHF1ajZvSm5LNnVtc0J6dFh0aTRMQ2M3QnpqWmpTVHBXSHJiTnA3b0JZb0ZDQmdVMXhUWmJvSzQwVDFsYm9yRWFuUXZVWVZXc3pzZTBSbFlJYUJnVkxOUmpzSWQ1KzZmT0JZa1ptdURpL21paFNaQ09oMnF0UE10dFpPczlNOE40MGNKNlhPYWJhMHM5UHNORHZOS1UySFNJTitwSzc2VEZVNlZIZHRXbDN4d1VHRW5VaTlNM00xREt1N3N3SmxnMmFtN3U0MG1LWVhlWU1LM2F4ZzVsRG9BcjVKNkdhRmgyZEZ4eDZFUHRwdXZVR3RyK3VwMEQwdElJYllEOTZMeEVKLytvR0xZS0JoQlNtQ2taQ0N5UmNiR2Q4U3NCcWZVVkJTa1IxWUZuU1BWNlF3QmJyZTVTRFppcTg1NlVZMUdSUm1JQm5wQ1JwTGlYejNLZUFvQTdMcVUwWnJXY29QWkx1ZzBDV3lKSE5DNFI2U0hsa01taXNHdXVVd1RoVFJUSmY2RlBXSEl0REpWcUk0TW4zb25IVWxnVE1LU1phVFJIaXQwV1JpTWswWlNyamp1Z3NGbC80anoycUJTYzZTR0ZwZ0xSSkowcVhhREhyZUM4ZkJpQWRGSXpHTWQyOFEzZ0hudWZLVFZCSzVMNndJSTQ2Z0ZRTFQ2QWdOREhOSUpQcWxUd2ZLcUNpTXRnT0FOQnFkeDhrSkRqV3FyMEpBTElMK0RERm9pb3hjeDZBcDdBV3NLT29tNW1PcERiMmRORXB0NkxJOVNoWnZSVUVhN1VDTGRVYkR5ZThWcVE5UnVGUFJUUXlsdVFZRzRkYmxoY0FHRUkwZVhCZ2tlS2M2aEVNbUFZaFVzVU1sQ1RJVEhvai93QmlGazZJZWtyQlNVWG5ySU1pNzFZTkNTYjVLTlE2UEtsc0lCRWlqMGJQb3ZjUzBVVUVUbFNSS2ZZY0FmSUJld3RncmNrVjd2cHpqWWVrMGdnY0JhNTc0WGh6RWc1eHJWNlNvaHdmNUZvN2pscWdabFVLaVBLc0g4ZFV1Q09TOFIwaU1raVZSQVVRK29ReGFtUWc5b2xUUUNua21JTHFrbFFsVkY0OGw1RFZlRnpvYVpwSjE2b0dDUVhDWU1peGRPdGt3Q3Uvb1ljOVVhY09KVkZFbjNVckNXSFZBODdTU2pWaFJpTHFSdTRVS0szWmtXY3dveXRwSURDZlJxTk51SkN5OG9uUVVJd2tYRmNXZEdvRzh4SDFtbUhsVWtNQktiUVVvZGF2NDF5c0lDYUdpSG5JRXFIcFQ1ZXFSRlVEODF5Z2xiRUIxMkNvNHlSVWtDbFNHL0twRzNjQnkxQk9GR2psZEJUV3pncnF2NU1DZjFMSXFqQURFRjJCcTNZL0VrMWl5dmxsNkhId0JaZ2hsbDFUUlNMVmxSNXB4T3ZUOEVZWEVzZmxGbEJxRm9Mc1ZxK2ZKVXBxc1p4SjFPUlhHRXVDa1pSVXd1ZGRScTNvcm1kRjRlbTY5UWlMUm1nUTlvSFczbDlMTVdaL29YbmN4UngxZ28xY2V6OEFBbHM4WWVxYnFKTFJjcU1DY1N1STVHaU9EbU96TXkxK0szcWtVdE0yeTBZVkw1bXdKVXNQMXJuQkdGSU9PcVYyUmxPa0VqT3hlZUM4bEFKNHRTSWxObDFmWGYySkVJRmJsaTA3Q3BySFhsMjRTdU9KR29vYWFKWWxZU3lCQ2pHRFBwTFNIR3NXU0pLb3lHVDEwS1hXWUN3Qm9rM3FNYkFVUEVwRG1XUFhWM1lIbFVMbkxsQ1hYS2V1V1ljb1NSSlYwUGJpUjhQVjlBcFZ2OHJFS0toaTA2YlhURVVuRXQzVXA5N1RiaExvaU40Y1pQS2RuNEtQZStvNVFBL2dmSnJBVk5FV1NNYVNHTjQ1WkJISmhrQURuWThxai9JcHhrNzRFM1hzMFNQWjZHZWV2MjBPUVVwUEJUVWczUThJc3Z1MWdWQzlEN3JDYm1xWVh6SkJscG5vbmdwZWdTNk52YzBLMERYakpCMy9FektrNlNSUTRQVkNZZzA3bGtQUWpOd1JCQmZhNndoa2tkZGNENzFtSUE0NWNOZE1DSzFVTXJLOCtpQ1VqR1N5cS80UFErakxiQjNvbExVWjRxYnFYT0xMVG93Qk03OGlab3Jub0JtVmtpQ1YyUFNxN2x3RkZrbzZHbS9obU9la2hGWWw5Qndub1pZa0RHYWs2c0s2aHRCRWs0SktUaXRBRWY2bHhQUFB4bUVHR0thRytVTEVMOWNnaUdJUEV1cEJlL0k5N291ckxoWXlERE1LUHhkYko0Q1FTMDU4QTdsUmpoYk04Y3dHR0ZXVUdFTHFXYW14VHpjdERCcXVUU25LMDJjZ1p4UE1iTHR0WWdIU2dlaEZNb1Z2MGpPZFRrTVZLam9GQ2plajJzK1dDN0FYbE1GZ3VmMWRBaVF2THJuQ0p1dFZjTDJ5SFZuQzMydVJHNDBiMXdPL3BPS0t4b29zQUp6cU5zU0NxdzBtbWlVRWhYRjRBcHd5cUJ1RkZzYmNvdjhnTEdvdEZIbDl5L2xWMjlVVGtSTFRNYU4wL1Q3VVFDanU1REhKcGNnRUxpL3lNQWdyblVHQzlsK0EraC9JWENNZy84cVE1NUtvbEY2c3JZQlVMTGo3UjZLNmk0RmlWY2hVVTNmQlNnZ0RCakFWeHczb0VNeE00MXBYTEZlczBMT3A0WWxIUkRRb0E5Q2hxbUxDNXBSQ0czb3hVcC9ZSW16eElBY3RHbzZOakVnaHprU0lYZ0lUVWtVYWl1MWlEaEZCNlZOeWM4RktqRkpVQXRUS1lRRjlkVVJ4UEFjRWJFZzVYbnRHdytjblZYMUJSamw2WkFsU3Y0QXhDTGhnUkFFMlFnaEdvK0RtRERRUEhFUmtNamtsQWJ6elBlQUN4d0pHdldYam53TElkVWdwQ2w2WXhDTW95aXRXZ3U3SEtOR0JVREd3U1VGUjJyKzJCL09WVTI0UDNLQ2ovMFRGZUE1cHhBV2NOS0pnanl0VVBWWGxBN2ZSQ0JycDdPb29GSGRCTmVzeGlMRVJVam9TQjM1bkdBNW9xeFE3MFlLb29hYk5VMGg1ZHJBWnBKd0dTekJSNnRINHNveTRBTEJGaXBVcUJIdHBOUlZ2RkN0SXZCYU5VZ0FvSkZWQ3BMSkpEMGxWSUxrY2l6OUxEb0pQQVE0WUVqcEZrUnAwQ2gyaXkxSjNRdzQ1R3laSUVUdlRFY0hwY284RUNtaUMxRlZCMWxDVHNBYVVlYksrVWtkRDl2NVVlNjFFcWlSV0xTUlVIT2ZQcGdocVFaQ0h4Z0tSWFRkQjNEVlUra2VJQnVyNmUvQ0pQMG5YdEpEN3BrSEVBUlpKNkVSVzEwNUg0OVcyVEJCeGZWenBUa0dvdUJkV05FUlN5VUJCdmdnd0tWWnBLb2pLRkF1NVVrOXpNTkpxTW5sV2xQM3IxaFNRNFc2RUE5RXp5a0F0NnVRNitrT0tBUFFZMWMrU0NrcW9IQUJMQkpkZmxkaVBKdmI0QUlPbnc1Z0YxdU1PYmcwb2pFc2NDUWUyVHdDVVJKTHNGTkIyc1dNOFJTa2tVTktDU1UzVVo4WkxwTWpsMTBDQUVxNTNTZ0lTMnFNdWxRMHNEa2c1Y0MycnZkTndjQTR5YVhzb0dvaytUVDF4b3dCTE1BNVZXdjlkLzhJcURNaXQ1SUcvRFBuZmtiWS9Hbm51ZlVYODY4blpBL2FrZE1odVYxaG5JMnc3UVdEL3Jjdzg3UlNHUmRNc2txTDJJUkhvREJGZ1pXUDBWOVNZS2QwQ3RxU0k0aWdZRXpWQTFvSTR6N0FGTjJVQWlOSHFBVXlwalUxUVVwempRbkNPZ3NYS1ZaQ0NOb01McE1XdEpvZ2trQkU2bjZlSUpuQUYxb0xQQzJrTWQyUmZJbFo2TGo2REFLWTdUejU4bE54TUdzYmtEcmhmVVRBZGNoMkdsSFhCZG4xSzY4KzZyRU5WTDZoeDBpQ1RqR3ptaWNSMGJHWFhIMndsN3NobDRxS0RBZ0pGMGJnVGkzVy9hSXdxcHpVYkFhaEJJUE5HVWNkbWswM1MwVTRQYUtYNnl3cklaOEhLNmxaVE5nTW9GYzJIbFNoaXQrTnh4MlNGLzdOakpPdnBFdG1QZUEycW56N3REZmZieUxGQTB3ZzRjWE4zYXluWUE0WUxLSlhiZ0xIczByaFJuKzhJT01INkwranhRdWxFN0E2VWIwWFNVVzhqRDJySFpVVld1dmpaZ3JTeGg0YXo4MTRTa2d5anIyQVRaaldNQUZQeHhFbXRoY2FCK1h6eTYrWktkaEhVZ2hPVHNSaVVIMkU0L0tqeWlTZEpuWGFlUmF6S0lWWjJkeExOWVlMRlNYVE41RXVKeUIxR0dOTFdMUzMxRy9Xd2RlMUdyb1N6d1ErNUFrZzc2akI3bFp0bndSQ1B0Z0xKVWZxeXVXaEJOQjQ5RzZTU2hEd3UxMHdHU014cFhuTUhjRXMwTXpEcjdJMGF5OXF3OUt1V00vckZSS2FQTW5xQ0UvRW1ubWNEYVVTVStBUUJCaXpaSklpT3MrZGRSYU55c0dRY3lMSEt2TnhCUXFVd3ZxWG9PcVJLZEJ0MHZaRDhRUU9POG1ZcTRNeVNWbjdFblFRNUdpYzRyWmI3TENwelBLdjVDSkQxcTl5bWlNb1dtVFB3SU9Rd2NYOTMxUGRwQldFaEVJNUZ4dWw4amh3SDJVOU9jQnN4NkdORmNCWTZyUS9PamNRMTg0amlqbWZSbkU4ME1hQy8zUWhNQkZkOEtpeVF0NDJabVNIS0RadFpsZnRSMElsQWFiQTRqRlJzMEk0TzJzelpRMHNoWXlOQlM3RlU2RE5ybllSSDdGNWIySEdqdllVWXpZWEIzSStQdVJCWTdGZlZIdUpQVHJCa0VGNVI3ZlpLNDFOa3FqcmllcXhXZ0pOZ2RJOUhRRmtuVDJoR09VSCtjM0VGRDNZY2taWEtUQmVibitsR2RJYWRsUDhDZG9EcGIvR3dxL0VDV0QyVkdNemtmcHhBWm81MkEzQ2QrWUJQQTg3cUl2RENRUmc0QWRQWjFkQWMzbzVtTjNFM01UVDlxb0xrNFc0U29pRndPNDJvZ3dXT2tGd2tOcy8ySGJqT3kxUDZoUXNpb1A3RmY5cUJuOWZxN3NKMDg5Zk9GQVoxdVVKODdYbklPTTVxSnVNeXljZUN3Nmt5SDdjMGduTHNjUmhVSjlDalJoQzJhOU5MaCsyRXpzNm9nVkFQNmdJRndSak1UOWFzTG5qeWJob2lYYVJiNURoK1ZCQWpQSXhvR2EwWHNpd0puQ1ZYVElxRkJvTTVvdnhsT0Mrb0xiL09FN1BVd1lCOXpuTFdEMEVlcE85MENLTE5uSVl5YkhPZlZ6WWltWXB1ZUs0UEhtWmNyRHMrY1IyenV0YTl4aGZGKzhRUkl1c2ZXb3U1RVA1UEtjVnluZWRTZDNNc2d3d3JqL1NJUjlhZWZKTENkWG1WcFNnS0ZvTlJ6Q2dzYWVNZmZnZ1B2Ymwrd2JkSncrd0pySkEwTUpUMnVZUFFuZ2loeFlxQVkxd2ExMDJVVGZGWVdYTkdLdUp6U1RLekVMcHRRamVnNGtJYlJzRHJRc0lVME16anpmQ3hmRnRFMjdpVkNQYUxwM21HNGpYc05SNGVXV0puZWNCM1h1NFZMYkhvYmt1Um1BWDNlTDFCUmJmcTU2L2RZQ2N5ajVkNFI5V0U3M2ZpZWtjQnR2bzFFR0Z3Ujg2U3FDQ0FZVmZvS291azEyOUFzU1BrZ1JEQ0RyaDgwazFGSHNhdHJuVDhyb2lVUlo1N0RORWVUSDQ5Q0dOZEVVK2FySnBhTnowS1IwcGtoSkdCMW9aekdOV1ZCNnliUFo3ekxFalFQL1NLekl1YVVTUm02UVRMaFRhNHpMMUlhTmtaQlhlNGxuS0JFNm1wOW1MYUR2RjVwV0xwUVV2VHpMS09WM004em9IejBLbjBSQzhrWU45RDA4ejdNeEFVODlIb053OGwwaGM1Q3RFVjludk9uZytLajduVGdmRGlza1hvUHp6TngvMlIwQmxmQlZZUm5aeEVhcUg1d1VGREM2bjhTbkVlby9yTkFCZEhVcEpKYkpzSGFmMkVhcUtKWWdVbkkwUElSdEFXTExIamVYQVZOYWE5S2pNS0tjeStTREVIL0pCTW1UbnkwUmtBa3lzd2ZSVmtFOFA2b01FMUNEaW02ZlU0d2xzQ3pOek9oL01UTWdGQkVVMkFjUlpIUWRCUzNRQllBNkxBVnRJK0VUQTBPZytLWVRSVGxSZXVVZ3NaUWJCOUZRMlVFMDVzNmNFNEFBU1FVMGhuSHdhUFJTQkhEREpBZWswanZBcU5IQlFHVWtJVmdpSHhnWkNJUTJ5ZlhuQ1VoUEVpK0Vlb1YvVFFhZTBSRjFPTnZ6VUJGMURXSUtHaTJGUlhBaUJLZlhOSFlZeG80YUxwbkpvcTNoR0N0ZEJyaFQvWEE0U2tWM1JqOFRtOUhBdVV3Vm1GbER4a0U0d3NDbmR0bzlLM1RVenhyQVBuS2xJbEYvWWtnZmJORHlVWDBLQ2ZvWkJHd01FZ3NYYzJvblk0eG1JRlAzVXM2YWMxQVNmVVNTazhwMzNwT3N4ajdOWVA0Tmg4NFhLd1dZTlY1am9lcVJiL1k5eEtOV0N2d2hEdVcvdFNNRGxYWTU3eWdmSGtHQ0NJYWZhODdka3M0ZzFJakhOL1lNSTNlanNUSlZZQkVRbG5sYmVOUk96b0RMUmVhSXhyZENMSU10TVR0cUNSc3lUdURZa2N0WXhZUmpSNnZhRG1takI2bE80R3NKU1dWMmdIUWdCeFM3UXdxaVd2NHlITEdnMHRCdzNZazBlaDJoMkdRRFdjUWFMZGhoQnBuRW9qRE5CekN3alRhc3lvblJEb0RNczBxSjNNNFUzVEJYQm5Kd3FtS1UrVUxMMmVOcmw5VTlsQzJKa0JmR1ptU1dsRzlCb1hUSm9oRVBXUUp3cUl3aWJvWDJ0bGFrL1JGaFNyaE1FUWlVWlg3d25LQ1NOUUhaYjZWSSs2cmZNbjhHYzJocWtxelU0eFdpNW9xUXJvdExZU2dYeHBsSjFzYm9LdG1qb21HV3pJeGZySXpJR0VuU1dKeExmb0dTRW5RWUxNdVpsS1Uwem5weDA4S3g4TlpvK0F4UTd6UHhPSEh2U2FVUW1MWTJ5V0Z3TmRKb3RTUEt3Q3BqVUNxQnk2N1FpRUtVZ0hCV1dUL0ZkWXhkZGdrOGRhMlpaVUFDUm0zWkZPcXlFa2NsZFNqZmhVU2laRElZTTlIQWIraVBDYTFMMTR5OHRRUk8xYThLUWZUNnlSMDZsT3FxMFpoQlhnUjFDTGxtNXFlSHExU1VBNGVzdGNrdUFDYWhsMmpqRlhmUUpMNXd3WnYxRW40SWo2RDdwcmhEZkRnUWYxcXBPb1VIUUZQZFVKS2ZoOHNVaEdOZUJSQXBVTEpva1FScTlSSXowc0FYT2tYaFJrTnVkL3ZBZHl4SG5mdkVXOER2Z2dUQUVQb1pJcEczR3NBeVdHTUNEaVRvOENnMDIwUjZHM1BpZ0hMcWFjamdNZjBHQW1EV3VsaFEyRElQV0lqVHpvTFNrME9rbGNLcUdnUHB2M1BFZ2JSd2JYSi8yRXQxUHVzcVc5Ly9LLy8vT05mVndkaStIK0h2L3hoOWROZmZ2dWRPZnhoL1pzZnYxLy95amZtOEpVOWZQOTd4UUNRemp2K2grVDc5MzlTKy9YOWJ3Ly9hSXl2di9wZUM0MXZ1Mk9ReGFZemhHL2E3OUorVFB1Ny9UYSsvWHcweHJYM3pTZXRtYSsveDVPcGNPL0c2VlFTQmNaa05xYTE0YXpQcFYxTkpWaFBKRENyYVFUV0hQNTVqWmprdzhNLzY0a0ZwUGMxbzJTdFl5N0xaMnQ3NUR2RXNGVm1iRnV5bEhnL2Z0YVhyYjVvVjVjc1dyQVB5elcwdlJhaXVtQWZscXYxNit0c1paWE4xOWlyWmdrWlFkdFlFdDRMU3l4WjFOdDRFdDhOVDVxQ3Q1RW42ZDN3cEdtN0czbVMzd3RQSFBrNnR2R2t2QnVlNU0zSFRuMHVua3dVbDY0ZXJDb3VsL3JGS3VPa21hamtZUDcrN3grblIweDZUNTZ4KysyOWRlYXV1eC9MWFhlZlhMejMyMzFIM3ZJNzduNTJyN3I3cXZuT2NyK1BncW9FbE9MZnVnbnZhcmZObTQwZVA1emI1WmJlUzYvZlBtL0d1WG1sNW5tYmlqK3RmL0pNeHZuVU5VVzNQTTBVZXR5eW5xcGNyMk54Vy9QRUMvZHVXTVFwYXh1WlZGOTJkMjlac2JhNmZjWHVLM1ppZUwrcUZadnF2bUwzRlR0eEtYNnBGZnZxbkNjU1FMNjc3TTlaNHNQdW5yNWdpVFc3Si9hY0pTVy9xTS94RlhJaytTMGMrZmh1T0dJUFlkT3VDZTlLdmxJazJWYXV4QmZ5Mkh2eXV2cEhPczVpYStoRi9IN1VlMlB1dVBjMjUzdnVmYnpubFVNaFUzZmNlNVB1dVBmbG5oZE9ySGZjZVgvUHk4YTYxOVA1SzRQNEh3NS85OE1mZi9PWG4vL3VGNURzRjFzKzB6NVpmMy85WGQyRDlCQm5XQk9WYzAwbmEwS2ZrWWR2Y1QzVms0a3dERXhNQ2xiMStZejc5STBjUGFYZ0VockdLZXVQREY5bjg1WisyTFBEc3lseDFwOXFjYjlzWC92NWQzLzU2ZkREWCtudmRQanJEeitkOWN5NlNKNnp6KzNWaGZwRldTcVovdlcwREVQd1o1eTRWREZQRk10cmRkSnl0REYzMFV1NUxFTWI5L3N6bG8rUVdDOTNhajdMWFpwM1BlNDF5MTFhK05SKzhrTU1MTkdGancvLzdXSy9penN6VjQ2S3A2WnVJdi9rMFN0WktHSmxvVDZlVGhUVzJqRWIxM1QxTXgxOVRUZS9aR2Y3VGNsNUtaK3I1cWM4UFZmSE9UQitmQmlDTUpjWlM0eTI4dC8yMThUUTh5K2U2Tys2M3Y3aS9Pamg5aE9lZkxqa1NUMWpDZC9wOW5VVzR6MnlvZFlsWjlwdG1CSHUxeWZ6Ym1VZDhPOFB0T0h1Y2VBQ2xrSTU3SGprNXB0N1hlR01jMkRtSTNSdEx0MWQ3MlhLSEtRMHhNazQyMXB0MGxsOER6VGVEeFJ4U3o2ci90TU9CdnZwNXZGcmFzdVd3eUk3eXVHa0xMSzhsQnVPaThOMXdNdm5zUEgwSHNxMERpaU11d3hmZjRwRjhkUWphR0lzMGxKSHczQ3ZmeGlVMXUvd0tQSVRyZEMxZDYvZjYrOTgvZE52UC8zSFR6Ly83cWVmZi9IL0FmbW9lVllLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ28ySURBZ2IySnFDanc4Q2k5VWVYQmxMMFY0ZEVkVGRHRjBaUW92WTJFZ01RbytQZ3BsYm1Sdlltb0tOeUF3SUc5aWFnbzhQQW92Vkhsd1pTOUdiMjUwUkdWelkzSnBjSFJ2Y2dvdlFYTmpaVzUwSURFd056a0tMME5oY0VobGFXZG9kQ0EzTURBS0wwUmxjMk5sYm5RZ0xUSTFNUW92Um14aFozTWdNeklLTDBadmJuUkNRbTk0V3kwMU56TWdMVFF4TVNBeE9UazVJREV5T1RoZENpOUpkR0ZzYVdOQmJtZHNaU0F3Q2k5VGRHVnRWaUF3Q2k5WVNHVnBaMmgwSURVd01Bb3ZSbTl1ZEU1aGJXVXZRMFpNVGxCQksxTmxaMjlsVlVrc1VtVm5kV3hoY2dvdlJtOXVkRVpwYkdVeUlEa3hJREFnVWdvK1BncGxibVJ2WW1vS09DQXdJRzlpYWdvOFBBb3ZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxDaTlNWlc1bmRHZ2dOalE0Q2o0K0NuTjBjbVZoYlFwNG5GMlZ5MjdpUUJCRjkwajVoMTRtaXdqM0c2U29KRUlTaWNVOE5NeDhBTEdieU5KZ0xPTXMrUHN4VmRjMW8xbHdKSXA2M2k2Nmw5dmR5NjVyUjdQOFBwenJmUm5Oc2UyYW9Wek9uME5kekh2NWFMdUZkYVpwNnhIZm1QWHAwQzl1d2Z2clpTeW5YWGM4bTZjbnMvd3gvWGdaaDZ1NTN6VG45L0t3L0RZMFpXaTdEM1AvYTd0L1dPNC8rLzUzT1pWdU5CV1JhY3B4eXZMbDBIODluSXBaY3N6anJwbCtic2ZyNHhSeDh6RHM4ZlBhRitNNHdrb245YmtwbC81UWwrSFFmWlM3eFZOVlZaNG1yanpkTFVyWC9PK1F2UVMrSC85R2VJNFF4b3JZRmxla3pGRnM0WTJVYVF1L2lwVHBCVFpIeXZRR215Vmxla1crUU1wazRSZEptUjFzVzFMbU5mMHpwZENoWjdjbVpVaW9rVWlaUFBKbFV1WUFQODR1VEtqaDJVTVlaejlXUkppZ1MrVHN3b3dhbmljUXhua09VWmlaNTU0NXV6Q2dodU11aEFHOTJCZFMrZzM4TnFRTUdUYnVUQmpRbjJXRmhSNDZXNjRvOUtock9aUFFJNS9scVlRZXM5bG5Vdm9WYkR5VjBHTTJ5eE1JL2F5cEpXWEFIdmdOS2VNOEIyK1pNR0RYSEU4dkROQWdiRWlaRU91bDJ3UzF4ZStWbE9rWmZ0S1piQmY2YzN4aXdvQnpDenlwTU0zenNzSkNENTBkS3l3TXM4NjhqVUkvNzJRbVpZTDJ2aUpsd1AvSThRVENnRGtjZHlFTTZDVkVVaWIwYkZsaG9ZUE9sck1MSFdwWS9wY0tIZjZybnI4SkEyeVdzd3M5YWxROHZkQkJnNHBQVE9od2JtRk55Z1FOL0pxVWNiYXRTQm1Sejh2R015UE92T0xwaFE0YVZIeUtRb2V6akJ0U1p1eEc1Q2hoUnF3UHBJenpQYlFtWlVaLzdwV1VBVHZrUkdIWmF1anNLbEw2K1U0TXBNeW9VWEYyb1VNTnk5bUZIalZXODQwKzhibVNlMTN2NzlzZFB6MUVSbCtRK25NWXBzZURYeXQrTlc3dlJkc1ZmZEQ2YzIrbXFOdm5EN3hlaStjS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBadmJuUUtMMU4xWW5SNWNHVXZRMGxFUm05dWRGUjVjR1V5Q2k5RFNVUlRlWE4wWlcxSmJtWnZDanc4Q2k5UGNtUmxjbWx1WnloSlpHVnVkR2wwZVNrS0wxSmxaMmx6ZEhKNUtFRmtiMkpsS1FvdlUzVndjR3hsYldWdWRDQXdDajQrQ2k5R2IyNTBSR1Z6WTNKcGNIUnZjaUEzSURBZ1Vnb3ZRbUZ6WlVadmJuUXZRMFpNVGxCQksxTmxaMjlsVlVrc1VtVm5kV3hoY2dvdlZ5QmJNMXN5TnpOZE9GczRNVGhkT1ZzNE1EQmRNVEZiTXpBeFhURXlXek13TVYweE5Wc3lNVFpkTVRaYk16azVYVEUzV3pJeE5sMHhPRnN6T0RsZE1UbGJOVE01WFRJd1d6VXpPVjB5TVZzMU16bGRNakpiTlRNNVhUSXpXelV6T1YweU5GczFNemxkTWpWYk5UTTVYVEkyV3pVek9WMHlOMXMxTXpsZE1qaGJOVE01WFRJNVd6SXhObDB6TUZzeU1UWmRNekpiTmpnMFhUTXpXelk0TkYwek5sczJORFZkTXpkYk5UY3pYVE00V3pZeE9WMHpPVnMzTURGZE5EQmJOVEExWFRReFd6UTRPRjAwTWxzMk9EWmRORE5iTnpBNVhUUTBXekkyTmwwME5Wc3pOVFpkTkRaYk5UZ3dYVFEzV3pRM01GMDBPRnM0T1RkZE5EbGJOelE0WFRVd1d6YzFNMTAxTVZzMU5qQmROVEpiTnpVelhUVXpXelU1T0YwMU5GczFNekZkTlRWYk5USXpYVFUyV3pZNE4xMDFOMXMyTWpGZE5UaGJPVE0wWFRZd1d6VTFNbDAyTVZzMU56QmROamhiTlRBNFhUWTVXelU0TjEwM01GczBOakZkTnpGYk5UZzRYVGN5V3pVeU1sMDNNMXN6TVRKZE56UmJOVGc0WFRjMVd6VTJOVjAzTmxzeU5ESmROemhiTkRrM1hUYzVXekkwTWwwNE1GczROakZkT0RGYk5UWTFYVGd5V3pVNE5WMDRNMXMxT0RkZE9EUmJOVGc0WFRnMVd6TTBOMTA0TmxzME1qUmRPRGRiTXpNNFhUZzRXelUyTlYwNE9WczBOemxkT1RCYk56SXlYVGt4V3pRMU9GMDVNbHMwT0ROZE1UTXhXek0zTmwxZENqNCtDbVZ1Wkc5aWFnb3hNQ0F3SUc5aWFnbzhQQW92Vkhsd1pTOUdiMjUwQ2k5VGRXSjBlWEJsTDFSNWNHVXdDaTlGYm1OdlpHbHVaeTlKWkdWdWRHbDBlUzFJQ2k5VWIxVnVhV052WkdVZ09DQXdJRklLTDBKaGMyVkdiMjUwTDBOR1RFNVFRU3RUWldkdlpWVkpMRkpsWjNWc1lYSUtMMFJsYzJObGJtUmhiblJHYjI1MGMxczVJREFnVWwwS1BqNEtaVzVrYjJKcUNqRXhJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LTVRJZ01DQnZZbW9LUER3S0wxUjVjR1V2VUdGMGRHVnliZ292VUdGMGRHVnlibFI1Y0dVZ01Rb3ZVR0ZwYm5SVWVYQmxJREVLTDFScGJHbHVaMVI1Y0dVZ013b3ZUV0YwY21sNElGc3dMamMxSURBZ01DQXRNQzQzTlNBek16TXVNek1nTkRNeUxqZzVNVjBLTDBKQ2IzaGJNQ0F3SURFMElEbGRDaTlZVTNSbGNDQXlPQW92V1ZOMFpYQWdNVGdLTDFKbGMyOTFjbU5sY3dvOFBBb3ZVSEp2WTFObGRDQmJMMUJFUmk5VVpYaDBMMGx0WVdkbFFpOUpiV0ZuWlVNdlNXMWhaMlZKWFFvdlJYaDBSMU4wWVhSbENqdzhDaTlIVXpBZ01UTWdNQ0JTQ2o0K0NpOVlUMkpxWldOMENqdzhDaTlHYlRBZ01UUWdNQ0JTQ2o0K0NqNCtDaTlNWlc1bmRHZ2dPRE1LUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXdMams1TkNBd0lEQWdNQzQ1T1RRZ01DQXdJR050Q2lBZ0wwZFRNQ0JuY3dvZ0lDOUdiVEFnUkc4S1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveE15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDakUwSURBZ2IySnFDanc4Q2k5VWVYQmxMMWhQWW1wbFkzUUtMMU4xWW5SNWNHVXZSbTl5YlFvdlFrSnZlRnN3SURjdU9Ua3lJREV6TGpBNE55QXRNQzR3TmpSZENpOU5ZWFJ5YVhnZ1d6RWdNQ0F3SURFZ01DQXdYUW92VEdWdVozUm9JRE15TWdvK1BncHpkSEpsWVcwS2NTQWxJQzB0SUVKbFoybHVRMjl1ZEdWdWRBb2dJQzB4TURBZ1ZIb0tJQ0J4Q2lBZ2NTQWxJQzB0SUdKbFoybHVJRlpwYzNWaGJBb2dJQ0FnY1NBbElDMHRJR0psWjJsdUlFTmhiblpoY3dvZ0lDQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1VHRjBhQW9nSUNBZ0lDQWdJREF1TWpBNElEQXVOak14SURBdU1UY3pJQ0J5WndvZ0lDQWdJQ0FnSURFMExqQTROeUE0TGpreU9DQnRDaUFnSUNBZ0lDQWdOeTR5TnpjZ01DQnNDaUFnSUNBZ0lDQWdNQ0E0TGpreU9DQnNDaUFnSUNBZ0lDQWdNVFF1TURnM0lEZ3VPVEk0SUd3S0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ1pnb2dJQ0FnSUNCUklDVWdMUzBnWlc1a0lGQmhkR2dLSUNBZ0lGRWdKU0F0TFNCbGJtUWdRMkZ1ZG1GekNpQWdVU0FsSUMwdElHVnVaQ0JXYVhOMVlXd0tJQ0JSQ2xFZ0pTQXRMU0JGYm1SRGIyNTBaVzUwQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9LTVRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnb3hOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJRE16TXk0ek15QTBNVFl1TVRRMlhRb3ZRa0p2ZUZzd0lEQWdNVFFnT1YwS0wxaFRkR1Z3SURJNENpOVpVM1JsY0NBeE9Bb3ZVbVZ6YjNWeVkyVnpDanc4Q2k5UWNtOWpVMlYwSUZzdlVFUkdMMVJsZUhRdlNXMWhaMlZDTDBsdFlXZGxReTlKYldGblpVbGRDaTlGZUhSSFUzUmhkR1VLUER3S0wwZFRNQ0F4TnlBd0lGSUtQajRLTDFoUFltcGxZM1FLUER3S0wwWnRNQ0F4T0NBd0lGSUtQajRLUGo0S0wweGxibWQwYUNBNE13bytQZ3B6ZEhKbFlXMEtjU0FsSUMwdElFSmxaMmx1UTI5dWRHVnVkQW9nSURBdU9UazBJREFnTUNBd0xqazVOQ0F3SURBZ1kyMEtJQ0F2UjFNd0lHZHpDaUFnTDBadE1DQkVid3BSSUNVZ0xTMGdSVzVrUTI5dWRHVnVkQXBsYm1SemRISmxZVzBLWlc1a2IySnFDakUzSURBZ2IySnFDanc4Q2k5VWVYQmxMMFY0ZEVkVGRHRjBaUW92UVVsVElHWmhiSE5sQ2k5Q1RTOU9iM0p0WVd3S0wwTkJJREVLTDJOaElERUtMMjl3SUdaaGJITmxDaTlQVUNCbVlXeHpaUW92VTBFZ2RISjFaUW92VTAxaGMyc3ZUbTl1WlFvK1BncGxibVJ2WW1vS01UZ2dNQ0J2WW1vS1BEd0tMMVI1Y0dVdldFOWlhbVZqZEFvdlUzVmlkSGx3WlM5R2IzSnRDaTlDUW05NFd6QWdOeTQ1T1RJZ01UTXVNRGczSUMwd0xqQTJORjBLTDAxaGRISnBlQ0JiTVNBd0lEQWdNU0F3SURCZENpOU1aVzVuZEdnZ016QXdDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ0xURXdNQ0JVZWdvZ0lIRUtJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1ZtbHpkV0ZzQ2lBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnUTJGdWRtRnpDaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01TQXdMakF3T0NBd0lDQnlad29nSUNBZ0lDQWdJREFnTUNCdENpQWdJQ0FnSUNBZ05pNDRNU0E0TGpreU9DQnNDaUFnSUNBZ0lDQWdNVFF1TURnM0lEQWdiQW9nSUNBZ0lDQWdJREFnTUNCc0NpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pFNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tNakFnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0YwZEdWeWJnb3ZVR0YwZEdWeWJsUjVjR1VnTVFvdlVHRnBiblJVZVhCbElERUtMMVJwYkdsdVoxUjVjR1VnTXdvdlRXRjBjbWw0SUZzd0xqYzFJREFnTUNBdE1DNDNOU0F6TXpNdU16TWdNems1TGpRd01WMEtMMEpDYjNoYk1DQXdJREUwSURsZENpOVlVM1JsY0NBeU9Bb3ZXVk4wWlhBZ01UZ0tMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTWpFZ01DQlNDajQrQ2k5WVQySnFaV04wQ2p3OENpOUdiVEFnTWpJZ01DQlNDajQrQ2o0K0NpOU1aVzVuZEdnZ09ETUtQajRLYzNSeVpXRnRDbkVnSlNBdExTQkNaV2RwYmtOdmJuUmxiblFLSUNBd0xqazVOQ0F3SURBZ01DNDVPVFFnTUNBd0lHTnRDaUFnTDBkVE1DQm5jd29nSUM5R2JUQWdSRzhLVVNBbElDMHRJRVZ1WkVOdmJuUmxiblFLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ295TVNBd0lHOWlhZ284UEFvdlZIbHdaUzlGZUhSSFUzUmhkR1VLTDBGSlV5Qm1ZV3h6WlFvdlFrMHZUbTl5YldGc0NpOURRU0F4Q2k5allTQXhDaTl2Y0NCbVlXeHpaUW92VDFBZ1ptRnNjMlVLTDFOQklIUnlkV1VLTDFOTllYTnJMMDV2Ym1VS1BqNEtaVzVrYjJKcUNqSXlJREFnYjJKcUNqdzhDaTlVZVhCbEwxaFBZbXBsWTNRS0wxTjFZblI1Y0dVdlJtOXliUW92UWtKdmVGc3dJRGN1T1RreUlERXpMakE0TnlBdE1DNHdOalJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lETXdNQW8rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lDMHhNREFnVkhvS0lDQnhDaUFnY1NBbElDMHRJR0psWjJsdUlGWnBjM1ZoYkFvZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUVOaGJuWmhjd29nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lERWdNQzR3TURnZ01DQWdjbWNLSUNBZ0lDQWdJQ0F3SURBZ2JRb2dJQ0FnSUNBZ0lEWXVPREVnT0M0NU1qZ2diQW9nSUNBZ0lDQWdJREUwTGpBNE55QXdJR3dLSUNBZ0lDQWdJQ0F3SURBZ2JBb2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQm1DaUFnSUNBZ0lGRWdKU0F0TFNCbGJtUWdVR0YwYUFvZ0lDQWdVU0FsSUMwdElHVnVaQ0JEWVc1MllYTUtJQ0JSSUNVZ0xTMGdaVzVrSUZacGMzVmhiQW9nSUZFS1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveU15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDakkwSURBZ2IySnFDanc4Q2k5VWVYQmxMMUJoZEhSbGNtNEtMMUJoZEhSbGNtNVVlWEJsSURFS0wxQmhhVzUwVkhsd1pTQXhDaTlVYVd4cGJtZFVlWEJsSURNS0wwMWhkSEpwZUNCYk1DNDNOU0F3SURBZ0xUQXVOelVnTXpNekxqTXpJRE00TWk0Mk5UWmRDaTlDUW05NFd6QWdNQ0F4TkNBNVhRb3ZXRk4wWlhBZ01qZ0tMMWxUZEdWd0lERTRDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURJMUlEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURJMklEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEZ3pDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01DNDVPVFFnTUNBd0lEQXVPVGswSURBZ01DQmpiUW9nSUM5SFV6QWdaM01LSUNBdlJtMHdJRVJ2Q2xFZ0pTQXRMU0JGYm1SRGIyNTBaVzUwQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9LTWpVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnb3lOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVlUMkpxWldOMENpOVRkV0owZVhCbEwwWnZjbTBLTDBKQ2IzaGJNQ0EzTGprNU1pQXhNeTR3T0RjZ0xUQXVNRFkwWFFvdlRXRjBjbWw0SUZzeElEQWdNQ0F4SURBZ01GMEtMMHhsYm1kMGFDQXpNaklLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdMakl3T0NBd0xqWXpNU0F3TGpFM015QWdjbWNLSUNBZ0lDQWdJQ0F4TkM0d09EY2dPQzQ1TWpnZ2JRb2dJQ0FnSUNBZ0lEY3VNamMzSURBZ2JBb2dJQ0FnSUNBZ0lEQWdPQzQ1TWpnZ2JBb2dJQ0FnSUNBZ0lERTBMakE0TnlBNExqa3lPQ0JzQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNCUklDVWdMUzBnWlc1a0lFTmhiblpoY3dvZ0lGRWdKU0F0TFNCbGJtUWdWbWx6ZFdGc0NpQWdVUXBSSUNVZ0xTMGdSVzVrUTI5dWRHVnVkQXBsYm1SemRISmxZVzBLWlc1a2IySnFDakkzSURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5SRVpYTmpjbWx3ZEc5eUNpOUJjMk5sYm5RZ01UQTNPUW92UTJGd1NHVnBaMmgwSURjd01Bb3ZSR1Z6WTJWdWRDQXRNalV4Q2k5R2JHRm5jeUF6TWdvdlJtOXVkRUpDYjNoYkxUVTNNeUF0TkRNeElERTVPVGtnTVRJNU9GMEtMMGwwWVd4cFkwRnVaMnhsSURBS0wxTjBaVzFXSURBS0wxaElaV2xuYUhRZ05UQXdDaTlHYjI1MFRtRnRaUzlWVWt4U1VGZ3JVMlZuYjJWVlNTeENiMnhrQ2k5R2IyNTBSbWxzWlRJZ09USWdNQ0JTQ2o0K0NtVnVaRzlpYWdveU9DQXdJRzlpYWdvOFBBb3ZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxDaTlNWlc1bmRHZ2dNelEzQ2o0K0NuTjBjbVZoYlFwNG5GMlNUNHVETUJERjc0VitoeHpiUTFGVEUxc29BNlhkZ29mOXc3cjdBYXdaaTdER0VPM0JiNzh4Q2JPd0IzK1F5WHZKeEhuSnBieVd1cHRZOG1HSHBzS0p0WjFXRnNmaGFSdGtkM3gwZXBWeHBycG1paXZQcHEvTmFqRlg4emhoWCtwMllLY1RTejdkNWpqWm1XM09hcmpqTm5tM0NtMm5IMnp6ZmFtMlNmVTA1Z2Q3MUJOTEFaakMxcDN5V3B1M3VrZVdlTSt1Vkc2N20rYWRjeXdLNWhWZnMwSEd2U01MblRTRHd0SFVEZHBhUDNDOU9xVnB1Z2RIY1lEMUNyWDZMK0JwTU43YlB3Yy9BakdYNEd0N3Z3b1VzY1lsRVBOOTFKMkJLSXBReTNNZ3lpelVoQUJpd1dNdEE2SjhpZDRMRU9VeDF2enBnVExlSVNRUWk5aExlSGtnVDJQUEJSQmRSOEY3QUdJaDRqdThJbEJFWGU0VmdUTHFSQUhFSXVxeUt4RGRud2ozM29Eb1hoUHVTSUdZWDJPTkF6Ry9oWm5SYkpiNXVaQXhTa2Z6dE5ZRnd5ZlJKMkxKUXFlUndtb0d3NXhyK1g0QmdFeThBUXBsYm1SemRISmxZVzBLWlc1a2IySnFDakk1SURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5RS0wxTjFZblI1Y0dVdlEwbEVSbTl1ZEZSNWNHVXlDaTlEU1VSVGVYTjBaVzFKYm1adkNqdzhDaTlQY21SbGNtbHVaeWhKWkdWdWRHbDBlU2tLTDFKbFoybHpkSEo1S0VGa2IySmxLUW92VTNWd2NHeGxiV1Z1ZENBd0NqNCtDaTlHYjI1MFJHVnpZM0pwY0hSdmNpQXlOeUF3SUZJS0wwSmhjMlZHYjI1MEwxVlNURkpRV0N0VFpXZHZaVlZKTEVKdmJHUUtMMWNnV3pOYk1qYzFYVEk1V3pJM01GMHpPRnMyTWpSZE16bGJOek0zWFRReFd6VXlNRjAwTjFzMU1URmRORGhiT1RVM1hUVXdXemMxT0YwMU5WczFPRFZkTlRkYk5qWTJYVFU0V3pFd01EUmROamhiTlRNNFhUY3lXelUwTVYwM05GczJNVGxkTnpaYk1qZzBYVGd4V3pZd05GMDROVnN6T1RkZE9EWmJORE01WFRnM1d6TTRPVjA0T0ZzMk1EUmRYUW8rUGdwbGJtUnZZbW9LTXpBZ01DQnZZbW9LUER3S0wxUjVjR1V2Um05dWRBb3ZVM1ZpZEhsd1pTOVVlWEJsTUFvdlJXNWpiMlJwYm1jdlNXUmxiblJwZEhrdFNBb3ZWRzlWYm1samIyUmxJREk0SURBZ1Vnb3ZRbUZ6WlVadmJuUXZWVkpNVWxCWUsxTmxaMjlsVlVrc1FtOXNaQW92UkdWelkyVnVaR0Z1ZEVadmJuUnpXekk1SURBZ1VsMEtQajRLWlc1a2IySnFDak14SURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5SRVpYTmpjbWx3ZEc5eUNpOUJjMk5sYm5RZ01UQTNPUW92UTJGd1NHVnBaMmgwSURjd01Bb3ZSR1Z6WTJWdWRDQXRNalV4Q2k5R2JHRm5jeUF6TWdvdlJtOXVkRUpDYjNoYkxUVTNNeUF0TkRJM0lERTVPVGtnTVRJNU9GMEtMMGwwWVd4cFkwRnVaMnhsSURBS0wxTjBaVzFXSURBS0wxaElaV2xuYUhRZ05UQXdDaTlHYjI1MFRtRnRaUzlNV1ZoVlNGVXJVMlZuYjJWVlNWTmxiV2xpYjJ4a0xGSmxaM1ZzWVhJS0wwWnZiblJHYVd4bE1pQTVNeUF3SUZJS1BqNEtaVzVrYjJKcUNqTXlJREFnYjJKcUNqdzhDaTlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1VLTDB4bGJtZDBhQ0EwTWprS1BqNEtjM1J5WldGdENuaWNYWlBCaXVNd0RJYnZoYjZEanpPSGtzU3lreGFLb0pPWlFnODd1MnhuSHlCTjNCTFlPc0ZORDMzN2NTeFZDM3ZJQi9tajM1WVVLYXNQN3dmZlR5cjdGWWIyNkNaMTduMFgzRzI0aDlhcGs3djBmbEZvMWZYdHhHK0o3YlVaRjdQNStMaE43bnJ3NTBGdHR5cjdIVC9lcHZCUUw3dHVPTG5YN0dmb1hPajlSYjM4cVkrdjJmRStqbi9kMWZsSjVZaXFjK2Q0eW85bS9HeXVUbVhKc3pwMDhYTS9QVmJSTVVlb0ZQSDFHSjNTeVZGUUp1M1F1ZHZZdEM0MC91S1dpMjJlNSs4WWFTdGNMcHp2L2c4QVM4YlQrWitqS0ZFSWdLUVZLTlFmckwyaEVOYXNWU2dFdzFxTlF0aXdabEFJQldzN0ZFTEZHcUFRY3RZMktJU1N0VFVLd1pLbVV3VFJjQnhzVUdoWjA2bFNvdUY2cVd0RXZlTzRkRHJSOEIyRlJxSGVjOXdlaGFibWV3c1VtbWYvMHVsRTREc0FVR2k1WG10UldHblNER1dSV0hJdUpuV2RXSEx2VFkzQ2tudHZTaFNXWEsrdFVGaXhGOVlvdE05NlV4WkU0RnlnUXFGbHI5NmgwUEMvQkl0Q3kxNmRYRVR6dkZlajBEeDdtaWFGYUhoZTRod0t6UnZOdDh6eFBPdHhJWlZzVW5zUElTNVIydHEwUGZQZTlON0pZby9EcUtKcmZyNEJ3cC8yYVFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNeklEQWdiMkpxQ2p3OENpOVVlWEJsTDBadmJuUUtMMU4xWW5SNWNHVXZRMGxFUm05dWRGUjVjR1V5Q2k5RFNVUlRlWE4wWlcxSmJtWnZDanc4Q2k5UGNtUmxjbWx1WnloSlpHVnVkR2wwZVNrS0wxSmxaMmx6ZEhKNUtFRmtiMkpsS1FvdlUzVndjR3hsYldWdWRDQXdDajQrQ2k5R2IyNTBSR1Z6WTNKcGNIUnZjaUF6TVNBd0lGSUtMMEpoYzJWR2IyNTBMMHhaV0ZWSVZTdFRaV2R2WlZWSlUyVnRhV0p2YkdRc1VtVm5kV3hoY2dvdlZ5QmJNVE5iTkRNMFhURTNXekkwTVYweE9GczBNVE5kTVRsYk5UVTFYVEl3V3pRd01sMHlNVnMxTlRWZE1qSmJOVFUxWFRJeld6VTNObDB5TkZzMU5UVmRNalZiTlRVNFhUSTJXelV6TmwweU4xczFOVFZkTWpoYk5UVTRYVEk1V3pJME1WMHpObHMyTnpGZE16aGJOakl4WFRNNVd6Y3hOMTAwTUZzMU1UZGROREZiTlRBeVhUUXlXelk1TjEwME5sczJNVEJkTkRkYk5EZzRYVFE1V3pjMk4xMDFNRnMzTlRWZE5URmJOVGcwWFRVeld6WXlNbDAxTlZzMU5URmROVFpiTnpBelhUVTNXelkwTVYwM01GczBOekJkTnpGYk5qQXlYVGN5V3pVek1WMDNObHN5TmpGZE9EVmJNemN3WFRnM1d6TTJNVjFkQ2o0K0NtVnVaRzlpYWdvek5DQXdJRzlpYWdvOFBBb3ZWSGx3WlM5R2IyNTBDaTlUZFdKMGVYQmxMMVI1Y0dVd0NpOUZibU52WkdsdVp5OUpaR1Z1ZEdsMGVTMUlDaTlVYjFWdWFXTnZaR1VnTXpJZ01DQlNDaTlDWVhObFJtOXVkQzlNV1ZoVlNGVXJVMlZuYjJWVlNWTmxiV2xpYjJ4a0xGSmxaM1ZzWVhJS0wwUmxjMk5sYm1SaGJuUkdiMjUwYzFzek15QXdJRkpkQ2o0K0NtVnVaRzlpYWdvek5TQXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDak0ySURBZ2IySnFDanc4Q2k5VWVYQmxMMUJoZEhSbGNtNEtMMUJoZEhSbGNtNVVlWEJsSURFS0wxQmhhVzUwVkhsd1pTQXhDaTlVYVd4cGJtZFVlWEJsSURNS0wwMWhkSEpwZUNCYk1DNDNOU0F3SURBZ0xUQXVOelVnTkRFekxqRTROU0F5T0RjdU1qSXhYUW92UWtKdmVGc3dJREFnTVRRZ09WMEtMMWhUZEdWd0lESTRDaTlaVTNSbGNDQXhPQW92VW1WemIzVnlZMlZ6Q2p3OENpOVFjbTlqVTJWMElGc3ZVRVJHTDFSbGVIUXZTVzFoWjJWQ0wwbHRZV2RsUXk5SmJXRm5aVWxkQ2k5RmVIUkhVM1JoZEdVS1BEd0tMMGRUTUNBek55QXdJRklLUGo0S0wxaFBZbXBsWTNRS1BEd0tMMFp0TUNBek9DQXdJRklLUGo0S1BqNEtMMHhsYm1kMGFDQTRNd28rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lEQXVPVGswSURBZ01DQXdMams1TkNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tNemdnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXekFnTnk0NU9USWdNVE11TURnM0lDMHdMakEyTkYwS0wwMWhkSEpwZUNCYk1TQXdJREFnTVNBd0lEQmRDaTlNWlc1bmRHZ2dNekF3Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdMVEV3TUNCVWVnb2dJSEVLSUNCeElDVWdMUzBnWW1WbmFXNGdWbWx6ZFdGc0NpQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1EyRnVkbUZ6Q2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNU0F3TGpBd09DQXdJQ0J5WndvZ0lDQWdJQ0FnSURBZ01DQnRDaUFnSUNBZ0lDQWdOaTQ0TVNBNExqa3lPQ0JzQ2lBZ0lDQWdJQ0FnTVRRdU1EZzNJREFnYkFvZ0lDQWdJQ0FnSURBZ01DQnNDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0JSSUNVZ0xTMGdaVzVrSUVOaGJuWmhjd29nSUZFZ0pTQXRMU0JsYm1RZ1ZtbHpkV0ZzQ2lBZ1VRcFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqTTVJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LTkRBZ01DQnZZbW9LUER3S0wxUjVjR1V2VUdGMGRHVnliZ292VUdGMGRHVnlibFI1Y0dVZ01Rb3ZVR0ZwYm5SVWVYQmxJREVLTDFScGJHbHVaMVI1Y0dVZ013b3ZUV0YwY21sNElGc3dMamMxSURBZ01DQXRNQzQzTlNBME1UTXVNVGcxSURJM01DNDBOelpkQ2k5Q1FtOTRXekFnTUNBeE5DQTVYUW92V0ZOMFpYQWdNamdLTDFsVGRHVndJREU0Q2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEUXhJREFnVWdvK1Bnb3ZXRTlpYW1WamRBbzhQQW92Um0wd0lEUXlJREFnVWdvK1BnbytQZ292VEdWdVozUm9JRGd6Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdNQzQ1T1RRZ01DQXdJREF1T1RrMElEQWdNQ0JqYlFvZ0lDOUhVekFnWjNNS0lDQXZSbTB3SUVSdkNsRWdKU0F0TFNCRmJtUkRiMjUwWlc1MENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS05ERWdNQ0J2WW1vS1BEd0tMMVI1Y0dVdlJYaDBSMU4wWVhSbENpOUJTVk1nWm1Gc2MyVUtMMEpOTDA1dmNtMWhiQW92UTBFZ01Rb3ZZMkVnTVFvdmIzQWdabUZzYzJVS0wwOVFJR1poYkhObENpOVRRU0IwY25WbENpOVRUV0Z6YXk5T2IyNWxDajQrQ21WdVpHOWlhZ28wTWlBd0lHOWlhZ284UEFvdlZIbHdaUzlZVDJKcVpXTjBDaTlUZFdKMGVYQmxMMFp2Y20wS0wwSkNiM2hiTUNBM0xqazVNaUF4TXk0d09EY2dMVEF1TURZMFhRb3ZUV0YwY21sNElGc3hJREFnTUNBeElEQWdNRjBLTDB4bGJtZDBhQ0F6TURBS1BqNEtjM1J5WldGdENuRWdKU0F0TFNCQ1pXZHBia052Ym5SbGJuUUtJQ0F0TVRBd0lGUjZDaUFnY1FvZ0lIRWdKU0F0TFNCaVpXZHBiaUJXYVhOMVlXd0tJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQkRZVzUyWVhNS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F4SURBdU1EQTRJREFnSUhKbkNpQWdJQ0FnSUNBZ01DQXdJRzBLSUNBZ0lDQWdJQ0EyTGpneElEZ3VPVEk0SUd3S0lDQWdJQ0FnSUNBeE5DNHdPRGNnTUNCc0NpQWdJQ0FnSUNBZ01DQXdJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1EyRnVkbUZ6Q2lBZ1VTQWxJQzB0SUdWdVpDQldhWE4xWVd3S0lDQlJDbEVnSlNBdExTQkZibVJEYjI1MFpXNTBDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tORE1nTUNCdlltb0tQRHdLTDFSNWNHVXZSWGgwUjFOMFlYUmxDaTlCU1ZNZ1ptRnNjMlVLTDBKTkwwNXZjbTFoYkFvdlEwRWdNUW92WTJFZ01Rb3ZiM0FnWm1Gc2MyVUtMMDlRSUdaaGJITmxDaTlUUVNCMGNuVmxDaTlUVFdGemF5OU9iMjVsQ2o0K0NtVnVaRzlpYWdvME5DQXdJRzlpYWdvOFBBb3ZRVzUwYVVGc2FXRnpJR1poYkhObENpOUdkVzVqZEdsdmJnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElETUtMMFJ2YldGcGJpQmJNQ0F4WFFvdlJuVnVZM1JwYjI1eld3bzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqazFOeUF3TGpjMk9TQXdMamMzTmwwS0wwTXhJRnN4SURBdU9UWTFJREF1TnpVM1hRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1BEd0tMMFoxYm1OMGFXOXVWSGx3WlNBeUNpOURNQ0JiTVNBd0xqazJOU0F3TGpjMU4xMEtMME14SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wxSmhibWRsSUZzd0lERWdNQ0F4SURBZ01WMEtMMFJ2YldGcGJpQmJNQ0F4WFFvdlRpQXhDajQrQ2p3OENpOUdkVzVqZEdsdmJsUjVjR1VnTWdvdlF6QWdXekF1T1RNeklEQXVPVFE1SURBdU9EY3hYUW92UXpFZ1d6QXVPVFExSURBdU9UWXhJREF1T0RneVhRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1hRb3ZRbTkxYm1SeklGc3dMak0zTlNBd3xFbmNvZGVkIERhdGF8fHx8fEZ8fHx8fHwgDQpPQlh8NDl8RUR8NTg0NzctMV5QdWxtb25hcnkgRnVuY3Rpb24gVGVzdCBSZXBvcnReVlNQVUxSfHxeQVBeUERGXkJhc2U2NF5Mall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzBOaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRjZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzBPQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRrZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFNQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRFZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFNaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRNZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFOQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJREU1TGpnME15QXpOeTR3T1ROZENpOUNRbTk0V3pBZ01DQXhNalVnTWpOZENpOVlVM1JsY0NBeU5UQUtMMWxUZEdWd0lEUTJDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURVM0lEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURVNElEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEYzFDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01TQXdJREFnTVNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOVGdnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXeTAxTGpFMU1pQXlNQzQyTmpZZ01URTRMamcwT0NBdE1TNHpNelJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lEUTBNamtLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdJREF1TmpneUlEQXVPVE0zSUNCeVp3b2dJQ0FnSUNBZ0lEYzRMalF4TVNBd0xqQTNNaUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREF1TURjeUlEZzBMamt3TWlBd0xqZ3pNeUE0TkM0NU1ESWdOeTR5TXpNZ1l3b2dJQ0FnSUNBZ0lEZzBMamt3TWlBeE1TNHpNemdnT0RNdU9EVTBJREUwTGpZNElEZ3lMamN3TnlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURneExqVTJNaUF4Tmk0ek9UY2dPREF1T0RreklERTBMamczSURnd0xqZzVNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdPREF1T0RreklERTBMamczSURjM0xqZ3pPQ0F4TUM0MU56UWdOell1TkRBNUlESXVORFU0SUdNS0lDQWdJQ0FnSUNBM05pNDBNRGtnTWk0ME5UZ2dOell1TWpFM0lEQXVPVE1nTnpZdU5qa3pJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNOeTR4TnlBdE1DNHlNVFVnTnpndU5ERXhJREF1TURjeUlEYzRMalF4TVNBd0xqQTNNaUJqQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DQXdMalk0TWlBd0xqa3pOeUFnY21jS0lDQWdJQ0FnSUNBM01TNHhOVGNnTUM0d056SWdiUW9nSUNBZ0lDQWdJRGN4TGpFMU55QXdMakEzTWlBMk5DNDJOaklnTUM0NE16TWdOalF1TmpZeUlEY3VNak16SUdNS0lDQWdJQ0FnSUNBMk5DNDJOaklnTVRFdU16TTRJRFkxTGpjeE5DQXhOQzQyT0NBMk5pNDROaUF4TlM0MU16Z2dZd29nSUNBZ0lDQWdJRFk0TGpBd05pQXhOaTR6T1RjZ05qZ3VOamN6SURFMExqZzNJRFk0TGpZM015QXhOQzQ0TnlCakNpQWdJQ0FnSUNBZ05qZ3VOamN6SURFMExqZzNJRGN4TGpjeU9TQXhNQzQxTnpRZ056TXVNVFl4SURJdU5EVTRJR01LSUNBZ0lDQWdJQ0EzTXk0eE5qRWdNaTQwTlRnZ056TXVNelV5SURBdU9UTWdOekl1T0RjMElEQXVNelU0SUdNS0lDQWdJQ0FnSUNBM01pNHpPVGdnTFRBdU1qRTFJRGN4TGpFMU55QXdMakEzTWlBM01TNHhOVGNnTUM0d056SWdZd29nSUNBZ0lDQWdJR2dLSUNBZ0lDQWdJQ0JtQ2lBZ0lDQWdJRkVnSlNBdExTQmxibVFnVUdGMGFBb2dJQ0FnSUNCeElDVWdMUzBnWW1WbmFXNGdVR0YwYUFvZ0lDQWdJQ0FnSURBdU5DQXdMalF3TkNBd0xqUXdOQ0FnY21jS0lDQWdJQ0FnSUNBNE1pNDJNVElnTVRjdU5UUXpJRzBLSUNBZ0lDQWdJQ0EzT0M0ME1URWdNVGt1TkRVeElEYzBMamc0SURRdU9EVXhJRGMwTGpnM09TQTBMamcwTmlCakNpQWdJQ0FnSUNBZ056UXVPRGMySURRdU9EVXhJRGN4TGpNME5pQXhPUzQwTlRFZ05qY3VNVFEySURFM0xqVTBNeUJqQ2lBZ0lDQWdJQ0FnTmpjdU1UUTJJREUzTGpVME15QTJPUzQyTWprZ01qQXVNekV4SURjMExqZzNPU0F5TUM0ek1URWdZd29nSUNBZ0lDQWdJRGd3TGpFeU9TQXlNQzR6TVRFZ09ESXVOakV5SURFM0xqVTBNeUE0TWk0Mk1USWdNVGN1TlRReklHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdaZ29nSUNBZ0lDQlJJQ1VnTFMwZ1pXNWtJRkJoZEdnS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3TGpRZ01DNDBNRFFnTUM0ME1EUWdJSEpuQ2lBZ0lDQWdJQ0FnTVRNdU16STFJRFV1T1RjMElHMEtJQ0FnSUNBZ0lDQXhNeTR6TWpVZ01pNHpNelFnTVRBdU56UTVJREF1TWpNMElEY3VNekE0SURBdU1qTTBJR01LSUNBZ0lDQWdJQ0F3SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F3SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQXhMalV4TXlBeE1TNDNNVEVnYkFvZ0lDQWdJQ0FnSURjdU16QTRJREV4TGpjeE1TQnNDaUFnSUNBZ0lDQWdNVEF1TnpRNUlERXhMamN4TVNBeE15NHpNalVnT1M0Mk1URWdNVE11TXpJMUlEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01URXVPREV6SURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TVM0NE1UTWdPQzQ1TmprZ09TNDRPRE1nTVRBdU16WTNJRGN1TVRNNUlERXdMak0yTnlCakNpQWdJQ0FnSUNBZ01TNDFNVE1nTVRBdU16WTNJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhMalUzT0NCc0NpQWdJQ0FnSUNBZ055NHhNemtnTVM0MU56Z2diQW9nSUNBZ0lDQWdJRGt1T0RneklERXVOVGM0SURFeExqZ3hNeUF5TGprM055QXhNUzQ0TVRNZ05TNDVOelFnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNBeU55NDFNVFlnTWpBdU1UWTFJRzBLSUNBZ0lDQWdJQ0F5Tnk0MU1UWWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lESTJMakE0T0NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUxTGpBME1pQnNDaUFnSUNBZ0lDQWdNall1TURnNElERTNMalU0T1NBeU5DNDJPRGdnTVRrdU1EY3pJREl5TGpJNE15QXhPUzR3TnpNZ1l3b2dJQ0FnSUNBZ0lERTVMamczTlNBeE9TNHdOek1nTVRndU5UWXhJREUzTGpZME5TQXhPQzQxTmpFZ01UVXVNRFF5SUdNS0lDQWdJQ0FnSUNBeE9DNDFOakVnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREUzTGpFek1TQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMUxqSTVOQ0JzQ2lBZ0lDQWdJQ0FnTVRjdU1UTXhJREUyTGpnNE9TQXhOeTQyTXpVZ01UZ3VNVGMzSURFNExqVXpNU0F4T1M0d05ETWdZd29nSUNBZ0lDQWdJREU1TGpNNU9TQXhPUzQ0T0RVZ01qQXVOakF6SURJd0xqTXpNU0F5TWk0eE1UVWdNakF1TXpNeElHTUtJQ0FnSUNBZ0lDQXlNeTQzTXprZ01qQXVNek14SURJMUxqQTRNeUF4T1M0M05ETWdNall1TURnNElERTRMalUyT1NCakNpQWdJQ0FnSUNBZ01qWXVNRGc0SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTXpjdU16WTVJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdNemN1TXpZNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016WXVNemc1SURFNExqa3dOU0JzQ2lBZ0lDQWdJQ0FnTXpRdU56a3pJREU0TGprd05TQXpOQzR6TWlBeE9DNHhORGtnTXpRdU16SWdNVFl1TmpNNElHTUtJQ0FnSUNBZ0lDQXpOQzR6TWlBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTXpJdU9Ea3hJREF1TWpNMElHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UWXVOalkySUd3S0lDQWdJQ0FnSUNBek1pNDRPVEVnTVRndU56WTFJRE16TGprMU5TQXlNQzR4TmpVZ016WXVNVE0zSURJd0xqRTJOU0JqQ2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdOakF1TWpreklERXhMalUwTWlCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURrdU9UUTNJRFU1TGpjNE9DQTRMalkxT1NBMU9DNDRPVElnTnk0M09URWdZd29nSUNBZ0lDQWdJRFU0TGpBMU15QTJMams0TVNBMU5pNDRNakVnTmk0MU1EVWdOVFV1TXpNNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBMU15NHpOVEVnTmk0MU1EVWdOVEV1TnpVMklEY3VNemN6SURVd0xqYzBOeUE0TGprMk9TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklEY3VNemN6SURRNExqTTVOeUEyTGpVd05TQTBOaTQwTURrZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURRMExqYzROU0EyTGpVd05TQTBNeTR6T0RVZ055NHhNakVnTkRJdU5EQTNJRGd1TWpZM0lHTUtJQ0FnSUNBZ0lDQTBNaTQwTURjZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURRd0xqazNPU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdOREF1T1RjNUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJREV4TGpjNU5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lEa3VNalE1SURRekxqZ3dPQ0EzTGpjMk5TQTBOaTR5TVRVZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURRNExqWXlJRGN1TnpZMUlEUTVMamt6TmlBNUxqRTVNeUEwT1M0NU16WWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTBPUzQ1TXpZZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdNVEV1TlRReUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ09TNHlORGtnTlRJdU9EUTNJRGN1TnpZMUlEVTFMakUzTWlBM0xqYzJOU0JqQ2lBZ0lDQWdJQ0FnTlRjdU5UYzNJRGN1TnpZMUlEVTRMamc1TWlBNUxqRTVNeUExT0M0NE9USWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTFPQzQ0T1RJZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMk1DNHlPVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09Ua3VOREUxSURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnT1RrdU5ERTFJREV4TGpVME5TQnNDaUFnSUNBZ0lDQWdPVGt1TkRFMUlEa3VPVFEzSURrNExqa3hNaUE0TGpZMU9TQTVPQzR3TVRVZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURrM0xqRTBOeUEyTGprMU15QTVOUzQ1TkRNZ05pNDFNRFVnT1RRdU5ETXlJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTVNaTQ0TURnZ05pNDFNRFVnT1RFdU5EWTFJRGN1TURreElEa3dMalExTnlBNExqSTJOeUJqQ2lBZ0lDQWdJQ0FnT1RBdU5EVTNJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQTRPUzR3TWprZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURnNUxqQXlPU0F5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBeE1TNDNPVFVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUE1TGpJME9TQTVNUzQ0TlRjZ055NDNOalVnT1RRdU1qWTBJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQTVOaTQyTnpFZ055NDNOalVnT1RjdU9UZzNJRGt1TVRreklEazNMams0TnlBeE1TNDNPVFVnWXdvZ0lDQWdJQ0FnSURrM0xqazROeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJREV4TkM0Mk9UY2dNVE11TnpJM0lHMEtJQ0FnSUNBZ0lDQXhNVFF1TmprM0lERXpMakE0TWlCc0NpQWdJQ0FnSUNBZ01URTBMalk1TnlBNExqazJPU0F4TVRJdU5qVTFJRFl1TlRBMUlERXdPUzR5T1RZZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURFd05TNDVNRGdnTmk0MU1EVWdNVEF6TGpnNU5TQTVMakE0TVNBeE1ETXVPRGsxSURFekxqUXhPQ0JqQ2lBZ0lDQWdJQ0FnTVRBekxqZzVOU0F4Tnk0NU1qVWdNVEExTGprd09DQXlNQzR6TXpFZ01UQTVMall6TVNBeU1DNHpNekVnWXdvZ0lDQWdJQ0FnSURFeE1TNDROamtnTWpBdU16TXhJREV4TXk0eE16RWdNVGt1TmpNeElERXhOQzQxTURFZ01UZ3VNall4SUdNS0lDQWdJQ0FnSUNBeE1UTXVORE0zSURFM0xqUXlNU0JzQ2lBZ0lDQWdJQ0FnTVRFeUxqSTVNU0F4T0M0MU5qa2dNVEV4TGpNeE1TQXhPUzR3TkRNZ01UQTVMamN4TlNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFd05pNDROVGtnTVRrdU1EUXpJREV3TlM0ek1qRWdNVGN1TVRReElERXdOUzR6TWpFZ01UTXVOekkzSUdNS0lDQWdJQ0FnSUNBeE1UTXVNamN4SURFeUxqVTNPU0J0Q2lBZ0lDQWdJQ0FnTVRBMUxqTXlNU0F4TWk0MU56a2diQW9nSUNBZ0lDQWdJREV3TlM0ek56Y2dNVEV1TWprZ01UQTFMalEySURFd0xqZzNNeUF4TURVdU56azJJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEEyTGpNNE15QTRMall6TVNBeE1EY3VOelUxSURjdU56WTFJREV3T1M0eU9UWWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lERXhNQzQ0TXpNZ055NDNOalVnTVRFeUxqSXdOU0E0TGpZek1TQXhNVEl1TnpreklERXdMakF6TVNCakNpQWdJQ0FnSUNBZ01URXpMakV6TVNBeE1DNDROek1nTVRFekxqSXhNaUF4TVM0eU9TQXhNVE11TWpjeElERXlMalUzT1NCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDFCaFoyVUtMMDFsWkdsaFFtOTRXekFnTUNBMk1USWdOemt5WFFvdlVHRnlaVzUwSURNZ01DQlNDaTlEYjI1MFpXNTBjeUEyTUNBd0lGSUtMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTmlBd0lGSUtMMGRUTVNBMk1TQXdJRklLTDBkVE1pQTJNeUF3SUZJS0wwZFRNeUEyTlNBd0lGSUtMMGRUTkNBMk55QXdJRklLTDBkVE5TQTJPU0F3SUZJS1BqNEtMMFp2Ym5RS1BEd0tMMFl3SURFd0lEQWdVZ292UmpFZ016QWdNQ0JTQ2k5R01pQXpOQ0F3SUZJS1BqNEtMMU5vWVdScGJtY0tQRHdLTDFOb01DQTJNaUF3SUZJS0wxTm9NU0EyTkNBd0lGSUtMMU5vTWlBMk5pQXdJRklLTDFOb015QTJPQ0F3SUZJS1BqNEtMMUJoZEhSbGNtNEtQRHdLTDFCaE1DQTNNQ0F3SUZJS1BqNEtQajRLTDBkeWIzVndDanc4Q2k5RFV5OUVaWFpwWTJWU1IwSUtMMU12VkhKaGJuTndZWEpsYm1ONUNpOUpJR1poYkhObENpOUxJR1poYkhObENqNCtDajQrQ21WdVpHOWlhZ28yTUNBd0lHOWlhZ284UEFvdlRHVnVaM1JvSURJd05ESTJDaTlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1VLUGo0S2MzUnlaV0Z0Q25pYzdYMVppMlJKZHVaNy93cC9HUm9hNnJidGl4QUZtVmtMQ0FRalZVSUxoQjU2cXJjWnFrcXE3bUlhemErZnM1amRjQTkzKyt4Nlptd2VjYU9Jekt6d0UvZWFuV1BMMmIrZkQvL2o4TVVYaC9kLy9QUC8vdW5EZi83MHl4OS8rdVZYaDROWmNqd1krdStMOXE5YzNlSDdIK21UTDZ3eGg0Ly9qLzdWZnZOLzhXOGVQdnorcC8vNys3L1JUdzhISzc5b0R5NHRJYWE4L2kyL1B2NjF1MTgwaDFvNk5hSS8vbzE0OXd2NFYrNStLZEdmUjc5MDc5Zis1KzkvK2N2UlovUnJpL2VIdjUvOHlCeis2ZDcvLzUvVFh6R0hmejRsV0hKT0ozOGUvdlhiZTQ4d2h4OVBmcEpqWGt5bEgvOXc4dVB2anY3dlgzVGdmL3pwRDZmRFB2cjVQUzVzNDVBaEh0MEFoMmlvN3ZHNGMyK2FaNU04bmFJOW1lQnNOclN2VHViQ0RQL2g1UC9ka2tyeS9TK2ppL2FJSXQ5YkdOOWRtdDdKRkU0bTkrMFAvLzFmZi9uYnlSdjV2OE5mLzN6MHM5OSsrNTA1L1BtWTZ2M0g0NCsvb1dQQ0hqNys2WmdObnRra3EwaitaZWtRcUpiKzRmeFNhL0dIanovZWUrbkhQeHorMFJqdmpZblJtRkRvT3h0ajdaY2ZqeG42OWNkTDg3czNpK2VaWWFxTFNmTVp1amE3bU9nNzM4cnNuSW1MeS9QWkdacVo4WThoUjNCSWVRZE9xYlBmRzk0YVo3OTZkc0FkLzZwWmJEcjc5WXM3L2tRV2pWMUxQUHg0NGFmT3RUK0U0blNuODVlanU4Q0dzN3RBUHdqOGUveVBGUFFwNjcvanhRZTFqMzRZZlpSTGY2enRMN1puRCtJbjJMTm55T3VWUy9RVWMzRUk5MW43cDkrYy9HQjBmUEhYVE1Bbk54Z3Yzek14NFUzVUpuRmhLK25YK1liU3I1TnQxVWd2Yks0MnhIdGJqUDYydExkSVVmcjQ0OFd4dEJQeTNwblJQbCtpODNkbnpEZVhhVUs0STBtWFNMNitQNEh4NXRTdlRYeWtKWlQ1VDI5bERQN3BlRnJUVXZoTTNzVFp5MXg3SEpZODdkS2lpM2V4aGVhL2lRKzI4bmxOMzNSKzIzZXZsaWZaTGNWdFhSdTJOSjdRdldZL3ZGYWVPQmNXbnpaeTVEMTlCNzd4SDRBYlkxV2N2NjQ1N3AxYnZMc3pOZ2NQdVhDemI3amJ0OTN1by90OTJ3MFA3dmpyYjNsNHoxOTcwNC91K20yMy9mbDlmM2JqNHp0L3l6S1kzL3ZidGgzYWVPT3RkM0h6b2UxM3BRNXdvZ1hRMmV6cnBaMTNZZS9OejZMTmJObDBsVDhxaXpaYzZmTkwvWEdaOUR4clo4c2xmM0tBeDZNcjdmMmI0ZEtHYS8rRVMrRklHYXB2aFV0elJlQk1ZUnlxQXAvRUg2d1FQSnk2RU1LUzR0UkEzTldGa3c5M2RlRnNTamVoTHRBdWRTTUhBb2wzc1h5clQrN05EVTZFVjYrQmhDV0d1SlgxRDNnb3Z2RFZhTjMyR3lNZDZSKzhMdk9iWVZLS1MvSlhhbW01Y1lwTjd2VGxyb09jREszeDZaMnVwQmVoZzR3LzJ4aHpmSml3amowUDY1UWxaZVd4L0l0T3Nib1U0OGZScW52WEFCMjU4ZTVXcVJ6cmVjVEFqdVZvVXdIQm5RdHl1N3hhTDYzVGV5djA4dG84dDdKSTI1T3Noa3VCc0syQnZudnJFYTNFNTU1dnRxUWhiNXJ2Ti9ydDdhM08xUm5hRE5GdW1Lc3ZOei9YUUJydmxwbCtwU3M0OENwMlBhaDdzN091Zm5IelNYTVUrelNDL1RBVGhySG8rMUhzNnd6WmVNTW1yUGRsaWY2aUNjc2ZGZUdPcjR2eCtxVDEzL0hpdzlZUGZ4aC9TSVpuZTdUdHI5OU4ySmR0d3VhUlFUcVBmTzltNjl0em5MdXJIT2NwYkRZMHBwSGd3K0UxdXMzRDRzb1Zidk5qTHZtM3dpVkhmMVYzbGNscUc2OGVMYlF3dURhTzByUmpWQy94OTVlR3U0M2ZtT09JNXdPdVk3NWZmWTJjc04xY1p2VkZabTloOTgwd0tTNnpEWHd4OGxYR1hxZFA1aG4ycmZEWGk5N28zc1FsaHl1OGVPK2ZPRUoycmU0NFRKdlpZa1pzTWlTMm1oSmpZMktyT1FFTmlrOHhLU1pHeGZWbXhkaXcyR3BhWERJdUxwZ1hNd1BqMnJ0aWJHUWNYdUZOTVVxd1lTR2xxVFh4RlBmSlJxdmlDZGk2eWJyWVlsL2M1alhzcm1DVjJCdmxpb3M0emNNL2gxZXZ2R3l6UUM3eUxZMFRuRjQvMzdiWUpCY3ROMWIvNHVOeWJYamZiTFZPdGt0aEpnY3NpYUVzWnRMNGhQdG5tNjB5RU1FMklkd2cyN2JZTGllYzgyMFp2ME9iLzdPNE9MZGhidWFRMkdiUG5QRDNnL0o0Wk5FOG1tWDRzSGJQTVA5dnQzdjBkM2E3NSszWlBlNERXelcwdDRmbnB1Vk04dzJxUEJrbGR5bUZtaTVDWHg5MmcyazNtSzQwbUtxL1N2V1BSN2QvK2ZMamJqSmR5YmN3RGtrY2RwTnBIZVE5US9QRHFHQ1d2MTQ5MTFKZG5MMG1EdE8vM3lySFBrSHJmcStyN01hMTdwVE8wam92UEdiWHVYZWQrODNvM0tQMEp0Rlp5NTBTK0E2RUpQSmhIcm5ZVmV6ekVlOHF0cWpZNFJQMHhEU3UzVGtjZHYzNmJwajMrTVovaHk5My9Yb2IxM3I5VTk1REVrZGZlMGppZWRsMmRVZ2lIQzFqdjRja1RyOGV3RGg2cHhmU2pSdEhwUzdlN0tsWXUzbTBtMGRIbW5tNWEySXdEa3U0eGJpNzh0UTlMS0cvc3R0TVoxOFBaRFBSRFdXdnVxRzZCZ0JhTGgwT3U5bDBOOHg3eVJ4cEQwdDhnckhwMzdLUnZvY2xydVpZSlcwcFhYbXErVmVoZTF1YWRQSjdQdEN1Zk8vSzkxRnNJdTRSaFYwNy9nVHRPT1ZQMG83alc5YnlQa0U3UHViYnUxMDd2akpweHo5K2l0Z2VWQmlPZEE4cVBGQlFvYUpEY3c4cWZISlFZZExiK0ZZTUcwNmhUYnRaczVzMXUxbHpUVlBrclcyUk4zYVllbVBXMG9aR3ljY0NNZVhOR2tzdVhlblgzZEFTK1BEcWRYNmJHQnIxcXVzODNrdGVlN05SR0dmU2txOHJxc24zYXVyckhsUFlZd29iRlc4YkZ4TmVBTWMrVCsxR240NC9HMytDMWJPajNyQTJMeTdkVHdyQ3FydVYvKzVMbko4WXMyZEVhZXZUNGE5L1BKeDhmS0ppanBYTG1WclpSMTRPNVhPYTJqb3o2V283RVBKNHNWOEZtemU2d2EwKzN6STZzNkdMTzMwaVltZWM2WldrdjgzNkRIMGU3T0RFYm5Sa0RqQ2kxR2NZam4rLzhOUDdvT0Q5cDVjMitobEFlQ2NXQ2QrREJsOC9HeGlZMFpQVk5UVHp2dnM4NitwbHNZQ09YY1FEK2ZqcG1FRGJ6bDYrWDM2K1BQbytUSGQyUXVuWDczNXorT25DajkvLzIrRzMzLzNGSFA3Mmw4UFgvM2I0bHl2bjhwQXVsKzFiQi9VMlhGeU9YTmxEVitlanQ4WDF1cUE4TndQMFMzSStIcHkvZkZNZm1XeGZQVmJmMG9rcnlqbExaNjkwZnY3K3gvSHVHSG1nRHFUM2hzSGErbHczeTJUa25oRWtTbzYzTi9MZzYrTFpWSDBCSTMrZXZUcjFvSDNSdkpaVEQ5cUExVE5GWGQ4eVpPTkZSczRYd2R6RGZ4MFhVbHlLenpzajZKcDFpOTBaUWVQam5ETHJkazdRWVJPV3N2T0Jya0VMcjhFM3hJbWFsN2h2RGRJdmtsOUsyam1oMW8rdHRiNCtUanhzV051Wnp6S3ZodHg1U0xTUjFWa1VsOG91dk12dW9oT0gwY0N4VG9hZ084eENqRStCR0lIMDVhMkw4N0pmWk9RWkdmbEdodDRSN0I5QlRxS1ptK2lTajJTK0wyNkdMVVBIMGRSMTlMaU1vUzNwUmlHS24wZHptYm1SaG82azdrcXlRMWZTYzJpTzI3Y2RqZ1JOM1VxUEVQSStjaTlsdjRRUXh1NmxMUTZtaHdxWmdZMjR6ZEcwNVpyMUQzN05YanVMbWRQcE5tWXhjMEE5enl5ZWM1OXZ5Q3hHTHFtdEFwaW54MDYxeVFGenR5eVNxeE5RTjNCbDRxSjZ1NHladUt6ZU1HTW1McXkzeXhuczBucTdmSm01dU40d1o3REw2KzB5WnVZQ2U3dWNtYm5FWGd0bm50YUJGbTdKZ1dhMitNN0dNTkZIMlZidmhnNjJlcGg1NFhZSDIvb0x1NFB0NGkvY3JJUE5QNzJEemUwT3R2T3Z6M1d3a1FsSEUvRzdnMDIrZGdmYjdtQTdtZVh1WUJ0VDdBNjJBY1h1WUJ0UTdBNjJFY1h1WUx0TXNUdllSaFM3ZzIxQXNUdllSaFM3ZzIxRThTSWNiTW5jVklaYURsSldQL1d5eGQwL3RqNW45NDlkZk00cjlJK0ZwL2VQK2QwL2R2NzF1ZjR4R3hkU3FmUHVINU92M1QrMis4ZE9acm43eDhZVXUzOXNRTEg3eHdZVXUzOXNSTEg3eHk1VDdQNnhFY1h1SHh0UTdQNnhFY1h1SHh0UlBJcC9ESDg2NS9seEs5b0xFUEZiYk13eGU2L3EvalZxYjJmYkVQbXZ1dFJKNzYrdkhyNXAxM05QTzVIMXp0MWRaM08vM0x2dnR1ZHVHV1o5eStSOUdqUjlPMjRtUEtJNVNrSjA2bXgxNVFGNCtWQjdzOXVIMXN6NjgwM2M0MStFSmRYQlZiUGxNRjB2TFRxWVA3bWZFaTNvUjJxbnRLSGZkdmxzVnhxNFNSNitxK2NhS2FDamIwc1R6emZUN25SbFROakVtRnNHRTBoMlNjSHR1L2FjNE9kOTE3N3FYWnR2ZU5kYWw1ZGE5azE3Z0kvNWR0KzA2OWZQcjJQVHBsdmV0RFVzZnVnTDM3ZnRGL3UyUGZ2NitYVnMyM2pEMjlZbHM2UzQ3OXB6Z3AvM1hmdXFkMjI0NFYzclhWbHFmUWpEMXIzTWJmczBlYVptV3lGM25xV1lXdjlnNmFVUHVrcHFWR1NiZlkyc1g4KzNSc0tMWENPQlhXUXA3eWZKeWRmenJaTDRJbGRKcFB2R21GRDNWWEw4OVh5ckpEM1JLbm5vS054bnh1Q2NkVXZ5WWNNcWZEbDFLbHZrNmI3UmI4OW9oVis5eUJPQWhyYllFdXlyNDczM3d5WTg1UTRrTjhZUmxiOURQUXVGdmpOOWY2RHZSTCtVKzg5ZXBFaUR0NHV4MWI4K2taYStuVjdBTVRuK2JQd0psdUo2S1RNMFlrbG5DZjZ6TlhBSGVIZ20rUG55WVV4dzBSWU5JLzdGcXNDWm4zV3FpMXkzb1JuOXcrSFgzLy9sOTMvOTVkY0QrVjlhRjdRWURwZmgxL2tUbHk1L2hqNjUvUE5MV3Mvdkx0WkxiYzNtQ3h3S08rUVFEczU4UWxIVzFoUy9PemtJd1B1UFE3Sy9EejRabGR1TkMrNUF5ZDNoOE8vK0VQN0RIUDR3ZXVaU2FqajVjMVNmSnh4MDFoOUdVOG9seXVjL0RENy83dUxQNTRtTE8rOFB1bnFMZ2J6bnozZmU5NjhINW4zSW1QZjArYzc3L3ZYQXZKK2NPWFkvYzQ2K0hwYjN1VUxXMDhjNzUvdlh3M0krSk1oNStuam5mUDk2NFBQRzRlUEdQVGpuSDdKbzVZblVYUGNKc25WRDJkSXlvc0VlL3ptNWpkT1NaaGV5a095U09vU0hsUlRMSjhUMjUrZElLZGlsVmlIS2RpaW40RGgzVVlqR2wzendTMDFLRk1aRVlhbHgrcVM0ME9rZ1JPTmRUcDlXUHlYS1MzVlRvckxNT1ZEcHhKb1JSVHJXeXBUSUxpVlBpZHhTMG16YzBTOWx5cVlZbGpKbFU0eExtYklwcHFYWUtWRmV5cFNtTEhsT1ZKZWNaMFRKTEhuS3BtU1hQRjF5eWZHcW5UM0o4eU5tVHdvczJCbFJYUEtVSm5FMzlCbFJYdEowWjZiQ0o4Q01xQzZwc2FrTWliSlprcktwanZkNHRrdGlOdVhGQUNMSFlJcENOTlplczErU1dIMExNQzV5NElJdEpuS0FLQzZ4Q0pHUFk2SzB4Q3hFQVl3cEx6RUpVUUpFWllsaWppNkFwaTZSMlZRUUJ3cWQ4RTZJN0ZncXhYSnpmU1p5NEVsdWlWTWF6ek9YWVk4djdSS1dvRnh5WSsyM3hDWG96Z1JDS1drSlBLYTRlUEE2a2dZdnViRDQ4V29xWlFuTVN3L0hWQmU1RDkwQ2xNZHFGbjZiSEN4REdydDRZcE92dlBDR1JOd0RuSWdLNzVnaGtlZXBXMCtMQ2J3dThLSzFQcUx0eTJreFFYcDNWUENreExrejFsV2tsRlhhSTdUa1hPTGxPU1FxaTJmRnlUUGZoMFNWRjV0MWhoODRJckxHTEk0WVplRjZzc1l1ampobHcrSUNvSEw4RUd2dFlpdWdvbVZDRERXRlQ1Y3hsYnpLbW9TMm5qVnhjVTRlV2RBYmFSOVlIVjRHVk1RQ21hbEJVeXc4TitaYVJZK3FQR3ArRmpqTkxjYy9rd3lyQUFFeE42UHdBeXdJYTJsYktidkEyckxXODFIT2t5am9XWUczcUx3WUNNakdSZHhTdkh6R1JJbVBWNmIxYUZoMERla2FCQ2UvdFhSVTh4cXNhRXZ6eDRhWTZrVHRHRkxScGlBcDh3WkM2NFpiajNuWml3WTl5eTJHZDJ4aENZeXAvR0s0dXcvSkhCRHhHV0xSN1U0a1lneDRqK2NYZVgzeW9RVjhzand4dGhuby9FTmp5bUl6MEVrYXdTcmw3TkVnaDNKRno2cHFFRmk0cVlsSFZXOEtkSEF4bi9UT0FkeWlBN2tvVlVBdjlHbzVpRkkwcGdwcUZWakVMZUk0Rzk3RUI0T29rdGdPWGk2RU1WVVc0NEZHRjlIZ2kxZ1B6RFN3SUdoQVJhUUVtTVhYYnRXMUE0amtUSk9yQnozS2lmMUEyNnlpWjNreElHaGpCOEIzMGozWWd1Q2pCTDFSN21jK2p5SzR4OVRDNEtNTnZUQ0xEVUduWkFYU0lWMHV5NEdMOWlFWnJteEYwT0dkd0tPaUVRdUJMb0lJZG12a3RFcTVldEJGUUxZckdSSVY2ajJXYkZmNm1QU1JDaFpXbEVFVEVWckpaTHZTTFU1RURuQ0JiTmZFaWcyU0g1bXVwTTRSVVVFc0tMd1ZTTEZCRDZwaVJ0RGRpNjRjc2wzWlJDREZJWUxaa2ZFYWcyZ1pDVXlQckZjMkpVaC9BTmFySmZPVmJRbFNEUW9ZUGRtdmJFelFBa1dpSVFPV0xRVytxTkhvRTU5NnZIR1FjTWlHWllPQ05xRkg0eXBpVWJBeWlaNVZ4YVNnR3hHOWtjeFlOaGZvSmpOZ3E1SWRHNXljUmhsUk9iRXFIRllkR0hKYmJoL0VMckpreGE0d2NLL21xRGFEWFBwanFzUlpYSHgwTy9UR3JLWkZRRmFoelVWdGl3Z3ZDN0puMmJqd1l0UU5xY2lnWmNPQmIzd2diTEpvdlJDaFk1a3NXall2ZklLSFZoSDlrQWVQekFzeWF0bThJSFlob2loMkE5MzdTS2NocTliTlpWM0VYY0VLRUxKQnlLNWw2NEx1T3FTUmtXSEwxZ1VwaThEWXRtVFpPdGxsWUZ0WDBZdG1HN1p5ZzBpNTZUSjZueGZqZ204NndGTXlicTNhWWdWUnhXNWNCTUF0dWdTczJtTG82S0lUWGhvSldhaHIwZjFsNVp3SGtxYVBqZHdZWVAwNXVpM0p0T0JMckFBaWJqSGNiUGd4a1dNcmdJZ0FEeHhObmk0NUlpcm9TWUhOQ2hwVFFBT1BmTUJVNkZaelBPcUNGZ3RSc0FaR3JBSW1walBTSEVITVZmU3lJallGVFJGRXZCM2RiMnhUMFBDQjh1VEk5R1Z6Z2ExcE1IaStCYjNZeWNBUTRBeHVOaXJvTHhBUGRyUmQyS2lnS3hNbzA0NCtycklCRXlLS1lpN1lncWVZSk5MQXh3SjZWaGFqZ282WURCWURIeHRSamlza2F5dXFCU3Y1UUFWMmRJVTNld0hOa1laZHRCa3QwQ01kWGZSRjdpL2dobkpPRmd4ZEZJQWtpRkhoTXg2NXFBSnM4SUQxNTVMR0d3emM4YVF2U01EQllxcWlFUWZoeFppcWlrMUJKZy93SkR0dWhHL2xXV2c1ME9XVzFMZVowTE9jaEIzd0JlMzROczBpbllxZUZjU3E4TkRZZGw0MFlMNVYwZUNUUkI1Y3hvL0tFbm9na2FOSGlYT1FGY2tJRmp5elNYYVlCNDhLMGxHTy9VSm80NU5jMkdxZzdRZ2N1STVrek5FSE9nRFFiaVd6TmtZMVJjSGd5YXhsMjRMT09LRFdPVEpyeGJhb3lNM2h5S3hscThIQWNJNGp1emJLeVd6UTRJdVlGa2JVaHpGVkZkT0NiZ3d3UXpKcmc3VEpBK2FhSTZ1V1RRWWlBdnFhSTZ1V3d4REdvTEN0aStJUGwxR0JHWkpkeTRZRnUxM1I0T1dpRjhzZFVTV3hHUXlNN1RteWJUa1lZUXJTSXgwWnQyeFpZTys1SS9PV0xRdGVYT0JaU2V3MFhxakFuSFpKMWg1ZlpNRCtjTWxwUk1JZzE3SWo4OWJyam9WdkRJdGFmdWhJSXV0V0FoY1oyWWN1SmJFWjZFaENSM2lTdUFZWkRZQ2txRjJCMTBPU0hjaW5LWEFZT0RKdG5WcGhhRkJrMnJKZHdkY2RPQ2pKdEhWeTI2R3poaXhicXhjR1VPQWRtYlpzV0xDRER3MHJpbUhCUnlGZ0JKbTJiRmh3SEE4eFFpek1pVXZWa1duTDhRajI5QUtpS25ZRjM1eGd4UmM1UUpnUndCSGdDanR2bWZIb3pDWEwxcFR1N3gxVGVRbEhlSWNNTEZlQ2hpTXE1QU9adGtiMXU0cW9rZ1l0QWp6ZXlMUTFhclNpVFUybXJWR2pGVEdpeXVHQUZpa1p2MVVEUE1EdDRNajRaUU9EVkhTMGVjajhGZE9oSXBlcUkvT1g0eEYwMTZGanNubzFNQUkwVnNqOFpRT0RIYTlnYVpFNXh3WUdkcnc2OXFhSzN4WHNNSFp2VnZHN29rRVZOaS9vcFhEa2xjOVpOc3pIRFBVMDRpSjJMUmlUcDl1eWlDODRJaUxIb1lnS3RTUFBVVmpIdGlZUW55ZUpGTFgvZ2ZIa1NVa3BJajJQcGlmSk1oTHpySUFxU3lpQ1ZwVkJMeXdhaXBEY2dqRlYxVkNFUjBsMlhOZkt4Z1VITE1BYnJkV0FSVUhHazZjdHcyWURYYjZJcVR3Z0RUR0N3ZHNndG9XTHlFNzJWbFlMWDc3QU0rYXR4Sm5sV0VOVVdhd0dNbXJBRWVLdHhDclkrWWY0VU1XMndHZXlaeDNGYVZ3TkxHWTY5SkxlQWhrOXk0bmQ0S0YrNFozWHpDWURWNm9lMlh5RkFjdklrMlJpdTFuUkc1TW1OemxnQlhzU1g5U01IQ1JyVnpTOWlWZlBtS2hxZWhOWThONUljcE5IcWpLRGNVaDJrMFBKTnA2dVUwbHZNc2lKNkwzTVMwS2ZhRmhCVEF0MmlZT1Z4VEZ5WFg0Z2N1MzFJYnlVUVZUSnMwVnV4UU5UMExPS1JDTVNYRElNdFZWblFSTFA2NjZJMW8wR0gyVFVjb2lBNWNkYVdKUUR5YUkzZW9sR2NFWUhJQXBxV0xnRlBTbUtYVUduSlRxMWdyQ0pyM3QwaVhFNlhCWGJOcUpoRlFsR2NOQVBVVlV4TE5oRERVUk54cTNUYUt4QlZKWnRpNHJYS1JtM3BObXlJeGR3aTJ4YnNobHFRWTVjVDZhdEpEb1pGTFAxWk5xNm1aWHN5YksxNmdkQUp3aFp0cExvRkpIVzdXUFJSS2VNbGdNWnRoS0tRQzRtVDNZdG14VzBzTkFFeWE1bHM0S3oxY0NCbEp5bU9TWGtSZk5rMTFyVmdnR3p5S3cxZGJyQnlLNDFiYk9pS1NheEsrZ3lzR2p3V2UyS3ZLQVhGalVZS2xLVmZSTE55RXJyaGpFVldiWnNWdEQ1RER3ZFBsdk5jZ3JvZEdCdnFjZEthZGFTQjUvUUpVZTJyeVE1RmJnRnlmYVZKS2VLQXJhZWJOK3FlVHNaRFN2MUxDZWtoV1F0ZS9ENEZpRGJ0Nm9XZ3JaOVpxZ05DWitDS1JZaldVNDQrOVNUN2N0aEM3cXMwVjFldFBiQlpUaEZNbjRsSURFWlY5Q0FCUFJWK1JJbHpjbGhpNENNWHc1YmtCNklicWNpQlJBV1g2MWsrM0pBd3VLanJjaFM0T3NKYWQ1azJZcDFVVkNjenBObG0xdFFESXlMTE51c09TbG8zVlF0ZzBDTG1jemFyQWFyUTFTUlRRdEcxUVBDSWJzd1MwNHlvcEZrL0FxZEY3NUtGUVJIYXhFM0t5dUh0Y0R5SkdQRXFtQzNNcWdZNHVzN3FHbVBudVhFckRBQmJmdGd0QkRDd0F5bXdLNWk5ZFFuUUJRMUdtR1JUaHFNV09QaTVNMkFLbXZNSWlLTk9oZ3RodURJQm5wamxXZ0UzV0FnWVNWWWNZSHdEUWJTS1lNVmU0OVYxNFNveEJuRWFqQXFXTE5hRStFS1VzWUMzZlJCanpZUVB3eFdzbUVsMUlXZWxkUzI4TWhKRXpoWFdhc0MwUEpTNDE3U1BSRlZsWUNFejBndkNFN1d1MFEvd2Jqb0ZHMFhGS0J4WWxxUTdRRE92K0MwT0lLb2dPNGFTTWdjamlBcWg2aWlKam9WZEVRRXRvaUNlbWNCVWRZOEovRlZqNm0wUUlKOStxaXVza3FlRTdUZEEzM2NvaEVKVVVsY2w5YzhXczNlYWN3Q0pxY0hyd1VTRmlibEJLOEZFaFpXakFYV0hMejZaOUc0a2dRa3NIODJzS3BpNVlSRHU0eUU3RFFpaG9iVkNpUUNVbklEclNxYlo3bENnUk95azFTN29NSlh4Mi9pNUNQMFBzL1dCYWY0Z0tFSHFZNmdLOWFnSjRsanRrS1BTQ0RUMXZLREFETzFRSzlHZUg1d0RWdmh1YUVySlVoZGhOWUVEWW5JcU9VNGhJR3BiQ0ZLaVl6VThZRFZRbFl0bXhWYW9UT204bUpXMEZXRzlxQWs0Y0pzTUNMUlFBUmVLMlQ2VnIxWTBhT1MyQlVXWnA2R0tNNXd2bGZCWW9sYUZzR1pPV0Foa09sYlZRTUdzZE5BdG0vVndBNmtzbUpXT01sUkdsT3g5MUNVZkRDc3BHVVJuTjhDK01EZ3cxbWR2T2haVWN3SzcrRnFJTnUzYUVJc0dudnV4Uk5vS2FkV0ZwRlJBbE1nMjdmWVNVcFJJTk8zekRLS0FsbStiRlFFYUVVSHNtdWwrQnF2MHF4MUVjRkNabVd0aStDU0cwQVVKUmJoc2FTejVDOUl1UkNRZEpZRWQ3bFVBVXZKcnMxYTZJVEdyblVSRGt1bkdJMUZKR1M2aDJJMUZnR3pkRU1SdjdOVXBDQXFPYkY1VXlNTHBFaGxCUHVYVU04Q3NtdVQxcG9nZHBXa3RrV0ZoMm5KWWx2QVNGY2d1elpxc1lsSEwyejFFUTZlOFZWVWFURWh3WXFvc3VtNUdoWHNqQ3JSVlRZUFVZTUg4Y25XaUlraytZTHpqTkhJU1NWbkduVDhjZTZ0Qkd1QjV6bndoU3JGSmdtOXJXaU9rNFU2VWRXNkNMWWp4MVRSR0UxeWlzakhHNDNWSktlTTdJQkk0ZzNxWEFmTEtySjMxMnJxTENEU3VnZ0xDMUFqamRxcjY2V2dGeWJOY2FxSTg1RzFnWmJZaDZpS0dCVnV3bFN0aTNCUWhZcWFZaXkxanFoM2lOVWNKM2liUitzV2RhZG1RT08xZU1Lam5STnRLNHVJa0ZzMmFvb1RyR1dJV2xRZ1JpWjZWdFlzSitobGk3Wm9sbE5GL3NaSVFwWXNKMWluSDUxcFdVNGdMVFk2cTFsT01Fa2hPZ21jaXZNWjdCOWFMMWIxRmFCR1JUTGtyT2J0QUlNaE9pMk00THhzTkM0NXNLUmtFaEJsaVVZNG1LTEZUZk01eTRsWUM2ZFlKV2FSVVhJSTQ3bEwwWFZBdVZDUm93S2FsQWc4VVpHcm9jVDNCVWk4bWhZdzJoSkpkczIwQUxkMDlGR05CcGo0RzcxVUxxTFZUa2NSWHhTSVFLb25BakxYSXl1UGhXMDlnNFlzZTRYdVMzUUtCYW5oclE3bGpjUWc5ZUdjQlFWZXg5a0JuZ2NlMEpNOEd4UVZWb3hGYmhrMThjaEdzblk1L21Bc1BEV0MzTWtTZlFVeUNWSUJLcTV5c09DQytFYlk3ZTRSbFJaRVlCZCs1TDVSV2ptTVJzK05vNXc2V3dIZm96aWNKSVlPeHNXdG8zU3JBNXJRNjZ3ZEdudlVPdXVJM0U2UkRGcTJKeHlzdG9sazBJbzlZWkQ3STNMN0tPMTBBanRhVlRVb0FsUmxrdFpFWVBkbzVBNVMyc2tGbkdaazBDYjFhWUxjbVVnV2JWTHpDMmhya1N4YWFkamtrUDg2SmkySndLMEZJcmVSQ3BwaUF4WTk5NUhTZEIyRG5sVzBhWk5GR21sTVZiT2JLdkk5eGF4VkVUN0RJNVNNMnFqVm15RENHclBVclV1dEVPQnFsc3A4YVlDQm5oVWtXdUZnZjZlWXRTckN3ZlRIeUEybDNLeUlKSEpIS2IxU2daa1d1YVdVZHNsQkw2eTlMQnV4dm1oWkJIZHNBVVJXb2hEWTF4ckpxQTJhQ3dzTTVGaTgyaFVCSGwwbHFGMEJzODlpa2JJSXNtZlE3Y09kcFNSWkZKQmsxdTF4YzRGWXhMRFVCa3hqb3NwM1FNWG5aSlY2Q0w2andjN2h4bEtCaVdCalBNZjZVb1Y1aUpFYlM3bEpUbTBVZE52WjFWcTFGb0t2VmpTb3RDWTJvUmRtVFd6Q1Y2dm1JVWxFRzhpUEhjbFJybFp3bVNkak5FYmgwQUdmakpaRDBOVUtGa05paDBYVGFqT2c4b3RtQ1hoRUZNU2NjTkJsbVloUFZtOWdjTGNtbytVUURsYmFKQ09CaDRsOW1VeFJjd0ttbHlSdUx0VU1UUEFzYmk3bHhNSUVnWjlrdFI0Q251L0pTbVdqR0pnRlVIbXRtaWpvVEU1ME5rclZSRVgzVHVLbG9GSEZnTWFsOVJEQllxb3NjWWpna09HUnVMbVVwc0lDYXloWmFldkRIV2xBKzRUa2pEYXRzWWhFVzdwR3BLQW5Ub25SenBIQXNrck9iZWo4bXRnOXFqMFIwUXVEdG42RmJ0bmt0QjRpb01oSGNrbWJPR1hrNlU2OEliU1pJWHBmNmQxZkRYcGg3VTJjMFBuZ2pjWWhJa3FKUyt3Y2lLSXdBN3MrcVNOY2poRXdlbTR1cGM3aWdKNGxtcktrU0tKbmFWa0U3S3FVYUo5bU1Wb0RJc3BzWG1nVjBKaElhczhLckZCTlhzSkRPYUFFalJURUJFdXcwVk1LVWhHUjhHVVJ4UENJTUVrNXNicHR1Zmx1UlUraUxjcGRmTkd3STZ1aEVlWUxKKzN3SE9IZG00TDBtSnc5cWJEaUdEMHFsMGhCK3Q5Tm5oU2xpUTBUQVJvcGcrQldVT2hCbk1KTmpBUmFhSXBpMFVmWXpDeEZhYndRQzRyekpqSm55WkxnNGxXd0NhSVVRQ1M4ejdtZFZKQ1d3V2pnaFptWUloNTRaWEVrbURtUXVKMlU1U2ErNk81TFVnR1JMVkpDVTVMY3FnemRPNG5tUlZkZURuQ25rQmxMSmdRWlFjQXFTMGtLOTNLQmgwV1M0b2NDRTBkVGttNEViSkdnSnhVMkg4alVRQ3VjdTBoeGQxckFiekpmeVh3b0JkNzhXY29lS2g0MmNkb25kcWVoaTVoc1Z6WWZBb3BIcEN4eHQ1cWc2cGxsc2RXQ1RKcVVXODJEd2UvanE1enROVGp5b3ZaRFFFNitSSWFyMDBvNnhFOWFBRTV6WFNHVjdaWUJpQ1duNHJwbEFLbThaaS9Cb3V2RTNhTTBrVDhocXFqMlEwRUhQbmVQRXM4Y0NQQ2tva1VQenFHT2k2bUlENUFOQTRPb3Fwb1BHZDVudElhdHR0OXdpTXFLK2VEeGZWMWROd3lRQnM3dG85UXlBSHVIdTBmTmZFaXBSclVlS2xJOHRVR1RaRHlBRlYrMTZDRkFXejl4V0ZmN1dxTUxncnRIcWFvTHhKTzVra2E3aEJkRVpjVjQ0RXZYQWlvbjNSbEI0SVpJSklrcGVoUll5OXBoaTFzdkFoVWcwNVpuNHlGbTVEbkk3QXhJMGxnUjZKM1phTjBEM1hJR2pVdFNqTGxwWWtCdmxDUlFicG9JRk1ac3BKRXNOMDBFWm5YbU5sTFNEUkVOeTJyZFE0TGx1TmxLNHdxbVFxd25JNWZOaHdUMTVrem5GWnNQQ2E4YUsxM0N1R2NpdUF5ejFicUhiQUJKbHFCRGhnbnhXVnJQTVZGRzg2dVN4WlJoZzk2c1FVcWJvU002T3kxNnlEQ2NsWjBXUFhDekMvUkdjY0pJdDBmUTBwK3piNzFRQVpzemM3REVDUlhpaEJPRUVLWUNIcHVzZm1ydUw0bFdvSk91QUV3RmRNaXNmZUdaQ3RUVVpPN2JsYlNqSmRpdzNFY3FDaFZ3ejJXdjFRL1pBME0rY3hzcEo5MHhFWjRFdDVHeVFvWEV5RlZmUWdSVWxzeFIvaXBVNkVqeVd2eVFBM0xiWnkrOTBMaHBKeHg4bGFCRGp1aGV5ZHhJS2dnVmVCU0hscndRb2JNNWFPMURocFVibWZ0SUNSRUlIZVVnZGo1VFZmUkN5V25tdHFUb3RndWkvekVWV3FkQlN4OHlUSHJJM0VjcUNCWGlWcFdZUTA1SUM4emNSOG9wRlhnaE41S3kybmtWYkorb3RROU1CWWhFTnhKdWdiMVBGaTNuTXJHb3dXbER0N1RYTlIvUjRKUGtNdkdaQkdRZHRmWWh3MHpVekRhMjA1c01QYXVLalpHd3FzR211TnpvYU5razBkcFlod0RXYjA1YSt4Q2hXcGFUWUlpd251VFFzNlN5bDd0ckF5bHlHeWxGeS9Ib1VZS1JJam9sZWxZV0V5UEFUcFE1U2VrRE53RkFMSzJheXhUZzlaT041akxCTGt1WjcybHR3NEVPVkZwVlltTWtxSTVrcjhFSFZMcWJ1WkdVWnFxamRjcU5wRm9VQmowcmFTNFQ3RUtldVpHVWhsUVJ0NHJtTW1IMWdLeGN5V1V5a0tvWXpXVXFHR0hJYWpwVFJzY2JONUlLU29TbzFoSUlVQnlWdVpHVU5xVkh0MkxSQ3ZxSHg0TDlseDJkMFNzdUk2MGROZ3J0QStIK29iTEdGZmNQMVZGZWlmdUhLbHBXM0Q5VVg3TGkvcUZpaUJYM0Q2V3JkOXcvbElPOTR2NmhST0NPKzRkU2FUdnNIMHF1N0toL0tJTjVSZjFEUkN2cUh5SmFVZjlnaWxSSC9VTkVIZlVQMGF5b2Y0aG9SZjJENGZxTytsZFFZTG1qL2lHaUZmVVBFYTJvZjhnbHQ2TCtJYUtPK29kb1Z0US9STFNpL2tFdllVZjlRMFFyNmw5QmZwV08rZ2RkSVpwQkJ1c2VPdW9mSm1xb2Z3bEJJM1hVUDB6VVVQOVFFNDhPK2dlYkI5eUIvaUY5ZkFYOVEwUU45UThTZGRRLzJFMjNvLzRoN0tRRytnZEpWc3cvb09mZFlmNEJWMTdIL01ORURmTXZvNFNQanZrSC9la2Q4eStpM05xTytSZlFreHJtSHdRU2E1aC9mRzJPYVJUeUw4QW1BQjN5RCtiMWQ4aS9qT0l2SGZJdm9sQk9nL3p6MEtmVElQODROUUVRTmNnL2lETFdJZi9FNWh3UmRjZy9oK0dHT3VRZkxQSllJZi9nK3UyUWZ4WUcwRHJrbjRYR3hRcjVWekZnWVlQOFF4ZCtSL3lEc2JFVjhjOWhVTU5XMEc1UWJWcEQvS3NRVHJRQi9sVjRLemE4UHlKQ0tCb0s5MWN6aE8xUXRMOWFNTHlnZ1AwWkF5Rk9HdGdmY2Nxajl5bllud25JdnVwZ2Z5d2h4S3JhNms0Z3pGZ0QrN013bjd1RC9VMmdDaHZZbnkzSUJkUEIvamlPT0VIN2N4NGo5Q25hSDJkY29Ra3EycCtiUVBRMXREK0xoOTdnL21EeitoWHViekt1Mmh0aElTQ2hEdmRuNExidmNIK0FvbUg5UlRpL2p2V1hVVlJpeGZxRHlia2Q3STliQVNMb1BRWDdJeE1FUVdjMXNMOElzem83MkYrMDZQNXVZSDgwTEhSaU5iUy9VQ0FFWm9QN3cxcEZoL3NMQVNQbXRiSjJtTEhRNGY1Z0M1dU85dWNoUEU1SCsvTUJZd0lxM0orM0VOSlY0ZjRjekZ2dGNIOE9HbjRkN3M4RkRKcW5jSC9zYWdPY1Y3Zy9QZ2dSdEszaS9VbXZHRVMxbHJXajgxc1IvNlNzSGF3YmdmeVQ4Z1ZBazdWZVBVTnRSVEgvNU5wSFlJV3RxdDFqckx1RyttY2hlS1dpL21ITXBBYjZWMkZmeUliNXh4bjFnRWFMMnZGSm80Qi9QQ1JFbERvb0IyQm5nL3Vib0hRMXVEOERVYWc3M0orcDhIQm9jSDhXRlVSM3REOEw0NGNkN2M5Q1U3aWgvZGtLMWJxRzl1Y3cybTVEKytQK3pZQkl3ZjRjQnJoc1lIL2FUbmxNMWNEK0pzTnFZSDhCd2d0MnNMK0VjZndVN0E4djVBYjJGeUFHU0FmN3d5MmVPOWhmQ0NoTTB0SCt1RWNTd3Q1VHRMK1FNWTZmb3YxTnJycUc5aGNxY2tWMHRMOElyY3lHOWhjTlJFTnVjSDhSSW5GMXVMOEFtdzUwdUw4QUV6azczRi9BSUpFTjdpOEU1UC9vY0g5aEF1U1hPeXdIZkZaWmRLR2lyYUY0ZjZMQUljQTdMV3YzRnNQaVdXMmZXMUFHUzRQOGsvNHpVOHcvMGVRUnhsNVFMSEVEUVVVVTlXOEN4c3F3ZnpOb0g4WDlZd3N3b2FFcjhKK0ZYYzFYNEQrb1k2ekFmeGo5cXdQL1JZaTQwWUQvREt5ejZjQi9Cc0llZE9BLzR5Qndvd0wvR1pqUzJZSC8rTzRFUktrWHNLT2hLK3dmYm52V1lmOE1ETzkyMkQ5NHYzYlVQeTYvQXRKcHFIODJJVk9sb2Y3WmdvSkpIZlhQV1JUdTc4Qi96dU5uS2ZDZmc3QU9IZmtQdCt6b3lIOWE0VE9tS3IxK0hjSVdLdktmaDJwMVIvN0RSMkJIL3NNWnNCMzVMM2dvb0liOEZ5TEdHbFRrdjVBaFZsVkQvZ3NGQWhnMTZMOEFuWVVkK2kvQ2RKS08vY2NoTy9Rc3dmNkxzQXFrWS8reDZZM0E3QlQ3YnpMNGh2M0hzVTJFeEtmWWZ3emJCNGdVK28rZUNPSXdIZm92R0R4RmhmN3pHU1ZITmVnL25IUFNvZjg4VE5qczBIOE9BMjAxN0Q5WGtEKzBnLzl4L3h4QXBOaC8zT2NKdlZDeC81eEZTbmpIL3NQdC9EdjJIOFpoN3RoL0ZqWUs3dGgvMWtJRTNvYjlaeW84U1JyMm40RzkyVHYybjRHYWM4Zis0ODdYZ0VpaC80eUgxMktEL2pNQkF3UUs5SitCVFRVNzlOOEUzS3RCLzVrS1pkMmcveGdCZTQ3K1oxR3BYQWYvNDQ2Z0NEOVB3ZjhzeENQbzRIL093TXRNd2Y4Y3JJWHM0SC9jaFI4UUtmYWZ3empaRGZ2UFZhaFZOdXcvajZGdUcvWWZXNmVBU0tIL2ZJTFNhZGgvSHJyYmo3RC8wT0FWK3cvM2Z1bllmeHlOUkdDRGl2MFhZTGZuanYwbmJYN0hSQXI5cHdBMlk2cFc2bDRnWEo4aS93WG9qdW5JZjN5TW83SFg1dklFRkpyQ2xPRTlVTmRDZDNSa05lUy9nTlhBaHZ3WHNMWFNrUDg4Uk1ycHlIOCtRVjQxNUQvdm9Ua215SCtUNXZNTittOEd6cTNZZndMcmdvQVNxMEtMQndqZG9PaC80dUVDdUF3Sy95ZTVtZ2o0em1rUmU4S29mYjRiR1JCTFVCRUFMV3pJMEJBQUxheHBXUkVBb2RkalJRQ0VIVWc3QXVBRVFxb2hBQnJVb2JnREFKcUljZThVQUJCM1N1OEFnS1pBbmlvQUlMMFhJU0UyQUVBTGpkd09BS2hkSmNkVUNnQm9NWjVIQXdERXZaVTZBS0J6R0w1UUVRQWQ3S1BRRVFBZFRHSHJDSUN1WXFTOWhnQ0lRSzQ3QUtEM0tHN1hBUUE5ck9Yb0FJRGNtd0ZSS1FDZ3J4QnNxaU1Bd3VZVVJ3aUFFTDZ3UXdBaVRiZWpBQ2E0SWpvS0lFWVM3U2lBR095bm9RQkdtSFBSVVFDeGw3V2pBRWJZTDdlakFESkNISHFqb2dDR2pORUpCUVV3Uk14VFJRRU1IcUp1TlJUQUFIMHRIUVdRUGYyQVNFRUFQZFIwT3dpZ2gxMEtPZ3FnaDlEdUhRYlFaVlNxMW1FQVhZS1FSZzBHa0VFVDBlZ1ZCdEJaZUZvMkdFQ0x3ZE1hREtCTkdDelE5dnduNEpCcE9JQnNzS0M5b1VDQUU1eThEZ1NJVDVJR0JKandEQnNRWU1SVUt4RGdKaHhBdEdFN0VHQ0J3RnNkQ1JERGMzVWtRUEM2RGdPSW9jd2FEQ0JzUzNnRUE3Z0pCUkR0c0RzVVFIUUwzNkVBSXVUVk94aEF0SzQ2RENETTNscGhBR0dMd3hVR0VDWS9LdzRnaG1WdU9JREJZb2cvQlFJTStEaHFRSUNjakRvSEFvUkdXOGNCREJtcXNBMEhNTUMwckk0REdDbzgyUlFIa0NPWWN4ekFnRG92ZGhqQWdER1NHd3hnZ0Yya09nemdCTEc0d1FENkNpK3hCZ1Bvb2VuVFlRQTlGcUxDQUNLczVZWUJpUE41T2dhZzFvSVBxUm9Hb0lPUVFCMERVQk1JeDFSYUR1OE14Q3h1R0lCOEhJSGwwR0FBYllCNG93b0RPT25Fb2ppQWd0V0xpTFFhM21RTVlLaVZFU2JDczFTaEFBVU1FUUNYZEN4QUI3RmdPaGFnQlNHNUZRclF3aHFwRGdYb01PYWVRZ0hDMnRvT0JXZ3dVaytEQWpUUXFiaENBVTR3RVJzVUlLd3k3bENBRmpiWDdWQ0FiQUFDSWtVQ3RCVWxYcXhJZ0E3aHZuVWdRT1N2N2ppQURycVBPdzRnUisvUUJCc09vRU0yeUlvRENEdGFIZUVBb3JYVmNRQWhHRkdEQVF3R3NsUmhBRGt0RTlBMEdFRFlqV0dGQWNRWVBCMEdFRmE2ZGhqQWdNRWNHd3dnNTFLaU4yb3RQRGIrT2c2ZzVtV09xUVFITUVDODNvNER5QTAwd2VBYkRtQ1k0TzFwTFh5QW5waU9BOGpXSFhxalZrMTRpRVBXWUFDNTdTVWdVaFJBancvVGhnS0lhODRiQ3FDRDlXRWRCZEJGaUIvVVVBQWRyS0ZwS0lEU1ZCL2g2UWtNSUlkb0VLQ2dWc0xiQ004SHhRSGt3QkZ3bkRZZ1FBbENvZkxjdENnR0ZEcHh0UjVOaTFiR1JGb0pieUxFSXdxdGJpSWc1WHRGQTRRdGNGWTBRSWRyaXhzYW9JZDF3eDBORU9YT0tCZ2dyR25wWUlERVVGUTUzY0VBSFlSeTdHaUFNSW44Q0EwUVFVcmR3UUVpZUxFT0IraFExc0lLQnhnZ3BtcUhBNFNXU29jRHhOZDBnd1BrNHdFQi9UVTRRT2ltWGVFQVlYUEtGUTRRdG1Mb2VJREJRS0N1aGdjWVlCcFl4d01NTUUycUF3SkdaQnV0Z0lDb0FtM0ZBNFI5d1ZjOHdBSWhuQnNlSU8xdDFBbWdBUUxTM2thTHF3RUNSck1GRURCZ2dNZ0dDQWlqaVIwUU1HRE5yUUVDaGdoUDB3WUlpTk5yT2lCZ01DaVZxZ01DY3JjcEJFR29sUk0rWURoREJRVDBzRzFhQndUazFGVEFWQVVFWkZVSkRVc0JBYlV0MnBoS1N5Y2NxcTN0ZUlCMGNTS05SZkVBMlJzS29xb05FRkJTTHFhSWdIeHpJc05ISVFHbExRb2FGNmRqU1RVRG9CRk1RS2tHUmUvTFdtUGhJRXZ2VUFFaE1HSXJuNEJkN2xkVVFBT3hIVG9xb0VYZXU0NEtpTEVmT3lvZ203cUFTT3NuR1BZUHZWQlJBWEUrVDBjRk5CVmllRFJVUUR1Wm9xSUNXdGhFdTZNQzJrMm9nQk0wcDQ0S2lBV2txSUM0WjJ5SEJYU3dFVjJIQlhRdzg2TERBbXBYd1RGVmd3V0V5WllyTENEVUYxZFlRTGo3VjFoQW1OTFRZUUVyQnVsVFdNQ0FBclFkRlZDYjZZeXBGQlV3d05xM2pncklOeitDMzJ2MUV3bWlyelZVUUZ4WjJXRUJaMVFLQ3hoZ3VWYURCY1NZRXgwV2tHR3RFT2Fkd2dJR1dNM1FZUUU5OUYxMVpNQUp5RlJEQm1UdEV4QnArUVFHVUduQWdOWmg1QjJwKzBySTVtendnSktaaXFEL2l0WndRMlRvQmhBb2xSOElRMDhRQXVYY1F1MkhySm9aSGdXUEdrWWcrd3dSaXFlQ0JGcnQyanVtMHZJSm1FcSt3Z1JHQ0Y1NUJ4TUlwOWhnQWpFTVhZY0poS2xHSFNiUWVDaWdCaE9vT1U1aktvVUpOREJWb3NNRUdoaFhhRENCQm5ZUjdqaUJPTXUxNHdSYWozeHFIU2VRK3pnZ0pFVEZDYlFZa0svaEJPTDZqNDRUaURHV09rNmdnNjA5RzA2Z3d3dTE0UVI2aXgrbE9JRWVRd3MzbkVBUEhmZ2RKM0J5MzNXY1FOaGhZOFVKaERIYUZTY1FWb2QybkVCZzMzV1FRQzRlbUlNRXNrOEo5U2hUa01CbzRJbmFRQUlqcklMcElJSFJZZmcvclorSTBESFZRUUk1cXdJOVMwRUNJd1o1VlpEQWlMenVIU013V2d6R1ozb0NGTVRaczczbEUycVAxMEFDSi9kK0F3bWNxRWtOSkRBWS9DeXRuL0FZVFZ0UUFnVmhBTFd0a3g1TTB0c0R2VkNBQWpuVENEMnFhaTAzREpvMnBFQ0JiVUNOOGdRcVVGeDBZSWFLRmNqdVBnakw1OVhLZ01rU0RTMVFVb2dRbGRaUFdCakVYT0VDS3dLazdtaUJHWldSckdpQkdLSzhvUVVLT04rSXFJTUZHZ3VScEJwWUlEYWFPMWdnRndOUHdRSVpUZ3UxT3d5OS94T0VGRlN3UUlPNjUzYXN3QW5NU3NNS3hCcFh4d3JFcGJzZEsxQmhDNFpVRFN2UVFtMjNZUVZhMklDMll3VmlaYmRqQlRvUDRUNGFWcUNEWGRJN1ZxQ0R3UFlkSzlEREJzNGRLNUJPRzRUbDFiQUNQWFNyZGF4QUQ5TzdCU3ZRdzhEamloVm84SU5zejRGQ2dKd2RLeEJDcXE1WWdSSGRCVWRnZ2VoUnNlZEFvY1hjd0FLamdTZzRDaGJJdWdHQ01GU3d3T2kyZ0FWR2g4YmVzQUlqOUpaMXJNQm80V3BvV0lIUlFNeWdoaFVZQ2hSMXd3ckVqYTRhVmlDK3FSdFdJRi9DQ0ZoSXdRSW44YUdHRmlnSittaUtWVzBNdkNBVUx4Qlg1VFc4UUVHcUJVUmlJVTZDbUEwd3NHYU1UOGk1SjlWQzJTaGlZTUU3UjlzKzU0cUhKSWlCR1FLSE44UkFUdkJFc0lLQ0dKZzgwbWc2WW1DRmE2cEJCaWFJOGFhUWdSRWVvUTB5TUVKOFFrVU1qTWc5MFJBREkyeHgweEFEWTRhTFhCRURJeXdiNjRpQk1QbW1Jd1k2MUUrc0l3WUdqUE1uMVJJSk5tMXVpSUVKZXJNNllxQkI0R2NOTU5CQkdMVUdHSWdhSWpXOHdBeTdTRFM4d0Z4UTJtdkhDNFJKUGcwdjBNRUhOY0RBZ0xFQVJaa3EwQ3ZUQUFNTERJUjF3RUNZOWRFQkF6RndhQU1NeEFlS0FnYldncUVBRlM4UXVteFh2RUNvcVhlNHdJaGgrVXczSUZBMzhUdTRRS1NwMzhFRklnMzFEaTRRU2ZrT0xoRHgvUTR1RUNtZksxNGdLRUk0d2d0RTI3ampCUWJjVmJ5dVdCNEltSy9oQldMRnN1TUY0dEYzdkVDWThicmlCUVpVWmQ0QkEySDdxUlV3c0VCVnZTTUc0cU9oSXdhaTJQWUtHSWczWWdjTWhFMVZWc0RBaEk2SERoZ1lZREZ3YnBpQ0NJdXBBd2FpM2o4clhpQ0d1T2w0Z2RDcVdmRUNFd1NJYTNpQk1VT0F1SVlYR0dFSnlJb1hDRk5SVnJ4QWkxWjh4d3YwRUQrcDR3VUdkSGl2ZUlHdzFmYUtGd2d0L2hVdkVCYlRybmlCME8vZThRSVREUHNlUVFZaVdKMEdHV2p4Q3h0a29FT1h3UW9aQ0F0TlY4aEF3UGVPRjRqeHREcGVJTVo5NjNpQkVBQjZ4UXVNK0kwTkx4QldOYXg0Z1JqVHJlTUZScVFjcm5pQkdLV3M0d1VtaklEWDhBSVR1b1ZYdkVBWUgxb0JBMkZaNFFvWW1PQXVhNENCR0dxdUF3WmlmTGdPR0poUXB0QUtHSmdnSkdMREMwd1ljNi9oQldKQWlnNFlpTEo2Vjd6QURCZHF3d3VFYVNFclhpQSttanRlWUVhcThJb1hDTXNQVjd6QWpNRU9HMTVnaGxCbWQ0Q0JhSmQxd01BSUFWRTdZS0JINnM4S0dHalJnbWlBZ1FtbVhuYkFRSVdQR1ZNcFlDQmZMR2lLQ2hpWVlCNWFCd3lNc0pWeEJ3eU1DVE5DQVFNamJIVFFBQU1qN09YZUFRTTFoaittYWtVU0VZTVBLbUJnMkFRWTZERWlYVU1NWlAwVWlMRWhCbm9ZUysrSWdkN0FNMXdSQTEyQndLTU5NZEJGK01LR0dPZzhpdGVzaUlFR1NyRWhCdUkycEIweEVLY0xkTWhBNjVFWnVFSUdRaTlxaHd5RXRlOE5NWkRqSTRoYnJVNGlZVDRvWXFDQjZUWXJZbUJDTy9ZbEFPL1pnNkgvTEZmUmNoUEN3L2VYNGVsT0h2ZnRELy85WDMvNTIyQlNSdjQ3L1BYUGc4OS8rKzEzNXZEbjBXKy8vemo2dFcvTTRRdDcrUGlud2Vja1dKbUlrei9ZMHZyNEl4amh4ejhjL3RFWVQ3WlorR0JNTlBSM29UODhmYituLzAvNi80SCtOaCsrL0RnQ0FQejY0MHlDUTFaZExjTWhxbUdYSVBHSHU2ME1CR2dIeUljajNFTXpRRDIwNXZEUGwzK0IxWkc3UDBaSWlIUzlPam9oTGcrU3NTcmQ4S2o2RHJOeHdLQ3RLNWZ6QlByM2FQV2l0VHRZdVhqZDNxMWFiNlN2Nm5qZDNxMWF1a0NNL2FyOTdVZXI4K0xhM0xJeWI0UmhsdFNGcXprVzNqTEhIQmxNVjNNc3ZtV09lVklqcitaWWVzc2NDNlMwWHMyeC9KWTVGc204dUpwajVTMXpMSkdwdFpsalliOHJIWHRJcitmWUU5eVZVNTIyYVlzRG5mYSt5amxnckQ0cURsSEYvL1NiejFjc3B6TWhkcjZXcVRneWFWL0pWTHpQcjJVcXdhZlhNcFhvNDJ1WlN2TGh0VXdsZTM4alV3SHVMcmt2MjR5NGcyQ2hTYjB0bDFjZHU3T2tucjhUUm1kTStJYitMdWYrTWZmTkxmbkZsa2gvdjN5M0dNbnh4OUZuaitvVTIrQWRkbFlReGo1L3AyelFnMS9XZnJIbVVaYjVEVEtOMjl0dloxdDhHYWZEdHJWdHM5dlg5dW5YdnJidmovVElRbjRaYS92bCtodWMxdXR1YzJtOVZhZU0wOTV3MjN3eWI1aEp4Vy9qVVh6RFBOSWFzam1QMGh2bWtVM2JlSlNmMmVjcGZoei9BR1oycEljOXIzY3RNZUQ0YTVsSnlLOWxKcTltZGVYNlNpWVMwaXVaaUhVdmNTSm5xdlUvSEg3OS9WOSsvOWRmZnYyckNlR3Z0bjQ2L216MHllam55SDY5eS9VS2t1U2FUczRrYlBtdUx1bjczakFzWk1HRVBYV1MzWGVPM1hlS25UbkRHQXdqbmZ4NTN3L0dRenRkTjV5b2JDcjkrTlR2OWQxbG5wOE1leXlMYlJ3eWgzUUxIQkxGNXRHNGMyK2FaNU04bmFJOW1lQnNOdWFRVCtiQ0RQL2g1UDhaMHp6NS9wZlJSWHRFa2U4dGpPOHVUZTlrQ2xoUnZlVENQMWRIVDVUUVM2b25kMzczdW9ya1g1YXhUaTBIVGhnUnV2aFQ5ZlBJSysrTmliRWxuWEk2akQxVlFvOVV6N0hDK1N3elpHQjVrK1l6ZEcxMm5Gb2I4ODNNamxHZTgzeDJwZ1ZISGw2TzRKRHlEcHhTRjY2dnU5ODh5eEtlM2ZOM3Y4cnRXQzRrR1YvWThXY1h2SkZRekk4WGZ1cGMrNk1IYSs3Uk1EaW5EV2QzZ1g0UW5QQkNtcWZKVTlaL3g0c1BhaC85TVBvb2wvNVkyMTlzeng0a3VKWm56NURYSzVmb0tlYmlFTzZ6OXA1Q2cxU1p1V2Y3NkFaYkxrVTJ0MWpyNDJqbXlENi9ZSnVQN2ZMN1c0eit0clMzU0pPNVlKb2ZuUjladzQ2Y2toL2RKUlA5ekR5Zm1lYWJtRUhySVBPZm52WFdFUHpUTVlhYnZpY0IxTjNBSG83UU1udXNhOUZhcm1xd2QvOHZuNytubjc5N090WTk3VHFpcTNZYnF5U2xtWk4wbVQzdlJvN0QxOEFTeCtYQWZ1c1MwbFR2STc3VVY4dVhVclJ0L0JhdXZOZHZVeDZBRzlpOHZPWjQ1eTZUTHVYSkNYL1JHSjdlNWR0dTg5Rjl2dTFHQjNmNjliYzZ2TmV2dmRsSGQvdTIyLzM4ZnIvZ3NzRHVpaTN4NjlrOXY5VXZqektYeHQ3NGk3NTQ1SW0vNnM3ZmtxMTBrcW5rQnRHeEMvNzZ1YmQrSTk4MnFRV1B5a1BwNUpPa2wrd21WcnB2bnA1THo3TzZiT1htU3ZqYU96bmlTN3YwNmppSytQcTQ1QmlKMlcxZlB5dVg0amlPK0FxNU5GVVZUbmowUVZYTHk4ckNKL0huMHozUzF5a1VESUVkcHlianJsQ2NmTGdyRkdkVGV1RUt4YWtiZ2Uzanl6dlZMY25jYVJndlZRMHBrdTVuNkRzTkFtYS8rODNocDVlcHZ4UnVzYjc5K3RudTROQ2Y3ZXJPK2VCNmdzdlJSVjYrM05XZGU0UHJxVktOUzN5bHYvdHlWM2RPaG5iejZrNUszUDl5VjNiVzM5aVZuZUZUdnIxWlpTZnFuZWp6MjNTUXNCSlh0bXNZYTlPbk4zUGFtMGhiK3dyTndmVHZOOE9oRFJHVTAwVDk5dDMxcS9CbU9GV3pPaENlYnkwOWxlN0FvR0ZtajcwYy84YXVQUXlmOHUwUE54dDdJZTNodzVkN2FHVVByZXdhdytQN0djSzQ5T2pyWFZ1NFhXMkIreGNudjBkV2puOWpWeGVHVC9uMmh4dVBySmhCUVRjSk00UTc1U0tNSWlyWkg1NHpzV08vVjE4b2g2SmdGVzVkakdtL1NlOFA3Z1hlcE5jWHpUMUtIWWc5cndNcGpLTWpYSlovMFMxVGwyTDh1THpsbnVyRzUxZ2VHZ2lHOFZaR2E5VXdDTTU2VHQ2TFR6OW9BUWxqUFZWVTZuWkIzSFB6N05KaXY3Zk1MN0g4WGcrYnROajdTL25JTkQwTHlCa0dLdXNmaDZCVk9Cd2Y3bkZpamd1emg1ZXJkUGlxa3JabThmVHo4NnNyTThqUUhWckErVnZqM1V2WDRpYnVuM3FmOG1SYm9RMjF2WWpIR1ZqRmMzR3JqZzZweXdmVTJlRTBPcGcyZEI4NkV0NVJqUlEzbWhXSk5Da0lBMzJUU215U3pKcXFJUkw5b1BTeGpodlV5ZTgyU2N2bi9MdnZtb0JpKzMwR2ZuamZubS8xWnhMTjlIZTFYUEw4MnNaM0lRSEVrVTV1Y1k0SWJlV2piWDVlRHNaZjl3NWN0RFkrKzdnRVo0RmpmRDUzNVZsd2NUVnQyditYMXRGNVlvTm5BTCtMcFhkYlN3cy9kZWM5L1d5NVA3TWRGbEtldXB2MDI5dWJuYXRnNFpZTmMvWGwxdWZxR1prb2t3NHhuK3RYTFFpWjdnNjhVRzUyM293ZFpyYk1tdy9jMDhMWko3Zzl2WU8zNThTcEUyL1lteE9NWTl6SFM5NGMvc2hMTmpEOUl6WnZ6dnJ2T0hoWUhIbHoxZzl6NlkrMi9mVzdOK2VGZTNPRy9obHpaNTJNQWg5c0dFeHRjY01JblNNN3AzKzk3a0RUaGhMZmh5dnl2UjN2aDdzaTkzWHppdDVXM25wNGpTNmlrQVRwY25jdDZ0ZDUwbXRjU3RtZHIzZGZaN3FjZDB1Mk80ZnV2czQ0bEF1cE9zL0tJZXlHdlZhOUdSYVliMnNLdDBIWDNhcnRqdlhkclJvdjFIay9SZXVkNkwzWGE3NWozWGVyOW50Si83M1lMUS9yd0Z2YnA4LzE0Q3RhdzRJdCt4aE5ZYS9UaWJkb3hWdjE0bzJhOFViZCtDbTY5ajZ2YUx4ZnJKM0Z0azZQMVRmTHFzSW16QldzQ3MvWkMzcWI1ZlVFYk50a2dUMmtEWGFiSzlGZHdkS3BUZllwVnRuaDFXOWc1ODJTekZXSFhXZzhtL1N1ZUFPOHk2UWtoU3M0bDQ1VzNZZkhYM1ViVUdpOExVdDFrblJ3czNoazF5cFcyMjd1cDhPaWVSbHNpOHY4RURqaDNLYmo4K1ZBMHp5em5zUWRYZU5WeHl6c0FNZGZuM2hJekxqNnNBYjlzTUhMYnREMzM5a04rcmRtMEkvUk1EZTFkbmxidHRLMnNxZ3RoVkdITjJBRWJXbktjbkxOYk9pdmRuajltcnpQUzY1WGNLMDNzeW1Qajl6MGdybVdNeDBUVjYyMmVxUTBmdGl0bi9WcnQzNXUxUHJoQStEOWJ2MmNmajJBOVRQcDhYUWoxcytnMzlOdSsvVGYyVzJmTjJmN2dHQm1kRWRWbUo4YnpOeHRwQXREM20wa3RaSENKOWxJL3ZHMTFwZTd4N2ZrODEyVGEvUUdPTFlwdzIvbjJmVTVmenZQcnM4Q2ZCS2VQYTE2UFd5SnRpdlkvWGQyQmZ2TktkaFYwNFBzTUgvUDBqM3VEbGNHSS9iRUxWVzBFKzJaSzdTZ0IzZGczSkNlVFNkSnZ1cFdldC9pRUwweDJic3ZkMTE3MTRGMlhmdjhhOWUxZDEzN2FYWHRjVVBCWGRudXY3TXIyMjlOMlhaZkErVjVMN25aZm4zSHhkUzk1T2JTcCtlZFhjZ2N1cEdTbXpsUzJCQXI3RVdaZlp0UXd6NnRYc2RBM0xERDRTMkVZNjZ0b1pnQVpCME9lNzVhSCtTRmR0L3Z2OXp6MWE2Ti9IRytYOWp6MWRhdlBWL3RlZG4yeWZscUdSWHM3Zmxxcnl4ZkRYMDYvbXo4Q1Q2dytqRVZzMTlNU2VuK01UVTc3dnJ2bDRPNXZrc2VhWWd4NnNLaGYxVVZKMjZYTi9kNW1LbTNZN2pVK1JtWFZnM2R3RU92Z3ptNGRQa3o5TW5sbjE4eS9uOTNVZFBlZWdzRnk2MTJmUWdIWjl6MTZ2d1dKeEYvSFR1SzR1aWVZN0svRDArOWZ4cCtNanIzU05ML1BQam8zLzBoL0ljNS9HSDB6S1hVY1BMbjRWKy9IZEFTQjUzMWg5R1VmSW55K1ErRHo3K2JuYzFEcnU2OGw5VmJET1E5Zjc3enZuODlNTzlEeHJ5bnozZmU5NjhINXYza3pMSDdtWFAwOWJDOEp5c2RzWjQrM2puZnZ4Nlc4eUZCenRQSE8rZjcxd09mTnc0Zk4rN0JPWCsxN2ZuOGFxNzdCTm02b1d4cEdSbDM4dWVMdXhGdVVFYmhZV1VrTWNIWS92eGsrUVRMa1VYTGdDZmpqUlFjV2VCS2hHaVNVeHBBNUJjYmxjZ2lvbFJuYnd1TDgwcFRFRkhPUWxUQWs2SkV6NWtvSTZMU3hqMCs2RU5hdkhLcEZFUlVsVTBGUENrdmRLRllSYUVaRXJWM0lZb3UyeExHUkhXVnJVTkVxVEZwdkpXajZjSXREaEZOaFJ0dEYyNnhpS2dMZDB6alZ0a21SRlNVU3hrUStTN2JIQkZSbCsyWTN6RjAyYUxYeGVtNzRnYlp4clFZNVZHR1JFMjI2SFY1bGExSFJFMjI2SFdsQ3hlOXJxekNCYStyeS94QmRSWHVlRWpKckJzWEVqWGhvaWZaVmJqak1iVmpFc3dzdVNYNjZidjhCdUVTVWQrNDQ2MlVRaGR1OW9pb0MzZE1FMWZaRmtTVTAreEJxWWsyVlVUVFJRdGVsdGQ5aTJpYVpOSGJ5aXJaaklpcThpaUJJZFV1WEVDVXpRYmhadE9GbThaanlyWUxOd1ZFbEtZRHowNHl4YXhjOUlDb1NUZU9tY25JU2ZxZ2lHaWFlTWZIWkE1ZHVyRWdvaTdlTVUxY1FweU9PbmJweHZFMnlhbExOd0taNUM1ZE5PN2NwWXVlVkZicFdrU1V5bFJ3dFVzM1JrVFVwVHNtS3FaSkYvQ1NhSnAwNDNqY3hhN2lkWWlvVHRsVTNDcGZpNGlhZk1OWUtzV3Y4aDB2cHhLNmZJRWZrb2lhZk5Icm9xQkdUMllYdTN5QlVGSVhMeHBTV3NVTEpwZWJlQU9rYWVJTllFaGw4WG0ybjRpb2lSZU51M2J4b3RmVmRmdU8xMEExWGJ4Z2R0V3U0bzJJS00ya1cxMlhMbnFiNjlJTllOeCtGVzlFUkUyOGlDaDA4VnBFVXhyUm1DWjI2UVpJMUtUcng5S3RxVXNYRS9YTkMxNlhWK21PYWNwaWxFbStJcUs1Y09zcVhFUXpsNjAxWmhWdWdWUjVPbkJyeUxhcVc2aTZnQ09nY2wzRThGbHVsWEVDVkg3ZHdnNVNOU21EcFdCTjRBdERxTkRvNHlyb0RLblNmUENwaTlwN1NOV0U3UU9neWwzWXZrQ3EzUFlFWWxkWmhSMGdWUmMyZWxaZGhaMGdWUmMyWUwwMXE3QURwS3B6ZmxtN0NodHNJZnA0dnF0VlJ4UWlRT05YV1Z0STFUYzI0S2tOaTV0dkRhTHFzZ1pFY1JWMWdsUk4xRkE4YVJXMWhWUmQxR2hjbVdVOEhWZGVSUTMyb2kycnFNSFdzTFdMT25oSU5kLzhqSTRjcGl1UXFGS2VIUFRXMlZYVURsSjFVWU94TzlkbEhTQlJFN1VESzk3NVZkU1FhSDZLdU5BRjdRcWthb0oyaU8reEN4cU9QWFZCd3plbUptaUgrSjRYMjVobElWVVROQnhXNlpKMkVWSTFTY054MVhWWFk2b3VhaUFnYjNnTHp1WklWUE1YZXJ2S09rQ3FMbXRBNUZaUmcvUEIrMVhVSGxKRkhid0ZDOEtIVmRZT1VuVlpJMjdGTG11YklGV1ROYVJLWGRad2pvbTk2L0lzc0xwODdySzJBVkxWK1JSTGx6VjhWT215dG1qd2RSVTJlR013aTRuVEtRYXpDaHVNSzloVjJKQ295ZHFDUXltNFZkWU9VblZab3lsNlByTm1LNEtvdXF3QlVlaWlOaGxTYldCVzdLSTJCVkkxVVJza25zUm05bFNJdVl2YUpFalZSRzNBNGdxbGk5cFVTTlZrRGVkWXU2emhHeXQ3WjJlamoyYVZ0WU5VVGRhSXE5R3V3ZzZRcWs0WFYzUmJoRTFVTmMrSDVWZGhnelVZdzdxdkhhVHF3Z1ppakxFTEd5MHZvdW9iRzRneHBuVmpRNkltYTBTVVYxRUhTRFhmMXJHc2txNlFxa2thRWRYMUJQZVFxa2thU1NlWkxtbDA4eWU3U3JwQXFnM1hkWEliVHZEa3R0eldpVTdkS2JlSXFBa2F2UzkwUVNNZGo2aktoaGZHOWE0dWtLcE8xYVNVMk9hWnZqQjFTYU1aNWsyQ0xxdWdLNlNLODJXYTZpcG9ENm5TWEJOa0tLM3BlVVJFZlVzaktydUsya0dxTG1vMExMZUtHbE9WT2J1eVgyVU5pZnJ4amFZWTF1TWJEU3V1c3JhUXFzc2FFQ1UrWkdaTFBxZFYxR0FKNXJ4aFV4UFJmRlBuMGlYdE1WV1ROQnhWWlEvTDdJQWdxakszdG9ycGtrWnY1S0x5UEYybnhYWlJBMGtYMXlXTkRwc2kwY3ZwQzMwWE5SeThYMFVOMkZYQ01yY2VpS2p2YXJBZ1NseGxEWW1LbmZNaGRWR2pZNFNvUk5RV0JmUnR5U3BxQzBsRXpnWXFuYVdJbkUyQnZwRlNwV0dNaVNoamk2bFkwTVpEUVZjamd1WW9CS1lpUWRlTTB2WnNwU09YUTBNTzB4QWpxNGNIV3hVM0U3MFQ1TFV3RVVtWkdJWThVdlFpRWpJdGlJcUpTTWEwbGtHdWphMkJSVndzeWlOaElub1JiV21EbmtSSHJjVDJ3VHFvaVNYTVJCRVNrWUQ1YlVoeW1lWEwwWFpNUktPaExRaldlQ1ZPYzRBWXZxeXd5R2poSmNTa0t0SWxPNlpDSXBJR3NRb0UyQnd0V3BJdXZYUkN4RHZZV0RBNXg1OTZpVUJob3Bva2hnT09mY2N0bm1TZmcyUEYwYVkwTFgwM1FTbzVxdU9TMFFTREh0VUZqajNJU2UwczJuaU9UaFE2ZmRseG5CT2t5dG9FRTNpN25Va3NabkdZRmtqRlo3VTNLSWZQTWN1ak9CMTlnVlFzYVErRFJZN08xdURVWVJvaEZjdWFPK29qcXNxeWRna3lsWS84SUV3RkZqdFRzYXlkUVJhN28zdElaSjJScGNwVWlkZGdRSmUzMDZ1V3J6WVE2MklxRmpieEl3RmhXeS9DNXBVUklCVUxtM1lJcUhoeU5HemUxUlhsbWpOUktYd2hPY1Q1eUZQanJBY0xpVWpTMWVHUjAxSExxU0VPU1RDem5QbW05SkNJeEV4UFFsdUh0aktwRWhXbXRqTVJDYmxHdkJJcXk3aG1sR2JHUkNKaWcvUWxSeXRUUkV4SFZvQlVJdUlJUlV6SGtBKzZxREJWS2JKQUlaWEVhbm14cHdDcGVEOXJXSE5NNVdVL0c2U0RPaGQwUDhONkFhYUtXVUppSUFISzBjZldTb1FLSFVaRXhmdVpJMEZvOEVuMnM0ZlppVXpGd3ZZQjVZbzVKeHVMb3hib0ZpT3FJdUVJaXdaZlJOWSt3Yk9iRDlxaXd3SkVWWTl1NkZ4aktqbTZLNG9STStLNUh0MlF5TElqV2FLdEJWS0pxQTNLZDNSZURIQmVnVGxES2ptNkk3d0d2TmVqRzhiS21VcjJkVVYxTkk1WTdwcFdreUZWRWYwSVZHUTRIM1ZiUThPTHFmam9oa3FpbytYQ1IzZEdEbk1tNHFNN1FBMkRsaWNwbXRWaEpoUVd0Qmd3aUliRVhQQzk1Q3RMbVlnZ242b2MzUWJGbzEyUVU0aUdaREVSbVcwVmxoTzVZRmtlRlZQSVpRcVNWVjF3S2x5RHNrdVlxcWpSaVZTaTRHVWptd2lQVUtLaVFmTXRnZFRmRUZpK0xaOW9UQlZsSjdOdWtTRVY3MlRhbzFBeVNROXRnd3hycHVLZFRHZUhSWE5rcUZaVklTdWtJakdMTG8wNFVXUW44NkdWSUZXUm1Ec2NmTlZET3lKM0xWT1ZkZ0VBcW1qWVB1TlFjOEZVTE94ZzBCYU1WbVJOeXhVZEMxSENmL3lvQklsWTFMNUNyVHg2RVRVZE5CbFRwU0NYbDBFekRDSnFOblV5cEJKUlo2aVZ4eWlpZGg2ZWFrU2xKa1ZFUkVsRXpXcytRS3JDTzRPMkpKcGlGbEdUTFFQOEZrd2wreHFmTjdHSXJFMUFqaWtYcThoYVRYTkVSYStxRlI0UmlRNWNQZ1JCNml6VGtLUko2UVlEVDVibFhEMGNFUkh4d1kySG5lUWlyZmljU1Z4SldRMWNMa2thbWxXWVFzOUVKT0lhVVEyY1M0RWx6SmUzZzBRaVlJL0tUVnlLS3VDTW41WDA0TGFRNVltMVdYR1VnTldaNkp3NlNBWmhnRVJKclhYa1ZFcEZqMjFzaHhOVmR0TWR6MjNtMGxRakp5cnU5VW1uS0JoV050SVJNRmk0NDdPTWh4TkMwQ21hcmV4bHVpNlE3a3RVTE9xSTc1d3N6ajdPU2tCV0lUZU04NUpKNENBUmk1cU9OalQyd0pLbU15dGdJcFoweE82OEhFWFNkQnFoZTRLb1dOSmMvNG9tbUVUU1hBQ2JJQlZMbXFpUW9aQ3ppRHBoZFl5b1dOUjhiS0hSaXdlVnFlRG9pNGhhQzJySFZGVkV6VlNBOStxMGJna0hpSXBsblN6VVFvcGxZV3NKTHlKaVlTZDRqQlFKYkRJUjZJWEFWQ3pyQk5OSlhmR0MzWkpnT1IxVHNhd1RiS3pnU2xCWmV4UkJZeXFSdFllbmZJa3Fhdy9xNzVsSVJPM2hFaXlKQzF1WUNpMUJEUm5JZ2tpUVNyWjFSdlovS2JLdDhiVkNSQ3pwZ0tNQ1pLR3hxSVBEWTYrc2NMTWFETll5MzgreDV3OGpLcFkwSkxIYXp6V2dWQjZtWWpHYkRPZFhwVFJwWnExVmNlWlZXRDdzU0pNaE1aY0E5UUl5d2tuS2RBeWltNjdLRlpld2lzVWVUUzdJQitFeHBpRVp4NExDa2E2Szg0cjdGa1JJUkJLT01Jcm8yTTBjbVFoZEZGV2FjYytlVktSdkx3enZNbEhSZ2FOVlIrZnM5RzJWeFl1SlBDMFJFdStNeUxKNDUwUWszaGtSWjVoZ29UQk44bE1pUHhjdkUrWDU2MElUNzRTb2lSY1J4UzVlVEZUU2xDZzE4V0thT2lmS1hieUlxSFR4WXFJNEgzZGxSOGFjYUM1ZmphRE9pZWJ5dFhhRGZObkFtQTVjTTM3bVJIUDVraUVkTnRETTVVdTN4VnkrN0U1Mkc0amluRTFwZzN5SmFJTjg4eGI1NWkzeUxWdmtLM0hvR1ZIZEl0KzZRYjdPek9YcnpBYjVPcnRCdnM1eHhzbWNhQzVmamxMWERVUnorYnF3UWI1RU5KZXZpM3dUem9ubTh1VndqOXRBdEVHK2VZTjg4eGI1Rmc0UXpvanFGdm5XRGZMMVpvTjh2ZGtnWDI4M3lOZXp2VFdqY1J2RTY5MEc4WHEvUWJ4RU5CZXZEM1B4RWsyZGN5bHVFSzlQRzhSTFJCdkVtN2VJTjI4UmIrRXlsRG5SZkhKMWkzanJCdkVHczBHOFJOVEU2d0NSNVJRaFZ1Z3RKRkw1eGdDSVhKTnZRbVB5VGI0VjByQjRLL0tqK1JCRXZCVnEyRVNVSEJORnhJSEk0azBCUlc2WUtFdHpMRVNUV0x6WkkzY1BFNUY0YzBHZVZ4L0VFVmRnNUpDSlN1UTBSSWVlVkZpODFTS0RuSWxvWGpXaW1JMFBsY1ZiQzdKOWZaUjh6OVpXQTFGeGUwRFMvb0g3ekxNanRmU3VEWWlxZDZNRFJGSkl4dlgrU01ic2t4V25PT0JuOU14dXpuaEptQ29YeVhncGFGUkJlanU2aWdLZVRGVTA0US94S3JLWUpVaVpJRlgxNGpoSHh3Yjdpck5HRnRIZ3MwaGFDendSRmZkNERBbGxnbm4xS0hNeFlzUlVMT2tJZTJsNTJ1eTJPY1VUcE1yaW93WVpCVDRaa1hXQ3lTeE14WTBlRSt3SDRKTVZXU2VQbkRsTXhiSk9NRTNQSjhucTVIb3F0Qlhaa2VxbFZDcWlOM29SZHNwNDlFRklFSytDQ0pwN0RJSkZRME5tUVd1VFFVVEZndVl1ZzJDUDBjUlkwTm1nMEExVFpTR0N3OHJTOURFYkZFSm1LaFowdG5EM0pMbEptUXF5WFpKcHBlWUt2YkdLb0RQYytrVEVjczZ3QTVkbkRpU2hBdEY3eng3ZTdPRzltN1hiY3ZZb2JkTm5iYmRNVkNDZ3lWUXNhTzZUaUo3bFZkQUIzb1paV3k0VEZkSjJzalpkcHIrQTM1V3BSTklCM1NsWnV5NXpiMFpJSkhLT3lJL3RjMUk1UjlUVGhxbTRDMlNPeU9mdnN6WmV6akQrNi9sMjRyRUZSS0tDamxnNDJuc1plN3VaS3VuUTBYMVl0UHR5amlqbG5xbVNNc3VpWjJrRFpsb1ZJRjdtdFlhRlR4cVAzcWc5bUJOZU5FVXl6emhXaWE2Nm9sMllJejdoaTdaaDVycDc5Q3p0d3h3aWlsa29sb3hCU1hndm9ZRjlCNEN3TkU0WHd1M0NPVHFkaU9EOFN2UHpEV0NFZERvcklDNEQ0eGI2dzlQM2Uvci9wUDhmR0Vqdnc4c0FLUnlpQTl4QmVId0JNRHhHQ0I0ai9JQVJlc2NRdTBPcSsrLytHS0VLQ1BKWUdHQUtLTzdZNkd6OERyTnh3S0ROU0krTFc3K2ZEdTl4WGJYZVNGYnllTjNlZzlEOHF2M3RudzlEOTNrWlJsZm8xUXdMYjVsaFpINWV6N0g0cGpsVzdmVWNTMitaWTQ0VXRhczVsdDgweDhnZ3Y1cGo1UzF6ekVlL25XUGg2YTdLcVlMV1ZKK0JnblpmZnhvd3RnRWJENkdtL3ZTYno5ZVNwak9wOGJYTXhJYjZXcWJpakg4MVU0bnB0VXpGazhIMFdxYVN3bzFNQmZnNzVJNXBNNUpJaS9kdnpPZFJ4LzRNeVhYdmhORVpFNzZodjh1NWc4UjljMHVPa1NYUzN5L2ZMekpFSzIyS3c2TjVSVGE0QngzZkwra0Jkc29HM2ZGbDdSZHJIbVdaM3lEVHBQeCtNOXZTeXpnZHRxMXRtOTIrdGsrLzlyVjlmNlIzYklzM3RiWjkzZGYyNmRlK3R1K1A5TWhqOGpMVzlzdjFQem50NGJUTllmZFduWFRFcE9JM3V1amVNSSswNDhpY1IvRU44NGpCb3Jid0tEMnplOWV6ejhvL2dIY2swc09lMmRIRFBhRmZ5MHhDZmkwemVUV3JLOWRYTXBHUVhzbEVySHVKRTVscGpmaHo5T240czlFbmwzOSsrYWRqSyswdVdhc21ic2FiamhiUVdHaDN2K1U1OWZ4SVV2VHpKUlcrbnF2UEo4TGgzOGhSU2ltNUcvU3hYRlpaWE9iL2xuSFlrME9WRklCNHJBRDhsbjdybHovKzlhZkQ5My9qZjV2RDM3Ny82V1JnMW5HZXdDY1A2dDZOelkybk12L3BlWkdHNEU4WWNWODdPZEpJenJVUUsrblZNa1N2Zll3TWI0K1BKeHp2bm5SdmpLdWFSY2lPY2UrYXN6eTNETUlQOUozdkhPZVNiZmorN3Y5ZFZDZDdmSCtzdWF6YXlraERRUzZBMWV5bjY1dDd4SnJUNkFaVytqQWJMNmw1SjhyZEpaWHVQanZwYjI1c2svS3BQbmZNMDFNdFRqQzErNGNoS0hPRnNjeG9xLy9QRVg1ejd4ZVBsTDZ4cXZmcy9JZ05lQm56NU4xOW50UVRsa2lRcHEyekdHK1JEWlg3VEVuZkdjZ0k5OVdSM0cxTDNlVy8zL0dHdThXSkMyU1pGZndwT0hQenphMnVjTTdlejJZK1EwZXlkRGU5bHhsZWhkc3JUZVpKYTlXVmxwbkU4MzNYY2diZnQyL09WUHB3OWZ4SFdzdVd5eUp6NCt2SzBBemNTM3Y3ZFhFNEQzcC9DaHVQbmJ1R0JqQmduSDJFaysyaFowREhXT1NsanFiaFh2NDByTGI2UmJQSUQ3UkNMLzMwL0dmdEoxLy85SWNQLy9uVEwzLzg2WmRmL1g4KzBPOEpDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tOakVnTUNCdlltb0tQRHdLTDFSNWNHVXZSWGgwUjFOMFlYUmxDaTlCU1ZNZ1ptRnNjMlVLTDBKTkwwNXZjbTFoYkFvdlEwRWdNUW92WTJFZ01Rb3ZiM0FnWm1Gc2MyVUtMMDlRSUdaaGJITmxDaTlUUVNCMGNuVmxDaTlUVFdGemF5OU9iMjVsQ2o0K0NtVnVaRzlpYWdvMk1pQXdJRzlpYWdvOFBBb3ZRVzUwYVVGc2FXRnpJR1poYkhObENpOUdkVzVqZEdsdmJnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElETUtMMFJ2YldGcGJpQmJNQ0F4WFFvdlJuVnVZM1JwYjI1eld3bzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqazFOeUF3TGpjMk9TQXdMamMzTmwwS0wwTXhJRnN4SURBdU9UWTFJREF1TnpVM1hRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1BEd0tMMFoxYm1OMGFXOXVWSGx3WlNBeUNpOURNQ0JiTVNBd0xqazJOU0F3TGpjMU4xMEtMME14SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wxSmhibWRsSUZzd0lERWdNQ0F4SURBZ01WMEtMMFJ2fEVuY29kZWQgRGF0YXx8fHx8Rnx8fHx8fCANCk9CWHw1MHxFRHw1ODQ3Ny0xXlB1bG1vbmFyeSBGdW5jdGlvbiBUZXN0IFJlcG9ydF5WU1BVTFJ8fF5BUF5QREZeQmFzZTY0XmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpNZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJOQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJOaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpjZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJPQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmprZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzNNQ0F3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJREU1TGpnME15QXpOeTR3T1ROZENpOUNRbTk0V3pBZ01DQXhNalVnTWpOZENpOVlVM1JsY0NBeU5UQUtMMWxUZEdWd0lEUTJDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURjeElEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURjeUlEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEYzFDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01TQXdJREFnTVNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjeElEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOeklnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXeTAxTGpFMU1pQXlNQzQyTmpZZ01URTRMamcwT0NBdE1TNHpNelJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lEUTBNamtLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdJREF1TmpneUlEQXVPVE0zSUNCeVp3b2dJQ0FnSUNBZ0lEYzRMalF4TVNBd0xqQTNNaUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREF1TURjeUlEZzBMamt3TWlBd0xqZ3pNeUE0TkM0NU1ESWdOeTR5TXpNZ1l3b2dJQ0FnSUNBZ0lEZzBMamt3TWlBeE1TNHpNemdnT0RNdU9EVTBJREUwTGpZNElEZ3lMamN3TnlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURneExqVTJNaUF4Tmk0ek9UY2dPREF1T0RreklERTBMamczSURnd0xqZzVNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdPREF1T0RreklERTBMamczSURjM0xqZ3pPQ0F4TUM0MU56UWdOell1TkRBNUlESXVORFU0SUdNS0lDQWdJQ0FnSUNBM05pNDBNRGtnTWk0ME5UZ2dOell1TWpFM0lEQXVPVE1nTnpZdU5qa3pJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNOeTR4TnlBdE1DNHlNVFVnTnpndU5ERXhJREF1TURjeUlEYzRMalF4TVNBd0xqQTNNaUJqQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DQXdMalk0TWlBd0xqa3pOeUFnY21jS0lDQWdJQ0FnSUNBM01TNHhOVGNnTUM0d056SWdiUW9nSUNBZ0lDQWdJRGN4TGpFMU55QXdMakEzTWlBMk5DNDJOaklnTUM0NE16TWdOalF1TmpZeUlEY3VNak16SUdNS0lDQWdJQ0FnSUNBMk5DNDJOaklnTVRFdU16TTRJRFkxTGpjeE5DQXhOQzQyT0NBMk5pNDROaUF4TlM0MU16Z2dZd29nSUNBZ0lDQWdJRFk0TGpBd05pQXhOaTR6T1RjZ05qZ3VOamN6SURFMExqZzNJRFk0TGpZM015QXhOQzQ0TnlCakNpQWdJQ0FnSUNBZ05qZ3VOamN6SURFMExqZzNJRGN4TGpjeU9TQXhNQzQxTnpRZ056TXVNVFl4SURJdU5EVTRJR01LSUNBZ0lDQWdJQ0EzTXk0eE5qRWdNaTQwTlRnZ056TXVNelV5SURBdU9UTWdOekl1T0RjMElEQXVNelU0SUdNS0lDQWdJQ0FnSUNBM01pNHpPVGdnTFRBdU1qRTFJRGN4TGpFMU55QXdMakEzTWlBM01TNHhOVGNnTUM0d056SWdZd29nSUNBZ0lDQWdJR2dLSUNBZ0lDQWdJQ0JtQ2lBZ0lDQWdJRkVnSlNBdExTQmxibVFnVUdGMGFBb2dJQ0FnSUNCeElDVWdMUzBnWW1WbmFXNGdVR0YwYUFvZ0lDQWdJQ0FnSURBdU5DQXdMalF3TkNBd0xqUXdOQ0FnY21jS0lDQWdJQ0FnSUNBNE1pNDJNVElnTVRjdU5UUXpJRzBLSUNBZ0lDQWdJQ0EzT0M0ME1URWdNVGt1TkRVeElEYzBMamc0SURRdU9EVXhJRGMwTGpnM09TQTBMamcwTmlCakNpQWdJQ0FnSUNBZ056UXVPRGMySURRdU9EVXhJRGN4TGpNME5pQXhPUzQwTlRFZ05qY3VNVFEySURFM0xqVTBNeUJqQ2lBZ0lDQWdJQ0FnTmpjdU1UUTJJREUzTGpVME15QTJPUzQyTWprZ01qQXVNekV4SURjMExqZzNPU0F5TUM0ek1URWdZd29nSUNBZ0lDQWdJRGd3TGpFeU9TQXlNQzR6TVRFZ09ESXVOakV5SURFM0xqVTBNeUE0TWk0Mk1USWdNVGN1TlRReklHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdaZ29nSUNBZ0lDQlJJQ1VnTFMwZ1pXNWtJRkJoZEdnS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3TGpRZ01DNDBNRFFnTUM0ME1EUWdJSEpuQ2lBZ0lDQWdJQ0FnTVRNdU16STFJRFV1T1RjMElHMEtJQ0FnSUNBZ0lDQXhNeTR6TWpVZ01pNHpNelFnTVRBdU56UTVJREF1TWpNMElEY3VNekE0SURBdU1qTTBJR01LSUNBZ0lDQWdJQ0F3SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F3SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQXhMalV4TXlBeE1TNDNNVEVnYkFvZ0lDQWdJQ0FnSURjdU16QTRJREV4TGpjeE1TQnNDaUFnSUNBZ0lDQWdNVEF1TnpRNUlERXhMamN4TVNBeE15NHpNalVnT1M0Mk1URWdNVE11TXpJMUlEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01URXVPREV6SURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TVM0NE1UTWdPQzQ1TmprZ09TNDRPRE1nTVRBdU16WTNJRGN1TVRNNUlERXdMak0yTnlCakNpQWdJQ0FnSUNBZ01TNDFNVE1nTVRBdU16WTNJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhMalUzT0NCc0NpQWdJQ0FnSUNBZ055NHhNemtnTVM0MU56Z2diQW9nSUNBZ0lDQWdJRGt1T0RneklERXVOVGM0SURFeExqZ3hNeUF5TGprM055QXhNUzQ0TVRNZ05TNDVOelFnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNBeU55NDFNVFlnTWpBdU1UWTFJRzBLSUNBZ0lDQWdJQ0F5Tnk0MU1UWWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lESTJMakE0T0NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUxTGpBME1pQnNDaUFnSUNBZ0lDQWdNall1TURnNElERTNMalU0T1NBeU5DNDJPRGdnTVRrdU1EY3pJREl5TGpJNE15QXhPUzR3TnpNZ1l3b2dJQ0FnSUNBZ0lERTVMamczTlNBeE9TNHdOek1nTVRndU5UWXhJREUzTGpZME5TQXhPQzQxTmpFZ01UVXVNRFF5SUdNS0lDQWdJQ0FnSUNBeE9DNDFOakVnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREUzTGpFek1TQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMUxqSTVOQ0JzQ2lBZ0lDQWdJQ0FnTVRjdU1UTXhJREUyTGpnNE9TQXhOeTQyTXpVZ01UZ3VNVGMzSURFNExqVXpNU0F4T1M0d05ETWdZd29nSUNBZ0lDQWdJREU1TGpNNU9TQXhPUzQ0T0RVZ01qQXVOakF6SURJd0xqTXpNU0F5TWk0eE1UVWdNakF1TXpNeElHTUtJQ0FnSUNBZ0lDQXlNeTQzTXprZ01qQXVNek14SURJMUxqQTRNeUF4T1M0M05ETWdNall1TURnNElERTRMalUyT1NCakNpQWdJQ0FnSUNBZ01qWXVNRGc0SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTXpjdU16WTVJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdNemN1TXpZNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016WXVNemc1SURFNExqa3dOU0JzQ2lBZ0lDQWdJQ0FnTXpRdU56a3pJREU0TGprd05TQXpOQzR6TWlBeE9DNHhORGtnTXpRdU16SWdNVFl1TmpNNElHTUtJQ0FnSUNBZ0lDQXpOQzR6TWlBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTXpJdU9Ea3hJREF1TWpNMElHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UWXVOalkySUd3S0lDQWdJQ0FnSUNBek1pNDRPVEVnTVRndU56WTFJRE16TGprMU5TQXlNQzR4TmpVZ016WXVNVE0zSURJd0xqRTJOU0JqQ2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdOakF1TWpreklERXhMalUwTWlCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURrdU9UUTNJRFU1TGpjNE9DQTRMalkxT1NBMU9DNDRPVElnTnk0M09URWdZd29nSUNBZ0lDQWdJRFU0TGpBMU15QTJMams0TVNBMU5pNDRNakVnTmk0MU1EVWdOVFV1TXpNNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBMU15NHpOVEVnTmk0MU1EVWdOVEV1TnpVMklEY3VNemN6SURVd0xqYzBOeUE0TGprMk9TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklEY3VNemN6SURRNExqTTVOeUEyTGpVd05TQTBOaTQwTURrZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURRMExqYzROU0EyTGpVd05TQTBNeTR6T0RVZ055NHhNakVnTkRJdU5EQTNJRGd1TWpZM0lHTUtJQ0FnSUNBZ0lDQTBNaTQwTURjZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURRd0xqazNPU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdOREF1T1RjNUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJREV4TGpjNU5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lEa3VNalE1SURRekxqZ3dPQ0EzTGpjMk5TQTBOaTR5TVRVZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURRNExqWXlJRGN1TnpZMUlEUTVMamt6TmlBNUxqRTVNeUEwT1M0NU16WWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTBPUzQ1TXpZZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdNVEV1TlRReUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ09TNHlORGtnTlRJdU9EUTNJRGN1TnpZMUlEVTFMakUzTWlBM0xqYzJOU0JqQ2lBZ0lDQWdJQ0FnTlRjdU5UYzNJRGN1TnpZMUlEVTRMamc1TWlBNUxqRTVNeUExT0M0NE9USWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTFPQzQ0T1RJZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMk1DNHlPVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09Ua3VOREUxSURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnT1RrdU5ERTFJREV4TGpVME5TQnNDaUFnSUNBZ0lDQWdPVGt1TkRFMUlEa3VPVFEzSURrNExqa3hNaUE0TGpZMU9TQTVPQzR3TVRVZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURrM0xqRTBOeUEyTGprMU15QTVOUzQ1TkRNZ05pNDFNRFVnT1RRdU5ETXlJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTVNaTQ0TURnZ05pNDFNRFVnT1RFdU5EWTFJRGN1TURreElEa3dMalExTnlBNExqSTJOeUJqQ2lBZ0lDQWdJQ0FnT1RBdU5EVTNJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQTRPUzR3TWprZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURnNUxqQXlPU0F5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBeE1TNDNPVFVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUE1TGpJME9TQTVNUzQ0TlRjZ055NDNOalVnT1RRdU1qWTBJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQTVOaTQyTnpFZ055NDNOalVnT1RjdU9UZzNJRGt1TVRreklEazNMams0TnlBeE1TNDNPVFVnWXdvZ0lDQWdJQ0FnSURrM0xqazROeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJREV4TkM0Mk9UY2dNVE11TnpJM0lHMEtJQ0FnSUNBZ0lDQXhNVFF1TmprM0lERXpMakE0TWlCc0NpQWdJQ0FnSUNBZ01URTBMalk1TnlBNExqazJPU0F4TVRJdU5qVTFJRFl1TlRBMUlERXdPUzR5T1RZZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURFd05TNDVNRGdnTmk0MU1EVWdNVEF6TGpnNU5TQTVMakE0TVNBeE1ETXVPRGsxSURFekxqUXhPQ0JqQ2lBZ0lDQWdJQ0FnTVRBekxqZzVOU0F4Tnk0NU1qVWdNVEExTGprd09DQXlNQzR6TXpFZ01UQTVMall6TVNBeU1DNHpNekVnWXdvZ0lDQWdJQ0FnSURFeE1TNDROamtnTWpBdU16TXhJREV4TXk0eE16RWdNVGt1TmpNeElERXhOQzQxTURFZ01UZ3VNall4SUdNS0lDQWdJQ0FnSUNBeE1UTXVORE0zSURFM0xqUXlNU0JzQ2lBZ0lDQWdJQ0FnTVRFeUxqSTVNU0F4T0M0MU5qa2dNVEV4TGpNeE1TQXhPUzR3TkRNZ01UQTVMamN4TlNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFd05pNDROVGtnTVRrdU1EUXpJREV3TlM0ek1qRWdNVGN1TVRReElERXdOUzR6TWpFZ01UTXVOekkzSUdNS0lDQWdJQ0FnSUNBeE1UTXVNamN4SURFeUxqVTNPU0J0Q2lBZ0lDQWdJQ0FnTVRBMUxqTXlNU0F4TWk0MU56a2diQW9nSUNBZ0lDQWdJREV3TlM0ek56Y2dNVEV1TWprZ01UQTFMalEySURFd0xqZzNNeUF4TURVdU56azJJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEEyTGpNNE15QTRMall6TVNBeE1EY3VOelUxSURjdU56WTFJREV3T1M0eU9UWWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lERXhNQzQ0TXpNZ055NDNOalVnTVRFeUxqSXdOU0E0TGpZek1TQXhNVEl1TnpreklERXdMakF6TVNCakNpQWdJQ0FnSUNBZ01URXpMakV6TVNBeE1DNDROek1nTVRFekxqSXhNaUF4TVM0eU9TQXhNVE11TWpjeElERXlMalUzT1NCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjeklEQWdiMkpxQ2p3OENpOVVlWEJsTDFCaFoyVUtMMDFsWkdsaFFtOTRXekFnTUNBMk1USWdOemt5WFFvdlVHRnlaVzUwSURNZ01DQlNDaTlEYjI1MFpXNTBjeUEzTkNBd0lGSUtMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTmlBd0lGSUtMMGRUTVNBM05TQXdJRklLTDBkVE1pQTNOeUF3SUZJS0wwZFRNeUEzT1NBd0lGSUtMMGRUTkNBNE1TQXdJRklLUGo0S0wwWnZiblFLUER3S0wwWXdJRE13SURBZ1Vnb3ZSakVnTXpRZ01DQlNDaTlHTWlBeE1DQXdJRklLUGo0S0wxTm9ZV1JwYm1jS1BEd0tMMU5vTUNBM05pQXdJRklLTDFOb01TQTNPQ0F3SUZJS0wxTm9NaUE0TUNBd0lGSUtQajRLTDFCaGRIUmxjbTRLUER3S0wxQmhNQ0E0TWlBd0lGSUtQajRLUGo0S0wwZHliM1Z3Q2p3OENpOURVeTlFWlhacFkyVlNSMElLTDFNdlZISmhibk53WVhKbGJtTjVDaTlKSUdaaGJITmxDaTlMSUdaaGJITmxDajQrQ2o0K0NtVnVaRzlpYWdvM05DQXdJRzlpYWdvOFBBb3ZUR1Z1WjNSb0lERTVNRFlLTDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlFvK1BncHpkSEpsWVcwS2VKenRYVnR2MnpZVWZ0K3Y0TXRlQ3BqbC9RSU1BNW9yTUdEQXVoallYcnMyYlZZazN0SUVLN1pmdjBOSnRraUpGT1ZHaVMyYk5PUUxMekxQcDNNaFA1UFdQZm9lTFJibzVQclRuNnZUdjFhUDE2dkg3eEFpV0V0RTRMRm8zbW5MMFBzN0tGbFFRdER5UDNqWHRQekR0VVNuNzFiL3ZIdUFYSVJvMVpBaXByQ1FTbTllcSticFptMURncXhaMXg2cTc3ZVFiWVBoSm0wakJjOWVvMDZ6WDk0OTNuaGwwQXh6anI0R1dRVDkxUG44T1d4QzBNOWhCYXkxQ3A3UnI1ZWRVeEIwRitSb3FUR3hrSDBiWkY5NW45N1dIYjllZlFpNzdlVjNVQmlIRUFHTVpvQVFkSlU5SHpvZE1YdENoaUxTUU1DY05HQlhnU3dPOE52Z004UEtLTDUrSWJYU2VqVjBSekd1WXVJRklnVENYZDcrKy9mTlEvQ043b0crZlBMeVhsOWVFZlRKcjNXeTlJc3Z3RTFRdFB6b3cyQ3cwclVXVmU4a29oWWJBdEF0N3pyZnR2eUFmaUNFNlIrWEhlUzRia3N2dXFYQ3RvV3FXNmpvcHBDenNQQjhHUU9vQThOWTYyQVNDeWZUTmpaU1BVSjhheHkwNHM3T0tWWG95elVLaWorK0dxSE91VzYzSFRmSWhGM09OdzJrSnQzV09hVnFoU1E5MFYzcUsxaWRBalZycWw3UW5ySTFIYXpQWDcwQWhzdTdhQWZpMnRhVVkwM1RPcmV1STFSUzg5WlZCdlN2VHVkZHdkSzZXS2Y4OVdtdkVPZFlVTEE1MWI5TU9lMWNuK2hySkxmcnl0ZTVuMk5uNkxyMWRlVktBem9PZlZPR0picUxsR2pLSzJjQ3hiZVI0cXRlWHRwQzZyVEhHSUNvZ3lCVTVTK0hBaGdtalJrbXRJNTNmOU5QMW5OaWRmcnRGVnBGc2s5K1I2K3ZiZ2g2dUVIbnY2TzNXd3FUanVRUlVTZXpub1NicTFXWnVWRXpWa1JFSFY3YTVVV2QzcERiUTRqWEtnVXZYRk1zRll6VUdZLzVQOThEa3JPWVg0cDRwcnh2R210UXphekFhcXl0NUlqRUFCNktFblVaUjFRa2RDc0lrNzIrUDhFVjFEMFhRbUFwcWxISnpIb3VMY1hNTXJvUFBkK05yU1pPMUo1cTRjSkxBcDR4VUErRGlKcHZTY0lZQlRLdkJEa3d0MFhCR0t5SjBRVUlxalcyVkJlVlFFeHBUSmxpQlFrdUZjejlpMHBBSUpTRGdmQjRrSkJjWUMxWjBRbWtHTWRXMGVJbXFoa1FWZFllSGhKVER0M2lOTklXTTZ3a09oUE9yRnBLaVRKc09PY0pZc21mV0hFYm4xakIrTktqTE1WenpiN3lVV3hvekR4V08rUHNTSW9mU1RFa1NZNWttQ1VaNG9xeWJGR01LY2xieG14d1NmSkhlUWJwZVpFQnEyUnhxNHh6U2VQWXBDU2Z0R2FVYUpKUjJzSDRjUXZMUzNxK2NlelNrQmRNK01GaFR4aXdURWJEb01lcUpNczBobWVLK3JveDNtNjhLWTdqbThhRVdqNTVxTjFXaWh6M05BOHBjanpVYnFUWXBaMG5UemFPbVJwN0FYTEFqaGhSSnNBZG95UjVnTGRISmNOVUhTOHdPZWJxZUpISk1WbkhpMHlHMlRwZVlISk0xL0VpazJPK2poZVpIQk4ydk1qa21MRkRRZVpsZVRReEp4NU5ZY0xkaEQ1TG83SHpKSTNtTGRGU3FVclpGVmlGYS9NYUZLNHQzbUMrWEJ2ZkFkZkdDdGZXVDAvazJnUmhtQWxMQzlkV3BjSzFGYTR0a0xKd2Jla2FoV3RMMUNoY1c2cEc0ZHBTTlFyWGxxaFJ1TFpVamNLMXBXb1VyaTFWbzNCdHFSclB3clVObCtZeDl6WktZOU1IZXN3ME13M3ZWcnNpV1dwWFpOUEZhbGM5dHNQYkl2blo5SnNWZHkyMmdnazg1M25aS1RrODJTbkJhcFR3UExHUlZmS1dSMDF0ZHZXV05YSUdoNFNxWmdJc3A3TE45UlRSNUxZdFo1ajJoY0RLSm1Md0dGKzZHZWRnYXBPaGZNalpOaUh2bWJhUVphZmFCSmtuazJrRGdlU2JTRFEyUUtMNSs4RnRuanlMMjc5TDA1Qm4rd2lNR0FXTW1SaVlsL3g1ekFnc2FXcE9VYXgyVWF5MmwrNFB3MnIxaksyV2FvNDFZeVhZOWl2Y0Y3TTlhTE5WTXpaYnBoaTJQTVhHRkxOZEZMUHRwZnZETUZzNVk3UGxrbUVxaXRHaXdkTmNGcVBkcFB2RE1Gb3hZNk1WZ21NdXpBUXpXN2FmWnZzeWExYlppRFdyOEtSenkxVXBuMnlSNlpSYUlqbkRVbXBadE1SUHU5TVNzWmRhb2hqRldpbFd0TVJQdTlNU3VaZGFvaW5CVmd0YnRNUlB1OU1TOVVKYU12WHZjRS84R1k0Wmk3a2FNKzdabjEwdlk2NG51NmdQVHVIYW51MmxCeERNTFl3bTR1Q3c1enk1MmNpSVRTMHBVN1Y0KzVmUXdzQ2g0VGlGUTBFanZjN2J5MHNxRGNQV0duTjRsOVNzeldrUDNHUzZMRlVTejQvbnBxKzNkME1OOStmeVJubkw1Tk1CdTIzRjNiMC9QTDBnYmlPTWdYRWl0bHdIVjl5MTBMTDZBM3VZY1FRQmVoT1c0OEY0VEQrbzluc0JPaVY4blhvTnJSNnZ2NnpRK3dmM25xQ0g5NnVnWTVSSnQzL21XenZWVVFhQ0JYTjczb1JiRzROaEhoNEEwVlY0VDgzN3NaOXlkek9KcW92Vk95b0E4MkJycE8ralFLRXR2SUpESWJ4ZWF5Tk43V0NrYWh4TzQyeXFjdmYrcFAzTUpOUnpiVTU4ZzlpWVFVcjVoNXhKRzVJSmd0QkFPcmRDR1BZZXd6Q091T2xFZnlEVmhkT3RnUUx2cG5UcXBoTmR2KzhXUExXZVhEVGUrN1FHVWRMNk16MXpnRDcxcmhLN3dFTVNtT1psTVhuVHhjUUdrSWlMTnFoMUkrSThZTEFXYTdjcUxnTUVPL091TzYzMW9IcDk0d3h1am9KVDZWYkR1RDJldzVLVGk3bHFPRlVDYTVLWGtKMjZlNERNMlphcCt4TTJtNVh6alZ1TTZZZ250eUlFampkdTRnakhTWE5BWUtDblc4dWZHcldNQ1JhYUdXd3NqRVNvRHBkTVp5Q05EREsvQlViV2pBaXFrU1IwSUFFY2ZRWURuMW9DY0dQdXRtcURZckQ5RndQMFFMTmhLZlJFR2hyTDdlYzFPZWVyRCt2NzRmMFBJS1NpOHdwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjMUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOellnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pjM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOemdnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pjNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tPREFnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pneElEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tPRElnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0YwZEdWeWJnb3ZVR0YwZEdWeWJsUjVjR1VnTVFvdlVHRnBiblJVZVhCbElERUtMMVJwYkdsdVoxUjVjR1VnTXdvdlRXRjBjbWw0SUZzd0xqYzFJREFnTUNBdE1DNDNOU0F4T1M0NE5ETWdNemN1TURrelhRb3ZRa0p2ZUZzd0lEQWdNVEkxSURJelhRb3ZXRk4wWlhBZ01qVXdDaTlaVTNSbGNDQTBOZ292VW1WemIzVnlZMlZ6Q2p3OENpOVFjbTlqVTJWMElGc3ZVRVJHTDFSbGVIUXZTVzFoWjJWQ0wwbHRZV2RsUXk5SmJXRm5aVWxkQ2k5RmVIUkhVM1JoZEdVS1BEd0tMMGRUTUNBNE15QXdJRklLUGo0S0wxaFBZbXBsWTNRS1BEd0tMMFp0TUNBNE5DQXdJRklLUGo0S1BqNEtMMHhsYm1kMGFDQTNOUW8rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lERWdNQ0F3SURFZ01DQXdJR050Q2lBZ0wwZFRNQ0JuY3dvZ0lDOUdiVEFnUkc4S1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNE15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDamcwSURBZ2IySnFDanc4Q2k5VWVYQmxMMWhQWW1wbFkzUUtMMU4xWW5SNWNHVXZSbTl5YlFvdlFrSnZlRnN0TlM0eE5USWdNakF1TmpZMklERXhPQzQ0TkRnZ0xURXVNek0wWFFvdlRXRjBjbWw0SUZzeElEQWdNQ0F4SURBZ01GMEtMMHhsYm1kMGFDQTBOREk1Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdMVEV3TUNCVWVnb2dJSEVLSUNCeElDVWdMUzBnWW1WbmFXNGdWbWx6ZFdGc0NpQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1EyRnVkbUZ6Q2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNQ0F3TGpZNE1pQXdMamt6TnlBZ2NtY0tJQ0FnSUNBZ0lDQTNPQzQwTVRFZ01DNHdOeklnYlFvZ0lDQWdJQ0FnSURjNExqUXhNU0F3TGpBM01pQTROQzQ1TURJZ01DNDRNek1nT0RRdU9UQXlJRGN1TWpNeklHTUtJQ0FnSUNBZ0lDQTROQzQ1TURJZ01URXVNek00SURnekxqZzFOQ0F4TkM0Mk9DQTRNaTQzTURjZ01UVXVOVE00SUdNS0lDQWdJQ0FnSUNBNE1TNDFOaklnTVRZdU16azNJRGd3TGpnNU15QXhOQzQ0TnlBNE1DNDRPVE1nTVRRdU9EY2dZd29nSUNBZ0lDQWdJRGd3TGpnNU15QXhOQzQ0TnlBM055NDRNemdnTVRBdU5UYzBJRGMyTGpRd09TQXlMalExT0NCakNpQWdJQ0FnSUNBZ056WXVOREE1SURJdU5EVTRJRGMyTGpJeE55QXdMamt6SURjMkxqWTVNeUF3TGpNMU9DQmpDaUFnSUNBZ0lDQWdOemN1TVRjZ0xUQXVNakUxSURjNExqUXhNU0F3TGpBM01pQTNPQzQwTVRFZ01DNHdOeklnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNCbUNpQWdJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1VHRjBhQW9nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lEQWdNQzQyT0RJZ01DNDVNemNnSUhKbkNpQWdJQ0FnSUNBZ056RXVNVFUzSURBdU1EY3lJRzBLSUNBZ0lDQWdJQ0EzTVM0eE5UY2dNQzR3TnpJZ05qUXVOall5SURBdU9ETXpJRFkwTGpZMk1pQTNMakl6TXlCakNpQWdJQ0FnSUNBZ05qUXVOall5SURFeExqTXpPQ0EyTlM0M01UUWdNVFF1TmpnZ05qWXVPRFlnTVRVdU5UTTRJR01LSUNBZ0lDQWdJQ0EyT0M0d01EWWdNVFl1TXprM0lEWTRMalkzTXlBeE5DNDROeUEyT0M0Mk56TWdNVFF1T0RjZ1l3b2dJQ0FnSUNBZ0lEWTRMalkzTXlBeE5DNDROeUEzTVM0M01qa2dNVEF1TlRjMElEY3pMakUyTVNBeUxqUTFPQ0JqQ2lBZ0lDQWdJQ0FnTnpNdU1UWXhJREl1TkRVNElEY3pMak0xTWlBd0xqa3pJRGN5TGpnM05DQXdMak0xT0NCakNpQWdJQ0FnSUNBZ056SXVNems0SUMwd0xqSXhOU0EzTVM0eE5UY2dNQzR3TnpJZ056RXVNVFUzSURBdU1EY3lJR01LSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09ESXVOakV5SURFM0xqVTBNeUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREU1TGpRMU1TQTNOQzQ0T0NBMExqZzFNU0EzTkM0NE56a2dOQzQ0TkRZZ1l3b2dJQ0FnSUNBZ0lEYzBMamczTmlBMExqZzFNU0EzTVM0ek5EWWdNVGt1TkRVeElEWTNMakUwTmlBeE55NDFORE1nWXdvZ0lDQWdJQ0FnSURZM0xqRTBOaUF4Tnk0MU5ETWdOamt1TmpJNUlESXdMak14TVNBM05DNDROemtnTWpBdU16RXhJR01LSUNBZ0lDQWdJQ0E0TUM0eE1qa2dNakF1TXpFeElEZ3lMall4TWlBeE55NDFORE1nT0RJdU5qRXlJREUzTGpVME15QmpDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQlFZWFJvQ2lBZ0lDQWdJQ0FnTUM0MElEQXVOREEwSURBdU5EQTBJQ0J5WndvZ0lDQWdJQ0FnSURFekxqTXlOU0ExTGprM05DQnRDaUFnSUNBZ0lDQWdNVE11TXpJMUlESXVNek0wSURFd0xqYzBPU0F3TGpJek5DQTNMak13T0NBd0xqSXpOQ0JqQ2lBZ0lDQWdJQ0FnTUNBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTUNBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURFdU5URXpJREl3TGpFMk5TQnNDaUFnSUNBZ0lDQWdNUzQxTVRNZ01URXVOekV4SUd3S0lDQWdJQ0FnSUNBM0xqTXdPQ0F4TVM0M01URWdiQW9nSUNBZ0lDQWdJREV3TGpjME9TQXhNUzQzTVRFZ01UTXVNekkxSURrdU5qRXhJREV6TGpNeU5TQTFMamszTkNCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lERXhMamd4TXlBMUxqazNOQ0J0Q2lBZ0lDQWdJQ0FnTVRFdU9ERXpJRGd1T1RZNUlEa3VPRGd6SURFd0xqTTJOeUEzTGpFek9TQXhNQzR6TmpjZ1l3b2dJQ0FnSUNBZ0lERXVOVEV6SURFd0xqTTJOeUJzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNUzQxTnpnZ2JBb2dJQ0FnSUNBZ0lEY3VNVE01SURFdU5UYzRJR3dLSUNBZ0lDQWdJQ0E1TGpnNE15QXhMalUzT0NBeE1TNDRNVE1nTWk0NU56Y2dNVEV1T0RFeklEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01qY3VOVEUySURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTWpjdU5URTJJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQXlOaTR3T0RnZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURJMkxqQTRPQ0F4TlM0d05ESWdiQW9nSUNBZ0lDQWdJREkyTGpBNE9DQXhOeTQxT0RrZ01qUXVOamc0SURFNUxqQTNNeUF5TWk0eU9ETWdNVGt1TURjeklHTUtJQ0FnSUNBZ0lDQXhPUzQ0TnpVZ01Ua3VNRGN6SURFNExqVTJNU0F4Tnk0Mk5EVWdNVGd1TlRZeElERTFMakEwTWlCakNpQWdJQ0FnSUNBZ01UZ3VOVFl4SURZdU5qY3pJR3dLSUNBZ0lDQWdJQ0F4Tnk0eE16RWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lERTNMakV6TVNBeE5TNHlPVFFnYkFvZ0lDQWdJQ0FnSURFM0xqRXpNU0F4Tmk0NE9Ea2dNVGN1TmpNMUlERTRMakUzTnlBeE9DNDFNekVnTVRrdU1EUXpJR01LSUNBZ0lDQWdJQ0F4T1M0ek9Ua2dNVGt1T0RnMUlESXdMall3TXlBeU1DNHpNekVnTWpJdU1URTFJREl3TGpNek1TQmpDaUFnSUNBZ0lDQWdNak11TnpNNUlESXdMak16TVNBeU5TNHdPRE1nTVRrdU56UXpJREkyTGpBNE9DQXhPQzQxTmprZ1l3b2dJQ0FnSUNBZ0lESTJMakE0T0NBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURNM0xqTTJPU0F5TUM0eE5qVWdiUW9nSUNBZ0lDQWdJRE0zTGpNMk9TQXhPQzQ1TURVZ2JBb2dJQ0FnSUNBZ0lETTJMak00T1NBeE9DNDVNRFVnYkFvZ0lDQWdJQ0FnSURNMExqYzVNeUF4T0M0NU1EVWdNelF1TXpJZ01UZ3VNVFE1SURNMExqTXlJREUyTGpZek9DQmpDaUFnSUNBZ0lDQWdNelF1TXpJZ01DNHlNelFnYkFvZ0lDQWdJQ0FnSURNeUxqZzVNU0F3TGpJek5DQnNDaUFnSUNBZ0lDQWdNekl1T0RreElERTJMalkyTmlCc0NpQWdJQ0FnSUNBZ016SXVPRGt4SURFNExqYzJOU0F6TXk0NU5UVWdNakF1TVRZMUlETTJMakV6TnlBeU1DNHhOalVnWXdvZ0lDQWdJQ0FnSURZd0xqSTVNeUF5TUM0eE5qVWdiUW9nSUNBZ0lDQWdJRFl3TGpJNU15QXhNUzQxTkRJZ2JBb2dJQ0FnSUNBZ0lEWXdMakk1TXlBNUxqazBOeUExT1M0M09EZ2dPQzQyTlRrZ05UZ3VPRGt5SURjdU56a3hJR01LSUNBZ0lDQWdJQ0ExT0M0d05UTWdOaTQ1T0RFZ05UWXVPREl4SURZdU5UQTFJRFUxTGpNek9TQTJMalV3TlNCakNpQWdJQ0FnSUNBZ05UTXVNelV4SURZdU5UQTFJRFV4TGpjMU5pQTNMak0zTXlBMU1DNDNORGNnT0M0NU5qa2dZd29nSUNBZ0lDQWdJRFE1TGprek5pQTNMak0zTXlBME9DNHpPVGNnTmk0MU1EVWdORFl1TkRBNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBME5DNDNPRFVnTmk0MU1EVWdORE11TXpnMUlEY3VNVEl4SURReUxqUXdOeUE0TGpJMk55QmpDaUFnSUNBZ0lDQWdOREl1TkRBM0lEWXVOamN6SUd3S0lDQWdJQ0FnSUNBME1DNDVOemtnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJRFF3TGprM09TQXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEUXlMalF3TnlBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURReUxqUXdOeUF4TVM0M09UVWdiQW9nSUNBZ0lDQWdJRFF5TGpRd055QTVMakkwT1NBME15NDRNRGdnTnk0M05qVWdORFl1TWpFMUlEY3VOelkxSUdNS0lDQWdJQ0FnSUNBME9DNDJNaUEzTGpjMk5TQTBPUzQ1TXpZZ09TNHhPVE1nTkRrdU9UTTJJREV4TGpjNU5TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05URXVNelkwSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTlRFdU16WTBJREV4TGpVME1pQnNDaUFnSUNBZ0lDQWdOVEV1TXpZMElEa3VNalE1SURVeUxqZzBOeUEzTGpjMk5TQTFOUzR4TnpJZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURVM0xqVTNOeUEzTGpjMk5TQTFPQzQ0T1RJZ09TNHhPVE1nTlRndU9Ea3lJREV4TGpjNU5TQmpDaUFnSUNBZ0lDQWdOVGd1T0RreUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DNDBJREF1TkRBMElEQXVOREEwSUNCeVp3b2dJQ0FnSUNBZ0lEazVMalF4TlNBeU1DNHhOalVnYlFvZ0lDQWdJQ0FnSURrNUxqUXhOU0F4TVM0MU5EVWdiQW9nSUNBZ0lDQWdJRGs1TGpReE5TQTVMamswTnlBNU9DNDVNVElnT0M0Mk5Ua2dPVGd1TURFMUlEY3VOemt4SUdNS0lDQWdJQ0FnSUNBNU55NHhORGNnTmk0NU5UTWdPVFV1T1RReklEWXVOVEExSURrMExqUXpNaUEyTGpVd05TQmpDaUFnSUNBZ0lDQWdPVEl1T0RBNElEWXVOVEExSURreExqUTJOU0EzTGpBNU1TQTVNQzQwTlRjZ09DNHlOamNnWXdvZ0lDQWdJQ0FnSURrd0xqUTFOeUEyTGpZM015QnNDaUFnSUNBZ0lDQWdPRGt1TURJNUlEWXVOamN6SUd3S0lDQWdJQ0FnSUNBNE9TNHdNamtnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0E1TUM0ME5UY2dNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTVNQzQwTlRjZ01URXVOemsxSUd3S0lDQWdJQ0FnSUNBNU1DNDBOVGNnT1M0eU5Ea2dPVEV1T0RVM0lEY3VOelkxSURrMExqSTJOQ0EzTGpjMk5TQmpDaUFnSUNBZ0lDQWdPVFl1TmpjeElEY3VOelkxSURrM0xqazROeUE1TGpFNU15QTVOeTQ1T0RjZ01URXVOemsxSUdNS0lDQWdJQ0FnSUNBNU55NDVPRGNnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0F4TVRRdU5qazNJREV6TGpjeU55QnRDaUFnSUNBZ0lDQWdNVEUwTGpZNU55QXhNeTR3T0RJZ2JBb2dJQ0FnSUNBZ0lERXhOQzQyT1RjZ09DNDVOamtnTVRFeUxqWTFOU0EyTGpVd05TQXhNRGt1TWprMklEWXVOVEExSUdNS0lDQWdJQ0FnSUNBeE1EVXVPVEE0SURZdU5UQTFJREV3TXk0NE9UVWdPUzR3T0RFZ01UQXpMamc1TlNBeE15NDBNVGdnWXdvZ0lDQWdJQ0FnSURFd015NDRPVFVnTVRjdU9USTFJREV3TlM0NU1EZ2dNakF1TXpNeElERXdPUzQyTXpFZ01qQXVNek14SUdNS0lDQWdJQ0FnSUNBeE1URXVPRFk1SURJd0xqTXpNU0F4TVRNdU1UTXhJREU1TGpZek1TQXhNVFF1TlRBeElERTRMakkyTVNCakNpQWdJQ0FnSUNBZ01URXpMalF6TnlBeE55NDBNakVnYkFvZ0lDQWdJQ0FnSURFeE1pNHlPVEVnTVRndU5UWTVJREV4TVM0ek1URWdNVGt1TURReklERXdPUzQzTVRVZ01Ua3VNRFF6SUdNS0lDQWdJQ0FnSUNBeE1EWXVPRFU1SURFNUxqQTBNeUF4TURVdU16SXhJREUzTGpFME1TQXhNRFV1TXpJeElERXpMamN5TnlCakNpQWdJQ0FnSUNBZ01URXpMakkzTVNBeE1pNDFOemtnYlFvZ0lDQWdJQ0FnSURFd05TNHpNakVnTVRJdU5UYzVJR3dLSUNBZ0lDQWdJQ0F4TURVdU16YzNJREV4TGpJNUlERXdOUzQwTmlBeE1DNDROek1nTVRBMUxqYzVOaUF4TUM0d016RWdZd29nSUNBZ0lDQWdJREV3Tmk0ek9ETWdPQzQyTXpFZ01UQTNMamMxTlNBM0xqYzJOU0F4TURrdU1qazJJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQXhNVEF1T0RNeklEY3VOelkxSURFeE1pNHlNRFVnT0M0Mk16RWdNVEV5TGpjNU15QXhNQzR3TXpFZ1l3b2dJQ0FnSUNBZ0lERXhNeTR4TXpFZ01UQXVPRGN6SURFeE15NHlNVElnTVRFdU1qa2dNVEV6TGpJM01TQXhNaTQxTnprZ1l3b2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQm1DaUFnSUNBZ0lGRWdKU0F0TFNCbGJtUWdVR0YwYUFvZ0lDQWdVU0FsSUMwdElHVnVaQ0JEWVc1MllYTUtJQ0JSSUNVZ0xTMGdaVzVrSUZacGMzVmhiQW9nSUZFS1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNE5TQXdJRzlpYWdvOFBBb3ZWSGx3WlM5UVlXZGxDaTlOWldScFlVSnZlRnN3SURBZ05qRXlJRGM1TWwwS0wxQmhjbVZ1ZENBeklEQWdVZ292UTI5dWRHVnVkSE1nT0RZZ01DQlNDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURZZ01DQlNDaTlIVXpFZ09EY2dNQ0JTQ2o0K0NpOUdiMjUwQ2p3OENpOUdNQ0F4TUNBd0lGSUtQajRLTDFCaGRIUmxjbTRLUER3S0wxQmhNQ0E0T0NBd0lGSUtQajRLUGo0S0wwZHliM1Z3Q2p3OENpOURVeTlFWlhacFkyVlNSMElLTDFNdlZISmhibk53WVhKbGJtTjVDaTlKSUdaaGJITmxDaTlMSUdaaGJITmxDajQrQ2o0K0NtVnVaRzlpYWdvNE5pQXdJRzlpYWdvOFBBb3ZUR1Z1WjNSb0lEVTNOamtLTDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlFvK1BncHpkSEpsWVcwS2VKenRYZWx1Sk1lUi91K25xRC83eHdEVGVSL0F3c0NRMWdnd3NNQ3VOUytncFViU0doUnRTd01idTArL0VaRkhWV1ZHZFRlSDNjMXVva2NpV1ZtUlYwUitHUmw1UmYxaityZnA3bTY2Ly96VC96dy8vTzM1eStmbkw3K2JKaW1DbXlUOGQxZWVRdExUNHk5QXVWTlNUcC8rRDU1S3l2L0dsTlBEOTgvLy9QNDNlRHROaWhLcVNYdGhuUS90THlYZlRqWW5sRk9LTmZhdStNc1UyczBwZHFkQjVwS1V1ckpIenlwSUlaTldVN0JPS0cyWG1YWFovZWYzWDM1ZTBHb2w3dFIwWjBCWTNrMVJCK0ZqY090TU1DTCtOLzM2MCtvdEpuYktDbThtZ3duVDlPdm5hUlhqeDk4dmd2K1Y2L0w1K1llK0pydHJpVldMMDcrNm92L2NoZis2cnJDYy9tT29LM0R3bDI5WGI2MFNNb0xrcExCcFdyTWNvekNoa3A1V3BBUVMxOEJ0SVNhVll5b1JqVkV0YUpEMnVFNllTYzZJT09SWlNFNDRDMW0zSXB6SHVLVXlPZkRJc1pCSjZ6eE5FbFpEalFyUnhCeXpGRkdEWnN5emtESUxUeXlwTU51S3lLSll5WE9kNTdwTnY3c1lYQWlISFdyeHU4ZUkwU0I4ejRQRUJDZTg1VkZpUWhBNnpUQXhJZWE0VlhRMXpBQ2wwamlrTkZwdHgxWk9hZVpTSnc0c2xSY1dMYUR0Z2x6QVJic2N0NVpUd3h4Z0NvMUZUS1ZWdmxzNVJTNHIrYjRUMEdncEJiRG9RMEsxdUFhTmRrb2tYMmxQSGMwSXIrQjFvV3BuS1c2RWpvWENhMkdOMU1jdWJhWWxBd1BDa0craFdSRXM1VnZMU1I1ajF6cmwwQ1BMUzZhdDgxVUp3T2htcWtvaHh5M2x0TEFaODYyMHpNc1RUeXQ4eitVVXVhemsrMDVBWTBBU0t2S2dzUWE2bmVGQlk0MFROczZnc2NaVDNDcThGbVpBVTJrY2FCcXROT1pjVG03c1dpY09OSlVYRGpRbUF2OTZCbzJCYWxQY1VrNExNNkNwTkE0MGpWYjRuc3ZKY2xuTDl6cEF3NXN0UWJqSnE0aUt1TE5hUUdTbWt0YlNpV0NvVWVObFl2UVVVMHVoVVZZMXFFYmxYa2hHd3pEVDUxbElSaVJzdUZZRUFBWGlsc3Jrd0NQRFFhWjBvSE1pV215elRMU1dJcFlDU2tnekdSSWxWLytKb3hRK1cvWlpDa3RKWGdjZzltc1JHRWlEblJ6TUMyS3ZSS1FTMmhkU0p5V3BSY0lCSVJPdHREa205QmdVVnd0RGorOGxYMGpRK0hySXRKQkE2QTZicnhVU3dXWnAxYUhBSThzRWticGVEamFuakZDblREUW01SmlsakJhMlk2YUZSRXc4OGFUQzcxd0lpV01sMC9lQ0U3RExndWJWaUVIcFJWNlBHSkIwTXJNaU1kZ01jZTVoTGF5NGlVV21jYnFrMFVwZm44dkptcURXaVZNbmxSZE9vUmh0aGZTelJqRmE1N2kxbkJyV1hMNlp4dW1WUnF0OHQzS0tYRmJ5ZlNlZ1FidkxLUjQwMmtIblNUeG8wTjZNZGdhTmhsa0Z4cTNDYTJFR05KWEdnYWJSU21QTzVlVEdyblhpUUZONTRVQ0Q5bVowTTJqUUhxVzRwWndXWmtCVGFSeG9HcTN3UFpkVDVMS1M3enNCalZVQnRPcmtJR2szSHFFK0RVVG9CZzdRd3c3WFA1QmtVVjlqTENVTWpVVTFiQWFqSWhNMHpFS0hEQXZKQ1VralVTc0ExL2hhUlNqd3lGYWVTRjJtQ3UxaEhDUnlKc3JtbUxXTUdqWk1wcGtFTER6eGhNcHJLd0lGTWN2eE9wREJHcTkzd0VVSURCcm05MzJmRWJaaUFmcE5XRUNoQnMzUXRlazlBNFJLS1czVThxWVdMRFZnVUhDM0pEMTFwRlVlZDEwSmQ4dTZkSm5PMVgvaUNZWE51NlVJRnZLN0RoUWNZTEhDaEkxRGhBVnRtQ3luSDhDUWRLbnFCMmx5ck5wbmFualFENFhBNllkS3FuMjNGWkM3ZHFrSWc0eGFlUVlaYUVSYTFmU0R3YlhUQlRKYWVFUkdKUTNJYUlUQzYxd0VDR0loeC9lQ0RGcGdHSUdSdkZDY3FvRFJOZFora2xLT1V5UlZnejBveW5zR0U1VlNtcXZsVFkxWmFzQUJJdGVad3dQWUltR0dnOHp4S2hwS2tBRkRwb3hZS084ckZHcnVpSVFtdDNjQ0JJMnJ4NUZCQWxyZHlqQlFJUE03Rml6ZzlwUmF5YXFFeldEd1p3SURoMGFxRGRZS3lNMVpLc0lnb2xhZWdZU0dpYVhXRFJNYXVqZkZMR1cwOElpS1NocGcwUWgxakd4RjRQZzV5L0dkSUFOVnMrY25KTmFEOGNUUFI2d1BXY0oxSGNoSGpOcFdpVXFRbVkwVUVqY1pxYVM2V05YS0tFdFp1VHJzY2xobWdwMit3Z3doTFJiRURPZ2h2NWk5bGlBM2VjMGtkdTVhU0hYcTJzb28wbGpLOURwd3dwcWF4bTZ0aENXM3RSQUdpbjJ4RGdhQ1dTNkQxZUM0Q2xZb3pDSllwWlQxcVpZL3JWNlZlckFyWU5zTFlOQlkxcmIxTDZFaUtwN29vV2NiMUVzQ1dpN1FDNk1aRFllZ1ZGU2hBRmxNUnRYMXNwU2NYd1NIR3FuTjFiTkdrZExhdVFnUUd5Z2NNMWNwS09FRFBBd2pabVlCeUVwNU5YTllGdC9lM2RxYlVscFl4d3huR2pTL2M4eHdwbUgwMGJMT2duVE1zYXFLcitGaEhsUUkzRVNva3VwUTB3cklJMUdwQ0RPYzFjb3p3NWxTSU1EVWhqTWxVNDVaWjFzMVBBNW5sVFFNWjQxUWVKMkxBRUVzNVBoZWtKRzN4RGlkcFowWFhyRktTenRVTWsxcmFaZEU2WCtrdGxwNDFGdVZ4Q2l1UmlxYWF5NkVGRSt0RHFPN0toT004bExKQ212YTZyM0tlM3l0akJhMlRLYVp4T2lmUmlyOHpvV1FPRll5dlE2Y3NNTVpIdld5YW9xNGJUSXN2bG82OVZGb3ZaRlpUb2dVcXJZeHh3VzFUSXV2Tld5WlJkSkN3Mk5lWTc2RkJnTU5MYjYyY2hTZEJxdDF5cUZIbHBkTTY1b1Q3S2lBaTZLRnFzQ1FvcmlsbkJhMlRMNkZsbmw1NG1tRjc3bWNMSmUxZkk4TWxHK2YvdmZ2UC8rMnJrODlma2ViVFRhZnpZck04VHRKLy9YSDcvN3c3WGR5K21tZDVmMm5kWlNQbFArbkg5Zmw1aE9FOUVkaG4vZzBGdmZwaCtuZnBUVHBqNS8rMnNIYk42cjI4S1BnUjhMUHgveGpWSi9pbTArOHNBYUJIQzR1R0Z3TW5zdTh5ZXNnZWVFbWc1RUJUMVRBUUh4UjhncWp2TUE2bUNYMmNhU0RYZmpXQXNXREpRckVlSlBuY2VRSjQ0U1RNc0EwRnJkNEwwbWVJQXdIMG5CUVBmZ2ZKamZ3OC9FNEFoa09keThCWm1Ca3NpcFA0blF2am4xeTNSSVlMN0pCYUZ0aTJ5KzRwZWowQU1WT1VMdEY5WVpjb2wyS0dlUGZpS3ZyWmorekgwZG11NTdGUlhCcFJwcStWbkhOb05CV09IT0l0SXFLa1dhWG1ua1Ivd3ZhMEs5ZVlGZVlmQkxrMHJRUUNNdWlCZ0wxREpPWXJJMGl2Q3RoKzFDMDFKbHNDU2RqdWtBcE9XYnNDNDFzNDFxQUtMUzNFQ0R1NkN1VEYwWHN4UWhQVzhad25kVlhGWnk5bjhkQjZyMW9NTGpUQ3cwM3dQRiswbVVKN1pUV3dVNDloZlBGaTVPR2psa0t6aFNjUEdUYzJGaWxjd2JKcUxxbmVqbHlNUWJuaGJtLzJLcHMvSXdjZWhjTGl2enBaYVFCUGFpM0wwdEsrcUhZQWlGTENxWG1WSkZNUlpZdTd4NFdhdnNNRXNQdE1aZjhKYzVQWkpIQ2ZaYVVEUXVjWVRpVnY2Uy96ekJ2MGJkcHkyM2FjaFhpZWovVEZ0d1JzNjRjVmJvZ2pRNDZ4M3dvK3NnV3pWMjF1OHE2NjV4ajRpNjloUnRHTWtsL1UxdzN4WFhwNHJvdXhiV3oxK0Y1S1JrRDdleHhiaWYrY1JVZEwrVzV6N2ozTTExaEI0U0p0b2tIWUVyWlAxNS8vekZDKzBONDFad3lNWEdoVFJJWDQ2VTdmMjlnT3Vna0FpcmNBRDFRNGxHdDNub1lENnk4MVRyTGNhd0F4Z2ZPeTg1cUZGUjJSelBBYkhDOGl4Q0ZlNFI0MVowTzA2d1BKQnpsdkFuYlM5UXhUcUJJNW5TU0UxRk5RZEtCdis0RUNsN3V6UzRrUEhmcVJ3TXBDTnVmM1ZsemMvOFZEb04ycnJhQ1hhZWpoaHBMSVVQMG5IV3MzZ1RURDh4T2JMOWFmVUdRSDA4amVTdkNobHNjbnk5bFd1WTQ4N0VncjA0RGVZWk53S3duWHN6SXBjYmRJaTlDejZYSGUrNVpBT2ZGdS9GR3BJUUtIZWVDM0ZMVlRhRWZwTkNOUzNqK2xmZjZsSXpBMDBmUzRKVGp5bFc2QVpWdWdGR0o1NzhIUnBPd2h2UzJHcThRYUJvSDBubng3ZlQycVp1TGdQWVY2ZlZERVFJeTUvc0JFaVRqT0loYUtlQmlGRHpoa1VydnZBRGhHUWNXdDgxNnNUOEFmbjBkQngyalpTVVBBMFF2R2JBN1hCNGJoc3NTVG9vVUtaMDBaKzA4V25xaGxZZDZlVEJHbzdUVGJYRDRxc0ZCYTRDejMvRHVCalFkVDJ2OG5BM2pkRW1FdDM2UVQ3cVZ4cGcvR2wyaHZJbjlvMzBFMVFLanNuY0JaaXBhVDdkQjRpUTl3QnBTZmx3UFFJZU9EaDMxa0FWMTVUM0FhT0xDVzRYVDk0NVJ3TDdPMXpiVGNEbGI1M3VaWVhTSWVlSVpMeGh5Rm1jQTNsdDJVVlhlbFB4QkVMZUtYUEx5M2hoaGRvV2VEOUczM05YUEFDeEFOWmxzeUF4ODRra2pVdkl3NGVsdU81ZlRrdGFNdEZOUGNrSHM3dUloZnZWS0hxK0JSN2VoNVBIdUZMYSt4bzV3NVQzQUJObzhSQ1Z2ek1Db1FiOE8yQVhzY0JNYnp3U0JEakQ2NlBnLzFhSmRYclBpdkNYZ290M2swbmhsOHhxWDdFd2tWaFRESk16TFhBVHdqa3QyVVdmKzFYbTFXUUN4NDBXMjZUWlFmOTFTWFZEc2ZXbDZiOFpMNmxlb25nek9vekl2REk4NGZnK2FpZFF6eC82cHpVLzBxSHZCZUw3NlVSa3ZIOEtvelByM1JhOExBVnBkRDFma3J3NzB4U3AxQm0yOTBSazZvZDc0d1NhbHpWWm5GS3I1aXh5VHVZWEVJSUxaY01TTG96SU95MzY4Sm45MVRRcm1FdW14Uk5md2Z4bG9rUVptUDFwWldpUUFmSUpwZHJpV1JxWGxzUTBuN1lWMlNsdnJyQ3VFM2hSZWVEWVpZNHNXQ0FNcmdkTU9UOTdkYksxYTdOZkEydk1ERDc1K0Q1WldVVkNNb1VYWHJVWTd5K3UzTWJPTTNNRHhkRHZQY3F4cEpPN3ZlZDdPSWh2WE00N1FISGxYZEVZRTlMcUVIOE55dUQ2bUpyejFpVUF4d3VrVDdYeWViWDZ0UERsa0F5TXI5VG8vQ1pVN2l1MVZ2aklvTTBOaU9PdU9FSWc4SkdoSEIrMlliTGhwL3E4MGFOQXAzNFpqTXBoc09rdmdEdGR2MEFDRFdoRlNkZWdaRFZZWVMvanVaeGZhZStyNjZJWFhueFhnS21yOG5ocFlVOUFNVWlZLzNlYmRKK2tBWU1wN2ZxVkpSZER4aFA5aEorVHE4SzhpQU45bElQZVROQlVDbnZray9UNDRWNHVLWEtRYk90dHpWZzN2Y05JSXNBNzQvYThrOVUzRmYrMmNOZUEyQ090ZkVIMmo0Q2RJdlJ4UE5GMGR4dEZYdC9iQWpFYWQzVy9xQS9kVGNJd0pnMS84SVM5OWdMZnpIbXRSZUZYRlNUVUZuREZIZFR2SG5zVnpqQzB4UmVzVExPaVR5VENSNHhHbnF6UGFrMFhUSExIYld6V2c4SzNoRVo5MDd2UjZkQ0grRllEZnVySzA5WDVYOXhqMVJRLzJCZEJIa004QXQvaEptQlhBRitBdUxtL3E5V1M2cnJ4OExtNXdiTDI2WE55ZmtNT0t4UlZtaXZPaGhOWDhucTVGaDg1MXcwT09zMHhQZWJvU0RvdDB6Vy9SWEErcXJ5M3BNTStQU0Z2MlFOQmlNaTd1cHExdThxM2Mvc2hsdWFuNFRNTG5lcTNiWlRjdlMxa003bCtLbnlYNmF4ZDFYY2l4bFdHTFk2dUgrUjNLUmEydXlqWHRzYVU1ZGwxQW5iKzdIcVZIT2F4VTZhNytXbE5hQzRNSCtsV1hheVVzVVhZUkxZd0VmV2JkcXgzYVMwcjErOUYwSmN6MEErcjhWdUdYR3lZYWRQQURRSlBDR2Rqaktxckd0ekhBRTR3T0N2Y1JJbjRkU09GZDUyVk1nNXNwa04vNnJBYjZaNGVrWnIzYVpSQURFRmV0N2JoSVRQU25JR0RPQVpGSnQrQnlDZlFsMEpoQzBmWEhaUVZnZXBTdmFQK3lldWt4aWZIdzVEQU5ucHhGbFVOenNHVnloeCs4ZDVQRjRpWGVRWnVmbHRFazhoTFJnRjNXVWVIK0FYM041V2tWTnlpSW05WW5QaXhXQkp1cWw1UUUrZW4rUktQRWlTL0U5dXZYRGc4Z1lDWnJDNW80amYwQkF3Q1Y3ZXUyeUdENWVvbkhIMmVWdTZWd2Q5c1gwQm9hSlkwZXM3RmxUQWZhMFhwWTJRNmM1YkJRcStqTDMwRHJLZ2RBK05SMWxLcGZxMTc0VVBSaTBXc3V6djFmL1dsdFBTeHNoMjNMNFEwWmQrUWphQS9qU3QxK1R2ZnpZc0FjWklCc0R5Ukc3aDVJaHZ2Wk5hM3Z4NUE5OWk2ZVRudjFGd2hDOEt2ZnZhR0lWVnNiaUdnYVNyenMvbklUZVB1VyttRVNrcE8vQmdsUnp6K1pkSHBEcEdkeXphSmFNYmlQR3ptdHB3TW84UFhncFBHYjNxYitrUm0waXhpaEE4WjNISHNMRmw3YjJkVHV6blptYlk4MmdkcFM4NzFQSG1nQXFXYnF4NTY2dzRGTjU3eG1kcitablU1bTFkZmVWWGR3K1B6TmE4ZlBEVHRZU1RCTXRSbnQ0QkZ4SzNtam5leW0zbkxXdXZ3aXF1eU1PdGRoakJhaENCQmtBRk9NeDFVZGxlK1c2T2tWcGlMRE9sQVNGWVp5QmhzUjgwZUlsOVE1NDJXcTE5aGttM3BQNGQxaVJyajdWb3oyZ2Ywb2EwSWM2TmV3WDA5dHlkVlg4WUJwNnJSVlZ2T3VuNTdpdjZQNWNEeUxQSEFEaHZ3dzdaUUtlWEV1Zm5SUkVncC9mSjJndzdNcjcvQXZTRTk5VTk3Zlp5bGhYRldsaUQveXhIN1Jzck5uNlVjVUh1UzlaNi9raitqSmgvNGZoYjlMRitjNjd0TEhoWXNYT1JVck9yaXUyN2pacFIwUDlPTTdUVHFuMktQS2ZsSDN5WjVnclFxRVA1ekk3ZEhyVFUwVnJsSFpMbXdBbWt1N2JtMnhXeVBjWng4Y2NYVytEbVc0YWVqRHFFVDJXUXFjcmJEZld1RHNoZjBXQTJzekhHUTFzSGJEUVpaRHY0ais0eUdMNkMvUTNqSnVDUDdDMUlnN1FIbS8xcUs0Y2tXN3c4SlkyUmpGQzMxZGxDZGI0bjdEeG5DTWpSR3o3YkZ0WTd4R2pneFdaN1NpK3pDWk9MUWUwaHFIdGNkV2l6QnRzdDBxQjlrZFE2UEU5ZTdIU3l5RVFlVDdoSDdCQW92b09HNFR5Q3Vid1JhYjRiNUFPQjVCTXRzMndnc2NLbTZPZENERDIwajNGaU1kYnNsbHdZdWtuYi84NFU0SkZXQmlzV3ZFSzF2RmRkdTFLUW8xajNSMW01Z1V5bktFdEtjWUJYZHFiNFdINDdSQ2RNc1F3aDRWUHZTZ1ZWWkNCNnU0WVlCMnA1M0QzN2dTS1h4d3JNNEMzUkluTlY3K3BWTHd0Z3JSeXE4YXBFU1BUSHlnSmZSMDg3UkZpNzVrSXpGYUxwd2VINW1haFJyUDRKWWZKUzVQYkFLaVVaWlBQSTFLenRrMkx1aHB6T3ZuRFVHcDBiTVgvaU12VlpsSWg0QndmM2FybW5LcmpqSm5rMy9sU0pKbDB5REI0djRveGFXbmpTWWgya2FURUMxWDFwUXRWSnVXZkI0aWxyN3JiaXNvL0hjNHN1WGt3TVFaOVJNSjZpQmtPOXhzTi9qckY1NG1XWmpHc0Uwd28ydS9YSitBeU15dGtuRE4zMjgxZmFSdjV3cHNrd1JKWEtTSFI2YUNMc2NKQ0Z4S1JVOGJHUlBOa2dNS2pFb25iQnY3YjltTU1MZ0ZqOGN1ak1kRENsL2JsZ1pYamphMGxHdzBybVYweURUcVhNVTBTR3pUVU56OHE2NVVQZklWa2F5Q29kd3Q5VnJNcER5eGhSVWFwS0JrVk1HWnhRdG9MM1Rqd1kxTXQvYTZ6UFlDdGNQNGJ5TTUzZHJyQXRzTFArSGcvYTI5eXIvenR0ZXV5ZXZGVFlDVUFUTXR5blRJUEVoOUtEOHFyMXhGVStZN1IvM2FCb1B2TmgwSllIVjRPdjR5UVBzUVlKUERJVGxnT2gvd0V5YkJFNlRUQXMwY2hTYVhNUU02UEJwVitmdzIzVTNETENOZW9QZDQ2ck9QSGNtWDFlaXRDbytMb2t0clBIT0pwenZ4N0dOK3lHYzkrM3d5U2FFdFRVZFNsVVlmRkhRSlN0Rk5wejVCUU44TnltTCtIbytVNDUxWGwydWJIL3NFbEVzbTBTSFhuRmJSSTFzQ09TSE85WkNsYW5LajlwTFlrMmh6Wm80eFA1SktIMU9qUVVtU2ZCb29NZVg2MDdWZGFnR0R0NXpZVmlwekZqeWtTdE14azJyajl6RjdySzJXUTNaMzlFdnJ5Z21FNzkxaFhUa3NkZ0lOdjZKM3FzVmw3VVZLcU5hRmxkcStabmtDMllaV2xhK3dKQ2tqZzhqVU9MUDU5Zk0wNnY3ZmQ2K09OVmc3RWIyay9oOEJuNjlqZ1ZZS2NRNTVWZzZnMTRmMHF2VWhuSWRyenNxQTlqQW0vOHB4T1BPQUZDOXBIWnVqMGhQR1psYVBrRVFKNkZlTFNRL2M4bEROVHRaaStIelBaOXc1a0toSFMwY0d6MEplMFgrOG1CVmU5bWNYK1hIZG10YXVLUW9uWnZyQ2pNdzNGREFxUFZCc1RtNUVDK1hYSEZXUGZ1YXBBalUvV1l2WnlQaDhjZzR3TzdXNDFHZXNqUytYY3pLczFheFFEcEhNQzAzQ2RMeXdhY0ZNOTdjWVZ0ay9IVms0VjJXeGF1dXl4OW1YV0t5aGJGNnBlVStWTG9qSmNnRGozQWRoK1BmODIrMmhkUjRIa3pmZFVkeHR1TStwakZqNzY5MitOb1VwZ3FQUFM2QlZ0UnhrMnVEQ0kreVFlcXdQK3dCUzFCSXBmNEJVWHo3Lytqdzkvb2JQY3ZydDhYbFZNYVdoVjVtdnJsUi9tM0VubUY5MnM5SGs0VXVXSjREZVpQekcvVWFUUDE5bzZtZFo5WHgzc2QzZFd4eTVhUGNoUzFqWFRhbjdvOS9QMDFIaTl5MnhqbTk3MUxzVEowMDdFcDVUMkxyVFpJYUQyNllSbDRleWxqdDQzRzdkaFY1MDZ1VGhhS05nbjB3KzlESkpLNUhnMmJYNXZ1czFpaUVsRVVJZUgzWUpRdjlwMGU3MVMvYXFYSUR6MThpNGNuaGhFcWZ4dXprZnJ5RmZEWWY0b1R1NW4wUDlrSGZocjdjdnF4alEwY0UrUGovazB3bDBRQ2NVVzhmUEIzVm9pdjl3MWp0NFFhT1hUVnprQ1d1WGVIdEVPdlUrQkY1NUc0aHpsckZjL3pnK0tJN05BYWd4bk83dFpFTmZQaHVBZzZDUDNSaUgyOC9qdS9MbW0rY2ZIdjcyL09Yejg1ZmYvVCsyMTRlNENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS09EY2dNQ0J2WW1vS1BEd0tMMVI1Y0dVdlJYaDBSMU4wWVhSbENpOUJTVk1nWm1Gc2MyVUtMMEpOTDA1dmNtMWhiQW92UTBFZ01Rb3ZZMkVnTVFvdmIzQWdabUZzYzJVS0wwOVFJR1poYkhObENpOVRRU0IwY25WbENpOVRUV0Z6YXk5T2IyNWxDajQrQ21WdVpHOWlhZ280T0NBd0lHOWlhZ284UEFvdlZIbHdaUzlRWVhSMFpYSnVDaTlRWVhSMFpYSnVWSGx3WlNBeENpOVFZV2x1ZEZSNWNHVWdNUW92Vkdsc2FXNW5WSGx3WlNBekNpOU5ZWFJ5YVhnZ1d6QXVOelVnTUNBd0lDMHdMamMxSURFNUxqZzBNeUF6Tnk0d09UTmRDaTlDUW05NFd6QWdNQ0F4TWpVZ01qTmRDaTlZVTNSbGNDQXlOVEFLTDFsVGRHVndJRFEyQ2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEZzVJREFnVWdvK1Bnb3ZXRTlpYW1WamRBbzhQQW92Um0wd0lEa3dJREFnVWdvK1BnbytQZ292VEdWdVozUm9JRGMxQ2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdNU0F3SURBZ01TQXdJREFnWTIwS0lDQXZSMU13SUdkekNpQWdMMFp0TUNCRWJ3cFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqZzVJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LT1RBZ01DQnZZbW9LUER3S0wxUjVjR1V2V0U5aWFtVmpkQW92VTNWaWRIbHdaUzlHYjNKdENpOUNRbTk0V3kwMUxqRTFNaUF5TUM0Mk5qWWdNVEU0TGpnME9DQXRNUzR6TXpSZENpOU5ZWFJ5YVhnZ1d6RWdNQ0F3SURFZ01DQXdYUW92VEdWdVozUm9JRFEwTWprS1BqNEtjM1J5WldGdENuRWdKU0F0TFNCQ1pXZHBia052Ym5SbGJuUUtJQ0F0TVRBd0lGUjZDaUFnY1FvZ0lIRWdKU0F0TFNCaVpXZHBiaUJXYVhOMVlXd0tJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQkRZVzUyWVhNS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3SURBdU5qZ3lJREF1T1RNM0lDQnlad29nSUNBZ0lDQWdJRGM0TGpReE1TQXdMakEzTWlCdENpQWdJQ0FnSUNBZ056Z3VOREV4SURBdU1EY3lJRGcwTGprd01pQXdMamd6TXlBNE5DNDVNRElnTnk0eU16TWdZd29nSUNBZ0lDQWdJRGcwTGprd01pQXhNUzR6TXpnZ09ETXVPRFUwSURFMExqWTRJRGd5TGpjd055QXhOUzQxTXpnZ1l3b2dJQ0FnSUNBZ0lEZ3hMalUyTWlBeE5pNHpPVGNnT0RBdU9Ea3pJREUwTGpnM0lEZ3dMamc1TXlBeE5DNDROeUJqQ2lBZ0lDQWdJQ0FnT0RBdU9Ea3pJREUwTGpnM0lEYzNMamd6T0NBeE1DNDFOelFnTnpZdU5EQTVJREl1TkRVNElHTUtJQ0FnSUNBZ0lDQTNOaTQwTURrZ01pNDBOVGdnTnpZdU1qRTNJREF1T1RNZ056WXVOamt6SURBdU16VTRJR01LSUNBZ0lDQWdJQ0EzTnk0eE55QXRNQzR5TVRVZ056Z3VOREV4SURBdU1EY3lJRGM0TGpReE1TQXdMakEzTWlCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNQ0F3TGpZNE1pQXdMamt6TnlBZ2NtY0tJQ0FnSUNBZ0lDQTNNUzR4TlRjZ01DNHdOeklnYlFvZ0lDQWdJQ0FnSURjeExqRTFOeUF3TGpBM01pQTJOQzQyTmpJZ01DNDRNek1nTmpRdU5qWXlJRGN1TWpNeklHTUtJQ0FnSUNBZ0lDQTJOQzQyTmpJZ01URXVNek00SURZMUxqY3hOQ0F4TkM0Mk9DQTJOaTQ0TmlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURZNExqQXdOaUF4Tmk0ek9UY2dOamd1TmpjeklERTBMamczSURZNExqWTNNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdOamd1TmpjeklERTBMamczSURjeExqY3lPU0F4TUM0MU56UWdOek11TVRZeElESXVORFU0SUdNS0lDQWdJQ0FnSUNBM015NHhOakVnTWk0ME5UZ2dOek11TXpVeUlEQXVPVE1nTnpJdU9EYzBJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNNaTR6T1RnZ0xUQXVNakUxSURjeExqRTFOeUF3TGpBM01pQTNNUzR4TlRjZ01DNHdOeklnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNCbUNpQWdJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1VHRjBhQW9nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lEQXVOQ0F3TGpRd05DQXdMalF3TkNBZ2NtY0tJQ0FnSUNBZ0lDQTRNaTQyTVRJZ01UY3VOVFF6SUcwS0lDQWdJQ0FnSUNBM09DNDBNVEVnTVRrdU5EVXhJRGMwTGpnNElEUXVPRFV4SURjMExqZzNPU0EwTGpnME5pQmpDaUFnSUNBZ0lDQWdOelF1T0RjMklEUXVPRFV4SURjeExqTTBOaUF4T1M0ME5URWdOamN1TVRRMklERTNMalUwTXlCakNpQWdJQ0FnSUNBZ05qY3VNVFEySURFM0xqVTBNeUEyT1M0Mk1qa2dNakF1TXpFeElEYzBMamczT1NBeU1DNHpNVEVnWXdvZ0lDQWdJQ0FnSURnd0xqRXlPU0F5TUM0ek1URWdPREl1TmpFeUlERTNMalUwTXlBNE1pNDJNVElnTVRjdU5UUXpJR01LSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ01UTXVNekkxSURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TXk0ek1qVWdNaTR6TXpRZ01UQXVOelE1SURBdU1qTTBJRGN1TXpBNElEQXVNak0wSUdNS0lDQWdJQ0FnSUNBd0lEQXVNak0wSUd3S0lDQWdJQ0FnSUNBd0lESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ01TNDFNVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhNUzQzTVRFZ2JBb2dJQ0FnSUNBZ0lEY3VNekE0SURFeExqY3hNU0JzQ2lBZ0lDQWdJQ0FnTVRBdU56UTVJREV4TGpjeE1TQXhNeTR6TWpVZ09TNDJNVEVnTVRNdU16STFJRFV1T1RjMElHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdNVEV1T0RFeklEVXVPVGMwSUcwS0lDQWdJQ0FnSUNBeE1TNDRNVE1nT0M0NU5qa2dPUzQ0T0RNZ01UQXVNelkzSURjdU1UTTVJREV3TGpNMk55QmpDaUFnSUNBZ0lDQWdNUzQxTVRNZ01UQXVNelkzSUd3S0lDQWdJQ0FnSUNBeExqVXhNeUF4TGpVM09DQnNDaUFnSUNBZ0lDQWdOeTR4TXprZ01TNDFOemdnYkFvZ0lDQWdJQ0FnSURrdU9EZ3pJREV1TlRjNElERXhMamd4TXlBeUxqazNOeUF4TVM0NE1UTWdOUzQ1TnpRZ1l3b2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQXlOeTQxTVRZZ01qQXVNVFkxSUcwS0lDQWdJQ0FnSUNBeU55NDFNVFlnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREkyTGpBNE9DQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01qWXVNRGc0SURFMUxqQTBNaUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUzTGpVNE9TQXlOQzQyT0RnZ01Ua3VNRGN6SURJeUxqSTRNeUF4T1M0d056TWdZd29nSUNBZ0lDQWdJREU1TGpnM05TQXhPUzR3TnpNZ01UZ3VOVFl4SURFM0xqWTBOU0F4T0M0MU5qRWdNVFV1TURReUlHTUtJQ0FnSUNBZ0lDQXhPQzQxTmpFZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURFM0xqRXpNU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdNVGN1TVRNeElERTFMakk1TkNCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMkxqZzRPU0F4Tnk0Mk16VWdNVGd1TVRjM0lERTRMalV6TVNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFNUxqTTVPU0F4T1M0NE9EVWdNakF1TmpBeklESXdMak16TVNBeU1pNHhNVFVnTWpBdU16TXhJR01LSUNBZ0lDQWdJQ0F5TXk0M016a2dNakF1TXpNeElESTFMakE0TXlBeE9TNDNORE1nTWpZdU1EZzRJREU0TGpVMk9TQmpDaUFnSUNBZ0lDQWdNall1TURnNElESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ016Y3VNelk1SURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTXpjdU16WTVJREU0TGprd05TQnNDaUFnSUNBZ0lDQWdNell1TXpnNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016UXVOemt6SURFNExqa3dOU0F6TkM0ek1pQXhPQzR4TkRrZ016UXVNeklnTVRZdU5qTTRJR01LSUNBZ0lDQWdJQ0F6TkM0ek1pQXdMakl6TkNCc0NpQWdJQ0FnSUNBZ016SXVPRGt4SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F6TWk0NE9URWdNVFl1TmpZMklHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UZ3VOelkxSURNekxqazFOU0F5TUM0eE5qVWdNell1TVRNM0lESXdMakUyTlNCakNpQWdJQ0FnSUNBZ05qQXVNamt6SURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREV4TGpVME1pQnNDaUFnSUNBZ0lDQWdOakF1TWpreklEa3VPVFEzSURVNUxqYzRPQ0E0TGpZMU9TQTFPQzQ0T1RJZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURVNExqQTFNeUEyTGprNE1TQTFOaTQ0TWpFZ05pNDFNRFVnTlRVdU16TTVJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTFNeTR6TlRFZ05pNDFNRFVnTlRFdU56VTJJRGN1TXpjeklEVXdMamMwTnlBNExqazJPU0JqQ2lBZ0lDQWdJQ0FnTkRrdU9UTTJJRGN1TXpjeklEUTRMak01TnlBMkxqVXdOU0EwTmk0ME1Ea2dOaTQxTURVZ1l3b2dJQ0FnSUNBZ0lEUTBMamM0TlNBMkxqVXdOU0EwTXk0ek9EVWdOeTR4TWpFZ05ESXVOREEzSURndU1qWTNJR01LSUNBZ0lDQWdJQ0EwTWk0ME1EY2dOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lEUXdMamszT1NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTkRBdU9UYzVJREl3TGpFMk5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURFeExqYzVOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJRGt1TWpRNUlEUXpMamd3T0NBM0xqYzJOU0EwTmk0eU1UVWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lEUTRMall5SURjdU56WTFJRFE1TGprek5pQTVMakU1TXlBME9TNDVNellnTVRFdU56azFJR01LSUNBZ0lDQWdJQ0EwT1M0NU16WWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTVRFdU5UUXlJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdPUzR5TkRrZ05USXVPRFEzSURjdU56WTFJRFUxTGpFM01pQTNMamMyTlNCakNpQWdJQ0FnSUNBZ05UY3VOVGMzSURjdU56WTFJRFU0TGpnNU1pQTVMakU1TXlBMU9DNDRPVElnTVRFdU56azFJR01LSUNBZ0lDQWdJQ0ExT0M0NE9USWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTJNQzR5T1RNZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ1pnb2dJQ0FnSUNCUklDVWdMUzBnWlc1a0lGQmhkR2dLSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdMalFnTUM0ME1EUWdNQzQwTURRZ0lISm5DaUFnSUNBZ0lDQWdPVGt1TkRFMUlESXdMakUyTlNCdENpQWdJQ0FnSUNBZ09Ua3VOREUxSURFeExqVTBOU0JzQ2lBZ0lDQWdJQ0FnT1RrdU5ERTFJRGt1T1RRM0lEazRMamt4TWlBNExqWTFPU0E1T0M0d01UVWdOeTQzT1RFZ1l3b2dJQ0FnSUNBZ0lEazNMakUwTnlBMkxqazFNeUE1TlM0NU5ETWdOaTQxTURVZ09UUXVORE15SURZdU5UQTFJR01LSUNBZ0lDQWdJQ0E1TWk0NE1EZ2dOaTQxTURVZ09URXVORFkxSURjdU1Ea3hJRGt3TGpRMU55QTRMakkyTnlCakNpQWdJQ0FnSUNBZ09UQXVORFUzSURZdU5qY3pJR3dLSUNBZ0lDQWdJQ0E0T1M0d01qa2dOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lEZzVMakF5T1NBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXhNUzQzT1RVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBNUxqSTBPU0E1TVM0NE5UY2dOeTQzTmpVZ09UUXVNalkwSURjdU56WTFJR01LSUNBZ0lDQWdJQ0E1Tmk0Mk56RWdOeTQzTmpVZ09UY3VPVGczSURrdU1Ua3pJRGszTGprNE55QXhNUzQzT1RVZ1l3b2dJQ0FnSUNBZ0lEazNMams0TnlBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURFeE5DNDJPVGNnTVRNdU56STNJRzBLSUNBZ0lDQWdJQ0F4TVRRdU5qazNJREV6TGpBNE1pQnNDaUFnSUNBZ0lDQWdNVEUwTGpZNU55QTRMamsyT1NBeE1USXVOalUxSURZdU5UQTFJREV3T1M0eU9UWWdOaTQxTURVZ1l3b2dJQ0FnSUNBZ0lERXdOUzQ1TURnZ05pNDFNRFVnTVRBekxqZzVOU0E1TGpBNE1TQXhNRE11T0RrMUlERXpMalF4T0NCakNpQWdJQ0FnSUNBZ01UQXpMamc1TlNBeE55NDVNalVnTVRBMUxqa3dPQ0F5TUM0ek16RWdNVEE1TGpZek1TQXlNQzR6TXpFZ1l3b2dJQ0FnSUNBZ0lERXhNUzQ0TmprZ01qQXVNek14SURFeE15NHhNekVnTVRrdU5qTXhJREV4TkM0MU1ERWdNVGd1TWpZeElHTUtJQ0FnSUNBZ0lDQXhNVE11TkRNM0lERTNMalF5TVNCc0NpQWdJQ0FnSUNBZ01URXlMakk1TVNBeE9DNDFOamtnTVRFeExqTXhNU0F4T1M0d05ETWdNVEE1TGpjeE5TQXhPUzR3TkRNZ1l3b2dJQ0FnSUNBZ0lERXdOaTQ0TlRrZ01Ua3VNRFF6SURFd05TNHpNakVnTVRjdU1UUXhJREV3TlM0ek1qRWdNVE11TnpJM0lHTUtJQ0FnSUNBZ0lDQXhNVE11TWpjeElERXlMalUzT1NCdENpQWdJQ0FnSUNBZ01UQTFMak15TVNBeE1pNDFOemtnYkFvZ0lDQWdJQ0FnSURFd05TNHpOemNnTVRFdU1qa2dNVEExTGpRMklERXdMamczTXlBeE1EVXVOemsySURFd0xqQXpNU0JqQ2lBZ0lDQWdJQ0FnTVRBMkxqTTRNeUE0TGpZek1TQXhNRGN1TnpVMUlEY3VOelkxSURFd09TNHlPVFlnTnk0M05qVWdZd29nSUNBZ0lDQWdJREV4TUM0NE16TWdOeTQzTmpVZ01URXlMakl3TlNBNExqWXpNU0F4TVRJdU56a3pJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEV6TGpFek1TQXhNQzQ0TnpNZ01URXpMakl4TWlBeE1TNHlPU0F4TVRNdU1qY3hJREV5TGpVM09TQmpDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0JSSUNVZ0xTMGdaVzVrSUVOaGJuWmhjd29nSUZFZ0pTQXRMU0JsYm1RZ1ZtbHpkV0ZzQ2lBZ1VRcFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqa3hJREFnYjJKcUNqdzhDaTlNWlc1bmRHZ3hJRFEwTXpBd0NpOUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVUtMMHhsYm1kMGFDQXhNemswT0FvK1BncHpkSEpsWVcwS2VKenRmUXQ0Vk1YWjhNeTU3UDF5ZGplYjNXUnoyYzJTUU5pUURWbHlXUWpKSVNFSUJEQUUxQ3dRRExBcU54VzVYd1NoQklHQUZTaW9vUFZLS1ZXTHk2VTBJRmcrYTZtb1ZGdTFSVnVyV0dxVmdsSzFsa0wyNUgvZjJiTWhnUDIrdjkvelBkL3ovOCt6TXpremMyYm1uRFB2L1ozM0hCWkNDU0Y2c3BMd1JKcTJjTDczTzN6TDc2SG5NVUlNZWJmUHVlUE9FVU5QM1FIdFkzQk11bVAya3R2bnYvOEhuaEJuRmlFRG41NSsyNVRvVitUT0hZVGNDT09rZkRwMHBGbjBJK0Q4SXB6M21uN24vTVUxT2I1U1FocGhmdC9YWnQ4OWJjcVhQL25UZTRRcy9aU1F3cGZ2bkxKNFRtYTc0ZStFN0h3ZTVudm56TDF0enZjK3p6a0U1MjhRb3BQRmN5U2RFSEVIY1NmTG5ra2dpWjZ1VDd2V1h5bVZNVXBoMTkvWmZLSWNUc3prVG5hZEY1OGlabTU0MTEvNUNESER2TC8ydkZQWGVTRkU3R1FuZVk1c0lLdklJbVZQY2tTbkhrTGl0RjN0bnFmV3MrQzRCM0EzbGZ6cjlGdkkvMzZLa2Qxa3M5cmVEU3NqUGRxUGt1bmQ1dytUamVyS1ZyTjZLN1N1elA3UDAwZVFueVJuNkV1VXUyN3Nmc2lFL0lMOEhQQXhra3dnWThYZmk3K0h2bWF5Q1k1MmdQbEtlcE9WQ09WaXNvZ3NKVlBnV0tXT3JXSTRJbXpzVGxadmdiNHRnT2NueWNQMGJUS0t6Q2RSZ0tvN2FmemtCSmtKYzBmQmZXYVFWOG5UOEt3VlpCYlEwOGIxSWphZWRIMEJkN2dEOFA3ZlR3K1NhZVFoY2t3NW9ud0pUNCtTaGVSZTdodmdEMExNd2tOZFg1SHhaQmlzWVJZWnBaMmg5Q2RueUpFcmx3b25pVTN6SlBLTVFzaXo1Q0NaVGJEdWdQckZmMzhoWFVTWkZyOHp2ckRyTzEycnhjL0VQd2t2Q2VmNHFKQkI3aUwzQVdVZkpUOWtyYzJBcmQwa2xWSXBsVklwbFZMcC84ZTBHdXpvVnJLMWEwM1hIdEpFQ2pWcFpBL1kyV0ZLczlnS0Zua041RW5NOHY2UVBBSSt4bW55T0drQUQrQkExNmRYM2VVeHNOZW53U05wQUI5dkRDSHlUV3VpRXlkRXhqZmRPR2IwcUlhUkk0YmZNS3l1ZG9oY1V6MjRhdERBY0dWRmVkbUFVR24va21CeHY2SkEzOEkrdlF2eWUvbnpmTjdjbk93c1QyYUcyNVh1VEhQWWJaTFZZallaRFhxZFZpTUtQRWRKRVhYSDNIWE45VE5qR1hXdE1aTi9xRi95eGt4akxvd094b2pkNC9QYnZLRmdwSjg2S3lZR1lzVFJFRXRyYk41TDVNcElUQk80ZHNxWUdKOHZmZW1EaTBkN3ZQVXhJUi8rL0NPblJHTjltcHA5ZnVtM251N3hDRndUeTZ4cjl2azhNUzRmL2tiQUVQeU5uT0tOeHFSRzZQZDVFajBqWXFTeEdZK09ybzhyb1pOVStpSlFOalhIY3BLbmtjaTNMUkljN0s1ajF5eHpERzJYOXBveTZvYkdTTnBlWXZvNFJwdzQ3VUlsdUtKVnNUNEJXSWdFTFhZM0VvelJ0QzlqMUJHanp0R3c1S3NmZ1pkOVZQa3RPS2lQenZUWFIyY0FScU90VjNCNklZRlJuN2ZkMjk3VWJBdEJreTI2SWZicTJPYTlSa09kdis0MkEzUVExa0gyR296UVk4UU91TVdjdmRSVVRWbURNOVVQM01zUm5SblFaOGZsMXVNeE15WnZhSVdHZnlqZ0RVWWNWMFk2dW81dDdEbEU0TEpreTVGb0pSWVIwOVRGdElsRmVHZkU1Q2t4c3NHN3QraFkrOFlPaVV4dERaaWkvdWlVU2MweGZncE0yRXY0L1BycDQyTlpEWTBUb0FzZUJVZnJkQytTZXlncmtIamUrdW5lZGpqSHVhMVErb2NpMGEvcWowNi9yUlhaaExiNmg4S1l2cTU1cmUrWUoyYUh1ajVtQzhUTU1NMjg5SXlIYjY5M3ovRGlhWHY3V20vc1NWaHVqMUVmbHNBRWJsaDZlNzBmbmdZM3E1OVppeVFKZHBPTmNlT0lLQ09PdkdHS043Wnk2c3dFNzAzWm1PUi9YN3NVTTMzakErb0FmZUJLZHFHS3ltanJURnp5ekNrSVp2MU1iL3VHMnhpb0d4bG93Sy9lK3BsRDhjQUxnZnZKVFhEMWhPYjY2Zjc2S3c4RXdLSEI1MTk3cmM4WHl3amdoZTN0OWJqRUtWRllmV0xKTUhCbC9TZ1RuZ0NGOWRURjVQR3NJdU1aRGVDSjhwU2hFYlZMblRBQkw4T1IxcUdSaUM5QmQ1Z2EwK2F2Rll2OTNuYThvelkvbGhhUWZLL0EyTEYrUlExTnpmVkRQUXo2R0ZmWFBQaTgyM01lMmcyTjNkM1VEWFBhZytjOUNSdzFqUE0zakUxd3dmUmswVG8rSWNCY04rVmhxanFmM2ZXazIzTVMyc1A4dzFyYjI0ZjV2Y1BhVzl1bmRIU3RuT3IzU3Y3MnZTWlQrNXo2VmkrVGZBcjloemQ0WXNNMlJtSlM2M1E2RUlpTS9EYXNxU0htR0RzUnlUUE1PMzFLUWxuVStIMlZIcDh0a3B6VCtLK0dWVGtEamdlK1J6bHJsODdCMmt5Z2tUemVZYWhlT2tBcmVHSlN8RW5jb2RlZCBEYXRhfHx8fHxGfHx8fHx8IA0KT0JYfDUxfEVEfDU4NDc3LTFeUHVsbW9uYXJ5IEZ1bmN0aW9uIFRlc3QgUmVwb3J0XlZTUFVMUnx8XkFQXlBERl5CYXNlNjReSllvcHJPU21acENEYVl4bldRSHlNUTV1N2tGSjRTUDU5VFBHcVFnQ2JsUVpCdlhlV0xVWGJ1THpvUXh0NkpESlZEaUpyUnpibkRqM2txbWVmVVFPQm9CMnJUaHlMRG5pdkFsSFZpWkh1aTl2OVFPdDNBM2ovZ3VlN3NuUDdUYS8zUnNPTXZ3emRSdU5IUnNQTUY2c2pPa3FWWEk3NnBwNUQ2ZTJPQStQTFVNQTFGZFZ6QlZnRnlKT1FFdTJTMzd2Vy82WUZJaUpkYzNIUEZVUnIyUUQ5VVpoenZBQVNnMW8wYmY4SnlqcVRwSW14V2hWaktaalB3RmR5bFE2NzZxRXdXN204ZGEzdDZyYzFSTXMxUUJFcDM4N2JEQkg4Z040bnNSOG05MlBFTDdCVkpxcXFmT0hvU3g1ZklrWkl5TXhDK3JqbU9VY0syQzlucnBtTDJnZmtOYXhyT0d0OTA1SFlzZThyVU9aR29oNGVuWjNkSDNVT2hUVkhpd1pwM2hVdG9ZeWdkcXJlZTMvbnNOWEFvZXYyaGlaRHR3ZGsvc0NCTjR5ZUN5VGx2SE5LcFlxUGFvVTRiTkdJQ2hYajNkak1Ubm5ldXcyakwvcXJNZDkwU0Q0WUxpeVcvYkhOOGVHQlpLM1NwemZFUEQwUEIxK3pmQ0k1REFCVEhodEl4Q3BZSDhxUFZmMUFYM2xSQmZva2VXZXBXaFBPRnE3MTAvWGpkMHIwM1hqSmpTRGhhczlKQkhpWFRlK2VSOUh1YnJXMnNqZVhqRGVmTWdMemhEcjViQVhPL0hFaXlla2djSWQ5M0U2TnQ5elNDWmtKUnNWV0FjN245WkJDZXZUSmZzb21kYkJKZnFreElNSzJJTmt3c0dJa0JpUms3TUY2Tk1sK2xheVBwYjJFb1JmTm9peVR0YkxKczdNZWZaUzdOb0hQWWNwSVhwSzlwdW9tWHIyd2xWTnJMdURydHlybHoySkdTdGhocHhZNGJxYnJqejZwZ25OKzAwRUxtTWxQS2dXRTZCN0pTQzhFV1FKbmpFeEppRVJ3YjJLZVROUGVOb2xWTmV4U0FCVjJwOVJEODRBTnRtYlQ5YzE5b1JwVWl5dG9XbWlKMFlqL2FCdkZ5RkNtN2lROEVSTE1tV2psdklDNFVWUkw1RGdTWHM0ZUJLcW1wUDlTMEkybnkzZlovUHQ0di9ZZVpBN0dCOHBMcnpVdmxVWVEwVFMySFZXSTRzeFlpUXU0aUc5U1lpOElKZG11UG04UGsyUlBFdFdWbkZUSk11aEliWEUzaFFoR28ycEthSVJhdHczdXJsTWQ2WTduODg5R2pDWk5hTURIVjMvUEdpRXV2OVIwRFVmeVduUWwrODJRYUdIM3Z6OE1sNS8xTm5SZFU1T2h3R25EdnFjMXFOOEZwendXVENMNytnNnN4ODYrV0FnRURqOURodzJXSDJQZGpnWWJDRTFBZUtXWGdsQXlWcG5zQkhzWDBMekNzb0dsSWRLd1ZYVzhIa2FaMXA2cUJUYzZvSjg2cWVPZnpGR3QyNk5IWDU4KzQrT2JyajFydGt0azJmTzRHL3BuUDRnLzNEQjF0aVJ4eDU1OXVpRzFqdFpOL2Y2ejUvWmQvS2w1NTkvazF2MHdMSWxhemZldTJSdDg2Vko0czVMamE4OHZlL05ZejkrN2sxdTRjWjdGNjE5WU5uU05xRENvcTdQTk5YaVBsSkhiaUYza04vSldjMDMwa21qS0I5cG9DMGphV01GYlNxbkU4MTBwR3drbzhkMmRIMHFtNkNSUFpweXVkUW9TSWk1U2RBaGpoaGpGd3pCeXNKZXR3WEZyS0ZaTFE5RnNnVEQwRzBSZzRNTVBoY2hqb0VqYUtVWXNoYU9LQnBuSDNOYkw4SG5DbjFSNVB1aXVmVUxsNnU1aUxmT2tha3N6eGluQS95TzA1bXdBT1NPVzIwTm5nYWNBbVpiN0s1dzhEUm1HN1FRdjNna01KdzRiSGJpQ3J1RE5sZTRmMG5nMXNrdExRRWFhTUZFYm0xcEVmT0t1ZDRXM2c4VllMZWltQzhiVU0yRlNuTTR3TEkyaDNlVjJ3SEZ2VVBwNmE0MEN3Y2RnUE1LcDBhVFgxck53V1M0MHBtV3c5RUJ4WncvVDZPRnBxdThYUHhCK0phUjlRVjlacXg4SkRMN3dNb2I5anlSVXhYTURrZlgzVGhtVmN1QTlldnI1OXphMUdkc2sxNzNoSTduQ3VTYmd2NkJnMnI2NUZUN2V0M1krYjFSSzJjMzl4cDh4NHhGWTJwbWppNHF2V1UrSFp3ZkhwWTNkUUhONkZlVnQrSmVWMjY0YVVDZ3NUcS9mTWFPNlBiMzZ0TUhOVXdzdjNIcCtFQ2djVTc5NGljcVBXTmE3eHAwRDVXMkZkVDVmSU1LSjNiOCtMRWhKVGVVdUNUVEl4YkxkMzBWSS9yY3VuYnFzSnlNd2VQdUdqbDBlcjJmajVjT0szYk9uRmc0dkxyRVZyUUFOTkZHNVRCM3M3aUQ2TWtRT1NCS1JqcWFZbEhKVVExUHZPSlpEVDFMaUZHSHROQkpRQXZkV1Y1SzhQdHBScERUdnoxTmFtcUFsMXNDQWVvbk5vbUdvT0RHYjFGZW8rVmJsZVBLWVRxVjAzSjZlcGZTcG1nVkk0Rm5wa1BueCt5Wkl3OFJUZGVGL2ZCQUFvWmVOa0tqUXMrZURJSjE0U2Y0b0xNNmNCbGtNejVhWjZTYXN5STVTL0dwVE01T0I3b2Y3dWgrK0xOYmFLVnlmQ3NVaCtsQytuZjZUM3F2c2lYK2ovZy84ZG05bFl1MGlwd0JqcStYczhNOERSUEt5ZncrZ1hnQlF0SUhIa05XY3JJdFl6algwWFYyUC9SaGpRcUNDNHEwQlNVNzh5UUlzdlJONWtsOGJrcys3M2ZRcWljWExEaWpwTkZ6K0lSTjlCSzNqMXNHVDhpU0pZNk9pOXdJNXNRTEExNUthYkFGMUVHd0pRRFgrc3A4M0w3NEg3azhlbWtWWGplbjZ5eHRKSytEUHN1U2JVUVRtMGdjK2hkeStTRFA4VUV6UFBvZVFEUmM1K3FoR0Q0c0hqS2tPRmhibTE1YlhGeFhWMXhjQy9mcE90Tmw1L3NCZG5tU0lac1hVVW9rRUV3S3Axd3dTSmphQ2JSUTBEQjh2M2pqZG02UHVPT2ZpelhyUUNQZjNQVVh2aE0wZ0VUY3BGQjJrdlUyVzZaenZXeXdPblpFckZyUnRTTWlacWh5Qm51Y3pQT0EvL053c3pST28vSG5GUlNBUU5uTHkwTmVYdko1YlhEd25VT1c3Wjg3KzBmenEycVcvbVFCL2ZsdTVRUGxKTzFIQzdtM0R5aG5memJ0MW9OVS85d1I2djM1dExpTmk4WTN4MThFSEp3aGhIdEhQRXdzSkZzMm03V2tuZXEwV21yV1VqZlFHUjRZb3NIengwUDlTMkFEYk9HMVpkVjhSWWg3WjZkanhNVGJTc3FYTEpoZVVDMzh6dEcvcEs5cGx6VlVVKzlEck41SkNQOHhRTldYVk1rNU9ZNzFCdWd0eWw0diswaTJ4WnU5UGVKMUd3eWlSZHdSc1dnQk9Cc0p1WU5NaDRTVE1OckQ1MHNCVENiem9CUEtBRWFtTDZBTjZzRG45S0VLcWFqbWVhSHdodGJLa2ttM2pQWFhQN2VzK2FHN2FucmZ1SGpzYmF0SDUzS3ZkVzdvTTJuYjdERXpaSStRVnp0MWlEZXpXTzRkcTdzaE5IVlR5MDN0UytjTUhINTdKREx3ZXpkTTJyaGl4WTJWdDk4K0E5YTlES2h4Q05aZFNPYktROUxYWnpwNjhicThQQjFaTDF1dEFWMUdKclZtVWlPZm1lbk9kdStJOUxJN0hQWWRFWWZEa0swdDExR2lrM1JlSGEvbmRUcURhRkRweGtCRGZZaDRaQkJlNmFJQUpVQnJBMmhkWVVaVUMwRGJ1d3hzVGpWWEp2bjhaU0d2YllBdkQ2Qm53RXVpTTRmbkQ0MVljM2pPeVNXYlgyeFlja3RRbWJQb0hqcFYrZktSTmV1UFR0Z3lQYXg4UE9MZUNTSDYwSlFuN3FrZUU1dGJNUHgybVdac29McXZiMytpcVhUQ2lsSEtuOGNLdW9ybVJVQndvRFlSRE1DeEZ1SWsxWElPVDhWMmpTeFpOQnFyU3lmb3JMb2RFVDIxV2F4V0RYU3BqR0FQaDBLNGZxQVMyb0JRS0ZPS2x4NkhsZHRDVHIvTmIvTWhiMUFmY0FuZjFOSHhkSHp5NUdNdmJBc3B2ZWhuRGZjdnVVdmMwVG42SWVVRk92YTdNLzkyOFIvM2RJN21YbHI5cTkzcmtGOTJBdDVQd0ZyOHBFa3V5bXJQZExrU09NL1g1UUtHYzNNTmJyZG5lOFN0c1NPYWdRTGZqbUtHWDNjd3dKYVh3T3oxZUIxUXdEaktBVHpFSjdpS1B6Rjh6WkY1cjA3WnNuM004dWJna2YzWnNqdzRvei8zY1B3ZjJkN2hXWE1QTEI5Q0Q4NTRkbWx0MVo3SnhVM3o2emMrd2ZFQ3o3MjVWWm5JOFZWM1A0VzR2QnZXcndEZmVNa0FNa3p1WlRlUTlUNWZlU0FEQkRtcllFY2tNeXVyeEdxM3AxblRtRkNYOUJCcXRuclVxdUdFZkplaWdOdkN5VlVYcXdKZTZuS3lkVHREYk1sYVZURFFNQ0pVdkRKMDhhNHBzNTliVkQxdSs2azFXeWZjdmF4MXgxMkRoR2xuSmo4OGErRHVnaHVtMXc2ZVBpclFkOVFNdWZyMjRYM29MMmZFVnQ0dzRVZGZiMytSOW45dlllR2o0WnUvLzhkMSsrVUZUeTl1V0R5K1gvR05Nd2FOWE5WYUVSeS9BR2t6RldUNVM2Q05uZlE3UkxUMGZ0a3VXM1U2VUZoRXN0bWs3UkdiUm9mc2tSUmZSSDA0RTlGdTRUbE82eSszMjBGU1FlM3lYL3BhcHMrZWZJTVVzemZjT2pNNkxpUGVuOThrRGdvLys4N1hTcWZ5OTFVcnFaSFN6MS9kSHRnS0R5UVR1ajVqZXRGUEtrZ0RtU2dISzlmcmF0dnRvdE91ZzB3eTF4Y1hqKzYxWGlaT01UUjRjR2hIWlBEZ1FuTnU0ZlpJYm9iNWhoMFJzNVowK3lYSUVWaDE2eFpBYnhpWEdaYk9TN0JPQjJxU2dvS3JmUktuaXYwS0ZjRmxLc0lkMTV4UDZGVTNyYWJscnNHenQ5NTh5OWJaVlhkTnJKNWExMnZvc3VmdXVQM1plK3YzRlRiTUdnSXVScUJ3MU16YTZobWppMEw1UTI3dTMvOFd1U0JmdnFXMDdKYWFQTG9wUEMvYTVCN3d6TFFiNzU5YVVUbjEvakhUbmhuZ2Jvck9DMDkrN083cTZyc2ZtMTAzZTFSaDMxR3phNnRtTkJZSFJzL2lJcUZiaHVRWERMbWxkRUN6REhVemN0OWs0TDV6VjdqUFI5YnJYSkpVSGxndnUrd2wyeVBBZVFVaXNtR1c5anE1U1dJb0hPaWhlVVBkQmlZcE5INU5naFVUS0xxTys4Nk5lZWhVKzNkbkwxbzdaZnZNU21IU21Vazc1bFRYTC90UmRQWVA1MWJ0RFl5YVVUM285Z1pBd3F3aDRkc2FBcnovRjhySmQrOHUvWDVkNC9hUE5oOGFzbWpudEpteCs0YmQ4c092RGVQV1RTa0wzclNnZnRUaWNVV0JFZE1RTm1hZmhYUzIzNmlTMHpVa05sRWptZXl4aVNhSG5uZStrR3NOV2prcjdCVFFhY0FhblFack1JTTVEZmVjRG9kVlBnQXlYK1hhWDIvTmcyck5WNEpabDJVdzY1Mzd1ZzA4eHp5WUpyWU9LNWttcDF1dDFHcWlKakd4SG90czNTZnBYK0RWZFdBdDI5Q05NcUYvWTBML3hyVFNvcm8yRnRXMXNRUnRiSlhvMlVCMW1uazN1RktLeXF6bmNoM2c3WHdjSERJa1dGeGJXd1JPejVVbHhwOVArRDhjK1pSV0MxdjUyV3huRjVLdEd2R2xpSWJqNkVzUmpoSlJnSjNDQVhpMElFSUQxeUFHNFpFZ0FTU0lPNlBqcW1NRSt0c25iTzBjenorUEIvZHBXL3czYmFBQnFFVHVFMllMbytET2RiSnBNYmh1Nk50b1lRRDIvTExSUkViUDBWQ05oZ3JnVFg3MEUzVG9SRTU5RGhjTXZCSU1oRWd3Qk40WFBBODJCK0FGbGJFc3pPN2N5YlhGNytVbmNVR2xjUnV0MU5Eb1Ewb093SUpmeWRoQjQyZ0IxMi9KUmVDTDZEUlVMOEdET0ozZVlLUkdzOFhLQ3laZW9DWllIRTl4UkhBYnpYUVVyT2pUQTlnd3dkSll3NGhyREdQTFl0WWJCTkZvd2wyT1NiYW5EemRwWkoyVjQ2Mzg1Z2hZT2JCL09xdkp5SE1XdlJtY2swVWlCVWhGM0hOWkFNUlJ4TTFLWWhPRHRoQ1Fxd1gzUkNRWXJBR3pUaVQzSzlJcm1kSUhnY0FyZHJZRGd0MVBnRzJEMWg0N1pqbDJURm9MaFhqc0dPNkpmSDdleC90cHlNRVg5UFpydEx4b1AveEkvTWtIWCtRSzlqeHgybWdVRE9ZUDZSWUZqZVdEM0xTYzJzSCsrUGRSSHg0QmF4MEVuRmhCRG5MSkgyU1Qza3cxUnRpL0F3SUVYR1V4MEVUbnR0bmNteU0yV3dZbEdac2p4RTZselJISzZ6Tk1HZ1JhZzh5b1FXWmNuZzJPL243b1k3VXBVY3RCR01yT0ZuR2F1UHcrSjNYaS9pT3grM2I2YkJtSXVBenN5c0N1akJWQTdvdDRENmkvd1h2Z3VZejdkK0xEL1NveWRlQXpPRXJaM3J6bHMwQTQyV01MWDYrZTBVTW1pTEtXa00zSDJGN3JUSWRLOFBNMnRnbjNKZXNqOUpIRDc3Zk4zN3hIdVhqaTB2UHRqeXZuLytQTTFtZVVYZUtPZzF1V0hpZ1FiSWUyZHB3Uk9hWC9taVcvanUrSWQyNWNxcUFkbTl6MXFiQVJ0S1NUYkpldDlRWTZndENSUExXNnFJblhJNU9ZZ0l0NE55emNZQ1JPN0tpRHR0UHA0QnliSTV5REdHR2UwV2pXbVRkSGRBSXhsaUJMMVFBdkdsMFNJbGRDckVuTFJRbmFJaUpKZEJpWm5ER0ljUThOWW5ERldWRmJnWkF0eE5nRkFTZXdyOUg0dmJDWElyNkV2Y2RtcUxSQzJQakVlZVZYeWliNk9LMSs0LzRkaC84QkxuM3VaNmNlcnhwUDI2bE1tK251UWZ0dlZnNHE1NVJMeW9sVzFBYkFMV0sxS2tFUHl3V0VoNTBJbFVTaVoweWhRNllRa0p3Q3JsUkFjZ3JMelIxZFh5TVp6U3BybUZXeVFuMVdkc01VczltbVIxRDFDS29lK1VpL2d0RSt3UU9LeWdNS1JtWklrdFNKdUF4cmRxdGloSllnbWIwSUtwQVZZUWF5YnVTK1VTWXFUN3p6VzVwSkI4WVBpanZpOWNvQjVVNlJ1L3dRTGFaT3JqZFFFU0RqRHdCa1JqSkhIcUFCZURTd1o5NGNLTkVZT0dvQXVPeWNDT1FDNkFRZElXYU5BUmRzd0FVYmNNR0dGVlNGRHVwTHVHQld3d2p0eWEyaEVHN2F1amtVR2tGWXRnOFVwRk05K0FOeEhYY3EvaGFuaVYvaUdzVWRqeWoraHhXRHVyNnRiSmQ5aDF5RWE3Rnk0Szl5bkU0THZpdXdEaThJc0xNSDR3cHIwT0M2TkxndXpRcHRSOWRsWEpkV3hUcldhQ1cwUVdOaUE5eTlOblZsMEFRME1zM05sZ1RlTjc4MXNhRGQzQ2xnZituaCtCcjhiRERCK2VnZlpKQTlzcDRZcUJXVWhzaDRmaER3dk51MU9lSjI2MGlTMDYzR1hDTm51TUxyTHBkVE1ocUpnRlFXa01TNFlMSUNST1J6WENqV2NoN1RFWjZySlFHRmdJbURkTFVrcUxBd3IvZGFrUWpad3d6WGhHblBmSTN2VzhTQm1hbHpwNVNMeWtsbERmMEJyVHY3eEo3UC82YThRWFArdm51WmNweCtQSFVwM1VpSDBkSDB1VkdIN3dJT3VxaGNVRTdVMFMyUEpPZ2pmTW40WjRrOFhBZXFYNmNSZGNBLzFDN2FEYnlHMXhPRWdXaXVBSG9mQlNPREhHTkhkcUZtbllBekJKd2g0QXhoaGFncVFsR1ZJREY0amVJTG9PeERTaklTMEFyb2hWSFdrUERsN25qbTd0M2NKN3U1NzhibkFzdHY0SmpYRGV1a1VSWlBrQTZTRlJUNG1vZGIwT0JwZG5tSVJuZnZobEZLMHJvKzVRTFFNcEU3WlJlR255bTE2b0c4R28yT0J6bm5IVVplUk4yT3NWTlJKQ2owQklXZTZCaHdCamZLaDhwelVGOUNuak1ZTEdZMW9KcWdWSUQ1OTBpbnBQQzJnSU9vdW9jMlc0Z0xuUHJKK1BMeW0vKzBtK082bEQrN2QvV21xL2dkS3JhZmh0Vko1REU1YTdtRkZsckNGZzZnNlVzSGdoZmhOb0VPbFREd1pVbmFiVFRnTWpQbEJvdEVSUkhGaG9kTktKWG13TzF3TUFNaElIYURpRlJJMkNxa2dvZ1NkRUdWSURCREtFSTZKajlKS05Cc3Q4QUdOb2kwWUdZYWpUU0xVdnI4Rkl3eEkwbW92SUtHcVBEMDJmaHZjN1hDN3QyQ3hjMjVmeDNmem0zS044ZEJwY1lucDN1NGUrS05LbzM0blFDZFNPNlg5VlJnMm9kaGU3L0VtT0dDeWhUTXdyTGF5T3BQOXh0WS9kRitQYXVQeVc1RDduQlIxRjdIV1ZUbExLaS9aREJSc2FldVVwVXIwNjAxQ1EwRlRNWHZqTHQzYzdLNDQ1S2lybElEakVVODVMRHNYSnBKRnpob2dhUGN3YzFOcCtrTTArWWs4cG0zVTRHdDlFd3E2czBhdTgxdTU0WHJtQ1lUT3pKUkxwQjdLTldvZWhRamh6VGJnZmgzd1lERDNFTWZJRHpTQ2h2QWdmRFlWSTZ6b2VNTHl3K1hBaXpvQnJlRUdHRGhCSW1RUEN6ZUJ4U3lEYWdBZDRreVNxVTdrVlkwM2NXb3BabjdRNHZnZGlqcFRZckxtUzdvbnY0ajdRaFpOWUZNK2grLzRWK2UrNE1wZlMvdkU0YVZUTHY1NTUyQWxFNzN2UERDZ2Z5WkJHWkU2Q0VPOG1QWnZNaEU1eHJwWW80dXA5U0lFZ051d0dpclRzWExSWENPMEllMFUxSFFHM2c5dFY2dkoyelVodml3MlJCVk5yd21Bd1pzVHFPb3c3azZuS3ZEdWJvVmVoVVAraVN2SnN4cGtxN2hVaFViN0FUYzV3UXlXQkN4bTEydklLR2d6QllTNVYvRmM3THNHdDN1OTdsZjlUTUxodDNDb2tDdytPSExYNHM3TGo4NkxMTjZHLzlsWXEvNHFmZ3MyQUxjVDYyU2M0Z2RQQUtIeGdSMlZMald1QzkzcWl6c1ZIY3VXRE1uMGVzc2NYSk9aNFlWcjdEaUZWYTh3cnFjUjBYSm8rWlg0OVVaVjR3WDg0R3U4UVRFaEhwbkpWWDFPNWFjb3J5cGJLWUxhUzB0cExPVWpjbzdIeXVmVU1jSDU2aWtYSFRUTGRBL2dUNm16RkdPS2s4cDA4VlM1YkR5RDhoSDZRRHFwRm0wWFBXQmhFS2dyb0hZeVNhNWNKaUdjbFpxRWt4a2M4Ums0ams3YndUMXlHdVJsN1c2Ym5XeFhFTDVSTFpGWWNoQjFrVklKQ25OUkJIYUJMTWp0SFFGcDBvbjFGOHpLbklDQzFsZjVmZjJBQmpQd2JTeDJCL2FhL1J5aWVyZVNqNVE2YlQ5azdqeWx5K094dmI4VklseE9mR1B4UjBmdmZHRzBzbWRpUjk0WWpQTll2U3IwZVFEL2RKSUwxSXVaem9rd1dZeStUSUVoMFIwT2lmelRiTTNSK3pBMHpYSHV4MFlESDJBM3BPT3N5Mlk2TzFkWUpNcXluMWVWN3BOMG9KUStmSmhTNnpWMkNRWDZQT0tjcHZVdXdBbzhOYWhuNzU0aEE2aGZRNGVQRnhVU3I4SEpQbHk1dHlQSDNoZ2Zmc0g1OWF0YTJ0em56Z0JoSmg0OGxldnZvcUVlS08vWC9ud05aOVkrc3d6UUl1THp6eTFZd2RRSTN2SG8wbHFIQU5xWkpIZTVFVjVZTDJWOHJLRmduTmtFbDA1T2wwT3JGeG55RGJDMm8wOE5iajBOcVJMUXBLUUxyMlcyNVp3ZENtbDNGV1dvb0Mxc2ppYmdPYUI2YW5Dbk91Y1ZJTXFiUWJWNXpPb1BwK0J2VEpFU3NFV3VNVlZpc1pBZmVVRk85WnJkaWRBTmRweUsyN2ZpbmsvQzNZbUE5TE9ITjVGYmNuZ29uRHMxUXUrNmlFTndmYmQ5UG5KVHl5bzdUZHV3WWhlWlNYQjdQamVNeld6eGhSdGU0QnVxYnl4MUJWL1hOd1JiSDJ3dFdINTFIcUhJQlZXM2hEa3g4VXZGdHh3aHp4dkZVQ3pwT3RUL285QTZUTHlHOW5aVUVaSEZ0TmgrWFJvSmgzbXBBUGM0TGoxUlU2RnVnK3pNR1IwQm1Ma1ptalljRlJmNU1nVDNQMHo0VTRlMkxwNDNMSWJrT3NXd0VFQURQZnZyOWtjNmUvd2VJcnlFR3Q1aU9nOFJIVGVjb2VERm1GZkVmWVZZVi9SY2owcVJDdEt2cDdxOVJWVWw3QkNUS1RWZDRScXBiNTFaZjRjeVhSTEo2RUZ1TEdwKzJMVjRMWlVsTEhYZkJoRzY1MThINWdNY2VJYnZpc1J1Q1Y1dDg2WTJlL1I3YUVKeTI1bytFNXJ4YzBiOTdlOE0rVytYMWJjZFhONVllTzhodEh0MHdlUGU2RGo5cnpvOUphQngzTktmUFo1c3dmZWZNT1FYZ1ZqSmk5cW5McDVjbkhvYUxOclFOT2dpc2JhNnZ5QzhiZmYyemp6ZTVNS2pjNWN3RXdoY0tXSjdaTld5RVllbExzR1BIWU4ybkRHSU9Cd1hKTFoyeW1SV01DMDE3NHBvay9DSVhvNFJBK0hpT0JXOE9nYzg4azNaanl2MStsbEpBR1k5bjI0RXc3WXV0MWVoaklxZmV3T0ZqTzFnRjVWRFhQaS9jeXZOU2xUZHl2VCtEK0ozQ1ZGNU5CamZSYTg5M2RoaldheVZPN1BHZXdHMkV6WWRaeFI0UFRvcnB0NGtiL2VGc0hHRk4rekc0MElnUXNHakZZdFR0TGlKQzFPMHE0UVlLOG02OUhqUUxkZTZGNWcwdkNneTlxdHIvRDlFamdYaVVwNE4vNWgvSnZkZEQ2OVl6YzNOTDZUcStmdjdIeGN1WUUreTk4REs3WURWajloUHZhcnNtR1prYzRYMEs3Q1V0N2FiNktqamVqNG1CTTFiQnpvYUtFRWVnV3ZHUXM0RFJ0cHVVRG5hNm0yRDBvM3VuWE02YnVpcEkxYWp1YzVJMUlCYnRLSklvMDFDN2taKzZBaVFNY1MvL1VMa3NUYURTRnFad0hKOUZNYzc4MVRIbmZsR0k5QTE3QVVRUVpMR3c0SHV2Mk9RSkpqOGRWZDB1RVFQb21mUHhTLytDSjl3R0VRZEJsMEczaGF0NE9WZmJCaWVGVzljRGY2WEptRWFGdlI1NkpEWk84eUQxMlNTUmVtMFlWbU9zOUVGK2pwTW81NnZNQWdtVmlrb2RqcWdVMGNHSHd3czhnWkdXMUM3QmlnWWRCaDRFbWZDRVFSZkIxTVJyTUFITzVrd2VxUTBRVGpYeDRWdXg0VnV4Njh3QUhvTkNGMlRZaGRreHRPZ2JWZkJhd0QvSzVLTEsyc2RHRVliNVNWbFd6UDVsSk52eFVma28zY1JVV3J3NlV4R0hsRG1nTk1xVXR2c0xxODZDTGhBNkYyc2U4NFlDVldCTXFxY2ZGR1FyS053V3p3QUFDL0NXOE9NQjFLL0NWOW1rUlNmZkdyVTBzaTBZVFB4M3kvYnA5UHJiV3R5cXhmS084NUJFR1Rwdnp1NThxa1E3Uy9ReFRGVERyNEtWb2k2UVRCUmZPUlBJSzc3c2FSd3k0RFYxNCtVTjlRTmxFWWRmbjU4T2dCTnd1TktyKzJNZ203VGZiTjAxQkJUNm5JMjgwZ1dYb09wWVpEcWVFMENWbFhJeDFZeStsTTNFWHpja0tzR3VaTWEwU3ZGU0FPSVU5OVprdEtQZnF6YVA1UFltZ2RJQUpodjhKT3JVcnYzVXJvWjNTSUpwczNaTkZHOEZFWHh6L25MUHpHK0dMVHFMeHliaDJzMFFkcmpMSzR3aTdaWW9JMXdxYVVldGtURWZIOXNWVkc2Z2xzRXgzRVQvaUI0a2lSTTRsWllwSEl1M2lSQ2dMZEhCSHNSS2ZWYVRFTW9XR2VKem8wS0VhYXBBZERUU2IxTEExVnZBbmgwMnFwSmhHMkVQRGxEbjRMRWt6dU9oSTJzdWFLalVTQ0JRS29NU2krcGNXd3NoRHQ3T0FIWFA0MVB5VE9DVVNjZTduZ2thRHc5aVBvRlV3QUc3ZGFjSU0zazB1ZWxaczBFb1V0ckNSb1dMRFY2SHdvWXBTWUZzdXlVeWVmSldadGk0anBWbGpvY0t2VmJEZHZpOWdscjdYRXlsbU51ZGVxd0RiS0pmWk5YNnRSbnM5bEYwSkVmZGFNMVRxRVVvZnFJS2lqT25STFB3dGRjZFpnaTlpU2pFc0VWQTJkVU9ESnVJVFB6OTZJRkpSSitmbVNuNzJnOWRxMFdrM3lneUYrOVU1aDFsdmJmMHliYU9qdFE5c2UvZ1dkc2ZNZmMrZlBpaXg5NHNtT3ArK251Y0VBRlZmc2JsVytzelZQR250SHc2M1ByVVpzN0FKTlAxNDhCN3ZsYk5ndkI0aUJTaHJlU1oxVzU3YUlOVjNyMFh1MlJmU1NRSzZONXE1MnE0Nm9HeDBkRTZ2L0pHZkNrTnVkcStIc09OMk8wKzA0M2Q3R0xKVU5UUmFIakV5WnA1N2JJOHgwbGVlcVlxRGJVZ0VDOHYzT3hGNDVWR3AzU21DbStlNHZwZng1R2pwRzJMbFRXUExaTHo2ODlON3JzMzl3MzdZZlBiNzJ3VDFidDRybjRxMXZLT2Yvb25RcHIzTWpIcnh2NzVuWG4zdjVsOERicmNBRlU0RUxuR1NOUExHWnAzcHJocFV6RWllNExTeit1aTNDcGJOdzFMYUlUaUplMEdmQWkwaENJd2RMbndPMkR2dU0xKzQyVjR2NFdabUlFMFYvanhBVTJqZWdjakRRNHlXWUdvUHFYNEplWGo3UWxwUU5JS3BMa3FCcUJkKzY4T25mSzEvUnZDL1gzakgzTzk4L2NmU0oreGNHYjZEWmY0clRVT251eHRNL1BmQldCS2tJMEFpU1NzVkg1VXFyQnFpWXhSaWE4NGdlNUdEcXREaU5RRk9qWkNVMjg3WGI2ellxSmpqM29zcTVGK1MrakhOejNRaWdHd0YwSTREdTFUcVVEcDBGbVJtcHJldEp4Sjc4M0UxRVZvRWZoa1JVbVpoTEFBclU1QlBrUzVCU2tIWUtjei8vajc5UTh1N2JyVURQblNzZWV2NEhHOVkvdCtjNGRaeFhhT2t1YnVubFB6MTg3L04vZUhudnllTUpxUGtQZ0laMmtrRmUrSWxWQzBCck1MTFJ6MmdaanUrR3dFeEdNaklFcTE0QUhrNjNwZ05IUy9lQmpVOUhvNDdrMDJySmFnZDdhd09ZY3FqV3pLR2FJUWRhTTNURUhBNVBCdE5ZRkJHVzhFTlhteEFOSnR4MW1ySlJIcTdaZ0FVK0s4VXczUFd2SEZnd0R2MTZYem9TMk5tTkRidXpkd0dpUXN0L0VPOG54SGI4ZVBQYVA3NTNrVnBQblBqRGJycDI4ZnluSGZSM3p4MmV1Mk1xZGNXL29QMlV6citVZmZmeFhmZWo1UzhERm5oU3c0RkdhejlFSkVEQVFIeWo0SVJlblVrMG0wM2JJbWFyblFQTlJRRmdaTTBnWEdRaUp0R2lSN0QwQ0pZZXdkSzNHZFNkS0tzVDI1WlBaQU9MejZVN2crbTBwVWVNTGxTS01Xdndab0pYdml1d3NXQnFEWkliZ0hFNkU5OW8rTXRDN01XaWkzdXlaUER6Rnk0ODg4SUxoemMwRkltVFBPODl2ckZ6SXo5LzQ2Nm5YclFqUlpVY1FRS0t1a2srZVUyV0RBTGxyUllnYXkvR3l6cDhwY2pjaFE0R3BCWGpWNXdXUkRYTDREZjdBY3gwbDlXWjdjamVGb0U5cWpNai9Ub250VTB2cWhFUUJJN3RNQUlJdDc2MzRNV3BYcHpxeGFuZTFSSlNXRUpHbDVEUnBXRHZLNHplUTNPN1FzbUE4bFZhQzhtY2VNZENibTNKbDN3c2J1bTFxZXd2MlpIOXk2NWwvL2labDc3NzQrL1RwY0tDdi83c3M4dnZ2eGtGSWZqQnNrZWUvOEc2OWg4M3hkOFl2ck9WYnBuekNyVjlRa1U2WU5kMzQyOCt2SFRQQjc5ODd1UXJ5QVc3Q09FdmdnNndrWWZrUHB4RTRVOFNxRlB2TkFsV0FWbmZRSzQzV0ZkaWZVbkp2eWpuTU1sM21LNk5JTFhwdVFUeUZCVjV5a0VXUUhKYy9iTGdXaVZlazR6Zit2dzJDWUZWWTU2QURmN2l6czhYZzV3TEM5K25FN2d4VkQ2ME9YNEVWUGJNbDVWYmdSczJBVmkzaSsreDk5OWpaRC9SVEp0SUxGYXpmaXB2TnZGVHUwcXV0VWx0Wm5WdFpuVnRack5OU2pBczdoUmhDM1NhQUhNZXYrYk52QVBXYzZtb3VycW9YMDJOZitkT1VhZ3FMaDQ4dUxpbytsSW4vbWpCRmN5YVFMZEtTMDEwa1pFdTRlaHlBMTFCcVNucEVWUDBqOW0zalhtNERlTU1JbldLVG9OVlF3eEdJOFZRQVhvM1JNWXZJRTJvV2pBNmJyb3VzTjhtQ29rQWJ0ZEJaajRzRExrSkM0bHZOMXZVWUhJTnVnZHFQSm05eHNNSW5ScE9CamVQdi9pSlVvVW1rZTc1blpKUHp5bHA0cm5PR3ZxdVlrL0FRMGNDUER3WktJTmg0TDZWTHhTVkh4Z2l3VGNWcmlDU2ZZbkozZ2lNQkhTZFM5eFJNeDdrTnBkOGNIQ0VpWTRRYUE2QStGTjAxWDJVendMTktoZmhxL1IwYWhKRVo3cEhNTHZCc0dhN0pZZlZRTzMvMmVQUHlWbjRmQXZzUVd2VGJEalJoaE50T05IV1pzZXRabi8wTWl6b1pYaXVEY08wR1F5SVRvTU1XeEY0a29uMytneHRKUWxiRkFoSUxBenNWcUVxQmY2NG9BTG9Eb1pDTlRYNDNaa3J4RXcwWE5FU1NJU0VDMVFlN3VabDluMVV1Z3NaV2pOKzU0eDdaM3h2NTJlek53THU3L3oxak1leTUzNU1tN2hSeno1eTdQNTRCOWRLaTMreU9kNGhrS2NQTDdqMUhXRHlKSGN4SzRaeWE3c2l0d1pyVW5LL0RVSGYvQXU1VGZ1L2x0dTBmeUczcXRoK3E5d21ZSFdpNEM1N0NrQ2MvNGZkKzdqaGROaWhCeENxWjE5Kzc2VHFqVFFDUkJqdlhTLzdNMlFqTjVyWXQwVkl1Z1pza1VhNmxrcXJld1I5TDdBdFFTTFkyOUgxUithR1lOUVhEWlhWMEIzMVhaMkkrcUl4NHpPK0plcUwzdGJWNzM4REl2aFhMTmJyVENNOXY3UG5tdjZrL0kxbVh2Z3pwY3BmUDNpODQvQmpUenozbkp2bW5xY2N6Vk0rdWZSMzVUMSsxKytPSHZ6TnIxNDY5aFo2ekVxaGdMeCtsY2ZzU1hyTWdsV2orc3ovbnNkc3YzYlQ5Mjk2ekZkWm9LVEgzRTJ4LzhSalB2N0hTKy85Y2s2M3h4emZKdjd1d0xkNHpHaWJDNWx0UnJpM3lXVUo5NUo2ZU5YQmhOMlI2bUNhYlpickRlLy90SVBwQ2wwSGN3RDFYdy92c3V4NjczTFdWLy94R1NXbmZqTVpEZXQ5VzUvZnRYclRjMG9odC9aVmNEQzdhSDh3cVNlM3JkanorMS91UGZHTGhHUnlSMkQvS3BISUlXSUNsZDBiUWRZNmRWWkNESnlGdlI0a2RzTzE3OVhidEIxZFg4a1dEQjloQ0Vnclh2MUtNSXc3dlpPbHBjR2FwSnZVTFZyTVJUb1NHRHZqQVNDTmYxTkV6dU1uK0k0L0YvOUdJRy9QWG1KQmJURWRmRjRyVUtHWVBDVm5hQXNvbjA1NXZZbnE4ZTBRNkkyQWhFdTBJMzdMc0dXb1pQNVNIMnVPa05iUGxaR1dzUzJTSmhIY3hsUGV5Rk8rSDc4dDBpL2Q1ZXFUczlwcUpYMVc0eHRDRm1Id2lpVWlKNG9sQktsQnN0VFBLMndzK0lxUjErNnc2L0ZFMkJVYUdHOWxYZy9ia3QrS0FWZkErMzhaYnAxKy8xT244bXR1NmovMGpucC83VjBQTkt5WmNjLzNpa2VXWldkWE5vYUd6aDVWV0RkblMrUGorYkZwbXdyRFJYNkhwNksrZWREd3V4c0tpbmVOZEJhVWVmdVU5ODFMeTZ5b24xQTlhczdJWG9paFFOZFpicFVZQkcvNFhua1F6N2cwTGMzTzJYRkhaekJvTFJvajdKcTNSYlJBUkROK00yUUc4aGwxMTc1V2FoUFVBTDZndmtzVjhOc0RZeUptbVhSL1M0UEJRTkw5UThQYnZhMERMT0JuTlRibStWYXdieVhZZm81Yk5mQlc1YXRZYkNmbEZHWFkyT3ArQmk4dDRpWnZ2RlNtL0hwai9HZDNOT2V4ZjFjQU5QNFlYQThiMExoOGhJYkNIMjltaExYeTFLU2hUdDRrbWxEbUpLdk9TcThUdGZ1czFJckI1RVFvclZQOVNyR1RDWnpWNnJqMjg1UTJyYUU3U01zeFZuVmNLM0JYUGlkSXlGcTNTU1Rxamk0UnAwWGRBbHU2ajNjS3QvOVcyZkxNeGNXUDduejZNRDNBUmVNSGxTTjdIK1RHQUd6QXhQenJHTmNoeTJUekV1WklMYUowb1VCWmFOYUlJU1dCaFpqWUM2Nk1aRUJvSVd6YjJPZFBSaTNQT1htck1Sa3VNaElwOFpHY1dUQ3BvVmIyWW9JSHlyQVlhMm1BZlVjZVp0SFZaSWl2WjJpVmYxMlovcFJ5N3dFcVpHc0ZRem9JRWVra0FvbTdtd2FQcnViUXU4SGZ6b3JCbWoza04zTDZZZzlkbEVZWG11Z3lBNTFQYWFXZVZwaW9CeFdia2UwWjJhZElCdldjUS84RXYyTktROHlhMkI2THZjZkRGbXhuam1FVU00MVp2V1F3MXBUNG9nMWNTSFFvUGQxWU1TVURiMi9KZmhZK1plaXdzcExUV0YwT0Q5RWFqRlpEendCb2Q4Q3pPOVpKQXQxQnp5dWhUdldyUVB4QWtLSEVrYXpGbUhMeTJiZE5nc0RiLzd4VGVlMzVkd3lDanJlZWUrZ2RnNmpqckc4aG9yZ1ArcGIxQ3NkOTBGYjg0YUpTbm5SMjVsZjBMdU1GTlNiTmI0R1dnM3drTzVZNTZEd0xYV0tpOHcxMEdVOFh3QjRqK2ZXZUJmRmhTcDRaOEl4UG5qRmNtVlVwTktrMWUxdnVRR09KVzNDS0JaRlV5NEk0eFUyOGJHT3Z6eVgyWlFjcitjUTdkbWpaTUM2dFFUZmNDUTFlWTNNSVJyUFZTRGl6a2VQQWp1RmJGQk4rVHdoWVJNbnUrVHI4MjJQR2V1NEtIaE9JcFB3V1pUZHQrdGtKUjZZZzlqMTVsTFlvKzM1MlBOMHBVR1N2UzRxR2pzb042dXVWQS9RYnpxQTgzYnVRN2tHY1daUWMvbDNBV1Jyc05nem1ORXJNVk1QUk5HU0VJdmJwUkVJOHZDd21qOXhxTlZrbHhnWVMrQWo0Q2M2MkNKK2xZUkppU2NvUDFSaDVVMXBTYU5LU1FwTnV4a0d6U1JVYTB4V2hZZEIyZnlvRjduQ2dKaW4yNnN1SjVMYzRGVmRDNC95N1N1R0tNM0tnck9qZTZpWmx6a0hZQVVrYTBVcjlBcms4U1huWi9EMzcxcGQ1cGZPY3RjWTlnRThIbjJJMnY0cDdTSHlXZVlxVnNvL1lUMFdJQlV6cHFZaEc0UFcxemxONjZ5bmVxcWN1M3AzQjY3c0dNc2RkT2cyT2UvYy9zUHpYLzdpU3JwcjM5SlB6NWovejlMd2hreVlNR1RKNUVyL3FtZm56bm5oeTd2eG42SUZKUStwdWJhMnRuVWpZRGc4RS9QR09zbTlPYjd6Vld2VjM0dEd4bjBsNTRlOVZMMkI5NnU1aFdaZG5kUjYwS29acEJIL3BqNnEvb3dLMTd1bTRRb2oxNjh1ekx2M2FxblNQSk5NYXNTOTZFWkIrQ2I1RS8wUW43eWZQSkNkb05wSkd6UjFrRWJhNW1XUWpIT25KTVhxRTlPWkRaQlBVYy9pY3JqTkNJOEYzQjFqZkNjY3lPQ3h3N0lUamJqaW13akVCanNrNEg2L0ZlNGhMeUtmaUVpb2w3eWtXa25UaElYSkUrSnBNRmgrRDJrU084SitTSStKeU9OOURqbkErT0g1UDBvU2QwUDhLT2FJTndsZ25PYUxSa2NuQ01yVStBZGZKWkluUW54U0s5NUZuaFl2RXJsMkNzazZJTUp2WWhVMzQ1dURiRTNoVEU0UURaQmUvajdRS0IrRUlrbFp1RlNsajdiVmtGNzJBdTM3QTBTWFczcVU1UTNaaHZ4Q0RjYmdPNTNHdnd2VzNrZW5jUVJLQXNVMzh1OFFpdmtyYy9QTWtrLzhRTGN6L213bFU0bXlTU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbjB2NXQ4MStSWDZTdVFGYTZLNVR1NTlkeVB1Uk84a1IvQWJ4STB3aWpoZVRGVHZFbjhxeWFpK2I3bXZPYTgxcU1keC9JSHVoVzZyL1ZUOUh2MWx3MnJETzhhUGpOV0duOW92R1JhYTZibWhlYlRsc0dXMzFyWFdkK1hRdElCMndiSUg5aUhYNVhmZERRNDlxWDFTOXZyVEhjZVNNOU9ud0w1UlBxWHJrMnVmN3FudTg5a3RHVDhNTE15Yzd0SDY1bmlVYklleWJiOGorYXhxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6Sy8xdVpzTjhzVGZ1SVRDY2krNTZUSXhJSmt2c0pFUzJHU2RoeGlIaHA5UUc5bTQ3MGR0Q3FaR05Bc2xHYWJBU1RqZUprb3lqWk1DVWJRckxCSnh0VXZzeGFYYXhVV05uSnlxOVkrVGRXWG1EbEY2dzh6OHF6clB3REs5OW41U2xXdnMzS2s2eDhnNVd2c2ZJRUsxOWw1WEZXdnNMS2wxbDVqSlZIV1psWTJWNVd2c0RLamF6Y3dNcDJWcTVuWlNVcksxalp4c3JWckx5UGxTdFl1WnlWVTFuWnlNcmhyTFJnR1h4Sk9BL292MUhBbjVTV2hiL0tVL1RtOEljZnBidXkzbmtYaW1YM3BudVczWnZ4Njk5QWUrRWlLTzZjQThYc3U2R1lkVmU2WjlaZDk4M05uTDhnelpsMXgwd29icDhCeFczVDB6eTNUVjl6VDJiR3ZQU2xkUm0rSlhBTUNwUEFRRGpDMjRibkJvOEluNUNneUJOTzVQYzd1bkkvZWtuNEJ6ejdJMVo2aFF2N3piYXczQ0djM1dkTUN4L3FPaVo4c2QrVEY2NFpZaGEraHZFSGhhK2dMRkhMTDlpYVA5MXZsTUlsUitsTmNMWVNTenArLzdaZXVUVS9vN1hRWTZWRHlKTndjRjBmSGZoYllRQnVUZVg5ZytzU2RhOCtXTmZzTHdvbWFsY1cxb1BsOUlKQStKTy84QUg1TDBYRllma3ZIdWdlbjVzYnh2L2dKLzExdno4c3YxZllOenl1aVFzMGZjd0Z2REdqT1h5SWNzQklIaTRRN3pRRUxyOGdCcjZFa1ovL2dndkk3N3N5d3IrSEUveGQ3WTlMK3JPYjJEN096Z25MdjNXNXduOTlpUXU4dEFOR2FkdSs3UWFvVmlXcWxZbnFQdGtLOWFOd2JJZEpPN2FKY0p1UGZ2cDVXbnA0eTJZZTI3THBhMGQ2K053MkliQVpZR2EveXozTm5SRytmUnA5YUJ1WG1MQXR2MCs0c29JRUt0cTZjb0hiRHk3bkFwMi9Od1FPMFdwYXRROFdDQ0sxTDdkWEdNUm4zM0s0SnkzZTM4WUgzZ0xaK1FtVlQ4SGljY0g2Vi9MeXcvTExzR0FFNDFpbUIrdWZIcFBzNFpOdjREcU8vZlFFb09XMVYxbGJUcjhBR0RtN2dndVVURFdaTkhWN1grQUNMNnhJWU9CdHE1M2Q0bWp2UHVFajlINnlIa1EvUU5mc2F6ZXdLN00yNXVTRTE3Y0xnZlkyUTJBRHJHUFZmVFN3ZklVUVdOR1dBSGZJVklCdWFoc05ySU5qTFJ4cjRGamRKZ1ErYS90bkd6ZWpqZlp1bzU0S3A3dmM2U3h6MmdjNHJTR25xZFNwNysvVWxEajVvSk1VTzRjVTBKRzBnVGhKSXgwRi9ER0hqZ1NPR1VnSEFhZFUwakN4MEhKYVFTekVTQ3ZKSURnYTRIZ2REZ0Y2eXFHbm5FeUVneWNTSFFqWGFmYnhYYmxEZk5SQWpYQzlqdXJoZWczVnd2V3pxQTd1Ym9SeUVCd05jTHdJeDEvaHVBeUhCa1lNY0NjRDJRQUhUelZ5SHR5b29MZWxUMjlyV2JrbFZHN3RHN0FVQmF4NWZrc3Z2elVuMStMTnRaS2YwZjd3MlA2Z0RQdkRBZ2d0a1ZmU09YMC82c3VSS2lyMWtudk42ZlZrTDhFcTJVeDZnOUdrMGVwTXZDQ2FDT1ZNQlpxc1hBM3Z6clh5TmZ5SFBQOEUrWkJ3VmxldUsramlyV201YWNFMDNrT3p6VzV0cHRrcHVjeDJJYzBjOU5DaXFyNVZmYW9LcW5wVjVWVjVxM0txUEZYdUttZVZ2Y3BhcGEvU1ZQRlZwS294Tko3RzdBMmtZWHh0ekFFb2JSaFhHd3NGR2pwNGIxT3NOTkFRMHpkT2JONUw2WGNqMEJ2ajFuVlFNajRtck92Z29MTFhUWmpZM0VFemNIaU41eEJna3NRYVd0YzhFQWtFc21QUmhuSE5zWlhaa1ZncE5qWmxSMGhEckhSc3pPT3Z2ZTVYenVleEFsTHl2RWM3c0xkUFFYMnNiLzJVV0ZGOTYxQTJPTCtEYXVwbmRGQkQvWXdwVVBxSGRsQmQ0cndWV3Y2aDZpMDY2RURzcmF5ZkFkMlZPSXVkbDdQemNuL2lYajFXUWVmTlh4RDRUMVAzYk5Lai9WOGxlTWE4K1Vub3NNVjZZKzVZRFdENlcyYnYxU1BXRzV0cUcySzZKamdhSjhZeS9YRHlLcHlVdzRuSlg3dVhjSFhqOTNKWWFLQ1lPTEY1aUpOV2t5aXRnbU1BSEtWd0JPRW9ocU1JRGhNY0FodzhIRlMrTWRvVlZhS2QwYStpZjR0ZWlINFJQUjg5Ry8xRDlQM29xZWpiMFpQUk42S3ZSVTlFWDQwZWo3NFNmVGw2TEhvMGVpQzZOL3BDZEdOMFE3UTl1ajdhRmwwZHZTKzZJcm84T2pYYUdCMGV0VVFELzNhS0JQNGI2ZjhBNmJwc1h3cGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqa3lJREFnYjJKcUNqdzhDaTlNWlc1bmRHZ3hJRE13TnpZNENpOUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVUtMMHhsYm1kMGFDQTFOVEExQ2o0K0NuTjBjbVZoYlFwNG5PMDlDM1JVMWJYNzNNLzhKL1BQVERLRTNNbVFEMXhra2d3SmlRUnpTVElCTW55U0VId3orY0FrQkVqNENEWW8vb0Q0VEpRTzJJb3hmaEF0ZFZtZldwZTlnVmNOdExUMGxWcjF5YXZhMnNwcSs2VGFnbFVTbzBWbFFiaDUrOTZaaEFEMnRYMXJ2YmZXVyt2dW5YcytlNTl6OWo3N2Q2L0NDa0FBUUEvZFFJTjE5YTFidWUxek85Y2laVCtBWWRiYUxlczJMYXAvZHgyTzM4Q25lZDNHMjllNlQrLy9BTUNWQjJDczZWalQydjRYc21rckFJY1BGSGNnd1ptaVQ4UDVDemlmMXJGcDYyMmRVM1J4bkw4Sk1QM1V4czJyV3pmOHRQTjJnQm9SNTdNMnRkNjJ4VU1NeHdDNlR1RjZic3ZYMW16WjhPa1VIWUI4SEhNZGV4WThBT3crU0ZOYUhFOEdCbVE2d05pWlJEdjJJTFlmQWtqVHh6NVgxb04wNVBKcW5EdW9oV05EZEQwNGNOMFEvRjJnU3o2TVBQaysvQW5lVXNnSGsrekg0V0Y0Q3Q2Qk8vL3FBU05rSXduQlB3eWtnVlNTQXVKWHh2TkpHZUVueHFXRWd3Y24xcmxKQ3RHQUJKL0JuK0VVL0FiN0N6ai9BNXlIZjRPUHZ1SmdjWktNTGxKRC9PUUNqTUlYMTZ4N0hSRklJYkhDTDJFWDdJSHQwQXMzNC9nek9EMzVET1djVktWTlZ5YmI0R1Y0QWU2QXU1UE1aNkU5T1hvQW5vRWY0Ym9VTWdOOVlhT21nWTJHc1UvQUJtZmhDTWJiKzhoL0VQN3ZvUjB4L05lWTJrNnBnTXhGaTA0QWN3SnNtZ055QkYwYUl6ZWd6Ui9DT3pIWWQ4TUhhTWxKSUsyVmxqSkJzSS9QeDRiSURXUUptWUxyVHNKL3dIRnM3NWMrazNaZDJuVHB3Tmc5WXplencrenZtRGZZRlBweEpnM3VnMWZRbS9lZ3JkK0hFUmdERlZSUVFRVVZWUGovQ3ZmQUQvRnQrZEJZNzlpTFVBL1ROVTU0RWFxaFdvcXdNZmdtZmwvMFFqTTBRRFd4RWpOMGsweDhxNGFoRS83MXFsUGVnWFpTQVRkQkY5UWx2dndRRHNQTDdGSUFZVVZ2ZTFOanRLRisyZElsaThNMWl4WXVxSzZzbUMrVTN6Q3ZiTzcxcFNWemlvdG1Cd3NMOGdPenJwdkp6NWllbDV1VFBjMmY1ZU15cDJaTThhYW5lZHlwTHFmRGJyTmFVc3dtbzBHdjAycFlocVlJekNRZTBWTVpDYTBYMHlwam9zbGY1YmR5b21ucHlKS0FDSGF2ejIvamdvSG9kY2xWSXN1TDRBaUx6dHJJQUFnbFVWSERYNzFrcVVobld6L3o0ZVlsWGk0a010bjQ0NjlwYlJmejZpTSt2L1hYM2dsK0ZQZUk2WlVSbjg4clV0bjRzd2haK0ZQVHlyV0wxbHFrKzd3SnlpSVJhaVB5TXpqMmZna1NvY1FYeGJZK0lrNGRuMGFqWDZYa1lmd3dPWGFWbWt0SjNEcGdTcXVzRXNFNUFLYjNSWERKeTBaSzhIT2tUTXpqVVJFcmpwVFRJQ0FTNTJjaWNZakV0UVJWdmxLRXZPMVV5VmZZSU5TKzNoOXE3MFNMdHNjdTIzUWtZVkVmRitmaTlSRmJFSWVLMG1IeDFicklnTkZRNmE5Y1kwQUNLQVFZTUJpUllwUUplTVNXQVdLNmdTZ0R5aFM2Zm9BQ25Sbk5aNWZWRGNuUGVsSFlIY09CdndydGhoekhaYzdnMkxFOWsxbUEyOFpIanNRb29ZU29xUlMxQ1NXNFRsRm9GV0UzTnpEeldIelBvQlhhWXJ5cDNkL2UyaHdSNlZaY01BQjBkcWlqUVp3U3JtMUVFb3JDSjliQnllNnVVaHJaZVZ5b2c0dmpYRjRidzlaZkpUdjlDbnA3eDVxWUhDWWs1cTlDbnI0eWNwL3ZtRmUwWXg4U2JieG94bVhtTy83b3BlTWhUeWNuVCtQeCt6anhBS283aWV1VFd3d0NENm9lRC9sUkdoNFdXbDhodXlRdzRUWWxHaGUxSzg0UmRyZHlZbmZiK2tUc3RlNFpqMzlmM0NxYXZ2Q2hkOUEvdUZQWm1EUmxlMnk5clBMNlZ2bWFvZlZjZlBjYTVhcDdsS3RodkhLaDlWWHlJMi9FNkljVnVMc3hFdXJ3aHk0THhJdmpnTTYrZXEvUEo2Yng4c1o0UENTcjJOcU8yaWRVUnNabC9lV2M4UElFOWFrVWhRYWxnd2JGQnloUmFLMktKa25KQlkzeU5wa1RxNHBHZlFtLzQxSlJtMzBmTzh2UHhlVVR0ZG1pazdmNmppUHYySFV6dy9XUlVKVlh1YjFJVlVibURYbThRemdPMTA2UWlRZlh4QU5EM29TTndzdjk0YnBFRkhTTU43R0dSQUpURTU3SHBjbjF5cWtuUE40VE9LNzJWOGZpOFdvL1Z4MlB4VnNIeDdyYi9KelZIeDh3bWVKYlFqRk95WHlDOUNPN3ZXTDFucWhvalhXUTY5SEpjcnhWMTRkRlIxMlQ3SjVxcnFNMVVTeksvYjRTcjg4V0hWOVQrOWZZeVR6RGlNZTRsL01zYmoyTHVwbXdJbm01YXJtOERHSlY4SXJXRWpsTlVaTVZFY3lEMVVyTUtnM214M0k4M0N0bkNoM05EblV1VHhvSW96RVpNSExkcTB0UzhSQ2ZUODZoM1lNQ3RPRkU3SzZMSk9ZY3RIa1BnaERnMFhjeG1YTnNuT05hSVhPNnh6a1QyMk4rOUpVbnZQeHZ4UFRrZUk3Yi9IYXVOS0RZWHltMzdlS3hCcnpqK1JKUlY1SjB0Nk15UW51cDVJankwdkxJd0dQNUtoUGR2TEpSdGdsV3lialZ6NzNwRjYyOHlGWkdqbm5Mb3B6Vmh1V040SnFGdkp3MVdFWGY5TDlHNU5vSlRxdEl5a1NTS3RNQmE2bFMwbWwzQ1RJbmdvY0x4V1BKNkpwOHJlUUxvTDNqcSsrR2E2eCt2SjQzc2Q1bTk4czNmRU1wYWNsS25WMHQ1NUxYbDFoUkV4VlQ1SG9zcHB4Vkd0VFhXeG5oc1BwZ3R0WXBBeTdFZGNqT0ZybFlsVklHb3Q3SjVNR3hVN0VxdWV5aHl2SVNiektzc1UyWTlzcFkrL3NqdkJzai9PNDkwUTZNYmxHWWdUZmdpbENza2kwTmthU1ZTcnpKTEpKbExaS3ZjaVYvd29yamE2NjFicmpoaXRta2MrVVhnZy9aSlJPNTN4QVJxL254b3hMekJieDM4blRoVmV4RjQyeEFTM0MyUmJKUjhmMVQ0cjJDaHY0VkVpU3NJOXU5ZDhqdkU0cFVEUGpKcnJvQmdleGEzaGpCTjF6RllTc0F0NnNoY3BBaVZHV3NJam93RGZtUnd4eCtEQ2xVU3FiS1JIbkN5Uk1JRXp6eElLVlQxbnNQQ3dEZENwZFJDTXA4OVNBQmhhWWJweEZZUFVnbGFOYUVvQnhGa0FBVWNwZ0VSeGhmelNCTmw2QjFLelFGQmtDK3YyQmdCWjJnRjB5VW1mSU9FSmwwRUNsSENJQ2V3Q0VUTVJQdkFPNnFWOGlEcEh0QUwzZ1RLN3B4aFpEUWNOZUt5NkpYTkVZT21RQzNLUzBLcXBBQnpkMk5CcS9GWEVJWlRlSlUyWW40ZVNWeTZhOTU0MWE1WEl0UlhpNXBmNUxyWUNlR3lVQTIyVlU3K1U3Tm9qTmMzK1FWU2ZRNnBEMER3UFN3dHdJTldrZ1hqRnBDTTBDenJKNkJ3QWw3YWVBRWR1VW5DdktETnA4dDIyZnpQVVAvNStoTDFFdVhhdGhiTDhRZllwYmlDYzFqWjhndkdCTVl3UTB6QlkvSkxqYVpIQm9RbXpRdVBXM1I2OU00Uzc2RnNnUmE4RGhiMEJhRUFBK2VjcjRnbjJUbEZNMHVEaGJpRjZxR25qUW05cVVkRzJycjFuVTJKSHZxcDZ1cUZ6YTNMRmpVZkdsYUxERnFBZlJlemRnWjVsbjJJTGlnUXhCb2c4TkFtV0FLVURUamREb3B4dVEwVWFDMzZpa2o2M0k1S01mZUtPVUFJekhTUnFOWlo5NGIxVEVZWmNaOEkyVTB1cTNiMmNBUTZ0Y1NERUE1YjRPZ0o3QnFaVXR5aEpyaXBLVUZWclcwWkd2OEhOaXM0Q3QwMjNMOFdScVhNelZZT0lkNTlvbEwwa3ZTdmVRNXN2enRCeDRZZlAzOFI2OGNmU0s0bVBTUVNoSWhMeFJKcjkwb25Yenp5MlpBZXowTndPNW45Nkc5clJBUXBvQytMNG9GVk5jWFJkTnY1OHpFYkxicmQzQ1FqMHNETFlwU1E2aFR3bVRvQms2V1R0dUNoZmpobitOL21veFNvOUlxNlR1SEQ3ejl5ZEN2MlgyWFF0S0F0SVhwRyswYVBYbmlZOWxLS0kvK0E4clR3L1ZDRnNYMlJTbEtwN1hyU0Y5VVJ6Tk1RaEFZS2MwT1RwdXZwYlFvcm5EQ0VpZ1Z4N0t2MFBjSnBQOGdhY2hiVWtBNlNzOWorcVFEMG9WTHY4VFRFM0l1NElpRkxrRlBHTHlQbmFJQjN4dUhiSm9sU205VitnOFBwU1I3YzdJM0tmMnBROFprYjBqMmVxVS9KcVRvcHkwRTBESTdPSkpQS0pLd0NqOE9VQzVieHBkUTdzTG84NlNTY3JEN0xtNU0zaDMvZzJjZmVLRlk0SEtjeFU0cTEwRHl0TVJtdDlOTU91d2dKTU5odG5aenRud2JaY056UytXckR3Vkw4VXk4TS9wOE9ySE5udVBYYUltUDVPVDZVMTJ5RUpMcURoYlBJVDZ0UnZxSlNaZm1sRVRwdlBSOFNxYmVMUDJlbkNUWmZxdkdPNVZra3hOMDQrNW5lNjRmTGFCL2x2dnRYeDBZUGNQdUczMXg3YnB0RWJwV2pnT01YdmJuR0wxeTNrd1gzR0RmR3dXSHhyUTNxbUgwMnprWGNiblNMTnZwd0ZVUndDYkNUMmxKTXY3a1NLQXA2UTNwTGhJbklSSWtkMHJicExlZmYvWFZwLzdsK0kvU3lGNVNRUnJJMDlKTjBzdlNpMUliOC8yeHQ5ODUvK212M3pzdld5Z1Q4NzlQaWNickJEZHRKNndHSTBSRG94ZFpha2MrVFdoYXI3TXBLZ1FMQStQSlVYNDVJREFFMWtrL2xEcVpyVXpmeFUxTUg5SEtweG93eHBmaXFVWW9FREp5aldRT1RVcUFHTFVVVFZOWlVBaFVEbDFNWTlpWmFTd0pBVXl0QU1aWmFjTGtlclQxdUkzWnBaSmRlbER5a0diQ2UxaU4xa09tcy9zdXJFVkRwdGZkVUZsTHY0K3k3T2pqODRxUEZ3a0Z4VjVTN0NTNStHTW1PVWFTWnlneFVFVjZrcXNqSlJUSkpYTUlOUjMxb0EzSnNNOHdLdkpSZkVMMk9LQU9OUHBibzZWUkYwZlMzNG5lb1QwdjlVcjdoaDBNbzdlZGszWkw5NUhXMTgwYURaTkdHTkw0c2RuQU1MWlhaQ1hwUnhkRzI4cEhPMURaMEx4MVM1cm9sMGZuRmExWlZrY2ZsYjFmT25hR1BzbWtZZTNLaEwxQ3RVN3IwVko2VFpxR01xYTdDZTBtRnRyb1hoQUZvOVZJbVZsamhvTzQ2QXcyNDVFb205cHJzWmdkNWtlakRxdkZtQXE5aVp3Z1BrdjZ2YnJBVUduQ1ZaZkxHQjhSSEptV2dLWGNzc3l5eXJMWnN0UHlUY3UzTFBvV2IxU09KOFdaNkY2c2J6eklSUzYvZ0t4c2dSYWZyOGl2OFdOTnRtWm56L1puYVl1S2k0T2NqUzNTSmdPT1BpbTl3Nng3dmYrN3BKV2t2dlR5ZHlyK3RKSzhKUDNteUw2d0VOM1M5OEp6OTVNWnM3S2YzVFNjTlZzS0h3OTVuTnVLUTNmS3QxNklGVHNEYjIzRG1HOFI1Z0JMZ0NJbWxtVnA0aVpQUnQwcE92ZVRDL04xOUNOUlhXcUs4OUZvaXJWY1F6UWFZcnVYcytmYkticzl6VTE2aklGRWhScXlZWk5NREd3Q3ZNME9wWEs1bGk5Q2ZLbSt3amt1dkFRVXpZWmdvZDBsWDBTalpUSXV0VnVKL3JudWIzeHdYaG9tZWUrZStsejY3Y0hGbTAza21mZHEvN2lZT0w0WUl6T2tMLzQ0NzNjN1Zpb2FTNW5NemFoeE91U2l4ak42TlJvZHJYczRTazh4WjF1eSs2T1cxRFNMTzlPVjJSOTFXVm0zeDB0RGo5RTRuYzI2eDQ1bFJLNGw3Z2xYbENlN0NiL284eldDcGxZVDB6RG9qZnlDYkV6cnJGeWJrcytLOWFraUt5cnVEaGI1aUZ6cXg1T2R1UmxmTlQvL3hlMVBmdnVBeUd6ODVmSFRCTjc2UVF0RHlxUlh1NW83Yi92YTZyYmJiNUUra0g0K2x4aWFuOXRiOXdKeGZvaVJXZmpBdGt0bjYxcS8vblIvZC84amVLL05tS2EvWmM5Z2hsb2dUMGcxdTFJc0dsamRwQUU5cmFkTlBadzUzMHlaTDJjOTJyajh5amUyUTY2RTJiVnIxOWJXclZrVGxvNlRNdWFwVmFFRmpZMExGalpmWE1uSVZhQVhhMHViNHUwQ3dVdjBMb1BGeEZnWU5Kb1ZlZ2h4bUhROW5ENWZUK21UcjV5aENVTUZsWG91KzBzcHVLNmdISDFNbS9TejUrdlhLNUp1ZnBjMFVLWERPMW92NFNmTlV6K1FHaFBTYUI5angvdmdXMVhyMGxrTTVmajlhTFltVTkxbTBQUmNmc01sUXVkRVM2RnlyWnpKa2dyZHRLOTA4YnF0aXFEd1R3dW5VQjlrUHZMUGtwdUJINzFwUWprVm1Ma05lS3RDdUUyWXFaMXB5MkpTQzNvSllRcVlSNk1GcWIzcDZSbXBHWTlHVTYzcDZWa3pleE1TdGJOSlZvOHRNSFI4UEd3blphZHhjL3JPZENwZFFLTXM1aWVscGN3enk4a3RrRm9TSTF1SUJwa1k0ZTdTL0lJNXR0UkUyWjlGNWM2aWkyYmZRS0ZQM0s0Y3ZFY0s1WEpPcGR4VGFaY3poZkpuVlN4OVBOVFFPak5VbnpPdnBkd1gzdjd0ZjZyYVUxWDI5WXJNT1RNODA2NWY0QzlmdXloMzJUM2ZiWDdPU3lBd2ExWmdhdDVVajhWZFZOMWNmdU5keTdKZHpuTit2OUhsYzAzSnkzQ2JVbWRYcjV6ZmRIZGR0dXpiNldObnFCRjJEamlnVFNpeDBKazBaZFE0NE9Hb3cySFRVcmIrS0pWcU1HaFRORWF0VnZOd1ZHdkJVaC9BVERacmpEcExEOGVRR0xPRm9SaXMvQmhnR0dJdGdmRTBrYjhRUFlIeVpDN3ppVzh2K2F2TFp2TVhCWXV5YlVHWDMrYkVieTVxcFBwKzZlQXp6NUM1cDAvdkxDd3laWk1tOHM2ZmY5OG92ZlpucWUxQWhxempMVmh0NmpFU0UvSG5vazJzcVI4THFGVm5zU2dCYUxnY0VNcHJIOHFERSsrM1JBVkVxVDVaV25FUnZ1bnFwWit4dHh5WDlwTzVMNnhZUytidS96NzVIclgrMHNHVDI5WlNOUURLM3psZ254eDhaZVBzZ2xXV3NzL0JxMVArTis3M1BpLzdudHkvdTdsNjZzVU5vOSt3U0liVnVGYXZySWZFUHQxVGx5UUF5N21MR3k2OFlaRW1PT1BReU02UXY5TkIvbk5kb0lvU1JQb3orREg4THdMRlEvUGZXc05JVU1PZWxyK3ljRHc5MFYrenhnMVBhNTlOOERRMnFMbUdMOHJmSUdpNkc4R2dNMXoraytYL1Z1NVNLSjBZbjRPRlRBTXNIQjhydWxmTDllMnFQYitSSzhSbG9BUFFTL2RDQlowQjA1RjNDNmlnZ2dvcXFLQ0NDaXFvb0lJS0txaWdnZ29xcUtDQ0NpcW9vSUlLS3FpZ2dnb3FxS0NDQ2lxb29JSUtLcWlnZ2dvcS9HUGcreC9qeW12d01Id0tuNUxzU2JpWkhDVkhLWmhBSHJHVit1RzFTTTlKNGdPSW8vUW9NMnNDMXlUeE1YWUtleFA3SFJWVlZGRkZGVlZVVVVVVlZWUlJSUlZWVkZGRkZWVlVVVVVWVlZSUlJSVlZWRkZGRlZWVVVVVVZWVlJSUlJWVlZGSEZ2eDlCK1oyWnpvY2hLUDllVjVCL1M2OFZBbkF2RHQ0MktMK3o4c2NRWUladzBUTG1MTFlDODdHd1FtOHVmZTlVcW52S3I5N0I1czY3VXIxMzNwWDIxdHM0dm5VYk5wdTJZTE54TXpZYmJrcjFicmhwNTlmU3Q5N2lkRTFadHg2YnRaM1lyT2x3ZXRkMDlONmNudGFWZWtkbG11OTJmQUx6VGN4cENMQlcxT0FVOHlXS1NyUWNNM0xJYkNzVkJwbVBEaHFkcFlmSGpqR2ZIUEptbFpiUE56UG5rUDlONWkvWTVpZmJUeFFWUHp4a3RKYVdIeVVWT0xPUStYQ0F6QmZNMVBrdktmN3pjeXgvN2t1R0h4dzdkdWhMdjc5VS9vM29HVjg2VWtzL1BFUHpaMDVUdkhEYTRTcWQvUk95L044cHZoNmZxcU5rTXpUZ1E1SE5aT1BCc2N3TlB5WTNBU0dieUFaVWxDY2J5WWFETkI4K2dsTkNkZ3BWK3huK1c0K3gvUDdIR1A3eHh5aCszMk1hL3JGK0E5LzZCTU0vMFVmeEQvVXgvSU43V1g1dkg4MzM5YnN5cmF1NTFkU0NKeW4rMFg1TDVpUDlOUDl3UDRYS25SSlMrclB6U20vc0o2LzFrNzk4b1ZYMC9jTHRMVlg2RkV2cFlkSkpPb1FaTlA5eG5PRS9pdFA4YnV5L0h0Znc4UjQ5Zi9kT3duZnZZUGlkK0d6Zm9lVjM5TkRLbVhQYlBHbWxiVDJFMzRYUGZmamMyOFB5dlQwYS9wNGVMZStkNC9JVXUxeEZMdnRzbHlYb01oVzY5QVV1VGI2TERyaGdsaXR6dm9rc2d3QStGS2toWVhCQkxWbU0xdDFDYW9RQUdmblVNdnhKeXRtaGxBM0R4RGc4ZHpnOC9JUGhpOE9zY2FScFpQZkl4UkhtTEQyV21aT2JrcGRyeWRGNCtNTmtMVmtuT0N3eitKU1p2Q1hMbnpMTmI1bWFtY0psV282UVZ0Skd0Z2lyVEJhcnphUTNHRTBhcmM1RU02d0pDR1hTMEo1TUMxMU9MNlBmbzVsdndYdEFlVW1HMmFOTk43dXNick9kY1pvRFhqS3piRVpaWGxsTzJiU3lyREt1YkdxWnQ4eFQ1aXF6bDFuSzlHV2FNcm9NeW1xRERVUzBoeUhjVUNFNjhDcmg1UlZpa0E4UDBseTlXTWlIUlgxdFUyU0FrRzlFa1NwU3V3WUpOSWpNcmtFS08zdGxZMU5ra0tUSjdGN3ZZZlE0aU9GWTcvMVJuczhRMitWL2NhVTdJeW9XeW9NSE1xSVFGZ3ZyUksrL2dyOGF1cFNtNnlycVFGNU9TSndSYWhWbmhtSlZ5b0t0NHRtUU9CTHFiQlZIL0ZYaWNLZ1RKekZ4MkovZzhwTU9JUHhYQVhSdHZTeHZrdkN1UkROT3dHbVhvazNYVm14RmoxaU9OcmxXNmE0QnZXeWYydnFLc0tpcng2ZTJTVXozNCtSVm5CVGp4T1N2d0hyeFg3Rk1NODhLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ281TXlBd0lHOWlhZ284UEFvdlRHVnVaM1JvTVNBek1Ea3hOZ292Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsQ2k5TVpXNW5kR2dnTnpBMU5BbytQZ3B6ZEhKbFlXMEtlSnp0ZlhsOFZGV1c4TGx2cTMxUEpaVlVTS3BTU1lBVVVKREtWbEFrajJ3c1lVbENnaWtpa29RQUlhd0s3VTVBUUlXQ3Roc2F0SWtPVGJmZGpqTitEaStvVEtDbkZSUjM2VUZiSGJ0MVdseEFVSU0wbzZLU2V2V2QrNnJDcG43eitmODdKM2M3ZHp2M2JQYytrNThBQVFBZHJBY1dyQXR1WHVOWjhPTENzVWg1Q0lBNXZtalY0dVVQMXMzNUFJQmRCcUF2WHJ6c3RrVjl1aHdyZ09uM0FQYWRYUXZiTzFudGg4VUFuaktjVTlLRmhCU3pialMyVjJFN3QydjVtbHNmK2NyYWdPMmRBQ05QTEZ1NW9QMmp1ei9aQWpCdERiYkhMbSsvZFpYck92MStnTlc0SGs2NmFlR3ExbnNQL0EzYlJ3RzRPUDg1cEFMd3ZlQWF5cmtnMk9FM29BQUhsQUlRUHgzZmNqa0hrRWZHdjFMR2czd29NWkk1RmgvZ2Z3c21aa3I4TXpZQ0poejNHZll1a21kaWJRQytCL0svRGRXMHljUWxtdnVUNU8yd1RTblhZZG9HajhCTjhLTkEwb2dXZmpwOEIyZmhYNUwxczNBYTNvQy9LL1VCckw4RzBVdmpqc0V6MlBkN09BaDltRDhITDJDTndtclkvYjl0UVhLSUdZc3Z5Tk1rL0wzT1B5QUNYSUJUOERCY2o2c3Q1Ti9sMzRWSFlSa2NnQVd3RC83MWlyRmZLUG1YbU82R1crQmV1UCtxbFhxUzViWmsrYnlTUDQzcFBjWUUwMkVOMnQ2bmw0Y0xQanpQWmxpcm5HRUpuTVQ5OXNBT1JaODJKaGRzTE1TL2dNZmhIdmpGcFpWL09yeUY2Vm40V3Y0UCtUeDBJbTZITzVtdjBUN1FzTG43NC8rRFBMWEF6MkVUTE5Zc2tjZWhsTjZEZjhBZ1BJbWFmaEUrZ3FmUUFyZkFDdmdLUGtQNVB3RzljRE4zREd6Q1htcE5zVGljZ3hPd0U5Yy9nU2Y3STd4T1ZwTnA4RHU0azU4cE5uVzJ6bzAwTmM2YU9XTjYzYlNwVXliWFZsVk9FaXZLSjRZbmpBK1ZsWllVRndVTHg0ME5qQms5eWw4d2NzVHcvTHhjWDQ3WGs1MDFMTk9ka2U1S1MzV21PT3cycThWc01ocjBPcTFHNERtV0lUQ0t1Q1JYVlV0TnQ1UmUxU1laZmRVK3EwY3l6anczSXlDQjNlMzEyVHpCUUdSMGNwVEUreVZ3MUVrcDlTMTlJSlpGSk1GLzdaQ1pFcHRuUGUvRnlUUGNuaHFKeThNZjM3VDJUbWxFWTR2WFozM2JmYWsvZ25Pa2pLb1dyOWN0TVhuNE14Vzc4R2RhdTZkVHN0WWozZXRPVUtaS1VOOUNVMy84d3pJa1FwazNnbmxqaTVRMTFJeEVmb2hKdE9iNDRXdlluRW1pMWo1amVsVzFCQ2w5WVB4UUFpY2RkcTRNSkFoTEkveklpQlZyeW1vUWtFaktlWWs0Sk9LY2dTeGZ2UVdkZHFMc0IyUlEwOW50cStsY2doTHRiTHNzMDNNSmlYbzlVVSswc2NVV3hLckNkSjMwVWtOTG4wRmY1YXRhcUVjQ0tBVG8weHVRWXFBRVhHSlZIekdXRTZYQ0dHdkc5ekdnTmFINDdKVGRHcHE2SlhGckcxWjgxU2czN0hGYzd1bVBIOTUyWlJmZ3RLR2FJMUZMTUNFSlZaSW13WVJuaVNTMlM3RFYwemZxY0hSYnZ4VTYydnpHVGw5bisvVXRFdHVPQS9xQXphdnBhcEl5NitybklnbTN3dFRXNWFIcXJsWXlxanhQVFpjbmltMDZ0ZzF6WHpWVitsWDB6cTZGYmRSTVNKdXZHdnQwVlMzM2VnKzdKVHVXTlpMTkw1bHdtT24yajkxc3RNYTF4RU9iMGVpOUhta3ZzbnRGcjVmbWFBUXVaRDFhNDhQZGNMR2E3a3Fxa3NBbHRTbldPTFZUVVk2NHRkMGpyZS9vVHRoZSs3WWgrL2RHclpMeGF5OXFCL1dETTVXSlNWRjJ0blZUbHJ2YjZURnJ1ajNSclF1Vm8yNVRqb2IyNnFucHJxYUpUa1RyaDJhY1BiZWxwc3RYYzNsRFBEaFcyTHhyNTNxOVVycWZUb3hHYXlpTDdaM0lmWUpsN0xqTVAvVUp0NThnUDFXUzJLUVUwS1RvQUhjVTI2c2pTVkp5d0Z3NmpmYTBWVWNpM29UZWNhaWt5YnVYSCtQelJPbUttandweFcvMUhzVyt3Nk5IMVRXMjFGUzdsZE5MVEZYTHhBR1hld0RyZGZXWHlNU0ZZNktCQVhkQ1JuV3pmWFVOQ1N2b0dzcmFtaElPekZ6U1BBNU5qbGRXUGVaeUg4TjZyYSsyTFJxdDlYbHFvMjNSOXY3NCtnNmZ4K3FMOWhtTjBWVTFiUjdGOHduU0QyMTFTN1hiSXBLMXJZdU1SeVZUZTZ0dHJKTWNEYTFVUGJXZXJ2WkVzS2p3ZWN2Y1hsdGthRXo5ajNVbi9Rd3RIdTJlK2xuVStqbnlac1NJNVBiVTB2RFNqMUhCTFZuTHFKc2lKODB0NkFjTEZKdFZNdlNQMmJpNG0zb0tHOG1yV1RJN0tTQzB4cVRCMExqWGtLVGlJbDR2OWFHdC9TSjBZRU5hMzlDU2FIdWd3NzBmeElBZmRkZEdldzRQOVRpYmFjLzZvWjVMMDl0OHFDdFgzZXoveGFhdnRPZW96V2YzaEFLSy9KVncyeWtkYnNJemZsTW1hY3VTNm5aVXRiQnVKbGxqM0N5dDZmMFl2c0pTbWwrWlNHV0NVVEpxOVhtTyt5U3JYK0tyV2c2N3d4R1AxWWJoamVDWUtYN3FOUmhGai90ZUpqUjJRb3BWSW1HSnBGSTZZQ3hWUWpxYlZvYWRsNHpIVXhOdFMxclhsY2RLWGdDZFhUOThOaHhqOWVIeDNJbnhOcnVQbnZBMUphUWxJM1ZlTGZVbHR6Y3hZbHBFTXRONExKay9WekxrMTEzVjRzSG9nOTdhb0ZROE5aNHVxbXpKMDFhdGhJR0krMHB5Zi94RVd6VU5lOGd5SGVKT21qWG1DZEZlYld2Ly94YStIaTM4cm0yUkxyUnVTU3pBRTNpS2NWdkZXNXBha2xJcWN5ZTlpTzQxbFI3bDZ2NUxVaHdhODMzcDFqVmQxYnBpWFhvaGVMRzc3Skx2TjdWSXRmNmhwUkx0eVg3M2xjMHAxM1JQSGVvR2xJVEhOcFVLRmUrZk12ZFZOTlN2bUNCaEhGbnJ2cDNlSnd4VTl2bkk1b1kra1d5ZVBiZmxJSDRuZURZM3RleG5DRlBWVmhucHk4Vytsb01lQUZHaE1wUktpYlRob1Eyb0k3amFma2FyakhjZkZBSFdLNzJjUWxEYUMvb0pLRFR0RUkzQWduNG1RYk1tTnNwWE5oS0J3UjR1MFNNT2plYVFwazNRMWlzMEJmcUFubDNVODZKVzFJbEd4c1M0K3dnbDdVZktJZnhFMGhGNHdraE14TjJIc3hvVmNqOVozNmNUM1lrUjYzR0VtT0J3Yy9QbHJadm50anhoQkp5bTVMaFJKUVVVOVhvVWRqMzZFZTdSU2w5VmtpZmpaWGZVU3FPMEZQSFRTSGFTaHI4bDFhUHBlNVhCbHlkd20vaWI4U3ROQXhtaVFVTllEbGllMTNFUU9HWVBCWTVoVVhGczNOaWd6V3ZMODlxOGo3Qi9IenpBSEloTjQyLytMcnFUbTRsQ21zbzh4eGJpSzlvTTh3L2l0OVZ4c2RCb204THlXcjNKREp4V3A5UE9qbGgwMlRyR3l1cU1MTU9BMFFqbVZrRXdhQTNhU2kybk43SEdLWWJBUUZyb3FOOW1KeUZYSUZsQXhkSDVOOHpEQnFTRlhOWTNqNDRiNnlkOG1vWmxoNWZtbGZKc2tNMWpDK1d6aCsvYnVmTVhSK1NCRUNHZUF4NUN1RkRnWkFmaDVNR09rNEc5aThrSStaM0YrRUVDaStPZmtpM3dEUmpBTHVwQWtGckJvZHZIQmdhZ3dqOXViRnBPZm5GUlNiQVFuOEhDaFhCVFUzaGljM1Bxck5LeSt2cXkwbGs0Ty81dTNNNHV3Qk95WUhxU1lNNEVrTHZBdUxHRStBaTdJRmIzRjJZLzMvdnRyY0ptbE9mTStHa3VsOThQZXZ5ZXpCTWQyaTAyMHhhUkZReTlFVUVEbHQ0SXBPT2U0S3J3NCtNall5QXdNRzRzbjhQWXJCRDBZTVppNWkyMFdabVJKeTRTNFFMNXEvelZYK1dMQkFaZFpBV1pTKzRrOThTODhrNzVMdDRXT3hJN3hmaVlFanhiSTZweE1YOElqSkF2MmdVU0ZSbFdNQXFhM1JGQk1Hb1lGMVJVQktsTUlaVFlFZG0yK1d5Q29Da3VaMHVaeGFjcnRzOGJ2MnpKMGhCLzZMdGFicy9vQ3RjTGpvSWljU1NWV2dkK241L0NzNHlHTWpFVHZGdk1vN2FJcVNTVm1FZGxaanA2STVrYWRoUVp0VHRDY0ErL0RZSjRLTHFOblc1MEZIZUtvYzY4M3VLaWNxNjBuQzB1R3NQNGNwUmRnNFZaakRQRnpHak1yTlBwWlU4TjNwa3Z6dWxZTkc3TTlKSXNYOFdjWU11QnBsRnoyN3JEN1h0V1RmVFBXbFV6ZnZYMUllYmVsZFczTEpsM1hjUEk0WFgxa2FKUWMyaFlZK1A3M25GZWEzREJ6cmJydHQ2NkRJTjdjN09mcDN6ZkVUL04vaDM1OXNJTllqQTlJMjJMeWFZem1YVDRpVGRzaXloQXVsNm4xL1ZHaU1lV29uZFpyQnVtNi9XZUZBL2JHL0drcDZDR1VqUkpEZEhEb0RuYThVUkQ4a01CMnROQ2dVREFPbkFVdjZoS2kxT0RoZmgxNWZVVkJ6MVk1R2lLRlR1eThzNVV0Q2JPbDNQSE51a1hqOGxiVjNhVE9sbis1Ym9kTHo1elNqN3g0SlB5M3dmZUt2N2J5ZzBydnp4MDZzM0ZmMjQ4Zkw5OHNvR3ovSEhia1FHMG9TTDB5ZFdLUnptZ1ZIUTdvbHFXOEZIUkluQmFoM1ozUkVlc1pvZERNQXNDVlM0NnFUMFVERklGSUlQQmpGamhDOVNxaUMzbzlLR2l2VlRORHB2QWFOZzliNzMxUWV5V2xvT1A3U2pVTFg5ckh0ODcySEZFZnA1TWVHN0JKLzg0djNLd2c1bDdWSDd2SnBUZmcvRlQ3S2U0ZnpxTUY3T3NVVENZblNnM081V1ozZTR5dWxCVXJuU2paWGZFS0Z3bHFwQmkxTEdqZ2FNRGwyV1Q3OHZST0x5bzU0U0hnUy9ud1o5djM3SC9xWDhaM3hka25vM0ZYVFZsSDM4cmYvVHRHOTczNSsrNjgvYk5SdWI4Qy9KdTd0TlgzNUxqS0l0RjhVKzRrYWhMSDVUQ0pESEhBZEhjTVZ2Y1cwUjk5c2plaUp0M1dMS3plWXNsdFRkaTBmREIzZ2lmZmhWSGl1NFV1MCtZSTBHejgrV01ZWXFMN0NXVW56Um5QdktIcGhpa3pTeEdvMWlwR2Mweml3a1dsalBjeU1rOWp5OWM5dFRHS2ZNZk9iR2g0ZTRSd1RWMVRmY3Rua0NFTWYvVWZjTURTOGQvT214Q0pCeHVMYzhlRnA0bmhsb21aSk5qeS9iZk5ibnBrUXNQdjBpS2ppOUxkYnlla1Z1OThValA1TWFKcS85d2UvbWlxU1A4dFhNRHdhVXRvWUpwQzFIV3RhaHJUdEYxbm1nVERJSUIvUmlNSnVQdWlDbWgzNlJpOFNob2QzZ0NRYzlvZkNVWlRLbTMyTXR4Yy9kdWFNdjRIMWZrMWwxTnNRajdOSi8vQi9sUDhpSDVxY2Q3U1JDeFpNOExHSzlhNDJlNHRLUU02NkJaSEZVVzFUcnQwVXFNdjVXUUVSM0Q1MFpGY1BMQmlSTlJnaE1uWnB1b2JMUFRUWk43STZacm5JRVdvYVNXQnhTV3JBUFBXMUhkanFKeXBqUWZBMms1ay9CdlFaUEZPcFBpTGsyS3N6Z3BYc2MxN2Riczhoc3E1cTJZdFBxaDYrZjkwMnB4Uld2NWZORlQyeU4xTDltM2J2S0h1Wlh6UXFYWFYrWFRzbVJlVmY0NFQ4blVnb0twcFo3c2ttbiswZE9LaDVGZmxxL3BtT2txZW5qQnJIczZTc3M2N3BtNTRPRWkxNHlPTlJVM1BMU3l2SHpsUXpkTjdLak94U2QzdUxSOVNzSHd5UjNNek5FelFoNXZhTWFvMFRQTFBON3hNK2hOT0FjdGpVcHBKRXlFS1dKZVFZR3pLS3IzUUZSMHVrTzlFV2VxZ1UvTmM3djV2THhBYnlSUHcxdC8wTmhzd1dSZ1A0clNvZXBLWVFTQmltQjRjUmFySE5sblpoTVdtQkRVOXl3dWJkN0Q3L2FNbkYwM01jVlpQblZXWHZQV2ptTE9QbUg2dk9LNUQ5NDBhZG9HYVhINzR4dG5uTStyYkMwWmU5MmsvTHpLZVdXRnpSVzVyUHUvNUZkZW1xKzNPblN2bTl4T1UrV0dJK3M4SVg5R3hacEhGcTE2YWwzTjFOOE1aa3k1dVduTThDbUx5cXU3SnVmbFZjeWhaMWJ1UmM2QzkySWFlRVNiM1NpMTJxM0orNUYxN3JNRUJrS2g1Qm12dmlmWkg3Z3pKMTU3ZDdKcGwyOVJCbXdBZkIxYU9sNkRNRWNjeTFyTUpzN0k2WFZhaGlNR2d4RWp0NDNuaUlYZEViRllCSjFaYitKNHcxTGpIVWJHS0xEWUFSaDFLLzU3M2xHTXY3WlFnRW81RUxBRnFWdllLQWtUdlcxWVJPSjFzUG5EZllLRzVldmtpM2ZGWHJ0VEhtVFNpYkgrUloyZTB4bWVKOHZsWDJIdzI4V0VNOHREM3RoUjlNSTVlR3Z2UnQwN29WTDBnWk1ZOEdaeU1JN3RFY1lCQm1Ka0RRYVQxclE5b3VYQVlFaXpydVdwN1FlQ3lXc3ZnTytVeTdWeFkvTUVud2Z3TnZjV1luang1UUFHdldCaEtiZjdkLytRWDVJM2szOG1WY2UzYk45M1JuNmZtTjk3ZFZlNGlVU0pTRnJJb3hNK255Ty8vZTJBL0VrYlNxc1BwZFdWbEZhZW1BSzY3Ukg4aHRKdWorQURiYTBKTDdRZVVKZ1l1S1FlZktMUk40U1h0UVVMb2RqcTdTTjcySFI1aW56ZjNxY3ZrclRZQmI0M1ZpTS9LUy9uamwvOGxxUU1rZ3Q0YnR5RmZSdDNNVUNkT0VLcnhWQUVZQkwwUFNJUmNFT0xrQzB3ZGxZUUNNUHdLQXVXNkhGLysxVkdUOTlvaXNVWFVvbFFqVkExMkREZ0p4TDc5dUM3TEI4N1F3WmtCMVBLOTc0aWQ3OHN0MEJ5NzMvSHZYVlFJZzZqNjFzWWxEdkRhRFYyTFVGWnM1UVpBeVAwYUFMSnhSTWJZNVZ1aXI2VjJBTHZPUGJmWTZmSldkbCtsaFc0NDNMRHk3RkhjVjBDemZIVHZCVzFtZzV6eGFBcmJYdkU1ZExDa0Y0dGhtd0RvNytzMmJRMHA5VmdnQjZuMDQwS3RocUZHWHpBcjBpNE1HREQ0bHBsQiswMEhsSnRlNi9SdGgyMWpmZXVsN2Vla0Fma1orV2J5VDR5L1l1SC8vRHhTZm5kd1hkMkxwUGZZTndkdDVOdHBKYk1JSS9WZnJWQ2Z1UGNCZmxraURTL2xKUUxkeGI1dDhJb01VMXZ0aEtlcHlKaHpSWUx3UzhmdTU1WEpJS1N4bXVmR21GRjB2WUpHajFLSTJnTGxwUVNMK0hPeXEvSXBreUJPM3VXTTZhU0Q4aXcyREhtbDNtbVdEbGF3ZzJwYnViR1dQMlFIbDdGL1hod2kyYkNVUTB6K0FXZzRYcUlZbUgwRGxKMGlnYkd2anA0Nml3eml1KzlHRWpNNUcvRW1RNFlLVHJOZHNKek9qMnJJeGJvc2RtY0JsN2JvOFA0UVZVM0VBcEM0RW8yVTUxVWJTUTFMWmhmYkF2eU44cURzZGtaTmtGN2lqaVord3N3S3B6a3NrYjR4end3MklSYlhSUmRvYzBzL2NXUm90RURxRkVhcjZoWDJORXJISUp4ZTBUZ2RHdWR6blRMV3ZZYXIrQVR5bEZ5a3NNbzJyRVhXeGtXVURwYjhVbGRTOGFRRytWNzVQOTgvc0s1Wi85ODloTVgyVUVxOGJIOWtMd0tyOUxmeWwzY3QvTGZ6bjBodjBkU3Z5TUUzN3FLYjNKTDhkejBqVDlhZEJsaFI4U0lueloyMXJBandyS2F0VlpyaXBIME1BbXpIYmhrdGY3RTA5dGJ5TkZuRUhWVCtuUWtld2JJRXhlSVZmNzQvRE85dS9mS2YyTzBzVy80M2xPdnZ5NS96Znc1OXVWOWQ4VWdHUTk0M0RNVGh0TVlsWmFsMVdidGlHaTErbUdHWVRzaUJuVE5ORjN1V2h2SlpHd2NqTXpTOWVoeGUrdnphWVZVSGhBSVhuV0RLNUZ5RE90VEhvaERyM0ZuRnB1R3IwYmxXczczOGJ6ODZjbnNDUk9uakc0YklPOHMvTmVleWFObi8yenE4UEZGd2V6WXIxOG9uVmVkditGMnNyNjRibXhxN0JEZk83WjllL3YwZFF0cUhWeHFjZG5rQUZzcmo4a1Jydzh0WG9OV2tvdlNtcXBFc2hJeGswVXJFZERYQlJaNEJyOERXYjRTelp2cFlWbWRsbm9aVlo1ZkNlNUQzeFNLbjlOM3JKZWJLbmVlbFJkeWVSakJ4bkxIWDhHMTk2STkwTi9nbU1BcjJoa2Q5V3NqeTdQUVl6QllORDNja0Mwb0ZreXNHQi9SaUJNRkQ3R2pzZmZPa2lra2ZKYXBqdjJlcVdHWER4NlY1NUlIMkRycUZXYVV0MU9KakptaTBhQmhXSll4ME4vaXNBSDByMEFoTmVkUWlINEM0blZEN1JoZGpuZkdZdkxYc2tBNDBtSFRjWnBVMHMzM2ZyY0lMZmh3VVUyb2tpdUhSRXhpZjhhNThLWXBFNGNwZDR0eTAreUtNS2xLS05vVjBhS1RHNndiOFk1SmhEd2w2bHh6ditSQWNSRmVLa3JFRVp3cCtOSXVaZGZjOGVqSDhta3llbkRiMHFXMy9lby8rbmF0WFJtWVRJWjlGQ1BCY2UvVXYvamIzL1JIRWg3RWplYy94K2d5RERuSVl0eThlMWVFVHlWT3M5UGczQlV4V0MxZ004RW1RckpkRzdVSitRV0R5V2VvSzFHZzlmaUtmY2dFZlVZakV5Z1FWbm5uSnpncDRjYWY1bGFkK2ROSEYxLy96eHU0MHlmdlc3RmgxeTl1dTJYbnY3MUFIQU15S1h5RXVmM2k2WHVXLy9yWi8vUFFVL3NTSExIZm9VVHNHS2ZiUlRNSWVBdmdsY09sa3djaTZmM3hkOFI4bTMzRGRFdDZkanBqWTlQVGRSWWRkMzlFbDJwSnZUOWlzV28wc05IaGNLZVRqY2FrdXhVR3ZuYy9YYTVTWTBxbDBuSmVrcUhkT1p4K0ErQnI0YnRZTGZmUE8zNi9aZHVwRCtVNGNiL3h4cWtUWk0yaXpxMVdjdVMrM280L3R1QWwrZ1VaTFo4L1Y3ZDI2NDZia2ZNTnFORGQvUHRvSXhZb1FtMEtDeUpJc2JCZ3RwaDBIYXhvTXJJZDhiSEdUWGhkV3hYajlwTU1sM1VBYmVlRjVBMTJ4U3ZLZ1pHYkdFTU5EYUVKalkxbHAwOXovelV0RkpvK1BWUXk0K0pJamxyT0F4Z0d6bkIyMU54SU1WWGoxRm9BOUN1WmRRekRtSlZyUWRpa1hBczBZQitiVjFnWXFLQ3VvMmlGWGdwTzVRc25qVGxUTUd0eEZGZlArZmwxRlY3VzV6MjBWMDdsNEMvTGJuUFFQZnp4TTh3VGZBQlNNTVo0VTFMc2pKMGFwbDZ2TVFzR2pVYllGZEZZNkFQQkpCaTBsazNvWHNIQ1lHSGdrcG5TcStlU3FTYmVRVFliZmhvWGx5b2ZvNHFaTWs5VXI1VGZmdXl4MDE5OVZUbGpndCtRUTdLWXFnTURsZkxyQjJSb25aa0R5dDhOOEh2NjNmY1d6WnR2Q1g4RjdzU3Z1WitKUFVML0ZnRGVXZGt3OCtMU3dmc3RzbjRCMEw4d0lNbmZ2V0twL1YxTUJyQjhlWEhwZHg5WTVFczlReERoQytoLzcwTG92VXhrMTlQWSt1UEEzZ1pUcjJ5VHM3Q1luUlYvbDdzUlpySmwwSWhsQjZZN3VJZWdDTXNIdVZ0Z0VUY05hckhlaXZVNWRQeVByYzNQcDY5aWpJL2Z3QnorVDlESDVXTGlvWS9mQ2MxWGp1TStnajcyRFBScEZrS2Y0TU5raEdidThRVGYzTVZrMlEyNS9GN1l5K2ZRMlBYVGdIME8xM3NEazNqMXZrd2F0ZkgvTnpCZlU4dkU4bVB3Z3dvcXFLQ0NDaXFvb0lJS0txaWdnZ29xcUtDQ0NpcW9vSUlLS3FpZ2dnb3FxS0NDQ2lxb29JSUtLcWlnZ2dvcXFLRENUd2Z2aitMcUpPNkFSK0VEWWliZDVCVkd6OVF6aDVuejdOMXNuQ3UrQ2pjaXZzYkYrWW44Q3Y3bEJBcEV5RUs4VHVnVjNoVGUxSXhEbksvWnB1bi9VZnhHTzBtN0o0bHZYWXM2RGVJMEZWVlVVVVVWVlZSUlJSVlZWRkZGRlZWVVVVVVZWVlJSUlJWVlZGRkZGVlZVVVVVVlZWUlJSUlZWVkZGRkZWVlVVY1dmaHZUL2tKbnlBRXdIVnZuYlNRYXNFSUNGQU94a2ZURWxpQTN2bjBoTnkzenpMY3p1dURQVmZjZWQ2YSsvZ2ZXYmI4RnMrU3JNbHEzRWJPbUtWUGZTRmV0dXlsanpzeFJuNXVKdXpCWXR3V3hoVjRwN1lkZmROMmFrcjA2OXZTcmRleHVtZzZTZXpOcHZ6ZTZjbEVvYVlBMG1CcXJKTEdqQzFJbnBLQ1lPS2tnbDhtWWhrMkF2SmlaKzRvbC9qUFNIRGhLUlROelArc1YrTXZGQXZqOTBxbEhyNzQ4ZkZ2MU5ibmZvMVpkNXYvalhrUVdoMlkyTXYvRkR4dStSREliUWVhdzg5enpqRjQ4WVRLRWpoM2xsdk92RGRIZm83Yi93L3MrZVp2eFA5ekwrM1poNmQ5SE9FNkx4YkVwcTZGZmJCZjhPVEpUZy90SnNEZTM1TmVOL0FOTmplOGoyWGJuWnY5Nmw5ZCsvUy9BblRtUExYalBKaG53VFBNVTBQTVUwUE5jMGxPa2FjZ01RTW9WTUJnZGtFN0ovTFlNVHlrazRjWVR3L3V6Y1VEOEo3Ri9MK2Z2Sm1QMmJXTXJjRTBkejhrS1VTZHRoa3lsMDdEVWMrbkptWnVpVmw1UmVNZjBjbnVQVEhzWS90c05vRktwMFQ1SytmWXgvSHhMbzNML2dGRnIrYWZnSVpRM1B0cXlzMEpZbzU0OXUwdnUzNGdaM3JTUCt0VDJjdndmckE1c1M1eHZmNFVvUGRXd2kvczJZN3NWMHp5Yk9memVXRzdFOHMrbmJUY3lTVFdUNEp1SXVkYnBLbk01aXA3M0lhUWs2WVl3emUxSUJtUXNCVEF4cEpuUEFDZlhrT3BUQ0t0S001eDVQSnFBR3kwZ0l6S1NFbElJWkRLUU1KbUNxdy9RcUpnNHBKVWdwZ1ZaTUxGakplSnduN0dmajJaTzhSRThNT0Y5TGREaGZJQnFjdjVSb2NYVUQ1aE13MVdINkk2YlBNRjNFSkdDUEhsZlN3MVpNTEJIRVRGd29mN2g1eEhCTGdkODh5bS9KOFpsemZaYXNiTE1uMndMUGtIRzQ0VGp3WUVMekoyUEZUV1JWd1lrQ0JzTEVtaXZtcnNyZG04dFpyRGFqVG04d0NocXRrZVY0SXhER21DOWtaZ3VzSzl2Q1ZyRHZzK3h2NEgxZ0xHblphWUUwMXBLU25SSklZY2ZwZ3lZM0dXWnlhVEpNVG11YXljNmxtQUp1TWlwY0VCNFJ6Zy9uaG5QQ25uQlcyQjEyaFoxaGU5Z1Mxb1dGTUJ1R2NIMndpVWoyT3FocnFwUWNCTXZabFZMUVg5ZlBlaHFsUW4rZHBLdHZiZWtqNUw0SVVpVm1jejhhbk1SdDdtZXdzRmZOYlczcEorbTArMjczUVpRalNIVnRkLzg4NHZjUGt6cnBQNXUyZmxoRUtxU1ZYdzZMUUoxVTJDQzVmWlgrYTJGMUlrY1lJbHl1OTQzSXI1RUthdHFsVVRWdDFVclhtbjRpMUN6cEovcWFKZTJZKzZyN2lUYlJic09hcnpxNVFEOFpUNmxsTlV1UVhFWkhLZTBTcFYzaVM2eVYzTnBQVnEvNW1mLzdzUHFhSms2QTc1T3ZHVUo3SlpkVWdZSzh0cmRQUnlWYTMxaFpKMmtiTWRXM1NoaytiTHlFalJKc0dIMlY4SDhCNmx4bUZncGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNuaHlaV1lLTUNBNU5Bb3dNREF3TURBd01EQXdJRFkxTlRNMUlHWWdDakF3TURBd01EQXdNVFVnTURBd01EQWdiaUFLTURBd01EQXdNREU0TUNBd01EQXdNQ0J1SUFvd01EQXdNREF3TWpJNElEQXdNREF3SUc0Z0NqQXdNREF3TURBek1EUWdNREF3TURBZ2JpQUtNREF3TURBd01Ea3lPQ0F3TURBd01DQnVJQW93TURBd01ERTRPVGN4SURBd01EQXdJRzRnQ2pBd01EQXdNVGt3TVRRZ01EQXdNREFnYmlBS01EQXdNREF4T1RJeU55QXdNREF3TUNCdUlBb3dNREF3TURFNU9UUTJJREF3TURBd0lHNGdDakF3TURBd01qQTJORElnTURBd01EQWdiaUFLTURBd01EQXlNRGM0TlNBd01EQXdNQ0J1SUFvd01EQXdNREl3T0RrNElEQXdNREF3SUc0Z0NqQXdNREF3TWpFeU56Z2dNREF3TURBZ2JpQUtNREF3TURBeU1UTTVNU0F3TURBd01DQnVJQW93TURBd01ESXhPRFF6SURBd01EQXdJRzRnQ2pBd01EQXdNakU1TlRZZ01EQXdNREFnYmlBS01EQXdNREF5TWpNek5pQXdNREF3TUNCdUlBb3dNREF3TURJeU5EUTVJREF3TURBd0lHNGdDakF3TURBd01qSTROemtnTURBd01EQWdiaUFLTURBd01EQXlNams1TWlBd01EQXdNQ0J1SUFvd01EQXdNREl6TXpjeUlEQXdNREF3SUc0Z0NqQXdNREF3TWpNME9EVWdNREF3TURBZ2JpQUtNREF3TURBeU16a3hOU0F3TURBd01DQnVJQW93TURBd01ESTBNREk0SURBd01EQXdJRzRnQ2pBd01EQXdNalEwTURnZ01EQXdNREFnYmlBS01EQXdNREF5TkRVeU1TQXdNREF3TUNCdUlBb3dNREF3TURJME9UY3pJREF3TURBd0lHNGdDakF3TURBd01qVXhPRFFnTURBd01EQWdiaUFLTURBd01EQXlOVFl3TXlBd01EQXdNQ0J1SUFvd01EQXdNREkxT1RJNUlEQXdNREF3SUc0Z0NqQXdNREF3TWpZd056RWdNREF3TURBZ2JpQUtNREF3TURBeU5qSTVNeUF3TURBd01DQnVJQW93TURBd01ESTJOemswSURBd01EQXdJRzRnQ2pBd01EQXdNamN5TXpZZ01EQXdNREFnYmlBS01EQXdNREF5TnpNNE9TQXdNREF3TUNCdUlBb3dNREF3TURJM05UQXlJREF3TURBd0lHNGdDakF3TURBd01qYzRPRE1nTURBd01EQWdiaUFLTURBd01EQXlOems1TmlBd01EQXdNQ0J1SUFvd01EQXdNREk0TkRJMklEQXdNREF3SUc0Z0NqQXdNREF3TWpnMU16a2dNREF3TURBZ2JpQUtNREF3TURBeU9Ea3lNQ0F3TURBd01DQnVJQW93TURBd01ESTVNRE16SURBd01EQXdJRzRnQ2pBd01EQXdNamswTmpNZ01EQXdNREFnYmlBS01EQXdNREF5T1RVM05pQXdNREF3TUNCdUlBb3dNREF3TURNd01UTTRJREF3TURBd0lHNGdDakF3TURBd016QXlOVEVnTURBd01EQWdiaUFLTURBd01EQXpNRGd4TXlBd01EQXdNQ0J1SUFvd01EQXdNRE13T1RJMklEQXdNREF3SUc0Z0NqQXdNREF3TXpFME9EZ2dNREF3TURBZ2JpQUtNREF3TURBek1UWXdNU0F3TURBd01DQnVJQW93TURBd01ETXlNVFl6SURBd01EQXdJRzRnQ2pBd01EQXdNekl5TnpZZ01EQXdNREFnYmlBS01EQXdNREF6TWpnek9DQXdNREF3TUNCdUlBb3dNREF3TURNeU9UVXhJREF3TURBd0lHNGdDakF3TURBd016TTFNVE1nTURBd01EQWdiaUFLTURBd01EQXpNell5TmlBd01EQXdNQ0J1SUFvd01EQXdNRE0wTURBd0lEQXdNREF3SUc0Z0NqQXdNREF3TXpReE1UTWdNREF3TURBZ2JpQUtNREF3TURBek9EWTRNQ0F3TURBd01DQnVJQW93TURBd01ETTVNVEV3SURBd01EQXdJRzRnQ2pBd01EQXdOVGsyTVRBZ01EQXdNREFnYmlBS01EQXdNREExT1RjeU15QXdNREF3TUNCdUlBb3dNREF3TURZd01qZzFJREF3TURBd0lHNGdDakF3TURBd05qQXpPVGdnTURBd01EQWdiaUFLTURBd01EQTJNRGsyTUNBd01EQXdNQ0J1SUFvd01EQXdNRFl4TURjeklEQXdNREF3SUc0Z0NqQXdNREF3TmpFMk16VWdNREF3TURBZ2JpQUtNREF3TURBMk1UYzBPQ0F3TURBd01DQnVJQW93TURBd01EWXlNekV3SURBd01EQXdJRzRnQ2pBd01EQXdOakkwTWpNZ01EQXdNREFnYmlBS01EQXdNREEyTWpjNU55QXdNREF3TUNCdUlBb3dNREF3TURZeU9URXdJREF3TURBd0lHNGdDakF3TURBd05qYzBOemNnTURBd01EQWdiaUFLTURBd01EQTJOemc0TXlBd01EQXdNQ0J1SUFvd01EQXdNRFk1T0RZeUlEQXdNREF3SUc0Z0NqQXdNREF3TmprNU56VWdNREF3TURBZ2JpQUtNREF3TURBM01EVXpOeUF3TURBd01DQnVJQW93TURBd01EY3dOalV3SURBd01EQXdJRzRnQ2pBd01EQXdOekV5TVRJZ01EQXdNREFnYmlBS01EQXdNREEzTVRNeU5TQXdNREF3TUNCdUlBb3dNREF3TURjeE9EZzNJREF3TURBd0lHNGdDakF3TURBd056SXdNREFnTURBd01EQWdiaUFLTURBd01EQTNNak0zTkNBd01EQXdNQ0J1SUFvd01EQXdNRGN5TkRnM0lEQXdNREF3SUc0Z0NqQXdNREF3Tnpjd05UUWdNREF3TURBZ2JpQUtNREF3TURBM056TTFNU0F3TURBd01DQnVJQW93TURBd01EZ3pNVGt6SURBd01EQXdJRzRnQ2pBd01EQXdPRE16TURZZ01EQXdNREFnYmlBS01EQXdNREE0TXpZNE1DQXdNREF3TUNCdUlBb3dNREF3TURnek56a3pJREF3TURBd0lHNGdDakF3TURBd09EZ3pOakFnTURBd01EQWdiaUFLTURBd01ERXdNak01TnlBd01EQXdNQ0J1SUFvd01EQXdNVEEzT1Rrd0lEQXdNREF3SUc0Z0NuUnlZV2xzWlhJS1BEd0tMMGxFV3p4RE9Ua3pNelV3UWtSR1FVSkRRelEyT0RKRk1VWkdSREJHTmpZMk5VUkdNVDQ4UXprNU16TTFNRUpFUmtGQ1EwTTBOamd5UlRGR1JrUXdSalkyTmpWRVJqRStYUW92U1c1bWJ5QXhJREFnVWdvdlVtOXZkQ0F5SURBZ1Vnb3ZVMmw2WlNBNU5BbytQZ3B6ZEdGeWRIaHlaV1lLTVRFMU1UTXlDaVVsUlU5R0NnPT18RW5jb2RlZCBEYXRhfHx8fHxGfHx8fHx8IA0K</inboundTemplate>
        <outboundTemplate encoding="base64">PGRpY29tPgogICAgPHRhZzAwMDIwMDAwIGxlbj0iNCIgdGFnPSIwMDAyMDAwMCIgdnI9IlVMIj4xNzY8L3RhZzAwMDIwMDAwPgogICAgPHRhZzAwMDIwMDAxIGxlbj0iMiIgdGFnPSIwMDAyMDAwMSIgdnI9Ik9CIj4wMFwwMTwvdGFnMDAwMjAwMDE+CiAgICA8dGFnMDAwMjAwMDIgbGVuPSIzMCIgdGFnPSIwMDAyMDAwMiIgdnI9IlVJIj4xLjIuODQwLjEwMDA4LjUuMS40LjEuMS4xMDQuMTwvdGFnMDAwMjAwMDI+CiAgICA8dGFnMDAwMjAwMDMgbGVuPSI0NCIgdGFnPSIwMDAyMDAwMyIgdnI9IlVJIj4yLjI1LjMyMzMxNzIyODg3NDcyNDc0NzIwNTQ1OTI5NTcyNDE5ODY0NDU0MzwvdGFnMDAwMjAwMDM+CiAgICA8dGFnMDAwMjAwMTAgbGVuPSIyMCIgdGFnPSIwMDAyMDAxMCIgdnI9IlVJIj4xLjIuODQwLjEwMDA4LjEuMi4xPC90YWcwMDAyMDAxMD4KICAgIDx0YWcwMDAyMDAxMiBsZW49IjE2IiB0YWc9IjAwMDIwMDEyIiB2cj0iVUkiPjEuMi40MC4wLjEzLjEuMTwvdGFnMDAwMjAwMTI+CiAgICA8dGFnMDAwMjAwMTMgbGVuPSIxMiIgdGFnPSIwMDAyMDAxMyIgdnI9IlNIIj5kY200Y2hlLTIuMDwvdGFnMDAwMjAwMTM+CiAgICA8dGFnMDAwODAwMDUgbGVuPSIxMCIgdGFnPSIwMDA4MDAwNSIgdnI9IkNTIj5JU09fSVIgMTAwPC90YWcwMDA4MDAwNT4KICAgIDx0YWcwMDA4MDAxMiBsZW49IjgiIHRhZz0iMDAwODAwMTIiIHZyPSJEQSI+MjAxNjA1MTk8L3RhZzAwMDgwMDEyPgogICAgPHRhZzAwMDgwMDEzIGxlbj0iMTAiIHRhZz0iMDAwODAwMTMiIHZyPSJUTSI+MTUzNzA0LjM0ODwvdGFnMDAwODAwMTM+CiAgICA8dGFnMDAwODAwMTYgbGVuPSIzMCIgdGFnPSIwMDA4MDAxNiIgdnI9IlVJIj4xLjIuODQwLjEwMDA4LjUuMS40LjEuMS4xMDQuMTwvdGFnMDAwODAwMTY+CiAgICA8dGFnMDAwODAwMTggbGVuPSI0NCIgdGFnPSIwMDA4MDAxOCIgdnI9IlVJIj4yLjI1LjMyMzMxNzIyODg3NDcyNDc0NzIwNTQ1OTI5NTcyNDE5ODY0NDU0MzwvdGFnMDAwODAwMTg+CiAgICA8dGFnMDAwODAwMjAgbGVuPSIwIiB0YWc9IjAwMDgwMDIwIiB2cj0iREEiLz4KICAgIDx0YWcwMDA4MDAzMCBsZW49IjAiIHRhZz0iMDAwODAwMzAiIHZyPSJUTSIvPgogICAgPHRhZzAwMDgwMDUwIGxlbj0iMCIgdGFnPSIwMDA4MDA1MCIgdnI9IlNIIi8+CiAgICA8dGFnMDAwODAwNjAgbGVuPSIyIiB0YWc9IjAwMDgwMDYwIiB2cj0iQ1MiPk9UPC90YWcwMDA4MDA2MD4KICAgIDx0YWcwMDA4MDA2NCBsZW49IjIiIHRhZz0iMDAwODAwNjQiIHZyPSJDUyI+U0Q8L3RhZzAwMDgwMDY0PgogICAgPHRhZzAwMDgwMDcwIGxlbj0iMCIgdGFnPSIwMDA4MDA3MCIgdnI9IkxPIi8+CiAgICA8dGFnMDAwODAwOTAgbGVuPSIwIiB0YWc9IjAwMDgwMDkwIiB2cj0iUE4iLz4KICAgIDx0YWcwMDEwMDAxMCBsZW49IjAiIHRhZz0iMDAxMDAwMTAiIHZyPSJQTiIvPgogICAgPHRhZzAwMTAwMDIwIGxlbj0iMCIgdGFnPSIwMDEwMDAyMCIgdnI9IkxPIi8+CiAgICA8dGFnMDAxMDAwMzAgbGVuPSIwIiB0YWc9IjAwMTAwMDMwIiB2cj0iREEiLz4KICAgIDx0YWcwMDEwMDA0MCBsZW49IjAiIHRhZz0iMDAxMDAwNDAiIHZyPSJDUyIvPgogICAgPHRhZzAwMjAwMDBEIGxlbj0iNDQiIHRhZz0iMDAyMDAwMEQiIHZyPSJVSSI+Mi4yNS4xNDc4MjA3NDE4NjU5Nzk5NzA3NzA1MzAzMTM1MjAzODcxNTcwMDU8L3RhZzAwMjAwMDBEPgogICAgPHRhZzAwMjAwMDBFIGxlbj0iNDQiIHRhZz0iMDAyMDAwMEUiIHZyPSJVSSI+Mi4yNS41NjAyMTg0NTI2ODA5OTI3NTgzNDMxNjUzNzgyNTMyNjUzMzMzNjwvdGFnMDAyMDAwMEU+CiAgICA8dGFnMDAyMDAwMTAgbGVuPSIwIiB0YWc9IjAwMjAwMDEwIiB2cj0iU0giLz4KICAgIDx0YWcwMDIwMDAxMSBsZW49IjIiIHRhZz0iMDAyMDAwMTEiIHZyPSJJUyI+MTwvdGFnMDAyMDAwMTE+CiAgICA8dGFnMDAyMDAwMTMgbGVuPSIyIiB0YWc9IjAwMjAwMDEzIiB2cj0iSVMiPjE8L3RhZzAwMjAwMDEzPgogICAgPHRhZzAwMjgwMzAxIGxlbj0iNCIgdGFnPSIwMDI4MDMwMSIgdnI9IkNTIj5ZRVM8L3RhZzAwMjgwMzAxPgogICAgPHRhZzAwNDBBMDQzIGxlbj0iMCIgdGFnPSIwMDQwQTA0MyIgdnI9IlNRIi8+CiAgICA8dGFnMDA0MjAwMTAgbGVuPSIwIiB0YWc9IjAwNDIwMDEwIiB2cj0iU1QiLz4KICAgIDx0YWcwMDQyMDAxMSBsZW49IjEwIiB0YWc9IjAwNDIwMDExIiB2cj0iT0IiPjwvdGFnMDA0MjAwMTE+CiAgICA8dGFnMDA0MjAwMTIgbGVuPSIxNiIgdGFnPSIwMDQyMDAxMiIgdnI9IkxPIj5hcHBsaWNhdGlvbi9wZGY8L3RhZzAwNDIwMDEyPgo8L2RpY29tPg==</outboundTemplate>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>DICOM</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="4.0.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="4.0.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>false</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="4.0.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="4.0.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="4.0.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="4.0.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.dicom.DICOMDataTypeProperties" version="4.0.0"/>
      </transformer>
      <responseTransformer version="4.0.0">
        <elements/>
        <inboundDataType>DICOM</inboundDataType>
        <outboundDataType>DICOM</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.dicom.DICOMDataTypeProperties" version="4.0.0"/>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.dicom.DICOMDataTypeProperties" version="4.0.0"/>
      </responseTransformer>
      <filter version="4.0.0">
        <elements/>
      </filter>
      <transportName>DICOM Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
    <connector version="4.0.0">
      <metaDataId>2</metaDataId>
      <name>File Writer (local disk) - DISABLED</name>
      <properties class="com.mirth.connect.connectors.file.FileDispatcherProperties" version="4.0.0">
        <pluginProperties/>
        <destinationConnectorProperties version="4.0.0">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <scheme>FILE</scheme>
        <host>C:/HL7/Misty/out</host>
        <outputPattern>${originalFilename}_${date.get(&apos;yyyyMdHms&apos;)}.dcm</outputPattern>
        <anonymous>true</anonymous>
        <username>anonymous</username>
        <password>anonymous</password>
        <timeout>10000</timeout>
        <keepConnectionOpen>true</keepConnectionOpen>
        <maxIdleTime>0</maxIdleTime>
        <secure>true</secure>
        <passive>true</passive>
        <validateConnection>true</validateConnection>
        <outputAppend>true</outputAppend>
        <errorOnExists>false</errorOnExists>
        <temporary>false</temporary>
        <binary>false</binary>
        <charsetEncoding>DEFAULT_ENCODING</charsetEncoding>
        <template>${dicom_msg}</template>
      </properties>
      <transformer version="4.0.0">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
            <name>Modification HL7 ORU to DICOM - MSH Segment</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <script>/*
	fileName:		modification_hl7_oru_dicom_msg_segment.js
	Name:		Modification HL7 ORU to DICOM - MSH Segment
	authored:		Jeffrey Ritz
	created:		2023-08-17 
	description:	Evaluate source message (msg) transform to desired destination message (tmp) schema changes
	History:
*/

var scriptName= &apos;Modification HL7 ORU to DICOM - MSH Segment&apos;;
var debug= 0;
// tmp= msg;

if(debug&gt;0)  {
	logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; msg typeof: &apos;+typeof(msg)+&apos; msg: &apos;+msg);
	logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; tmp typeof: &apos;+typeof(tmp)+&apos; tmp: &apos;+tmp);
}

// Get HL7 ORU fields
// PID Segment
var patientId= msg[&apos;PID&apos;][&apos;PID.3&apos;][&apos;PID.3.1&apos;].toString();
var patientLastName= msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.1&apos;].toString();
var patientFirstName= msg[&apos;PID&apos;][&apos;PID.5&apos;][&apos;PID.5.2&apos;].toString();
var patientName= patientFirstName+&apos; &apos;+patientLastName
var patientDateOfBirth= msg[&apos;PID&apos;][&apos;PID.7&apos;][&apos;PID.7.1&apos;].toString();
var patientGender= msg[&apos;PID&apos;][&apos;PID.8&apos;][&apos;PID.8.1&apos;].toString();
// PV1 Segment
var patientUnit= msg[&apos;PV1&apos;][&apos;PV1.3&apos;][&apos;PV1.3.1&apos;].toString();
// ORC Segment 
var fillerOrderNumber= msg[&apos;ORC&apos;][0][&apos;ORC.3&apos;][&apos;ORC.3.2&apos;].toString();
// OBR Segment
var observationDate= msg[&apos;OBR&apos;][0][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString().substring(0,8);
var observationTime= msg[&apos;OBR&apos;][0][&apos;OBR.7&apos;][&apos;OBR.7.1&apos;].toString().substring(8,14);
// OBX Segment
var procedureCode= new String();
var procedureCodeDescription= new String();
var procedureCodeValue= new String();
for each(obx in msg[&apos;OBX&apos;]) {
	if(obx[&apos;OBX.5&apos;][&apos;OBX.5.3&apos;].toString().indexOf(&apos;PDF&apos;)&gt;-1) {
		if(procedureCode.indexOf(obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString())&lt;0) {
			procedureCode= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			procedureCodeDescription= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			procedureCodeValue=   obx[&apos;OBX.3&apos;][&apos;OBX.3.3&apos;].toString();
		} // end if 
	} // end if 
} // end for each


// miscellaneous setup
var random = new java.util.Random();
var now = new java.util.Date();

//  UID prefixes
var UID_PREFIX = &quot;9.8.7.6.5.&quot;; // get your own unique UID root to use here
var STUDY_SUB = &quot;1.&quot;;
var SERIES_SUB = &quot;2.&quot;;
var INSTANCE_SUB = &quot;3.&quot;;
var prefixUID= UID_PREFIX + INSTANCE_SUB + DateUtil.formatDate(&quot;yyyyMMddHHmmssSSS&quot;, new java.util.Date())
// create SOP instance UID for the new object and insert it into the object
var instanceUID = prefixUID + &quot;.&quot; + random.nextInt(100000);
// Copia^2.16.840.1.113883.3.1833.3^ISO|Copia DB^2.16.840.1.113883.3.1833.3.1.1167.2095802080^ISO|State Reporting^^ISO|State Reporting^^ISO
// MSH Segment

// (0010, 0020) - Patient Id
tmp[&apos;tag00100020&apos;]= patientId;
tmp[&apos;tag00100020&apos;][&apos;@len&apos;]= patientId.toString().length;
tmp[&apos;tag00100020&apos;][&apos;@tag&apos;]= &apos;00100020&apos;;
tmp[&apos;tag00100020&apos;][&apos;@vr&apos;]= &apos;LO&apos;;

// (0010,0021) - Issuer of Patient ID 

// (0010, 0010) - Patient Name
tmp[&apos;tag00100010&apos;]= patientName;
tmp[&apos;tag00100010&apos;][&apos;@len&apos;]= patientName.toString().length;
tmp[&apos;tag00100010&apos;][&apos;@tag&apos;]= &apos;00100010&apos;;
tmp[&apos;tag00100010&apos;][&apos;@vr&apos;]= &apos;PN&apos;;

// (0038,0300) Current Patient Location - PV1.3
if(patientUnit.toString().length&gt;0) {
	tmp[&apos;tag00380300&apos;]= patientUnit;
	tmp[&apos;tag00380300&apos;][&apos;@len&apos;]= patientUnit.toString().length;
	tmp[&apos;tag00380300&apos;][&apos;@tag&apos;]= &apos;00380300&apos;;
	tmp[&apos;tag00380300&apos;][&apos;@vr&apos;]= &apos;LO&apos;;
}

// (0008, 0023) Content Date - Observation Date/Time
tmp[&apos;tag00080023&apos;]= observationDate;
tmp[&apos;tag00080023&apos;][&apos;@len&apos;]= observationDate.toString().length;
tmp[&apos;tag00080023&apos;][&apos;@tag&apos;]= &apos;00080023&apos;;
tmp[&apos;tag00080023&apos;][&apos;@vr&apos;]= &apos;DA&apos;;

// (0008, 0033) Content Time - Observation Date/Time
tmp[&apos;tag00080033&apos;]= observationTime;
tmp[&apos;tag00080033&apos;][&apos;@len&apos;]= observationTime.toString().length;
tmp[&apos;tag00080033&apos;][&apos;@tag&apos;]= &apos;00080033&apos;;
tmp[&apos;tag00080033&apos;][&apos;@vr&apos;]= &apos;DA&apos;;

// (0008, 0050) - Accession Number
tmp[&apos;tag00080050&apos;]= fillerOrderNumber;
tmp[&apos;tag00080050&apos;][&apos;@len&apos;]= fillerOrderNumber.toString().length;
tmp[&apos;tag00080050&apos;][&apos;@tag&apos;]= &apos;00080050&apos;;
tmp[&apos;tag00080050&apos;][&apos;@vr&apos;]= &apos;SH&apos;;

// (0002,0003) = Media Storage SOP Instance UID
tmp[&apos;tag00020003&apos;]= instanceUID;
tmp[&apos;tag00020003&apos;][&apos;@len&apos;]= instanceUID.toString().length;
tmp[&apos;tag00020003&apos;][&apos;@tag&apos;]= &apos;00020003&apos;;
tmp[&apos;tag00020003&apos;][&apos;@vr&apos;]= &apos;UI&apos;;

// (0008,1032)(0008,0100) - Procedure Code Sequence - Code
if(procedureCode.toString().length&gt;0) {
	tmp[&apos;tag00081032&apos;][&apos;@tag&apos;]= &apos;00081032&apos;;
	tmp[&apos;tag00081032&apos;][&apos;@vr&apos;]= &apos;SQ&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;]= procedureCode;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;][&apos;@len&apos;]= procedureCode.toString().length;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;][&apos;@tag&apos;]= &apos;00080100&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080100&apos;][&apos;@vr&apos;]= &apos;SH&apos;;
}
// (0008,1032)(0008,0102) - Procedure Code Sequence - Description
if(procedureCodeDescription.toString().length&gt;0) {
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;]= procedureCodeDescription;
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;][&apos;@len&apos;]= procedureCodeDescription.toString().length;
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;][&apos;@tag&apos;]= &apos;00080102&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080102&apos;][&apos;@vr&apos;]= &apos;SH&apos;;
}
// (0008,1032)(0008,0104) - Procedure Code Sequence - Value
if(procedureCodeValue.toString().length&gt;0) {
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;]= procedureCodeValue;
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;][&apos;@len&apos;]= procedureCodeValue.toString().length;
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;][&apos;@tag&apos;]= &apos;00080104&apos;;
	tmp[&apos;tag00081032&apos;][&apos;tag00080104&apos;][&apos;@vr&apos;]= &apos;LO&apos;;
}

// (0008,0018)	- SOP Instance UID
var SOPInstanceUID = prefixUID + &quot;.&quot; + fillerOrderNumber;
tmp[&apos;tag00080018&apos;]= msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString();
tmp[&apos;tag00080018&apos;][&apos;@len&apos;]= SOPInstanceUID.toString().length;
tmp[&apos;tag00080018&apos;][&apos;@tag&apos;]= &apos;00080018&apos;;
tmp[&apos;tag00080018&apos;][&apos;@vr&apos;]= &apos;UI&apos;;

// (0020, 000D) - Study Instance UID 
var StudyInstanceUID = prefixUID + &quot;.&quot; + fillerOrderNumber+&apos;.1&apos;;
tmp[&apos;tag0020000D&apos;]= StudyInstanceUID;
tmp[&apos;tag0020000D&apos;][&apos;@len&apos;]= StudyInstanceUID.toString().length;
tmp[&apos;tag0020000D&apos;][&apos;@tag&apos;]= &apos;0020000D&apos;;
tmp[&apos;tag0020000D&apos;][&apos;@vr&apos;]= &apos;UI&apos;;

// (0020, 000E) - Series Instance UID 
var SeriesInstanceUID = prefixUID + &quot;.&quot; + fillerOrderNumber+&quot;.1.1&quot;;
tmp[&apos;tag0020000E&apos;]= SeriesInstanceUID;
tmp[&apos;tag0020000E&apos;][&apos;@len&apos;]= SeriesInstanceUID.toString().length;
tmp[&apos;tag0020000E&apos;][&apos;@tag&apos;]= &apos;0020000E&apos;;
tmp[&apos;tag0020000E&apos;][&apos;@vr&apos;]= &apos;UI&apos;;
/*
File Meta Information Group Length (0002,0000)
Number of bytes following this File Meta Element (end of the Value field) up to and including the last File Meta Element of the Group 2 File Meta Information

File Meta Information Version (0002,0001)
This is a two byte field where each bit identifies a version of this File Meta Information header. In version 1 the first byte value is 00H and the second value byte value is 01H.

Source Application Entity Title (0002,0016)
The DICOM Application Entity (AE) Title of the AE that wrote this file&apos;s content (or last updated it). 
*/


// Institution Name MSH-4.1 -&gt; (0008,0080)
tmp[&apos;tag00080080&apos;]= msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString();
tmp[&apos;tag00080080&apos;][&apos;@len&apos;]= &apos;40&apos;;
tmp[&apos;tag00080080&apos;][&apos;@tag&apos;]= &apos;00080080&apos;;
tmp[&apos;tag00080080&apos;][&apos;@vr&apos;]= &apos;SH&apos;;

/*
// Specific Character Set MSH.18 -&gt; DICOM (00008,0005)
if((typeof(msg[&apos;MSH&apos;][&apos;MSH.18&apos;])!== undefined) &amp;&amp; (msg[&apos;MSH&apos;][&apos;MSH.18&apos;].toString().length&gt;1)) {
	tmp[&apos;tag00080005&apos;][&apos;@len&apos;]= &apos;10&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@tag&apos;]= &apos;00080005&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@vr&apos;]= &apos;CS&apos;;
	tmp[&apos;tag00080005&apos;]= msg[&apos;MSH&apos;][&apos;MSH.18&apos;].toString();	
} else {
	tmp[&apos;tag00080005&apos;][&apos;@len&apos;]= &apos;10&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@tag&apos;]= &apos;00080005&apos;;
	tmp[&apos;tag00080005&apos;][&apos;@vr&apos;]= &apos;CS&apos;;
	tmp[&apos;tag00080005&apos;]= &apos;8859/1&apos;;	
} // end if

// if(debug&gt;0) 
logger.debug(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; tmp[tag00080005] len: &apos;+tmp[&apos;tag00080005&apos;][&apos;@len&apos;]+&apos; tag: &apos;+tmp[&apos;tag00080005&apos;][&apos;@tag&apos;]+&apos; vr: &apos;+tmp[&apos;tag00080005&apos;][&apos;@vr&apos;]+&apos; value: &apos;+tmp[&apos;tag00080005&apos;]);
*/
channelMap.put(&apos;dicom_msg&apos;,tmp);</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <com.mirth.connect.plugins.messagebuilder.MessageBuilderStep version="4.0.0">
            <name>DICOM Tag Set pdfAttachment</name>
            <sequenceNumber>1</sequenceNumber>
            <enabled>true</enabled>
            <messageSegment>tmp[&apos;tag00420011&apos;]</messageSegment>
            <mapping></mapping>
            <defaultValue>$(&apos;pdfAttachment&apos;)</defaultValue>
            <replacements/>
          </com.mirth.connect.plugins.messagebuilder.MessageBuilderStep>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.0.0">
            <sequenceNumber>2</sequenceNumber>
            <enabled>false</enabled>
            <script></script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64">TVNIfF5+XCZ8TWluaUJveHxQdWxtT25lfHx8MjAyMzAyMTIxNDU0fDB8T1JVXlIwMXwzNF8xMDAyMjAyM18xMDM1MzR8fDI1Mnx8fHx8fHx8fExSSV9OR19STl9Qcm9maWxlXkhMN14yLjE2Ljg0MC4xLjExMzg4My45LjIwXklTTyANClBJRHx8fEdFMTQ3Mzg4MDl8fERvZV5Kb2hufHwxOTU2MTEyOXxNYWxlfHxDYXVjYXNpYW58fHx8fHx8fHx8IA0KUFYxfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCANCk9SQ3xSRXx8T0JSXjM0XzEwMDIyMDIzXzEwMzUzNF5GVkN8fHx8fHx8fHx8fHx8fHx8IA0KT0JSfDF8fE9CUl4zNF8xMDAyMjAyM18xMDM1MzReRlZDfEZWQ3x8fDIwMjMwMjEwMTAzNTM0fHx8fHx8fHx8fHx8fHx8MjAyMzAyMTAxNDAwMTV8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwxfFNUfDE5ODY4LTlfQmVzdF9QcmVeRlZDX0Jlc3RfUHJlXkxOfHwzLjgzfEx8fHx8fEZ8fHx8fHwgDQpPQlh8MnxTVHwxOTg2OC05X1ByZWReRlZDX1ByZWReTE58fDMuODV8THx8fHx8Rnx8fHx8fCANCk9CWHwzfFNUfDE5ODY4LTlfJVByZWRfUHJlXkZWQ18lUHJlZF9QcmVeTE58fDk5LjI4fCV8fHx8fEZ8fHx8fHwgDQpPQlh8NHxTVHwyMDE1MC05X0Jlc3RfUHJlXkZFVjFfQmVzdF9QcmVeTE58fDMuMTd8THx8fHx8Rnx8fHx8fCANCk9CWHw1fFNUfDIwMTUwLTlfUHJlZF5GRVYxX1ByZWReTE58fDIuOTh8THx8fHx8Rnx8fHx8fCANCk9CWHw2fFNUfDIwMTUwLTlfJVByZWRfUHJlXkZFVjFfJVByZWRfUHJlXkxOfHwxMDYuNTN8JXx8fHx8Rnx8fHx8fCANCk9CWHw3fFNUfDE5OTI2LTVfQmVzdF9QcmVeRkVWMS9GVkNfQmVzdF9QcmVeTE58fDgzLjB8JXx8fHx8Rnx8fHx8fCANCk9CWHw4fFNUfDE5OTI2LTVfUHJlZF5GRVYxL0ZWQ19QcmVkXkxOfHw3Ny40M3wlfHx8fHxGfHx8fHx8IA0KT0JYfDl8U1R8MTk5MjYtNV8lUHJlZF9QcmVeRkVWMS9GVkNfJVByZWRfUHJlXkxOfHwxMDcuMnwlfHx8fHxGfHx8fHx8IA0KT0JYfDEwfFNUfDY5OTcyLThfQmVzdF9QcmVeRkVGIDI1LTc1X0Jlc3RfUHJlXkxOfHwzLjU0fEwvc2VjfHx8fHxGfHx8fHx8IA0KT0JYfDExfFNUfDY5OTcyLThfUHJlZF5GRUYgMjUtNzVfUHJlZF5MTnx8Mi40NXxML3NlY3x8fHx8Rnx8fHx8fCANCk9CWHwxMnxTVHw2OTk3Mi04XyVQcmVkX1ByZV5GRUYgMjUtNzVfJVByZWRfUHJlXkxOfHwxNDQuODN8JXx8fHx8Rnx8fHx8fCANCk9CWHwxM3xTVHwxOTg2OC05X0Jlc3RfUG9zdF5GVkNfQmVzdF9Qb3N0XkxOfHwzLjQ5fEx8fHx8fEZ8fHx8fHwgDQpPQlh8MTR8U1R8MTk4NjgtOV8lUHJlZF9Qb3N0XkZWQ18lUHJlZF9Qb3N0XkxOfHw5OS4yOHwlfHx8fHxGfHx8fHx8IA0KT0JYfDE1fFNUfDIwMTUwLTlfQmVzdF9Qb3N0XkZFVjFfQmVzdF9Qb3N0XkxOfHwzLjF8THx8fHx8Rnx8fHx8fCANCk9CWHwxNnxTVHwyMDE1MC05XyVQcmVkX1Bvc3ReRkVWMV8lUHJlZF9Qb3N0XkxOfHwxMDYuNTN8JXx8fHx8Rnx8fHx8fCANCk9CWHwxN3xTVHwxOTkyNi01X0Jlc3RfUG9zdF5GRVYxL0ZWQ19CZXN0X1Bvc3ReTE58fDg4LjY4fCV8fHx8fEZ8fHx8fHwgDQpPQlh8MTh8U1R8MTk5MjYtNV8lUHJlZF9Qb3N0XkZFVjEvRlZDXyVQcmVkX1Bvc3ReTE58fDEwNy4yfCV8fHx8fEZ8fHx8fHwgDQpPQlh8MTl8U1R8Njk5NzItOF9CZXN0X1Bvc3ReRkVGIDI1LTc1X0Jlc3RfUG9zdF5MTnx8NC43MnxML3NlY3x8fHx8Rnx8fHx8fCANCk9CWHwyMHxTVHw2OTk3Mi04XyVQcmVkX1Bvc3ReRkVGIDI1LTc1XyVQcmVkX1Bvc3ReTE58fDE0NC44M3wlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XkxWTXx8fHx8fHx8fHx8fHx8fHwgDQpPQlJ8Mnx8T0JSXjM0XzEwMDIyMDIzXzEwMzUzNF5MVk18TFZNfHx8MjAyMzAyMTAxMDM1MzR8fHx8fHx8fHx8fHx8fHx8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwyMXxTVHxSVl9CZXN0XlJWX0Jlc3ReTHx8MS4yNnxMfHx8fHxGfHx8fHx8IA0KT0JYfDIyfFNUfFJWX1ByZWReUlZfUHJlZF5MfHwyLjA4fEx8fHx8fEZ8fHx8fHwgDQpPQlh8MjN8U1R8UlZfJVByZWReUlZfJVByZWReTHx8NjAuNjZ8JXx8fHx8Rnx8fHx8fCANCk9CWHwyNHxTVHwxOTg2Mi0yX0Jlc3ReVExDX0Jlc3ReTE58fDUuMDl8THx8fHx8Rnx8fHx8fCANCk9CWHwyNXxTVHwxOTg2Mi0yX1ByZWReVExDX1ByZWReTE58fDYuMjd8THx8fHx8Rnx8fHx8fCANCk9CWHwyNnxTVHwxOTg2Mi0yXyVQcmVkXlRMQ18lUHJlZF5MTnx8ODEuMTZ8JXx8fHx8Rnx8fHx8fCANCk9CWHwyN3xTVHxSVi9UTENfQmVzdF5SVi9UTENfQmVzdF5MfHwyNC44M3wlfHx8fHxGfHx8fHx8IA0KT0JYfDI4fFNUfFJWL1RMQ19QcmVkXlJWL1RMQ19QcmVkXkx8fDMyLjY0fCV8fHx8fEZ8fHx8fHwgDQpPQlh8Mjl8U1R8UlYvVExDXyVQcmVkXlJWL1RMQ18lUHJlZF5MfHw3Ni4wN3wlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XkRMQ098fHx8fHx8fHx8fHx8fHx8IA0KT0JSfDN8fE9CUl4zNF8xMDAyMjAyM18xMDM1MzReRExDT3xETENPfHx8MjAyMzAyMTAxMDM1MzR8fHx8fHx8fHx8fHx8fHx8fFBGfEZ8fHx8fHx8fHx8fCANCk9CWHwzMHxTVHxCSFRfQmVzdF5Ib2xkVGltZV9CZXN0Xkx8fDExLjIxfHNlY3x8fHx8Rnx8fHx8fCANCk9CWHwzMXxTVHxCSFRfUHJlZF5Ib2xkVGltZV9QcmVkXkx8fDAuMHxzZWN8fHx8fEZ8fHx8fHwgDQpPQlh8MzJ8U1R8QkhUXyVQcmVkXkhvbGRUaW1lXyVQcmVkXkx8fDAuMHwlfHx8fHxGfHx8fHx8IA0KT0JYfDMzfFNUfERMY29fQmVzdF5ETGNvX0Jlc3ReTHx8MjAuNzZ8bUwvbWluL21tSGd8fHx8fEZ8fHx8fHwgDQpPQlh8MzR8U1R8RExjb19QcmVkXkRMY29fUHJlZF5MfHwyMy43MnxtTC9taW4vbW1IZ3x8fHx8Rnx8fHx8fCANCk9CWHwzNXxTVHxETGNvXyVQcmVkXkRMY29fJVByZWReTHx8ODcuNTF8JXx8fHx8Rnx8fHx8fCANCk9CWHwzNnxTVHxWQV9CZXN0XlZBX0Jlc3ReTHx8NS4yM3xMfHx8fHxGfHx8fHx8IA0KT0JYfDM3fFNUfFZBX1ByZWReVkFfUHJlZF5MfHw1LjYyfEx8fHx8fEZ8fHx8fHwgDQpPQlh8Mzh8U1R8VkFfJVByZWReVkFfJVByZWReTHx8OTMuMDJ8JXx8fHx8Rnx8fHx8fCANCk9CWHwzOXxTVHxETGNvL1ZBX0Jlc3ReRExjby9WQV9CZXN0Xkx8fDMuOTd8bUwvbWluL21tSGcvTHx8fHx8Rnx8fHx8fCANCk9CWHw0MHxTVHxETGNvL1ZBX1ByZWReRExjby9WQV9QcmVkXkx8fDQuMjV8bUwvbWluL21tSGcvTHx8fHx8Rnx8fHx8fCANCk9CWHw0MXxTVHxETGNvL1ZBXyVQcmVkXkRMY28vVkFfJVByZWReTHx8OTMuNDF8JXx8fHx8Rnx8fHx8fCANCk9CWHw0MnxTVHxWSV9CZXN0XlZJX0Jlc3ReTHx8My4xNHxMfHx8fHxGfHx8fHx8IA0KT0JYfDQzfFNUfFZJX1ByZWReVklfUHJlZF5MfHwwLjB8THx8fHx8Rnx8fHx8fCANCk9CWHw0NHxTVHxWSV8lUHJlZF5WSV8lUHJlZF5MfHwwLjB8JXx8fHx8Rnx8fHx8fCANCk9CWHw0NXxTVHxETFFBX0Jlc3ReREwgUUFfQmVzdF5MfHxDfEx8fHx8fEZ8fHx8fHwgDQpPQlh8NDZ8U1R8RExRQV9QcmVkXkRMIFFBX1ByZWReTHx8QXxMfHx8fHxGfHx8fHx8IA0KT0JYfDQ3fFNUfERMUUFfJVByZWReREwgUUFfJVByZWReTHx8NzUuMHwlfHx8fHxGfHx8fHx8IA0KT1JDfFJFfHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XlN1bW1hcnkgUmVwb3J0fHx8fHx8fHx8fHx8fHx8fCANCk9CUnw0fHxPQlJeMzRfMTAwMjIwMjNfMTAzNTM0XlN1bW1hcnkgUmVwb3J0fERMQ098fHwyMDIzMDIxMDEwMzUzNHx8fHx8fHx8fHx8fHx8fHx8UEZ8Rnx8fHx8fHx8fHx8IA0KT0JYfDQ4fEVEfDU4NDc3LTFeUHVsbW9uYXJ5IEZ1bmN0aW9uIFRlc3QgUmVwb3J0XlZTUFVMUnx8XkFQXlBERl5CYXNlNjReSlZCRVJpMHhMalFLSmRQMHpPRUtNU0F3SUc5aWFnbzhQQW92UTNKbFlYUnBiMjVFWVhSbEtFUTZNakF5TXpBeU1USXhORFUwTWpRdE1EVW5NREFuS1FvdlEzSmxZWFJ2Y2loUVJFWnphR0Z5Y0NBeExqTXlMakkyTURndGR5QmNLSGQzZHk1d1pHWnphR0Z5Y0M1dVpYUmNLU2tLTDFCeWIyUjFZMlZ5S0ZCRVJuTm9ZWEp3SURFdU16SXVNall3T0MxM0lGd29kM2QzTG5Ca1puTm9ZWEp3TG01bGRGd3BLUW8rUGdwbGJtUnZZbW9LTWlBd0lHOWlhZ284UEFvdlZIbHdaUzlEWVhSaGJHOW5DaTlRWVdkbGN5QXpJREFnVWdvK1BncGxibVJ2WW1vS015QXdJRzlpYWdvOFBBb3ZWSGx3WlM5UVlXZGxjd292UTI5MWJuUWdOQW92UzJsa2MxczBJREFnVWlBMU9TQXdJRklnTnpNZ01DQlNJRGcxSURBZ1VsMEtQajRLWlc1a2IySnFDalFnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0ZuWlFvdlRXVmthV0ZDYjNoYk1DQXdJRFl4TWlBM09USmRDaTlRWVhKbGJuUWdNeUF3SUZJS0wwTnZiblJsYm5SeklEVWdNQ0JTQ2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEWWdNQ0JTQ2k5SFV6RWdNVEVnTUNCU0NpOUhVeklnTVRVZ01DQlNDaTlIVXpNZ01Ua2dNQ0JTQ2k5SFV6UWdNak1nTUNCU0NpOUhVelVnTXpVZ01DQlNDaTlIVXpZZ016a2dNQ0JTQ2k5SFV6Y2dORE1nTUNCU0NpOUhVemdnTkRVZ01DQlNDaTlIVXprZ05EY2dNQ0JTQ2k5SFV6RXdJRFE1SURBZ1Vnb3ZSMU14TVNBMU1TQXdJRklLTDBkVE1USWdOVE1nTUNCU0NpOUhVekV6SURVMUlEQWdVZ28rUGdvdlJtOXVkQW84UEFvdlJqQWdNVEFnTUNCU0NpOUdNU0F6TUNBd0lGSUtMMFl5SURNMElEQWdVZ28rUGdvdlVHRjBkR1Z5YmdvOFBBb3ZVR0V3SURFeUlEQWdVZ292VUdFeElERTJJREFnVWdvdlVHRXlJREl3SURBZ1Vnb3ZVR0V6SURJMElEQWdVZ292VUdFMElETTJJREFnVWdvdlVHRTFJRFF3SURBZ1Vnb3ZVR0UySURVMklEQWdVZ28rUGdvdlUyaGhaR2x1WndvOFBBb3ZVMmd3SURRMElEQWdVZ292VTJneElEUTJJREFnVWdvdlUyZ3lJRFE0SURBZ1Vnb3ZVMmd6SURVd0lEQWdVZ292VTJnMElEVXlJREFnVWdvdlUyZzFJRFUwSURBZ1VnbytQZ28rUGdvdlIzSnZkWEFLUER3S0wwTlRMMFJsZG1salpWSkhRZ292VXk5VWNtRnVjM0JoY21WdVkza0tMMGtnWm1Gc2MyVUtMMHNnWm1Gc2MyVUtQajRLUGo0S1pXNWtiMkpxQ2pVZ01DQnZZbW9LUER3S0wweGxibWQwYUNBeE56azNNQW92Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsQ2o0K0NuTjBjbVZoYlFwNG5PMTlXNDlrdVkzbXUzOUZ2Q3dHR0tDUGRiOE1CZ2FxeXQwTkREREF6bllETThCaUg3enQydzdhUFdPN3NjYnNyMStSbENMamN2anBSR1ZtWlVibUNUc3JzeU1ZT2hJbFVTUkZmdnp6NGI4ZHZ2cnE4UEYzZi9nL1AzMzZqNTkrL3QxUFAvL2ljREJMamdmVC92ZFYveXRYZC9qaFQrMlRyNnd4aCsvL1gvdXJmL04vMHpjUG4zN3owLy85elYvYnU0ZUQ1Uy9hZzB0TGlDa2ZmL1BYTDc3MjdZLy85WjkvbEs4ZDZHdExLcTc5VzMwK0hQN3loLzcrTDcvOXpoeitNS2crZmovZS9xWjF6eDYrLzMzL2IxY1g3L25aOHBmTmNTblZwb04xWWZHMTllRDdQejA4NmZEOWJ3Ly9hSXozeHNSaVRQaW0vVGJ0eDdXZk5zUVEydS8yUnZ6VTNtdzByZ29kZjViYTc5eCtmM3FnTi81WDMvOTdiNzB1SnR1SEorU0hUOHdTL1BHRFFNMzFwazYvYnBjWTg4UFg0K25YVHo3Z3IvdmVBK3JweVhPK0ZoNzlpN0Q2ZHovOTlwVFIycnc5ekZ6NzhXV3g5V0hTMExjZXZwZmF2OGN2WEh6bHYvL201ejhlUDZGQnRobjYyOGtiNXZCUFovLzE3NmZFNXZEUHB4OHVPYWV6ZncvLzQ5dXpMNXZEbjA3K081clVCdFBlL1BIa3plK09mNTl3NmFTVEorK2VqWFlMSDB6anhDdmtRK3VhZTNvZW5BM29ZamluZzdFblE4RTliOUxtcE4vRXpCOVAvc3MxR1pIOCtHVmswUjAvejJmVC9OMzFRRTY2cTBzaTRaMDVrVUdYVXVoRURsMUxvZ014MmdpLzI1elp0dndlWk0rNTlIbllzN3k5VDZSRGVCQXlvUXNla1JSTkdPWCtYaFk2cGlFQmxrNmIrL3I3NjlHZmpYTGJVbmI2bnI3Z0djczNsMW5LV2ZxM0NidFREbDd6OEl5TGEzeTg1S1JmMGlrblQzbnBQZ2xqN0svUHhla1pLM1JtVElkMnRTQWVPWndjMmdxbVl3cU42VVA3YVJOdDJ5UmJHbHY3Yjl1T0RQdXgvN1RGWUQ4OS9WaWZlUm85R25MdEIyczhQUjNiLzhlaGJHVHQyMS9menhTajhmb1A1K05veXMrWkRPQjlQZlo3dkx1cGptaXF2K2xUK2thbUdZNzExeWRpM1BZbFRyOC9YSXJ0dTVqV2pGWjBlbENsdzlkajVkN1hWTUx4ZmJyY3NlRkNLMy8wZkY0cWlmMHd0aWtzMGJweXJtYXZxbE5uTENIREtsNm9nbVp4cnYvRG41NHFVWWYrem8vbnp5aWlFZEIzTEZQOGNOYkhYTnRiUDE2K1JkK2lmNG84cGx3L3AxdytxTFZQMU9QYjB2RHB0MDU1OC91L255aXhMN3RWYWwxY0xoV2Y4dkhreUNOUi8vRkV6UXNQNHY4ZU5wQ0xkU2toUmp6Z1BpQXlwR21nck5MNC9qZXBPbzBabGdiODRjNEU0NWh0cU9DRVMvR1J3b1A0K0hDSFU0MUdheXRONVoxT1k1eW81dU5BRC9tK1Rybmp6S0VCMG40Y0NtaTQxeGxFNTdnckQrSjJxR1Fra1ZnVVozSDkzZFZzd3NHbWZwWjBzVHYwYmg0MC9XMmZTV2Z4b1UyRkwzN1hXUjcrZnQwNml5OWhvVVdCai9DUC9Rai8xQSt0ajdKcEhyOWhMaHhSRHlzcHVMQ0VhQzhYRXViVStuNWI0OUFGajlhNWRNcW5OUjNuN09pN0VKcG56RURzMkRDbXlmdy95ZmljSmNNR2o1RzlOV1Y0STU5dnZNODFoNkVzZFRxUDliN25NY1gybE5rOERuY0VIUWtmUDNPODJuWEI2NUJtbisyRWV4a3A1KzVHekEyRDdlTjlieFBmK0c0blkyVmRPRjU3ZU43SUZva1RKd1daQk81T3RPTGdLdThqTkNiMk85RHl0WDBKMS9zeWM0NFRsMmVhV3Z3aU1pdmRqY3d5NCtlK1pSYXQ4Wm5Jb2l0REp6NEs5ODJiRkZzVm5leHQ2Slp1SThwVDNReFBkMEhaZDhIRHcxN0pMakRsaVZmK1k4S0RvcTJMTFRrZjlNZ0tkWkZkaEZoaEg4eEtlTkZsZ05GbGlORlZrTkU4ek9nNjBPaHdjRDR2bHhGWHAvRkd1dU5qbzZoUkdYUVJlL1ZhR1hRVmkvV2szTGt0eU13ZXptMmZXVlJadm5ETHBYTmYyQ1JDNnpKRzY0bkMwSjRyZml1NnZsbEJGRmM2Q2VZY0R1UmpYT2dYRGRjNmlwWjdpZHJheExzN3V3TXRjZkYyRnRrMUhHZng1TnFUN0t0dituL0hIdDFGdis4dlBnUTZXOUtsc3lVZVB4dGJaRnlGYzBqUUNMVTI5N2NFNE5Wb24zSlNTOWtTTGRmcWFaT2g0WUU3OE9yWW03dGJKZkQ2TVYrTzlTSjBYbHlWMTFkM2NwdDFKOHNreXpLWk9WNWlQQjhiL2VhdGNYOXpEaU9yZkovU1R5ZVhrM2M4cmZtencwQytPYmxXdVgyT0g1ZTdZQVByaTIvVk5Gbk5CdGx0azdOM2R0dmtldUNQc0UwK2Q2dDllVTM5d3NhNWlnY3FQZGhwQ09ZZUg4U2FlanJKbmhzcTIwV1czRDBJYjB1dWk1TFk0Q3VxN3FhNHp1N2dBSTVvanVPVmFuNGUybnpVdzJOUGgreFpHbkpRcldRcTlVVnhqSkJMZDdZSTR0dGNCTWhsVG1rWjlPUHZiY09pUVhIbWxMOTJCRCt6Tm5YMHg3eHhwV3IzOSs0NjFaUHBWSWZYckFYNWJvMWZhRUxubXM0ZENFM3ppQ1NGZklLWmtPVlF2M1pjbmJocm9NZnYwME1DNE5BaVRwM21vWjRFTG45ekhXWDQyUUo4L1YxZDZEd0lITHA0anU1V2NJU21lYjFaOFo5alhzd3Uvd0dIZHZtL052RFBsUDlQSkF6OXdJdVJ2NnhMUzJXbmZWMXFMWDdyRVdEdHM0V1UyQlNYNUZPR1V1RHEyMmNlaG5MK3pmbDNnZkM1K3ZyVjlwS3YvKzNxdmNzOUp1LzkrL1YzTC9jYUUwNzNtelIzdWVmb1JZZGN1UkpNOVBydTRoMXRMVjU4dHNLeDdSeTlFbFpYWDMvOUhGMlJaUFI2Sm5hdThPT2FHOWU4c0ZlYzJETGtTMUVuNzZXcjBjNUZIcjN5eXJMN1R1UER4VGdSaDJiTDdhdWo5R2lLYk1vazJYWWhzQXVCWFFpOEp5RndUTCtzVFFSY0t4QzNyVmRyRnNJZm1xemFsZkJQNGROYWVDdTkxa0kvNlhVUi9zbWtxeUdnM010TExTNDBxOWJhcHNHZEF2NmRkK2RhajdzMFgrWDE5ZmY2ZWw0Wkxab3YvYk9OS3Y2S0Y0UXdHYzNpYXJQTWwyYXhQNE5Hbk9waTBsd2pkdkVraUN1L1d1Zkh4ZWljaVl2TEcwYjNvV2YyMjdzWm1Xc2pDck54bWRLRFNKN2NubGxacTAxRTBpcmx6R3B2MGpPTXVmb2xrNm4wSnRlcTV4bmRNTHE3VzZzK05vRzl3ZXArdnRXcVd0K3V0cldLODgxMzI3czN0NnAydHkrRVhlMitKTnpWN3JUYjNyc1EySVhBTGdUZXBoQTQydDZwYWFSeE43MVB1N09HZTMzOGZJbnVTTUlYNlN2bytBK3YxMjJkUDQrMkhCcVBhOW11TGJ1ZUpIRk1IUGp3RkdCdTRESTJsTS9WbGlQY0pxdGlhSHpWTERiRjZ5MHlneGpyTEx1QUdSdnZJcWd4ZW9YczJ4U3NpSmlRdytKSUh0RWZvVW9yeDcvalNrUEhqMzdVUG1wMmMyL1dqZ2ZicTRhb0JYc3RLenYyMmFHam9hMTE0WksxSndCbDlFSkh5VTFuNzBVSTNFb0xyME9TbVcxaWpKTDRDRVhRMTU3TjVlaTlOVm5sRjNNU0RsUFhwVjk2YURnOWdjRGJ5TmxwaGo2ejdqbTRYTU1TUTl6RzZ1c0UvdWZqeUJjK05kM0dRNU5EV0Q5MHRKcDhuUmI2bkN5WitKcWZrejBqQkdJYmp6NzJYRXJiY3l2OVcxMDJMdGlsaEkxY0dabW1INzdzUnBwNGZaK1RPK0s2Mjc1bVB2WTFVOWVBeko2UFExOTJ6ZmlVbHNpWjZadFhUZWg1eWMrd2FoUkxXNVNGWUhOWGRKc0NWRmEwQm1hUlhXUFJMMXZEUC8vdUx6OGRmdmdyL1cwT2YvM2hwOVZoMm5Db2g3Lzg3bkQxNFlYNmd4V2dWem5USWJqRjV1M255cFBNNzlNNWFaeGIvRm1BN1dvamNBR3BWc0UydTBDekRMYlpCc0E2dU4wK2dCYkNyVGFDWmlWc3N4T3VMWVhIYlpiVlpUQzNHTFp0T2JUcDlHMjN1dkhRMXJ2UmVqaTNIOVoySGV2a3BVek1oUzBHdzhvT25zdm96Y3pkWkRnOEs2TnJXa3JDeDlrWnU3LzU4a3g2bVJYWXp2akZGcXcwbngwQlEyWCt1QVpiTGE5blhVcGJ6SXZuNVZoMlMzSGIxOUlaeDlKN1dWZk9SaWtMdW5YSGxYZkRtVkRid3IxaHgzMlNIL01TdTIyTFdmYTgzS3E1NlN5ZklaL3lkYjNEOFhwN2E4cjdzdFI4dy9rVzN3MW5tbnA3MjFZTHo3blZWZzJSbTJ4WjVwWmI1OWFGUFd0WDdkbUpSYnVpcHM4VTlXMnErc2tvZlNLSGxGa2YzcmJsaEJjVVdsTEtvc0xMNm1iVi9XeFptZlhsdExxZ3RpeXB1MkZTWEdZeTZYTDdhVnZ2czNtRlhRMnp6NS9PVVJIQ2t1TDBVbXQzVkp4OXVEc3Fyb2IwNmgwVnB4ZWR1NnRoZHpWOHZxc2hudFRiK0xpN0dtNHdmc0oxUmRUeCt2b051aHJhcjNERGpndnZoalBUbTkvYjduNTNad04zZEgyLytWL3R6b2FMenIwN1o4T0dXL1BWSFpmdndPZmdOL2tjM081emVENXpldmM1ckx3ZTZYT0liOWpuME1SUkxidkg0ZUVidThkQmJlWGJlL2M0ME85alBaVHlmdTQzMmtLN1FXTTE3NFV4d1MvVzNzQ1lEeThVei9EaS9xb1NscExqZG5lVkpDOE1LTytRZHZmVlplY3UzRmQ1ajVTNTBaeW0wazM1Vjd1VDVxeHJKeVpqUnFIV3U1T0dPL3JBc2R4WEZVbjQzUlZ4MWJtTDJ1enBEbHdSWVpNcndyK01LK0xiVjZjSTlVVGdXNlR3MDY2Q3o3ZDNYMG02dGIxT3R5NExZK1daL2xkVG9PcFNqTmZ4bGk1aXM4OVMyUDNWaCtta2x0K2ppenFDTEd3YkhJbnhESEt4VjZiMGlZbzEyNVZGL0FBOHZ3YXZmd1lOY0hYRFpaWjZVb1JtRklmc1ZmOUdVcnRnMEF0cy9DaE1jL3I1TllSQVh0eEpqSDIrZnVyRFhEM2doVjFYUlBuY1l0a3dGOTVoeklqVjdhZ0pvblVoZENXQU5PRnpObk51cWZGYTBweE0zZ2s0bDFSYkZ5dCsxSVNpLytaeVFIVWQxQ0V1aGt1emFaUENhOVN2emdzMXpZVVl4c1NQZWdJbnBST05QMEZENkF1R3F4VzVrellHdGxoNUtFSkwzV1dhNDFDdU8zWWhRTEh3dk1YZForTlMwK3ZNbXA4dmpVZUFmbnpPK2prYzJxbm9NMXhCcjNnTnZTNU1FM1MrMUxBNEI4OFhJTitzV3dHMnVtbEx6TnpmRStmcEtxN1dWcVgyYnl2dnJtRkIwYnRybXRZcUh0U3E1MzBGRVVyMjA1cXFWL0phVlV0NWZYZWo3anU3NmJqUlVmM21lSzBnY0Qwem94K0ZUR1lQYTNKd0d3aFpYcjNxU1dzWEpadHd1ZGFSdWI0c0lOd1JxTSsxazRzY3BidEl1WHJ0SW1VWEtjZnU3U0pscTM1U3ZXeWJSOGtUZ1B6M3lqMVRucndjRzcxU2N3aitWK09aMnVBK1dlWDNKcGZKR25ldmI2cmFnckFhQlBoNWFKNE9jZjY1N29vWEdHKzJpOCtieG5zc1dIdXZZM1dtTGpIYkRXUDE1V25IaXVCTGd5SE5hTGZVTG9rZmVkUzM4Nkd1SXlMdmF0VVY4YTVXTWQyeVcyb0g1OTFpL1NxaytpNVVkcUd5QzVWajkzYWhzdGxXcTdKdGRsdHRnNjJtd1pEZGhOcStHM1FQSVdLSmltYlBWZjVmOThETTFQa2JyekhjNzhqVXFXNnBiajVxUXJBL3IvVjByeVAyMFVrMDl6c3gzSDJwU3pKYnh2dTJWallsb3dXL1pkeHZaMjJINGhhWE5xM3RYb2xDQW5MdWRielJOUnRrby9SNmpoSERxS0ZRSHVPcWlYZWNVaGF6Vy94NmhXZjZLSkVhU244UXFpcTFkUHc3S28zMUQzL1VQOHhsTkczSDQvZVVzc1ByVGluYjBYYXZ5SGNJSEkweDdxWWNvbkJ6T3N5N0FvNjFPU3lrODN3V1N0Qzd3ZUFnekpzVWJrNkIrZmljS1RCVERBWVg0MkozREliRGpzRXd1dGo1NUUvSzhIeHBMSVpYdnRHOWlVdEk5NEVXL1RKbnFtOVNwYnd5Zk9pcEtQUzFMQ2x5QnRFdURIZGh1Q1lNcTM1V3YxZGhHRUs1TFpYeDJmRzg1N2hUcFNscWVkL285Tm8zK3VwR1Q3cDU5NlUyK2lRdk83cXdCRHF0Sm5uWmNWTmVkbmlsRUhFeFdCbmx2bFgzclhxNFBFZGVHVWpjclE1YnRVN2ViWklBZU8rMyt1OTFELzVXSHo3MDRuK09IMy9peWIvZGw2OTc4N2Y2ODljOCtsOUFCdXFlL2NNYmxIOWJ3T3EvaEN6YzZMSC9Bc3piNUxuZjRydS96eVBFM2NBcTYrT1M2ZzJIeUFadzlzT2JQM2kzdWZkWEhmeFJkL0MvZmI1dGNmaXZycllQTHl2YVhwaHJxY25UL0JrMldYNEdtK3grdUZZTElkNXM1OXFHd2dHSE4zOGUrRmdFNmVMelRvUjNLOW1DOFVzdDZYTjJLWjBJOWQzeUxkZ2wxNXY0dHFIY3dGUHhUYlUwdHJ0R3Q4L0ViQzd3Yktqek1adVJ6N0E5dG5sZmxFbllOZzEzeUxZdDNoajF3dmpqczNCeDdrRGQ1amk1MFluS0xFOGF5eThjcVZGeHBFNWRxYXVPaExrcjRmWXRQbk9wSHZZdGZ2bmF0L2lHdWh6UHZMVy9yR3RXclF5NnUyYkhkM2JYN1B0MnpVck5BYWZxK240eER6aU5YaVhiRXBuOXp2eTlZWWtoYnArVzkydmVFeFRsZGt2cjQ0bDE3OSt6ZFc5VFdvcTl5VXF0SndITEwzd3g4OEorT0pPYTlueVRyL3hqL3htOCs3QjdmbS8wS1gzUTQwTGZQdGU4RFV1K1JjNlo4Zk9yZDNvcytGQ1dIQit4UXovKzZ2dmQ3M3VELzNMd3JieGJ2dEU5UTc2SmIyOXlsOTdFTTZvWmxIYWUzUlFpMXlSYnFUZHBIOC9Gc3kvcmoxR3FwdTdlbVBHZDNSdnpicjB4ZVhlYStFTTFTekxsQnNFNEs1WjVPTHo5WURsUGFDamJqNUxUak9WM3Erclo0cHJhOGlxTzRMdmhtU1BjbloxaHQzaEt5bEwzSmJaN1NaNDFOaTQzVmZBbSsyc2NBRnp2OWxmdmRLVUYydzZBc051dHUzOWs5NCtzZG1iM2oxeFFmSVovQkgycWY2Wi9nZzNwQndQYSs3UkVmMmxFWXllTDVmOWR6cmxoSDRZbmpGeHIwMVhRMjVrelFIY0R6QndBbytmbDhDajBSRGZEa0ZZbVdWL3VONVhvMUk1dEsrMjNYeTZRUzZySmdvU3JkSzZIWTVnbEdyMnc4YUJKRHlUcmdSZzNscmU4emNjWDJiWDBDdUhtWllvMWlIbkZGeGhOSWdBY3pTWDNIUklYYzAvWTYrSkJFNzJRQ2Z6NWwrTkMyM2w1L1pENTgzcjNqLzEwU21qdXYvNzlZUzJrOStPL0hYNzUzUi9ONGE5L1BIejliNGQvdVhFd1Qra2YzN3AzRUhaTTA4OGlDUUVUbmg4dXlzdUM4dlIvS3VUZERGNi9mbFNmUkRuOWV2MkFmanhlek9UV3dEVmR3cVJNd3ZHSFArbWJRN3NzT0hpSytuNGUrSXhKejcyTmk2czIzVi9QZzYxTHRNbStocDYveEVhZFhuVjgxYStYcGxjZGFnb0UxdFRsS1NvVFB6TlpZUjdsZlJzWGtsdEtMSDVuaEhWcGNYWWpUTTdiNWtTaFduejczamk0NkpicS9iNDUyakdZNERINGpqaVJLNVVNZXZkOENNRXZ4dXdIaDVnK1BxVTN1RGVlTnY3SW1VY1pWeXAzbmhLRDk4RlpaSmRZRkZmUnJWQkxYd0NPRXlqRjIvTjUvNllzdlg5UzNsLzM5U3IrRCt3QlFYNmdxU2RvelF0eWM5YnY2K1dMNmh1YWU0ZWVsek50NHhYdEt1TFAybUNtbmlMVlZ6UzhSVmIxRnIyRTdOKzY3L0NGejlSejlBeVgyU2NlSko4WFg1UHVRdHJpUkhxcW03RXA0TURNbWJUbExQVlBmcGJlT29xWlkraytSakZ6TXIzTUtGNXVsMi9BamtCdXA2M3NuOE1mVEJWR2hiVmJsc2ljdmJkelplS0dlcitNbWJtbDNqRm5zSnZxL1RKbTVyWjZ2NXladWJIZU1XZWdXK3Y5OG1YbTVucS9uSm01dmQ0S1o3NnNreXpjazVQTTNPd2d3NEEzN2RqSytURER1OWtRWmJYNzNJNWYySDF1NjErNFg1OWJmUUdmbTl0OWJwZXZ4L3JjR01pbDdqNDNlZTArdDkzbmRqYkszZWVtVWV3K040Vmk5N2xwRkx2UFRhSFlmVzRheGU1ejB5aDJuOXM2eGU1ejB5aDJuNXRHOFN3K04venAzRUxVZUxOdURWN1pnVnE2cmUyelNMK2FURnhKckgwdytMdzNKa1pCMXpIdGJ4Zmx2Nk5yUDVZUWQ5clBSL252a052UHAvYnpUZnNKN2IzYzZhaU16SXJoZUdFeVltTnh2a0xQRmZZeXl3S2RlRUMvQ2t1cWlremNzcmFQTW1TeFZSV3RhUEYzMWZpbGl2V2FRM20wWXdOczdLZlBIajl4QnRlOU11L0Q2NEV4WVJOajdya01ieXhMU3BydXUrL2FyL1pkZS9YNjg5dll0Zm1PZDYxMWJqSE81bjNiSG1BejMrN2I5dmo2ODl2WXR1bWV0MjJKQW4yN2IxclF6TGY3cGoyKy92dzJObTI4NDAzcnFKeUNMN3VLZkUzdzUzM2J2dWx0Rys1NDJ4SWlxcW1hdi9XV2JldGU1N2I5TXJHRVpsc3NZWjdGRW1ybHhqNGoyTzlKVjBuT1M0aHhYeVNucjVkYkpPRlZMcElRekZMc1V6ako5bFh5Rktza3ZzcFZFazNUNzdMZEQ1eXoxOHV0a3ZTRlZza05WNVliTHVFZWVRZm5qRnVTTDNYRElueFZ1UWpUNlhUZnlJKzM2emVqOUhwaEFlQnFYRnpaWkNqZUYrKzkxN0k1WWdsSHFoZzFLdjlRNHBoTHpveEw3eVFYM3ZMZXE1elNZRzNibEM2L3ZTa3RZenU5QWltcGY2Wi9nbWZ4SkNrcnVoM1JlK1g3TzZMM1lVZjBYdnRzUi9SK2hZamUxbnhCU0crL1Ezby9BdExiWmR1T0NGdDNUTytWdnUrWTNqdW10OWJRanVtOUliSHIvVEJpeC9UZU1iMzdhOGYwSHE4ZDAzdThka3h2ZWUyWTN1TzFZM3Jmb3JidG1ONm5yeHZOcXgxZmFNY1hXdnZ3eGZHRnJIMEJnS0d3QXd4ZHZoNExNTlJzbitoTTJnR0crTFVERE8wQVEyZWozQUdHTklvZFlFaWgyQUdHTklvZFlFaWgyQUdHTklvZFlFaWoyQUdHMWlsMmdDR05ZZ2NZMGloMlVPOFQ4aDNVZTNlNjdVNjN0UTlmM3VubVhzRHBGbmVuMitYcmtVNjNZRVBUdUtyZG5XNzgycDF1dTlQdGJKUzcwMDJqMkoxdUNzWHVkTk1vZHFlYlFyRTczVFNLM2VtbVVleE90M1dLM2VtbVVleE9ONDFpUi9XK2ZMQ2VBOTEwMkFmSEY4TjI5NHptSGZaN3JaMGRIVTMxZklDZHY2T2p2VlowdEIzMmU5KzErNjVkN2NRcjNyVTc3UGUrYmZkdHU5NkpWN3h0ZDlqdmZkUHVtM2F0RTY5NDArNnczL3UyM2JmdGVpZGU4YmJkWWI5WkFDdzdDdXNhZTA1MjJRNzd2UytTSGZaN1h5WHkybUcvOTFVeVhqdnM5MjJYY0R2czkyVlhkdGp2L3RwaHYvbjFSVS8rSGZiNytIbytLYWwvcG4rQ1ovRW9Vd21tdTF3YmdiTTFjUHorOWNUUGw0OVpVbkJWV2xpTXovelhGcW4rRDRlLysrR1B2L25MejM5M3hYdHE0WHBDWGFIM2YxeDkzK1cxVC9UMzE5NjkxZ2YrZFNVVlpac3ZLWGpLY1hHRWkzc3JHUEcyd0trSFp4VkZsQ3N4V00rZXZ2US8vU0g4TDNQNDdYcHJTNm5oN0Y4dHo2bHh5em12NURtNUxKKytSUGJYRytPeE1Zakh4dXc4WG0zdEZoN2JuQUdQNmRPZHgydXQzY1RqaUdRRmZicnplSzIxbTNqc2theWdUM2NlcjdWMkU0OU5Ranh1bis0OFhtdnRGaDRYSkNyS0xpa2V6K0ZZQVlmYmh6dUgxMXE3aGNNZWlRbS9TNGtua01RT0NXTDNoQnllcDV5OEVnT3o4WXdjUVNmL2F2ZjJvcEV0WHBPMHdTOHVOUks3V0t0d3NwRkV5Z1F2U3dBa3hUV1N1RGhOaHc1aHNkU0tYWExRU1VMcmk4OUxTVHBKc1kzRUwwa1RYcTBUdGpUK1Y5Q1h1RVRDdVNCc0JaMmtVazIxdXBTaWthUWx0RUhiUUpRcVNmdTZ0V1l4Nm9NeStTU3RpVlREVFNVaFdBNWpGcXZ5cFUzT29jYkZPNTJncGtNMWk5cENYV0k0bEtUM05MYm54ME5wRStoMWlsd1BPUzlKNDN4YloyMktzMStxMm9halVlWW11cUpPMFppYU1vRnZLeFJ0ZVlSRGFpeFYreEZvN3BJSG81MVRSQnB0YWl4Vng1SVhSOGZzWXJScGlXWEprZjYxMmxOYSt6NVNTeXJIRXNWZlV4dE80MGNiUmJOdFd6OVVhZGw0MWJncHoxSW9NczFjc291MlNsTnRTN0E5U1ozN2JCZGY2VW5hRW16TElrU2VXTzBadVhVejBaUFV4ZEVXWDNiMEtGVlc1YnBVUjg5U0Y4ZWNvbTJDSm45eUlMbXFVSGpLdzJ2OXpWby9TcVFGMXZwcnRkRVdGZzI1TFJGdFlrdWxDU3VHK0xaT1VTMUYrUmEzYUROZm1la2w2R3UwaVpYRzd0YmRxZzJsOG81djNTMmFhSytWNUhicnJxclZXMk5aUXRtbFJKVWswQ25WZWx5cVNwSkk3TGN1MTZTU0ZHSjhMWXRSKzlJRWRrd2ljVlVTdDZRbTJrMFRWMW1sQ1RSMTFHM25WSnBFQStaK2gwZlJGSkpHTkRoMVBWbG5TSGJUNkp6S1l5Zmphc1B6ZWp1QjBOVm9lRW5sRDZHRkorbTZ5aDlYbG1qNWtMWGFDcmVlRjdlbFdnc3FDZmZWT3ErdlArdmJYZzNjSy9VTXRUNlJDS1ZlQmYxWmhlYVNlcVdPS2hoYUV0UXJmWmtHUnl2WituWkVxUnhzdWs0N2UwZ2RNdXF3V0Y4cVlMRTMzYUZwMTlTbnJJNHBzSkpEZlZLRkppbUloZFEzcjBzQjBqUGJNY05hWUhnVVRac2s2bk1DeTR0eUJRTVBMNnRNVHBibktoUkU0MG5aSkJhb3A3aE5pUVNnYmRxTjEya3FEWWhvMUVlMVE2bnhqamlwbW9XMkhTa3hNSTJxWk5sMlpGQzUzK2gwa1cxemxTNDdzTlBiSVViVDNtaUNPaFYwTGlTbVVic3NLaU9SWkoyR2p3YWlxV3FYQytrUHRENVVROFNTK2xxSFBUT2pVVTBWOE9HNnRmV2lTRmZQYmt1Nkd6MEJUdkVFOVBMSEovL2lXd0xkSnUwWEJmb2tUd20rMnlmc2xGNmJzTlJFWHpOTm00N1NSRnZiNS9xRWtTck1Ub0tvK3hGc1l2bW5tOVNlaEJHVEJKM0VpeFNOb0JYU0I1ckExcTF1VHhZRXlmMmlVNUFib1owd0dYZ2ErQkR5K2tIVlNKTG44OWNBVDRPbk05d3U2aVY1NjRUM3JMMVk5VUdaRHp2cmRUT3g4WU9VanFZaUJ0VXFibWRUSkwxWGV3ekpYazh1Z0toSjRNajJWN05JZE5PNzBLblVqaWpWRmpWc3ZVZTFGNG5WKzZRZnBPMDRibXNzRVZpQWJvcTJCVURBZFpxRjU5amN0Y0JZcGZnNWNrTjRZR21TbGVoMERhN1paZTBoUWZjZ05TT1J2Q0dXRnFOQ2tiZ25xaDFhU0JIUHJMS3I5aCtOd3dJSzl0MjFwNmgyVEUyMGNkdXNWOVc4YXlvV0VlaktiTFB1MmtQQTZyU0dYUWVVQTZFM2trZ1ZMa0E2c0hGSEZLb1cxb3lmN01nZ1Z2MDZ0TTlNb1VhU2JyVkZNamxhSzE0My9qTHRsWkowUTZIWlBXMWJsNnI3Tzhqc2FUcHdCZXBYa3h1TkcyMFNkZjNlUmVwbU05S0RPaDZYV1lscnM2VGJMTTB1YW4waFR5VXdqd3pOa0RVVmFIR2UvVUJrWVFJYUo1YXEweVVlT1lIWlJSdUl6eHBOVzliTWFLOWJoa244eFVaM3dKSU41aXpQUnRBZlZVakdrLzJzV3paZXJJUkdveXV3Z2Qyc05Ha3VBWnFhZVViMFZVeWVkcUdwK3JNY3UvWmQxZmRMdnlEdzBJQnNNMUZrWXRYdFRZZGxFS3RZcDJGUnh4T2JBQTFaTGMyZVQzbzdTUzRTZEZjakdZN0c4ZVRyWHFEQU81aG9zbTZrRjVJVnRFQUNJQ0YxaEs0MTFQM1hqbTl1cGlCYlgydzZEOXk0VFhOaUFuMTFOU1VnaUQ5QWYxQ2pvZnNHVE5Qa2VXVWE2RE5JZFN4V2pjYnh3TnRpMVhjb1dhaUphUW9nS1hLN3BEc1ltM3JqbUFUMHh2T01COTFkU2lSa3hkUE8wVHNjV05NTnlBUFVhS2g0YUVDMmJLTXBsV25BcUNLUEN0eW9FRWtVa2doSUN1OVJpN3d5NUhhZ1N6b0xhTHkwRXoyZ1NaRnBDbXFuZXQ3cnVvc2pzdWQ4NGtuS1lpeEU0SEpwTk5rS2pRYzBOVEZOMU5kTzRUT2kwYVFLYUlLMGt3Q0orTWQwVDBrczR0TkxRTitLN0ZObG1nSm9nbGhCSmdFYW5pMXdMMGcwUlo2bHU4S2JQbS9sV2FwQ1RUUmV4cVVmSTQyR3JtNUQwbSs3aUlaYzRkUU84ZzJTL0plVEF2Z1BwVCtxUVVRMFBLTkpsLytKbFc5dUpnTWE2WEhTU1J6SmZhWkpnSVpzeVVaVEE2RGg2L3lzMzIwazBiN29haHFRVkNja09vMlhPYzlBWDI4MDhpUmQxMjRrb1FoTkJqUXBpYmNidFZNa2prSGZOdXhUQnJleGpZRDlIS0hvQmozUmVIbVFSelE4cUNZUUtxRHAvVW1ndzdMV0MzQVlONW9xL2RHdjF1aXlYUHBUQzZCaENWZnBsMDdEZTdpU2VxRFRoTXcwSHBDSVYxNlgyNDJFRjJrRk95OE81MzVBSFNiZGxXalFCWUNWZ2V1V1JxUGh5NFlLanJVa3JoNEtwQ2lBSmdnREt5Q0o0aVhUWmJJNFNaZ0dkVG1Mejg2aUxoZWhjWUNrZGhLOU8xbnVFUXd3YWhxTjdkY3NCZEIwSHlKWWdoSlJROE9xZ0NiMC9qaEFFemYwT1FtTlIyUFB2YytvUDBWb0F1cFBsV25YblNpSkRZaEpPNFVqc1hDZjVacVRmTFVKMEhnck5JQkVlZ01FV0dGQktNNUpuYVpmd09tcU8va0QvYkJkZEpvc1BkYjE2VVJlNHptSjBJQjd4VEkyQlRpSjY1Z3NJSmZaazBLbWxJRTBSZHp6OEg1UzR2d01vdW5pQ1p3Qm9qTlNPeFhSRkJ4VFNEU3g5d2ZSOEpST25pVTNFd2F4T2ZjcFJjMlF5VXRUaXRxcGNUS2wyUkIvK1ZrSjBIUU9Pa1RTTDF3UWpaT3JZbys2NCsyRVBVUlRKeXVzMFFSaFQwWDk2VmZYRmcwOXlRYXNGZEdVY2RtazArUTBXUm1adHpCZVlZMm1YOG5yVmxMbTdUQ1pDeXQzNEdqRloyNWd3aDg3ZG5MSWdLYlBlMER0OUhsM3FNOWVucVhienhSSEorUFNyYTFHRS91elBLS1JaM2swcmhSbis4S1M4NTU1aVBxY1pUMEgxRTZSWjNsRVU5MmNoMVdlcGFzSTJZMjFBY2J1dWtnb2lDSk9TWnkwb29leUVJMXNITjJsMldpOEREd0ZSTk1YYWdVMFFUWmdSTzJFT20rbkh4VWUwU1RwczY3VHlEVVpqd3VRWk5sYkVUWFRsekxpY3Nsem10ckZwVDZqZnJhT3ZhalZVQmI0SVhjZ2lmUTNvVWM1YVFaRUpubjIzOU1pRFlDbXI2NWFFSTIwb3l0WUZDemNoNFhhQ2IwZE5LN1krNU1SVFc4SDBTVFpmZW9SdVVlbG5ORS9OaXFGV2Q2RDNJb1Nsc0kwRXVTR1ZpMWJCVzVCaTVaYkNRdGFSK1NzaVFIdm9kRVppMmk4dVA0am9zbmNqazB6R25TL2tMM0V5cmtsenB1cGlEdERVdmtaZXhMa0lNdjVDRzRJSDNaWmdmTlp4VitJcEVmdFBrVVVpMm5LeEkvUWFGaTRvaWp3MFU1QWg0ckUrdElDczRoRzR0NXFtdE9BV1E4am1xdkFjY21VSmpRdUs3R2hMczVvSnYzWlJDTXJGVWo3SUNwU0lJRU9hR1NUbHRuUTBRWGZvSmwxbVI4MW5ZaUFOUEFnUGdMWWpBemF6dHF3NEk1d0xHUm9LUVpSTUEzYTU5UlJEdUJERFBZU0RBd2Y1Y09jd2QyTmpMc1RXZXhVMUo4ZWNwMW16UVJrMWdkUmZ1SlNaNnM0SWowaWlNTW40dTdRNVJYRnlTTnBXbVZ4d1YzdTVBNGE2ajRrS2VuV2FDcVpKdm9SZTA4aXNrNjhPTllpVm1lTG4wMkZCUFhUaVY1bU5KUHpzZlR6TWM3YUNjaDk0aVg4UGVEenVvaThNSkJHRGdCMDlzbXNHemVqbVkzY1Rjek56aHlMeEg5ZmhBWWQ2V0ZjRFNSNGpFZzdXRG9KalVVTGxYeGRsTzJCK2hQN1pROTZWdkx6ZHZMVXp4Zmthc0FoSDFXUTZYTEFOVGxvSnVJeXk4YUJ3Nm96SGJZMzQ1RGRHc1E5NStDalJCTzJhTko3MG9pRnpRaHpIQnA0MzhSNTFzeEUvZXFDSjgrbUllSmxta1crdzBleHNoeVJuUkE0cWd5cWxIVFBIeU5XVFl1RUJ1a1hOTG5mREtjRjlZVzNlVUwyZWhCWG1RTnhoS09kQUM0cE1xZk1zV1FxczJjRjVCNk9ReWtDR202VVRDdUwzTjV4T09hQXVJakRNK2NSbXltZ0R0NkQ1U2hlTjVCOG1PUHcyRnJVbmVoblVqbU82elNQdXBPRnhxRCtsSDZSaVByVFR4TFlUcFZ4VFVtZ0VJeUxMQXcwOENyeURRNjh1MzNCdGtuRDdRdXNrU1JyR1VVd2ovNUVFQ1ZPREJUajJxQjJ1bXlDejJMM2VrRDZZSlFiYnloV1lwZE5LTk14eW5WUldOQ3dvckRIUXBydUEwTHJxenNOSXRyR3FidHNFVTMzRHNOdFhQcHRDRnBpWlhyRGRWenZGaTZ4NlcxSWtwc0Y5SG0vUUUyQVp1NzZUUktZNFJEL2ttaG9EcmZUamU4WkNkem0yMGlFd1JVeGo2OUcwWWlDZEJmY0g2WnhHMTdRTExBVEdqMG9kbDlMbmRGTVJoM0ZycTUxL3F5SWxrU2NlUTQ3eWF3N1lqeFp4TDlZNXFzbWxvM1BRcEhTamFaekdVMVZ2NllzYU4zaytZeDNXWUxtb1Y5a1ZzU2Mwclh4R2NtRU43bk92RWhwMkJnRmRiblltY3FlaGxvZnB1MGdyMWNhbGk2VUZQMDh5MmdsOS9NTUtCOUpEcENJaFdTTUcyajZlUjltNGdJZWVrbVV2TWwwaGM1Q3RFVjludk5IMUErUHV1TzZpZ0xQSVdFejdMSVI5MDlHWnpDclhnbWZuVVZvb1ByQlFVRUpxLys4TkJKVy8xbWdnbWhxVXNrdGsyRHR2ekFOVkZIWTZaeDFQS0NqQlZXUVoxQXcxQnFOUjlZYXEvOG9ySmo4cHJRS0s3S3lKQk1tVG55MGJJbFZmS2REWmdSbEVjRDdvOEkwQ1RtazZQWTV3VmdDejk3TWhQSVRLVkRBTVUyQmNSUkZRdE5SM0FKWkFLRERscStlRThKQ3lSd0d4VEdiS01xTDFpa0ZqYUhZUG9xR29qZ0pGQVJIcHF4NE1UUWFCdERwQjQ5R2sxbWs1Z3F5RUVSNkZ4Zzl5bTV5V3h6cVR1Q2p0Z1FVMnlmWG5BWEJBeVcrRWJJRjVlZ2xCbmNoTEJPUXp5Q3BNQlZwRUczajBTRlpIWml1S1BISkZZMDlDcVFSMGFCTU5CS3BqVWJYQ2FQd3Azcmc4SXljRFUwMCt0NlNLRU9pMFdHRVFtVVBXUTNBNHFYY2lzUTArdGJwS1o0MWdIeGx5c1NpL2tTUXZpbVhKRFdpUjNHbUg5SG9MQXdTUzBkWWFYbzdScnFjZ1UvZFN6cHB6VUJKOVJKS1R5bmZlazZ6R1B2VWpycFVmZUJ3c1ZxQVZlYzVIcXFSNkJRU2pWZ0JEaUtsSUpPV1duWE1Ec3BrOXRJWmtDOHZnSnVFUjZCT3FHTzNoRE1vTlVLd3hKaEdiMGZpNUNwQUltSEV0Y3J0NkF5MGpGUktOTG9SWkRNTmlOdFJTZGlTZHdiRmpncGlHOUhvOFlxV1k4cm9VYm9UeUZwU1Vxa2RmZWlHUTZxNUNCaUM0bk0wTEE4dUJRM2JrVVFEVVA4WVpNT1pDSnpMaGhGcW5Fa2dEdE53Q0F2VGFNK3FuQkRwRE1nMHE1ek00VXpSQlhObEpBdW5LazZWTDd5Y05icCtVZGxEMlpvQWZUVzAvNmtWMVd0UU9HMkNTTlJEbGlBc0NwT29lNkdkclRWSlgxU29FZzVESkJKVnVTOHNKNGhFZlZEbVd6bml2c3FYekovUkhLcXFORHZGYUxXb3FTS2syOUpDQ1BxbFVYYXl0YjBlNnBBNUpocHVTY3B4RUFHaFJua21TU3dtMFFnZ2NjaWFhUXRQRlRNcHl1bWM5T01uaGVQaHJGSHdtRWxWVUMrN0U0Y2Zrd2FrdXNRb2g5Y3hLSnlhdVVBR0ErbGpFY0FBRjhwcUx3QTJxU3RJQlFSbmtmMVhXTWZVWVpQRVcwdW94b0NFakZ1RTlpcFJTVDNxVnlHUkNJa005bndVOEtzRUlHSHBab2N5OHRRUk8xYThLUWNUUUREVHFVK3ByaG9GWTdWeXVuSFNTZkpJajFZcEtBY1AyV3NTWEFCTnc2NVIwb0pSUVphTitBT0s3Z3FKUmk3aU0raXVHZDRBRHg3VXIwYXFUaEhGYzZNRFlCdHhBRVU0b0NEK0tGWGNTaFlsaWxpTlp0d1VJcTcwaThLTWh0enY5d0R1V0krNzk0aTNBVitFUlVuOFIwNG1JdWxzOFpNUk9RaGlIc1h0Q3RqU1hjQ0FLejFQQmZXa3gwZ1kxRW9QR3dKRDdoRWJlZExab0J2MWcyUUhWRHgvM1I2Nm5pdGhYenF1YW1GY2dJQ0tjdG1mQUo2aVVPaVkvMzVFREtnK2d1RGxBZ3NBaEJPZVltOUZwK2pCVGdZMFVqcW1oQXB6S0FHbUllaW1Sd2lDdDZTbnZnY1dyV1NXcXZGU2duaENScDdxWVdqZHBCVDdac1NvcDJoZ202enBVd2FjTzRrMFZ2WDJnUUt0S3VsVXF2ZVBVR1VpZFZnMW9oTGJJd2pJSlBGZFFnVFE2NVEyZmtBSjg1bFBBSVRrUVY3Y3lyVVFnTktkTXRlUTBIUjdGbmQwQktzMkJLZGhKSEF0eEZoNkNkeENGell1a2dFV0VXcy9TWStCcXh4emxZMk9pZHdXUlZPdU1zb3BNbnljWlpUcDJjeUc5Z1NDR0FCMmI5dHZrbmFsbTgvTjlzZ0l1YWhaYlUxVEkvMFcyUHROVThnVkFTSnlQRWVCejJIMW1MUitCSGZZV3Frb0RjSnhNbk5GT0J1RWswb1Vlcnlma3lnODQ0Q1R3NGxmMUFCMFJzY3VGK0l4Y0NVeEZoc3pXZmQraVo1bFFUQ2t0NEoyR0VBWWdYZXNjbHMwQ1Y0U0NzaWhwSkxJSlpJekFJek9DLzQ2SVJtcTNDRVBJMCtHN2w4VUthemZWWG54Y1R0UXlJWE9BbEpOeVBXbmtRUkJ0SE1JY2pKWXdXOUU4YnFCSTBGb3VoQnFQNWtBSHFYYzA1RXJpTC9Bd3kzeDhtMUs5ZFJPd2tzVUxFUTl6ajJ3c0NJYS9WSTFTQ0NSOThBTkZ5UTB3Z2R3MjBkbmV4YmNSUWRvc3VBdTZpVHNTdVlsaG1nb0d0Y0RTNHV6UHFTZGlDNFNlRVl6dUFBZzFVaHFUdWxpVm5CSGlBYlVJMkFmRDlFQWRFR3htajF3bFZOVVJHUVMzWEV2S1BxOGZYVFlOaGJxakJWWkFBMHBiYjVPa0F5N1NwWUJUWWQ1Qk05aUhOWUFBbGM3U0NHS1pZdHlyeDlRSm4yLzhBcW95RUtVa0krQUV1VWpWOTFnRU5VS2FCZy9ENlc5eUcwOVNRNkFuMWNFYWh5RjFJdTNLeUNKRVlzRWN6dTBUS3VBSmpwZHlEV1NLSWlTRUYyd3g0MTdlTTJabUNZakdrYlBRd1Z5a2xqQkFRWE5ERFEvSk1Eb2FsWmdKeDBnaVFKZnFlK3N4TmUyREUySmJvcXRsTU1EWURzU0hVRHdsWWdteWJNQWNwUmJCQVVUd3ZBSjZDUzYvZzdTWVFDVUpzbkxJU0pvS1Q5d093RlFXaEJreW9pdjdIdC85Q3R5c3F4a1dBQVVLblJZUlRBUG9oQ0ZoRUNHeEhjZTBLSFZFZXNTQWtHTFlpV2pHNmdrWWVNUVQ3S0x1QVRxdGhCRW5KenJnQ0s3R1NwbEdrQ2pJQ0JFcnBwRFF0RVZnc2hHMVJBaDJscWVRVmQyWVpyQlJYTGlFNWhvUUtCTFlWMG1BTkRtSkpmTlJJSnd3TWlaSys0RW5TWkxuU0lFa3RhaE5NR0dxSXVkd1Z1eXk0TFJLMUgwVGhBa1NJZmFTWE9TTEkrQ3dGeFZtQU9pMVl6c3ZReVNPZ1RCU2pSTG5hWS9DWUpLeVl3RFZBVWpoMXBHK2ZYOW9Da0FhcTJET0FVWVgyY0ZKck9BcFVPaFh6SVJxSmtrRTZGYmF0a08yRk9QSGxVRlJWU0hYdXdJUklSR0NramtTUW0xRW1UZ0lNM0p5VEZjRVpQZDBpRkVFYWhTNlFDaHFEdFZxc21neEdVamp3SlFFZUt0RFJWRFRuakpLNFhoaVVGQVJDSHdUUlNBVUYyWWRtUVVhZ2ZDWk9RNVRaRnh3WVIxWTJmODZjVi9LMDRzZGRKbkVOQWQ1Q0N1T0plek40TzZrNFRORUtVZ2g4bks2Tm1UY0NhQ0lJZWpJS0VjeHdyRGFZYXlKM0I2b0hRSDViOEZtYXlLYUtLYmQ2ZmZDWUFzQ0k3R21TeWVJMEp2UnJIUkhhRVhScWtiV2FnVjBjaE5KUWdoVHVOS3hhTmtnSjZFR2FZNVA1TjJZbThIa0NSSmFkZlY4cEVIWVhCNlIwZTM5SWc3UFZVZlpGSm5BU3dCWU1BNWoweDlrTkdUSmRnZHprUWVYQWFaOFhsY1hZRnNrN3dJdUlCQkpCMWJJQUdTSXNnbkZqR24ydG1qaW1Uc3dYYUtJTEZNMm5FOTh6WUNtbzdFRFpJNXk3R1lHcUxwTU1qd1dSMEcyYUUrZDdScGo4WmVaaERRdVF3WVZyQ1lqOGk2QVpEWUdWSnlyb1BOWUtzZlFYTjFKMk1XWnlWRkZnQ1NLS3NIbkd5MXIyVk1JbHNpb2xGMVBOeUl1Tk1sQmtnN09PTGg2a0dYeFl5SjBKMUF4WXdGWDFFN1ZvSXlMQ0J4SFhHNUFob3ZXWGNHdGRNblMwKzdLMmJBVmxvMHJOZ3hjOUd6VXBnL3E4ZVNHTVFlU1JVRUJHVUdhMTNNZ0t6V2MxcUtQVUpXSjBEVDUxT0hGeWgyMlVKUzVqUitockpkck9Ub29qdTZZc2Z1ZzhPS21NZDJuTllWZFRpSGNhT2cwM1RJQkV6VEYyQUZORlhBUWZWN1VLcURKOGhOdXVBbW1nNzBZd0dOVGZOMm5EeExGKzdGaVFLR1hQekZqY3p0Z0o3Vlljb0RhaWRNNHRLSXBvTmE2MW1VeFMwZGd4V1NTRWF3N2swcTdvaWlpRWpxL0ZFRDJyZ0NtZzU3RGR1cHZjdDZPMzVncUFSQVltZHo3c2ZhQVR6MlkrMkErZlJqN2VnbmV2SEh0WVA2MDllT2JvaVdJN0lza0FkSFpObUUyQk1ubU1URkR4UjhOUExVOFVqUXlQTU1qNlQ0QVY2Qk90eWhqZUZFMUEwRDc2anF1cGxld2h5aXA0UWhuRkF6SGFFSHJQWXdFSG9pZXBTYnpybVUvc0hyS3d6QWZUajBIcHlMU3JOMzNQVUlhZko4NkgxOUFZRVJscW40Q2dPUzM2TkhkVlE1c0FiRFdHQUp0ZE1YV0VHelZXZVl6U1dPMDArL0NDNENmeFV0eURwck5EYk1aQ1hYNllPUVFVVFNvU1VLb3VtZ0VLaWRydVhxenBEU29hUWNJQmpRSmdIUjVIbG51aFFza0NaTk9qUEF0ZEdJa2l4QU5BZDVQcVRjd1VuUms3SWdrZ0NOdk9OZUlXUy9FZ2RNcFVGZEZwd1ZoNXJwVUVFRmRibWpyNEV1SjlrTkR0eVdsalIyZys3eXBDUnEyVlhBRUR2Q0RsWFVIemREWmk5SDJDSGRCVlFHcEJBYzFvQ2tSZDN4TTZqQjBrRTNIUER2bEE3ZU1hT1I2YktBSlBvNVNlOHhZazZTSGhzMG9SMW5YUTlQTEdsQW13ZjByTnpCc2hHWGUxb0U3SE1XN25qRXdiNy9nUEdUanZzUExiQ3VLc09GV2pjc3d2a0d6R01ENnI3VDBndXBPWENiUnpUeUxLQ2o1UUZjcnQ4dUVzME1EcW5rQWN6dFVUdE9udVhSMkozc3dBamJrZlVjVVRzZHZTOGhFbm1VUSt6cG16MmdvVXN6SGxHRTJZTFBjb1pPSmxUV1Y0UWt3dU9FQnQ2eDhqd2FlRWZiZ2pSZFp1alJYeVVmYXpPZy92VHlBdzZOYThnTXRDYzZpbTVFazlYUGJMZ25PbnFWUTg4cWNiNG5panpMSWY3VXZ2L1EwcWhwSm5mTGxFQ01LSGhzRmJuWGdSTlJCSmNjQ2wwSlpJUmJRa0p2OE9hVGhPZUlBSGlJSnM2SDd1cHM3UlF4Mk9DY1N5d1FYdStsUXdVdWlJUEJ6UjhWMG16YmxLRWN3TzUwN1FDMjAzSCswR3dObUQ4MEUxMGFBS2xjeE0rTndsZExtVlpxS2FYcjcraEJYWDMzYU53ZFVOdm5HWTNIcTczTWpvZ3k0UG5nNWhzUTFtaFl0ZThJeEw4YVpnZEpFYVBZSVg5QXA1a01mUk5OWHp2NlZOU2g4UUJKV1k4YUR5Q3hjd28vVTFQcVVIY0NwSm1xbm5Xb093SFNpUGdLaURsRDNiR0labFlYcGRGNE4zK1dqM1ArK0RMYlczWElPRFQwTUVQc0xiMkM2R1R0aEJubTV4UFNTSmNUSkptVmpTbDFqdUphNmhDNVFGR3BjMmpWdDB3am1KV3FjckFucTUvUlB6WlovY2h5bnBZL2JhRDU4WEUwZ25sZ0lJMUFtMEtCRmpvOGJKd0pxekFSbnIxNEY5cld2cGQrU3pOQkhVQTRkS2tEUjlXanJXOW5aWFQ2Y1JpUnE2R09lbU1KRGN0SXdRdGJaalNUS1dXVWU0OHU0SXRjQndXc3p0Y1pnUE1EelNiRkJDb2RVMTI5ODlDaDY2azZMQ3VvQzNUTHlzMW1IWHF1ajZvSm5LNnVtc0J6dFh0aTRMQ2M3QnpqWmpTVHBXSHJiTnA3b0JZb0ZDQmdVMXhUWmJvSzQwVDFsYm9yRWFuUXZVWVZXc3pzZTBSbFlJYUJnVkxOUmpzSWQ1KzZmT0JZa1ptdURpL21paFNaQ09oMnF0UE10dFpPczlNOE40MGNKNlhPYWJhMHM5UHNORHZOS1UySFNJTitwSzc2VEZVNlZIZHRXbDN4d1VHRW5VaTlNM00xREt1N3N3SmxnMmFtN3U0MG1LWVhlWU1LM2F4ZzVsRG9BcjVKNkdhRmgyZEZ4eDZFUHRwdXZVR3RyK3VwMEQwdElJYllEOTZMeEVKLytvR0xZS0JoQlNtQ2taQ0N5UmNiR2Q4U3NCcWZVVkJTa1IxWUZuU1BWNlF3QmJyZTVTRFppcTg1NlVZMUdSUm1JQm5wQ1JwTGlYejNLZUFvQTdMcVUwWnJXY29QWkx1ZzBDV3lKSE5DNFI2U0hsa01taXNHdXVVd1RoVFJUSmY2RlBXSEl0REpWcUk0TW4zb25IVWxnVE1LU1phVFJIaXQwV1JpTWswWlNyamp1Z3NGbC80anoycUJTYzZTR0ZwZ0xSSkowcVhhREhyZUM4ZkJpQWRGSXpHTWQyOFEzZ0hudWZLVFZCSzVMNndJSTQ2Z0ZRTFQ2QWdOREhOSUpQcWxUd2ZLcUNpTXRnT0FOQnFkeDhrSkRqV3FyMEpBTElMK0RERm9pb3hjeDZBcDdBV3NLT29tNW1PcERiMmRORXB0NkxJOVNoWnZSVUVhN1VDTGRVYkR5ZThWcVE5UnVGUFJUUXlsdVFZRzRkYmxoY0FHRUkwZVhCZ2tlS2M2aEVNbUFZaFVzVU1sQ1RJVEhvai93QmlGazZJZWtyQlNVWG5ySU1pNzFZTkNTYjVLTlE2UEtsc0lCRWlqMGJQb3ZjUzBVVUVUbFNSS2ZZY0FmSUJld3RncmNrVjd2cHpqWWVrMGdnY0JhNTc0WGh6RWc1eHJWNlNvaHdmNUZvN2pscWdabFVLaVBLc0g4ZFV1Q09TOFIwaU1raVZSQVVRK29ReGFtUWc5b2xUUUNua21JTHFrbFFsVkY0OGw1RFZlRnpvYVpwSjE2b0dDUVhDWU1peGRPdGt3Q3Uvb1ljOVVhY09KVkZFbjNVckNXSFZBODdTU2pWaFJpTHFSdTRVS0szWmtXY3dveXRwSURDZlJxTk51SkN5OG9uUVVJd2tYRmNXZEdvRzh4SDFtbUhsVWtNQktiUVVvZGF2NDF5c0lDYUdpSG5JRXFIcFQ1ZXFSRlVEODF5Z2xiRUIxMkNvNHlSVWtDbFNHL0twRzNjQnkxQk9GR2psZEJUV3pncnF2NU1DZjFMSXFqQURFRjJCcTNZL0VrMWl5dmxsNkhId0JaZ2hsbDFUUlNMVmxSNXB4T3ZUOEVZWEVzZmxGbEJxRm9Mc1ZxK2ZKVXBxc1p4SjFPUlhHRXVDa1pSVXd1ZGRScTNvcm1kRjRlbTY5UWlMUm1nUTlvSFczbDlMTVdaL29YbmN4UngxZ28xY2V6OEFBbHM4WWVxYnFKTFJjcU1DY1N1STVHaU9EbU96TXkxK0szcWtVdE0yeTBZVkw1bXdKVXNQMXJuQkdGSU9PcVYyUmxPa0VqT3hlZUM4bEFKNHRTSWxObDFmWGYySkVJRmJsaTA3Q3BySFhsMjRTdU9KR29vYWFKWWxZU3lCQ2pHRFBwTFNIR3NXU0pLb3lHVDEwS1hXWUN3Qm9rM3FNYkFVUEVwRG1XUFhWM1lIbFVMbkxsQ1hYS2V1V1ljb1NSSlYwUGJpUjhQVjlBcFZ2OHJFS0toaTA2YlhURVVuRXQzVXA5N1RiaExvaU40Y1pQS2RuNEtQZStvNVFBL2dmSnJBVk5FV1NNYVNHTjQ1WkJISmhrQURuWThxai9JcHhrNzRFM1hzMFNQWjZHZWV2MjBPUVVwUEJUVWczUThJc3Z1MWdWQzlEN3JDYm1xWVh6SkJscG5vbmdwZWdTNk52YzBLMERYakpCMy9FektrNlNSUTRQVkNZZzA3bGtQUWpOd1JCQmZhNndoa2tkZGNENzFtSUE0NWNOZE1DSzFVTXJLOCtpQ1VqR1N5cS80UFErakxiQjNvbExVWjRxYnFYT0xMVG93Qk03OGlab3Jub0JtVmtpQ1YyUFNxN2x3RkZrbzZHbS9obU9la2hGWWw5Qndub1pZa0RHYWs2c0s2aHRCRWs0SktUaXRBRWY2bHhQUFB4bUVHR0thRytVTEVMOWNnaUdJUEV1cEJlL0k5N291ckxoWXlERE1LUHhkYko0Q1FTMDU4QTdsUmpoYk04Y3dHR0ZXVUdFTHFXYW14VHpjdERCcXVUU25LMDJjZ1p4UE1iTHR0WWdIU2dlaEZNb1Z2MGpPZFRrTVZLam9GQ2plajJzK1dDN0FYbE1GZ3VmMWRBaVF2THJuQ0p1dFZjTDJ5SFZuQzMydVJHNDBiMXdPL3BPS0t4b29zQUp6cU5zU0NxdzBtbWlVRWhYRjRBcHd5cUJ1RkZzYmNvdjhnTEdvdEZIbDl5L2xWMjlVVGtSTFRNYU4wL1Q3VVFDanU1REhKcGNnRUxpL3lNQWdyblVHQzlsK0EraC9JWENNZy84cVE1NUtvbEY2c3JZQlVMTGo3UjZLNmk0RmlWY2hVVTNmQlNnZ0RCakFWeHczb0VNeE00MXBYTEZlczBMT3A0WWxIUkRRb0E5Q2hxbUxDNXBSQ0czb3hVcC9ZSW16eElBY3RHbzZOakVnaHprU0lYZ0lUVWtVYWl1MWlEaEZCNlZOeWM4RktqRkpVQXRUS1lRRjlkVVJ4UEFjRWJFZzVYbnRHdytjblZYMUJSamw2WkFsU3Y0QXhDTGhnUkFFMlFnaEdvK0RtRERRUEhFUmtNamtsQWJ6elBlQUN4d0pHdldYam53TElkVWdwQ2w2WXhDTW95aXRXZ3U3SEtOR0JVREd3U1VGUjJyKzJCL09WVTI0UDNLQ2ovMFRGZUE1cHhBV2NOS0pnanl0VVBWWGxBN2ZSQ0JycDdPb29GSGRCTmVzeGlMRVJVam9TQjM1bkdBNW9xeFE3MFlLb29hYk5VMGg1ZHJBWnBKd0dTekJSNnRINHNveTRBTEJGaXBVcUJIdHBOUlZ2RkN0SXZCYU5VZ0FvSkZWQ3BMSkpEMGxWSUxrY2l6OUxEb0pQQVE0WUVqcEZrUnAwQ2gyaXkxSjNRdzQ1R3laSUVUdlRFY0hwY284RUNtaUMxRlZCMWxDVHNBYVVlYksrVWtkRDl2NVVlNjFFcWlSV0xTUlVIT2ZQcGdocVFaQ0h4Z0tSWFRkQjNEVlUra2VJQnVyNmUvQ0pQMG5YdEpEN3BrSEVBUlpKNkVSVzEwNUg0OVcyVEJCeGZWenBUa0dvdUJkV05FUlN5VUJCdmdnd0tWWnBLb2pLRkF1NVVrOXpNTkpxTW5sV2xQM3IxaFNRNFc2RUE5RXp5a0F0NnVRNitrT0tBUFFZMWMrU0NrcW9IQUJMQkpkZmxkaVBKdmI0QUlPbnc1Z0YxdU1PYmcwb2pFc2NDUWUyVHdDVVJKTHNGTkIyc1dNOFJTa2tVTktDU1UzVVo4WkxwTWpsMTBDQUVxNTNTZ0lTMnFNdWxRMHNEa2c1Y0MycnZkTndjQTR5YVhzb0dvaytUVDF4b3dCTE1BNVZXdjlkLzhJcURNaXQ1SUcvRFBuZmtiWS9Hbm51ZlVYODY4blpBL2FrZE1odVYxaG5JMnc3UVdEL3Jjdzg3UlNHUmRNc2txTDJJUkhvREJGZ1pXUDBWOVNZS2QwQ3RxU0k0aWdZRXpWQTFvSTR6N0FGTjJVQWlOSHFBVXlwalUxUVVwempRbkNPZ3NYS1ZaQ0NOb01McE1XdEpvZ2trQkU2bjZlSUpuQUYxb0xQQzJrTWQyUmZJbFo2TGo2REFLWTdUejU4bE54TUdzYmtEcmhmVVRBZGNoMkdsSFhCZG4xSzY4KzZyRU5WTDZoeDBpQ1RqR3ptaWNSMGJHWFhIMndsN3NobDRxS0RBZ0pGMGJnVGkzVy9hSXdxcHpVYkFhaEJJUE5HVWNkbWswM1MwVTRQYUtYNnl3cklaOEhLNmxaVE5nTW9GYzJIbFNoaXQrTnh4MlNGLzdOakpPdnBFdG1QZUEycW56N3REZmZieUxGQTB3ZzRjWE4zYXluWUE0WUxLSlhiZ0xIczByaFJuKzhJT01INkwranhRdWxFN0E2VWIwWFNVVzhqRDJySFpVVld1dmpaZ3JTeGg0YXo4MTRTa2d5anIyQVRaaldNQUZQeHhFbXRoY2FCK1h6eTYrWktkaEhVZ2hPVHNSaVVIMkU0L0tqeWlTZEpuWGFlUmF6S0lWWjJkeExOWVlMRlNYVE41RXVKeUIxR0dOTFdMUzMxRy9Xd2RlMUdyb1N6d1ErNUFrZzc2akI3bFp0bndSQ1B0Z0xKVWZxeXVXaEJOQjQ5RzZTU2hEd3UxMHdHU014cFhuTUhjRXMwTXpEcjdJMGF5OXF3OUt1V00vckZSS2FQTW5xQ0UvRW1ubWNEYVVTVStBUUJCaXpaSklpT3MrZGRSYU55c0dRY3lMSEt2TnhCUXFVd3ZxWG9PcVJLZEJ0MHZaRDhRUU9POG1ZcTRNeVNWbjdFblFRNUdpYzRyWmI3TENwelBLdjVDSkQxcTl5bWlNb1dtVFB3SU9Rd2NYOTMxUGRwQldFaEVJNUZ4dWw4amh3SDJVOU9jQnN4NkdORmNCWTZyUS9PamNRMTg0amlqbWZSbkU4ME1hQy8zUWhNQkZkOEtpeVF0NDJabVNIS0RadFpsZnRSMElsQWFiQTRqRlJzMEk0TzJzelpRMHNoWXlOQlM3RlU2RE5ybllSSDdGNWIySEdqdllVWXpZWEIzSStQdVJCWTdGZlZIdUpQVHJCa0VGNVI3ZlpLNDFOa3FqcmllcXhXZ0pOZ2RJOUhRRmtuVDJoR09VSCtjM0VGRDNZY2taWEtUQmVibitsR2RJYWRsUDhDZG9EcGIvR3dxL0VDV0QyVkdNemtmcHhBWm81MkEzQ2QrWUJQQTg3cUl2RENRUmc0QWRQWjFkQWMzbzVtTjNFM01UVDlxb0xrNFc0U29pRndPNDJvZ3dXT2tGd2tOcy8ySGJqT3kxUDZoUXNpb1A3RmY5cUJuOWZxN3NKMDg5Zk9GQVoxdVVKODdYbklPTTVxSnVNeXljZUN3Nmt5SDdjMGduTHNjUmhVSjlDalJoQzJhOU5MaCsyRXpzNm9nVkFQNmdJRndSak1UOWFzTG5qeWJob2lYYVJiNURoK1ZCQWpQSXhvR2EwWHNpd0puQ1ZYVElxRkJvTTVvdnhsT0Mrb0xiL09FN1BVd1lCOXpuTFdEMEVlcE85MENLTE5uSVl5YkhPZlZ6WWltWXB1ZUs0UEhtWmNyRHMrY1IyenV0YTl4aGZGKzhRUkl1c2ZXb3U1RVA1UEtjVnluZWRTZDNNc2d3d3JqL1NJUjlhZWZKTENkWG1WcFNnS0ZvTlJ6Q2dzYWVNZmZnZ1B2Ymwrd2JkSncrd0pySkEwTUpUMnVZUFFuZ2loeFlxQVkxd2ExMDJVVGZGWVdYTkdLdUp6U1RLekVMcHRRamVnNGtJYlJzRHJRc0lVME16anpmQ3hmRnRFMjdpVkNQYUxwM21HNGpYc05SNGVXV0puZWNCM1h1NFZMYkhvYmt1Um1BWDNlTDFCUmJmcTU2L2RZQ2N5ajVkNFI5V0U3M2ZpZWtjQnR2bzFFR0Z3Ujg2U3FDQ0FZVmZvS291azEyOUFzU1BrZ1JEQ0RyaDgwazFGSHNhdHJuVDhyb2lVUlo1N0RORWVUSDQ5Q0dOZEVVK2FySnBhTnowS1IwcGtoSkdCMW9aekdOV1ZCNnliUFo3ekxFalFQL1NLekl1YVVTUm02UVRMaFRhNHpMMUlhTmtaQlhlNGxuS0JFNm1wOW1MYUR2RjVwV0xwUVV2VHpMS09WM004em9IejBLbjBSQzhrWU45RDA4ejdNeEFVODlIb053OGwwaGM1Q3RFVjludk9uZytLajduVGdmRGlza1hvUHp6TngvMlIwQmxmQlZZUm5aeEVhcUg1d1VGREM2bjhTbkVlby9yTkFCZEhVcEpKYkpzSGFmMkVhcUtKWWdVbkkwUElSdEFXTExIamVYQVZOYWE5S2pNS0tjeStTREVIL0pCTW1UbnkwUmtBa3lzd2ZSVmtFOFA2b01FMUNEaW02ZlU0d2xzQ3pOek9oL01UTWdGQkVVMkFjUlpIUWRCUzNRQllBNkxBVnRJK0VUQTBPZytLWVRSVGxSZXVVZ3NaUWJCOUZRMlVFMDVzNmNFNEFBU1FVMGhuSHdhUFJTQkhEREpBZWswanZBcU5IQlFHVWtJVmdpSHhnWkNJUTJ5ZlhuQ1VoUEVpK0Vlb1YvVFFhZTBSRjFPTnZ6VUJGMURXSUtHaTJGUlhBaUJLZlhOSFlZeG80YUxwbkpvcTNoR0N0ZEJyaFQvWEE0U2tWM1JqOFRtOUhBdVV3Vm1GbER4a0U0d3NDbmR0bzlLM1RVenhyQVBuS2xJbEYvWWtnZmJORHlVWDBLQ2ZvWkJHd01FZ3NYYzJvblk0eG1JRlAzVXM2YWMxQVNmVVNTazhwMzNwT3N4ajdOWVA0Tmg4NFhLd1dZTlY1am9lcVJiL1k5eEtOV0N2d2hEdVcvdFNNRGxYWTU3eWdmSGtHQ0NJYWZhODdka3M0ZzFJakhOL1lNSTNlanNUSlZZQkVRbG5sYmVOUk96b0RMUmVhSXhyZENMSU10TVR0cUNSc3lUdURZa2N0WXhZUmpSNnZhRG1takI2bE80R3NKU1dWMmdIUWdCeFM3UXdxaVd2NHlITEdnMHRCdzNZazBlaDJoMkdRRFdjUWFMZGhoQnBuRW9qRE5CekN3alRhc3lvblJEb0RNczBxSjNNNFUzVEJYQm5Kd3FtS1UrVUxMMmVOcmw5VTlsQzJKa0JmR1ptU1dsRzlCb1hUSm9oRVBXUUp3cUl3aWJvWDJ0bGFrL1JGaFNyaE1FUWlVWlg3d25LQ1NOUUhaYjZWSSs2cmZNbjhHYzJocWtxelU0eFdpNW9xUXJvdExZU2dYeHBsSjFzYm9LdG1qb21HV3pJeGZySXpJR0VuU1dKeExmb0dTRW5RWUxNdVpsS1Uwem5weDA4S3g4TlpvK0F4UTd6UHhPSEh2U2FVUW1MWTJ5V0Z3TmRKb3RTUEt3Q3BqVUNxQnk2N1FpRUtVZ0hCV1dUL0ZkWXhkZGdrOGRhMlpaVUFDUm0zWkZPcXlFa2NsZFNqZmhVU2laRElZTTlIQWIraVBDYTFMMTR5OHRRUk8xYThLUWZUNnlSMDZsT3FxMFpoQlhnUjFDTGxtNXFlSHExU1VBNGVzdGNrdUFDYWhsMmpqRlhmUUpMNXd3WnYxRW40SWo2RDdwcmhEZkRnUWYxcXBPb1VIUUZQZFVKS2ZoOHNVaEdOZUJSQXBVTEpva1FScTlSSXowc0FYT2tYaFJrTnVkL3ZBZHl4SG5mdkVXOER2Z2dUQUVQb1pJcEczR3NBeVdHTUNEaVRvOENnMDIwUjZHM1BpZ0hMcWFjamdNZjBHQW1EV3VsaFEyRElQV0lqVHpvTFNrME9rbGNLcUdnUHB2M1BFZ2JSd2JYSi8yRXQxUHVzcVc5Ly9LLy8vT05mVndkaStIK0h2L3hoOWROZmZ2dWRPZnhoL1pzZnYxLy95amZtOEpVOWZQOTd4UUNRemp2K2grVDc5MzlTKy9YOWJ3Ly9hSXl2di9wZUM0MXZ1Mk9ReGFZemhHL2E3OUorVFB1Ny9UYSsvWHcweHJYM3pTZXRtYSsveDVPcGNPL0c2VlFTQmNaa05xYTE0YXpQcFYxTkpWaFBKRENyYVFUV0hQNTVqWmprdzhNLzY0a0ZwUGMxbzJTdFl5N0xaMnQ3NUR2RXNGVm1iRnV5bEhnL2Z0YVhyYjVvVjVjc1dyQVB5elcwdlJhaXVtQWZscXYxNit0c1paWE4xOWlyWmdrWlFkdFlFdDRMU3l4WjFOdDRFdDhOVDVxQ3Q1RW42ZDN3cEdtN0czbVMzd3RQSFBrNnR2R2t2QnVlNU0zSFRuMHVua3dVbDY0ZXJDb3VsL3JGS3VPa21hamtZUDcrN3grblIweDZUNTZ4KysyOWRlYXV1eC9MWFhlZlhMejMyMzFIM3ZJNzduNTJyN3I3cXZuT2NyK1BncW9FbE9MZnVnbnZhcmZObTQwZVA1emI1WmJlUzYvZlBtL0d1WG1sNW5tYmlqK3RmL0pNeHZuVU5VVzNQTTBVZXR5eW5xcGNyMk54Vy9QRUMvZHVXTVFwYXh1WlZGOTJkMjlac2JhNmZjWHVLM1ppZUwrcUZadnF2bUwzRlR0eEtYNnBGZnZxbkNjU1FMNjc3TTlaNHNQdW5yNWdpVFc3Si9hY0pTVy9xTS94RlhJaytTMGMrZmh1T0dJUFlkT3VDZTlLdmxJazJWYXV4QmZ5Mkh2eXV2cEhPczVpYStoRi9IN1VlMlB1dVBjMjUzdnVmYnpubFVNaFUzZmNlNVB1dVBmbG5oZE9ySGZjZVgvUHk4YTYxOVA1SzRQNEh3NS85OE1mZi9PWG4vL3VGNURzRjFzKzB6NVpmMy85WGQyRDlCQm5XQk9WYzAwbmEwS2ZrWWR2Y1QzVms0a3dERXhNQ2xiMStZejc5STBjUGFYZ0VockdLZXVQREY5bjg1WisyTFBEc3lseDFwOXFjYjlzWC92NWQzLzU2ZkREWCtudmRQanJEeitkOWN5NlNKNnp6KzNWaGZwRldTcVovdlcwREVQd1o1eTRWREZQRk10cmRkSnl0REYzMFV1NUxFTWI5L3N6bG8rUVdDOTNhajdMWFpwM1BlNDF5MTFhK05SKzhrTU1MTkdGancvLzdXSy9penN6VjQ2S3A2WnVJdi9rMFN0WktHSmxvVDZlVGhUVzJqRWIxM1QxTXgxOVRUZS9aR2Y3VGNsNUtaK3I1cWM4UFZmSE9UQitmQmlDTUpjWlM0eTI4dC8yMThUUTh5K2U2Tys2M3Y3aS9Pamg5aE9lZkxqa1NUMWpDZC9wOW5VVzR6MnlvZFlsWjlwdG1CSHUxeWZ6Ym1VZDhPOFB0T0h1Y2VBQ2xrSTU3SGprNXB0N1hlR01jMkRtSTNSdEx0MWQ3MlhLSEtRMHhNazQyMXB0MGxsOER6VGVEeFJ4U3o2ci90TU9CdnZwNXZGcmFzdVd3eUk3eXVHa0xMSzhsQnVPaThOMXdNdm5zUEgwSHNxMERpaU11d3hmZjRwRjhkUWphR0lzMGxKSHczQ3ZmeGlVMXUvd0tQSVRyZEMxZDYvZjYrOTgvZE52UC8zSFR6Ly83cWVmZi9IL0FmbW9lVllLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ28ySURBZ2IySnFDanc4Q2k5VWVYQmxMMFY0ZEVkVGRHRjBaUW92WTJFZ01RbytQZ3BsYm1Sdlltb0tOeUF3SUc5aWFnbzhQQW92Vkhsd1pTOUdiMjUwUkdWelkzSnBjSFJ2Y2dvdlFYTmpaVzUwSURFd056a0tMME5oY0VobGFXZG9kQ0EzTURBS0wwUmxjMk5sYm5RZ0xUSTFNUW92Um14aFozTWdNeklLTDBadmJuUkNRbTk0V3kwMU56TWdMVFF4TVNBeE9UazVJREV5T1RoZENpOUpkR0ZzYVdOQmJtZHNaU0F3Q2k5VGRHVnRWaUF3Q2k5WVNHVnBaMmgwSURVd01Bb3ZSbTl1ZEU1aGJXVXZRMFpNVGxCQksxTmxaMjlsVlVrc1VtVm5kV3hoY2dvdlJtOXVkRVpwYkdVeUlEa3hJREFnVWdvK1BncGxibVJ2WW1vS09DQXdJRzlpYWdvOFBBb3ZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxDaTlNWlc1bmRHZ2dOalE0Q2o0K0NuTjBjbVZoYlFwNG5GMlZ5MjdpUUJCRjkwajVoMTRtaXdqM0c2U29KRUlTaWNVOE5NeDhBTEdieU5KZ0xPTXMrUHN4VmRjMW8xbHdKSXA2M2k2Nmw5dmR5NjVyUjdQOFBwenJmUm5Oc2UyYW9Wek9uME5kekh2NWFMdUZkYVpwNnhIZm1QWHAwQzl1d2Z2clpTeW5YWGM4bTZjbnMvd3gvWGdaaDZ1NTN6VG45L0t3L0RZMFpXaTdEM1AvYTd0L1dPNC8rLzUzT1pWdU5CV1JhY3B4eXZMbDBIODluSXBaY3N6anJwbCtic2ZyNHhSeDh6RHM4ZlBhRitNNHdrb245YmtwbC81UWwrSFFmWlM3eFZOVlZaNG1yanpkTFVyWC9PK1F2UVMrSC85R2VJNFF4b3JZRmxla3pGRnM0WTJVYVF1L2lwVHBCVFpIeXZRR215Vmxla1crUU1wazRSZEptUjFzVzFMbU5mMHpwZENoWjdjbVpVaW9rVWlaUFBKbFV1WUFQODR1VEtqaDJVTVlaejlXUkppZ1MrVHN3b3dhbmljUXhua09VWmlaNTU0NXV6Q2dodU11aEFHOTJCZFMrZzM4TnFRTUdUYnVUQmpRbjJXRmhSNDZXNjRvOUtock9aUFFJNS9scVlRZXM5bG5Vdm9WYkR5VjBHTTJ5eE1JL2F5cEpXWEFIdmdOS2VNOEIyK1pNR0RYSEU4dkROQWdiRWlaRU91bDJ3UzF4ZStWbE9rWmZ0S1piQmY2YzN4aXdvQnpDenlwTU0zenNzSkNENTBkS3l3TXM4NjhqVUkvNzJRbVpZTDJ2aUpsd1AvSThRVENnRGtjZHlFTTZDVkVVaWIwYkZsaG9ZUE9sck1MSFdwWS9wY0tIZjZybnI4SkEyeVdzd3M5YWxROHZkQkJnNHBQVE9od2JtRk55Z1FOL0pxVWNiYXRTQm1Sejh2R015UE92T0xwaFE0YVZIeUtRb2V6akJ0U1p1eEc1Q2hoUnF3UHBJenpQYlFtWlVaLzdwV1VBVHZrUkdIWmF1anNLbEw2K1U0TXBNeW9VWEYyb1VNTnk5bUZIalZXODQwKzhibVNlMTN2NzlzZFB6MUVSbCtRK25NWXBzZURYeXQrTlc3dlJkc1ZmZEQ2YzIrbXFOdm5EN3hlaStjS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBadmJuUUtMMU4xWW5SNWNHVXZRMGxFUm05dWRGUjVjR1V5Q2k5RFNVUlRlWE4wWlcxSmJtWnZDanc4Q2k5UGNtUmxjbWx1WnloSlpHVnVkR2wwZVNrS0wxSmxaMmx6ZEhKNUtFRmtiMkpsS1FvdlUzVndjR3hsYldWdWRDQXdDajQrQ2k5R2IyNTBSR1Z6WTNKcGNIUnZjaUEzSURBZ1Vnb3ZRbUZ6WlVadmJuUXZRMFpNVGxCQksxTmxaMjlsVlVrc1VtVm5kV3hoY2dvdlZ5QmJNMXN5TnpOZE9GczRNVGhkT1ZzNE1EQmRNVEZiTXpBeFhURXlXek13TVYweE5Wc3lNVFpkTVRaYk16azVYVEUzV3pJeE5sMHhPRnN6T0RsZE1UbGJOVE01WFRJd1d6VXpPVjB5TVZzMU16bGRNakpiTlRNNVhUSXpXelV6T1YweU5GczFNemxkTWpWYk5UTTVYVEkyV3pVek9WMHlOMXMxTXpsZE1qaGJOVE01WFRJNVd6SXhObDB6TUZzeU1UWmRNekpiTmpnMFhUTXpXelk0TkYwek5sczJORFZkTXpkYk5UY3pYVE00V3pZeE9WMHpPVnMzTURGZE5EQmJOVEExWFRReFd6UTRPRjAwTWxzMk9EWmRORE5iTnpBNVhUUTBXekkyTmwwME5Wc3pOVFpkTkRaYk5UZ3dYVFEzV3pRM01GMDBPRnM0T1RkZE5EbGJOelE0WFRVd1d6YzFNMTAxTVZzMU5qQmROVEpiTnpVelhUVXpXelU1T0YwMU5GczFNekZkTlRWYk5USXpYVFUyV3pZNE4xMDFOMXMyTWpGZE5UaGJPVE0wWFRZd1d6VTFNbDAyTVZzMU56QmROamhiTlRBNFhUWTVXelU0TjEwM01GczBOakZkTnpGYk5UZzRYVGN5V3pVeU1sMDNNMXN6TVRKZE56UmJOVGc0WFRjMVd6VTJOVjAzTmxzeU5ESmROemhiTkRrM1hUYzVXekkwTWwwNE1GczROakZkT0RGYk5UWTFYVGd5V3pVNE5WMDRNMXMxT0RkZE9EUmJOVGc0WFRnMVd6TTBOMTA0TmxzME1qUmRPRGRiTXpNNFhUZzRXelUyTlYwNE9WczBOemxkT1RCYk56SXlYVGt4V3pRMU9GMDVNbHMwT0ROZE1UTXhXek0zTmwxZENqNCtDbVZ1Wkc5aWFnb3hNQ0F3SUc5aWFnbzhQQW92Vkhsd1pTOUdiMjUwQ2k5VGRXSjBlWEJsTDFSNWNHVXdDaTlGYm1OdlpHbHVaeTlKWkdWdWRHbDBlUzFJQ2k5VWIxVnVhV052WkdVZ09DQXdJRklLTDBKaGMyVkdiMjUwTDBOR1RFNVFRU3RUWldkdlpWVkpMRkpsWjNWc1lYSUtMMFJsYzJObGJtUmhiblJHYjI1MGMxczVJREFnVWwwS1BqNEtaVzVrYjJKcUNqRXhJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LTVRJZ01DQnZZbW9LUER3S0wxUjVjR1V2VUdGMGRHVnliZ292VUdGMGRHVnlibFI1Y0dVZ01Rb3ZVR0ZwYm5SVWVYQmxJREVLTDFScGJHbHVaMVI1Y0dVZ013b3ZUV0YwY21sNElGc3dMamMxSURBZ01DQXRNQzQzTlNBek16TXVNek1nTkRNeUxqZzVNVjBLTDBKQ2IzaGJNQ0F3SURFMElEbGRDaTlZVTNSbGNDQXlPQW92V1ZOMFpYQWdNVGdLTDFKbGMyOTFjbU5sY3dvOFBBb3ZVSEp2WTFObGRDQmJMMUJFUmk5VVpYaDBMMGx0WVdkbFFpOUpiV0ZuWlVNdlNXMWhaMlZKWFFvdlJYaDBSMU4wWVhSbENqdzhDaTlIVXpBZ01UTWdNQ0JTQ2o0K0NpOVlUMkpxWldOMENqdzhDaTlHYlRBZ01UUWdNQ0JTQ2o0K0NqNCtDaTlNWlc1bmRHZ2dPRE1LUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXdMams1TkNBd0lEQWdNQzQ1T1RRZ01DQXdJR050Q2lBZ0wwZFRNQ0JuY3dvZ0lDOUdiVEFnUkc4S1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveE15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDakUwSURBZ2IySnFDanc4Q2k5VWVYQmxMMWhQWW1wbFkzUUtMMU4xWW5SNWNHVXZSbTl5YlFvdlFrSnZlRnN3SURjdU9Ua3lJREV6TGpBNE55QXRNQzR3TmpSZENpOU5ZWFJ5YVhnZ1d6RWdNQ0F3SURFZ01DQXdYUW92VEdWdVozUm9JRE15TWdvK1BncHpkSEpsWVcwS2NTQWxJQzB0SUVKbFoybHVRMjl1ZEdWdWRBb2dJQzB4TURBZ1ZIb0tJQ0J4Q2lBZ2NTQWxJQzB0SUdKbFoybHVJRlpwYzNWaGJBb2dJQ0FnY1NBbElDMHRJR0psWjJsdUlFTmhiblpoY3dvZ0lDQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1VHRjBhQW9nSUNBZ0lDQWdJREF1TWpBNElEQXVOak14SURBdU1UY3pJQ0J5WndvZ0lDQWdJQ0FnSURFMExqQTROeUE0TGpreU9DQnRDaUFnSUNBZ0lDQWdOeTR5TnpjZ01DQnNDaUFnSUNBZ0lDQWdNQ0E0TGpreU9DQnNDaUFnSUNBZ0lDQWdNVFF1TURnM0lEZ3VPVEk0SUd3S0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ1pnb2dJQ0FnSUNCUklDVWdMUzBnWlc1a0lGQmhkR2dLSUNBZ0lGRWdKU0F0TFNCbGJtUWdRMkZ1ZG1GekNpQWdVU0FsSUMwdElHVnVaQ0JXYVhOMVlXd0tJQ0JSQ2xFZ0pTQXRMU0JGYm1SRGIyNTBaVzUwQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9LTVRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnb3hOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJRE16TXk0ek15QTBNVFl1TVRRMlhRb3ZRa0p2ZUZzd0lEQWdNVFFnT1YwS0wxaFRkR1Z3SURJNENpOVpVM1JsY0NBeE9Bb3ZVbVZ6YjNWeVkyVnpDanc4Q2k5UWNtOWpVMlYwSUZzdlVFUkdMMVJsZUhRdlNXMWhaMlZDTDBsdFlXZGxReTlKYldGblpVbGRDaTlGZUhSSFUzUmhkR1VLUER3S0wwZFRNQ0F4TnlBd0lGSUtQajRLTDFoUFltcGxZM1FLUER3S0wwWnRNQ0F4T0NBd0lGSUtQajRLUGo0S0wweGxibWQwYUNBNE13bytQZ3B6ZEhKbFlXMEtjU0FsSUMwdElFSmxaMmx1UTI5dWRHVnVkQW9nSURBdU9UazBJREFnTUNBd0xqazVOQ0F3SURBZ1kyMEtJQ0F2UjFNd0lHZHpDaUFnTDBadE1DQkVid3BSSUNVZ0xTMGdSVzVrUTI5dWRHVnVkQXBsYm1SemRISmxZVzBLWlc1a2IySnFDakUzSURBZ2IySnFDanc4Q2k5VWVYQmxMMFY0ZEVkVGRHRjBaUW92UVVsVElHWmhiSE5sQ2k5Q1RTOU9iM0p0WVd3S0wwTkJJREVLTDJOaElERUtMMjl3SUdaaGJITmxDaTlQVUNCbVlXeHpaUW92VTBFZ2RISjFaUW92VTAxaGMyc3ZUbTl1WlFvK1BncGxibVJ2WW1vS01UZ2dNQ0J2WW1vS1BEd0tMMVI1Y0dVdldFOWlhbVZqZEFvdlUzVmlkSGx3WlM5R2IzSnRDaTlDUW05NFd6QWdOeTQ1T1RJZ01UTXVNRGczSUMwd0xqQTJORjBLTDAxaGRISnBlQ0JiTVNBd0lEQWdNU0F3SURCZENpOU1aVzVuZEdnZ016QXdDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ0xURXdNQ0JVZWdvZ0lIRUtJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1ZtbHpkV0ZzQ2lBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnUTJGdWRtRnpDaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01TQXdMakF3T0NBd0lDQnlad29nSUNBZ0lDQWdJREFnTUNCdENpQWdJQ0FnSUNBZ05pNDRNU0E0TGpreU9DQnNDaUFnSUNBZ0lDQWdNVFF1TURnM0lEQWdiQW9nSUNBZ0lDQWdJREFnTUNCc0NpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pFNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tNakFnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0YwZEdWeWJnb3ZVR0YwZEdWeWJsUjVjR1VnTVFvdlVHRnBiblJVZVhCbElERUtMMVJwYkdsdVoxUjVjR1VnTXdvdlRXRjBjbWw0SUZzd0xqYzFJREFnTUNBdE1DNDNOU0F6TXpNdU16TWdNems1TGpRd01WMEtMMEpDYjNoYk1DQXdJREUwSURsZENpOVlVM1JsY0NBeU9Bb3ZXVk4wWlhBZ01UZ0tMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTWpFZ01DQlNDajQrQ2k5WVQySnFaV04wQ2p3OENpOUdiVEFnTWpJZ01DQlNDajQrQ2o0K0NpOU1aVzVuZEdnZ09ETUtQajRLYzNSeVpXRnRDbkVnSlNBdExTQkNaV2RwYmtOdmJuUmxiblFLSUNBd0xqazVOQ0F3SURBZ01DNDVPVFFnTUNBd0lHTnRDaUFnTDBkVE1DQm5jd29nSUM5R2JUQWdSRzhLVVNBbElDMHRJRVZ1WkVOdmJuUmxiblFLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ295TVNBd0lHOWlhZ284UEFvdlZIbHdaUzlGZUhSSFUzUmhkR1VLTDBGSlV5Qm1ZV3h6WlFvdlFrMHZUbTl5YldGc0NpOURRU0F4Q2k5allTQXhDaTl2Y0NCbVlXeHpaUW92VDFBZ1ptRnNjMlVLTDFOQklIUnlkV1VLTDFOTllYTnJMMDV2Ym1VS1BqNEtaVzVrYjJKcUNqSXlJREFnYjJKcUNqdzhDaTlVZVhCbEwxaFBZbXBsWTNRS0wxTjFZblI1Y0dVdlJtOXliUW92UWtKdmVGc3dJRGN1T1RreUlERXpMakE0TnlBdE1DNHdOalJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lETXdNQW8rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lDMHhNREFnVkhvS0lDQnhDaUFnY1NBbElDMHRJR0psWjJsdUlGWnBjM1ZoYkFvZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUVOaGJuWmhjd29nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lERWdNQzR3TURnZ01DQWdjbWNLSUNBZ0lDQWdJQ0F3SURBZ2JRb2dJQ0FnSUNBZ0lEWXVPREVnT0M0NU1qZ2diQW9nSUNBZ0lDQWdJREUwTGpBNE55QXdJR3dLSUNBZ0lDQWdJQ0F3SURBZ2JBb2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQm1DaUFnSUNBZ0lGRWdKU0F0TFNCbGJtUWdVR0YwYUFvZ0lDQWdVU0FsSUMwdElHVnVaQ0JEWVc1MllYTUtJQ0JSSUNVZ0xTMGdaVzVrSUZacGMzVmhiQW9nSUZFS1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdveU15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDakkwSURBZ2IySnFDanc4Q2k5VWVYQmxMMUJoZEhSbGNtNEtMMUJoZEhSbGNtNVVlWEJsSURFS0wxQmhhVzUwVkhsd1pTQXhDaTlVYVd4cGJtZFVlWEJsSURNS0wwMWhkSEpwZUNCYk1DNDNOU0F3SURBZ0xUQXVOelVnTXpNekxqTXpJRE00TWk0Mk5UWmRDaTlDUW05NFd6QWdNQ0F4TkNBNVhRb3ZXRk4wWlhBZ01qZ0tMMWxUZEdWd0lERTRDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURJMUlEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURJMklEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEZ3pDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01DNDVPVFFnTUNBd0lEQXVPVGswSURBZ01DQmpiUW9nSUM5SFV6QWdaM01LSUNBdlJtMHdJRVJ2Q2xFZ0pTQXRMU0JGYm1SRGIyNTBaVzUwQ21WdVpITjBjbVZoYlFwbGJtUnZZbW9LTWpVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnb3lOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVlUMkpxWldOMENpOVRkV0owZVhCbEwwWnZjbTBLTDBKQ2IzaGJNQ0EzTGprNU1pQXhNeTR3T0RjZ0xUQXVNRFkwWFFvdlRXRjBjbWw0SUZzeElEQWdNQ0F4SURBZ01GMEtMMHhsYm1kMGFDQXpNaklLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdMakl3T0NBd0xqWXpNU0F3TGpFM015QWdjbWNLSUNBZ0lDQWdJQ0F4TkM0d09EY2dPQzQ1TWpnZ2JRb2dJQ0FnSUNBZ0lEY3VNamMzSURBZ2JBb2dJQ0FnSUNBZ0lEQWdPQzQ1TWpnZ2JBb2dJQ0FnSUNBZ0lERTBMakE0TnlBNExqa3lPQ0JzQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNCUklDVWdMUzBnWlc1a0lFTmhiblpoY3dvZ0lGRWdKU0F0TFNCbGJtUWdWbWx6ZFdGc0NpQWdVUXBSSUNVZ0xTMGdSVzVrUTI5dWRHVnVkQXBsYm1SemRISmxZVzBLWlc1a2IySnFDakkzSURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5SRVpYTmpjbWx3ZEc5eUNpOUJjMk5sYm5RZ01UQTNPUW92UTJGd1NHVnBaMmgwSURjd01Bb3ZSR1Z6WTJWdWRDQXRNalV4Q2k5R2JHRm5jeUF6TWdvdlJtOXVkRUpDYjNoYkxUVTNNeUF0TkRNeElERTVPVGtnTVRJNU9GMEtMMGwwWVd4cFkwRnVaMnhsSURBS0wxTjBaVzFXSURBS0wxaElaV2xuYUhRZ05UQXdDaTlHYjI1MFRtRnRaUzlWVWt4U1VGZ3JVMlZuYjJWVlNTeENiMnhrQ2k5R2IyNTBSbWxzWlRJZ09USWdNQ0JTQ2o0K0NtVnVaRzlpYWdveU9DQXdJRzlpYWdvOFBBb3ZSbWxzZEdWeUwwWnNZWFJsUkdWamIyUmxDaTlNWlc1bmRHZ2dNelEzQ2o0K0NuTjBjbVZoYlFwNG5GMlNUNHVETUJERjc0VitoeHpiUTFGVEUxc29BNlhkZ29mOXc3cjdBYXdaaTdER0VPM0JiNzh4Q2JPd0IzK1F5WHZKeEhuSnBieVd1cHRZOG1HSHBzS0p0WjFXRnNmaGFSdGtkM3gwZXBWeHBycG1paXZQcHEvTmFqRlg4emhoWCtwMllLY1RTejdkNWpqWm1XM09hcmpqTm5tM0NtMm5IMnp6ZmFtMlNmVTA1Z2Q3MUJOTEFaakMxcDN5V3B1M3VrZVdlTSt1Vkc2N20rYWRjeXdLNWhWZnMwSEd2U01MblRTRHd0SFVEZHBhUDNDOU9xVnB1Z2RIY1lEMUNyWDZMK0JwTU43YlB3Yy9BakdYNEd0N3Z3b1VzY1lsRVBOOTFKMkJLSXBReTNNZ3lpelVoQUJpd1dNdEE2SjhpZDRMRU9VeDF2enBnVExlSVNRUWk5aExlSGtnVDJQUEJSQmRSOEY3QUdJaDRqdThJbEJFWGU0VmdUTHFSQUhFSXVxeUt4RGRud2ozM29Eb1hoUHVTSUdZWDJPTkF6Ry9oWm5SYkpiNXVaQXhTa2Z6dE5ZRnd5ZlJKMkxKUXFlUndtb0d3NXhyK1g0QmdFeThBUXBsYm1SemRISmxZVzBLWlc1a2IySnFDakk1SURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5RS0wxTjFZblI1Y0dVdlEwbEVSbTl1ZEZSNWNHVXlDaTlEU1VSVGVYTjBaVzFKYm1adkNqdzhDaTlQY21SbGNtbHVaeWhKWkdWdWRHbDBlU2tLTDFKbFoybHpkSEo1S0VGa2IySmxLUW92VTNWd2NHeGxiV1Z1ZENBd0NqNCtDaTlHYjI1MFJHVnpZM0pwY0hSdmNpQXlOeUF3SUZJS0wwSmhjMlZHYjI1MEwxVlNURkpRV0N0VFpXZHZaVlZKTEVKdmJHUUtMMWNnV3pOYk1qYzFYVEk1V3pJM01GMHpPRnMyTWpSZE16bGJOek0zWFRReFd6VXlNRjAwTjFzMU1URmRORGhiT1RVM1hUVXdXemMxT0YwMU5WczFPRFZkTlRkYk5qWTJYVFU0V3pFd01EUmROamhiTlRNNFhUY3lXelUwTVYwM05GczJNVGxkTnpaYk1qZzBYVGd4V3pZd05GMDROVnN6T1RkZE9EWmJORE01WFRnM1d6TTRPVjA0T0ZzMk1EUmRYUW8rUGdwbGJtUnZZbW9LTXpBZ01DQnZZbW9LUER3S0wxUjVjR1V2Um05dWRBb3ZVM1ZpZEhsd1pTOVVlWEJsTUFvdlJXNWpiMlJwYm1jdlNXUmxiblJwZEhrdFNBb3ZWRzlWYm1samIyUmxJREk0SURBZ1Vnb3ZRbUZ6WlVadmJuUXZWVkpNVWxCWUsxTmxaMjlsVlVrc1FtOXNaQW92UkdWelkyVnVaR0Z1ZEVadmJuUnpXekk1SURBZ1VsMEtQajRLWlc1a2IySnFDak14SURBZ2IySnFDanc4Q2k5VWVYQmxMMFp2Ym5SRVpYTmpjbWx3ZEc5eUNpOUJjMk5sYm5RZ01UQTNPUW92UTJGd1NHVnBaMmgwSURjd01Bb3ZSR1Z6WTJWdWRDQXRNalV4Q2k5R2JHRm5jeUF6TWdvdlJtOXVkRUpDYjNoYkxUVTNNeUF0TkRJM0lERTVPVGtnTVRJNU9GMEtMMGwwWVd4cFkwRnVaMnhsSURBS0wxTjBaVzFXSURBS0wxaElaV2xuYUhRZ05UQXdDaTlHYjI1MFRtRnRaUzlNV1ZoVlNGVXJVMlZuYjJWVlNWTmxiV2xpYjJ4a0xGSmxaM1ZzWVhJS0wwWnZiblJHYVd4bE1pQTVNeUF3SUZJS1BqNEtaVzVrYjJKcUNqTXlJREFnYjJKcUNqdzhDaTlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1VLTDB4bGJtZDBhQ0EwTWprS1BqNEtjM1J5WldGdENuaWNYWlBCaXVNd0RJYnZoYjZEanpPSGtzU3lreGFLb0pPWlFnODd1MnhuSHlCTjNCTFlPc0ZORDMzN2NTeFZDM3ZJQi9tajM1WVVLYXNQN3dmZlR5cjdGWWIyNkNaMTduMFgzRzI0aDlhcGs3djBmbEZvMWZYdHhHK0o3YlVaRjdQNStMaE43bnJ3NTBGdHR5cjdIVC9lcHZCUUw3dHVPTG5YN0dmb1hPajlSYjM4cVkrdjJmRStqbi9kMWZsSjVZaXFjK2Q0eW85bS9HeXVUbVhKc3pwMDhYTS9QVmJSTVVlb0ZQSDFHSjNTeVZGUUp1M1F1ZHZZdEM0MC91S1dpMjJlNSs4WWFTdGNMcHp2L2c4QVM4YlQrWitqS0ZFSWdLUVZLTlFmckwyaEVOYXNWU2dFdzFxTlF0aXdabEFJQldzN0ZFTEZHcUFRY3RZMktJU1N0VFVLd1pLbVV3VFJjQnhzVUdoWjA2bFNvdUY2cVd0RXZlTzRkRHJSOEIyRlJxSGVjOXdlaGFibWV3c1VtbWYvMHVsRTREc0FVR2k1WG10UldHblNER1dSV0hJdUpuV2RXSEx2VFkzQ2tudHZTaFNXWEsrdFVGaXhGOVlvdE05NlV4WkU0RnlnUXFGbHI5NmgwUEMvQkl0Q3kxNmRYRVR6dkZlajBEeDdtaWFGYUhoZTRod0t6UnZOdDh6eFBPdHhJWlZzVW5zUElTNVIydHEwUGZQZTlON0pZby9EcUtKcmZyNEJ3cC8yYVFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNeklEQWdiMkpxQ2p3OENpOVVlWEJsTDBadmJuUUtMMU4xWW5SNWNHVXZRMGxFUm05dWRGUjVjR1V5Q2k5RFNVUlRlWE4wWlcxSmJtWnZDanc4Q2k5UGNtUmxjbWx1WnloSlpHVnVkR2wwZVNrS0wxSmxaMmx6ZEhKNUtFRmtiMkpsS1FvdlUzVndjR3hsYldWdWRDQXdDajQrQ2k5R2IyNTBSR1Z6WTNKcGNIUnZjaUF6TVNBd0lGSUtMMEpoYzJWR2IyNTBMMHhaV0ZWSVZTdFRaV2R2WlZWSlUyVnRhV0p2YkdRc1VtVm5kV3hoY2dvdlZ5QmJNVE5iTkRNMFhURTNXekkwTVYweE9GczBNVE5kTVRsYk5UVTFYVEl3V3pRd01sMHlNVnMxTlRWZE1qSmJOVFUxWFRJeld6VTNObDB5TkZzMU5UVmRNalZiTlRVNFhUSTJXelV6TmwweU4xczFOVFZkTWpoYk5UVTRYVEk1V3pJME1WMHpObHMyTnpGZE16aGJOakl4WFRNNVd6Y3hOMTAwTUZzMU1UZGROREZiTlRBeVhUUXlXelk1TjEwME5sczJNVEJkTkRkYk5EZzRYVFE1V3pjMk4xMDFNRnMzTlRWZE5URmJOVGcwWFRVeld6WXlNbDAxTlZzMU5URmROVFpiTnpBelhUVTNXelkwTVYwM01GczBOekJkTnpGYk5qQXlYVGN5V3pVek1WMDNObHN5TmpGZE9EVmJNemN3WFRnM1d6TTJNVjFkQ2o0K0NtVnVaRzlpYWdvek5DQXdJRzlpYWdvOFBBb3ZWSGx3WlM5R2IyNTBDaTlUZFdKMGVYQmxMMVI1Y0dVd0NpOUZibU52WkdsdVp5OUpaR1Z1ZEdsMGVTMUlDaTlVYjFWdWFXTnZaR1VnTXpJZ01DQlNDaTlDWVhObFJtOXVkQzlNV1ZoVlNGVXJVMlZuYjJWVlNWTmxiV2xpYjJ4a0xGSmxaM1ZzWVhJS0wwUmxjMk5sYm1SaGJuUkdiMjUwYzFzek15QXdJRkpkQ2o0K0NtVnVaRzlpYWdvek5TQXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDak0ySURBZ2IySnFDanc4Q2k5VWVYQmxMMUJoZEhSbGNtNEtMMUJoZEhSbGNtNVVlWEJsSURFS0wxQmhhVzUwVkhsd1pTQXhDaTlVYVd4cGJtZFVlWEJsSURNS0wwMWhkSEpwZUNCYk1DNDNOU0F3SURBZ0xUQXVOelVnTkRFekxqRTROU0F5T0RjdU1qSXhYUW92UWtKdmVGc3dJREFnTVRRZ09WMEtMMWhUZEdWd0lESTRDaTlaVTNSbGNDQXhPQW92VW1WemIzVnlZMlZ6Q2p3OENpOVFjbTlqVTJWMElGc3ZVRVJHTDFSbGVIUXZTVzFoWjJWQ0wwbHRZV2RsUXk5SmJXRm5aVWxkQ2k5RmVIUkhVM1JoZEdVS1BEd0tMMGRUTUNBek55QXdJRklLUGo0S0wxaFBZbXBsWTNRS1BEd0tMMFp0TUNBek9DQXdJRklLUGo0S1BqNEtMMHhsYm1kMGFDQTRNd28rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lEQXVPVGswSURBZ01DQXdMams1TkNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pNM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tNemdnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXekFnTnk0NU9USWdNVE11TURnM0lDMHdMakEyTkYwS0wwMWhkSEpwZUNCYk1TQXdJREFnTVNBd0lEQmRDaTlNWlc1bmRHZ2dNekF3Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdMVEV3TUNCVWVnb2dJSEVLSUNCeElDVWdMUzBnWW1WbmFXNGdWbWx6ZFdGc0NpQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1EyRnVkbUZ6Q2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNU0F3TGpBd09DQXdJQ0J5WndvZ0lDQWdJQ0FnSURBZ01DQnRDaUFnSUNBZ0lDQWdOaTQ0TVNBNExqa3lPQ0JzQ2lBZ0lDQWdJQ0FnTVRRdU1EZzNJREFnYkFvZ0lDQWdJQ0FnSURBZ01DQnNDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0JSSUNVZ0xTMGdaVzVrSUVOaGJuWmhjd29nSUZFZ0pTQXRMU0JsYm1RZ1ZtbHpkV0ZzQ2lBZ1VRcFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqTTVJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LTkRBZ01DQnZZbW9LUER3S0wxUjVjR1V2VUdGMGRHVnliZ292VUdGMGRHVnlibFI1Y0dVZ01Rb3ZVR0ZwYm5SVWVYQmxJREVLTDFScGJHbHVaMVI1Y0dVZ013b3ZUV0YwY21sNElGc3dMamMxSURBZ01DQXRNQzQzTlNBME1UTXVNVGcxSURJM01DNDBOelpkQ2k5Q1FtOTRXekFnTUNBeE5DQTVYUW92V0ZOMFpYQWdNamdLTDFsVGRHVndJREU0Q2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEUXhJREFnVWdvK1Bnb3ZXRTlpYW1WamRBbzhQQW92Um0wd0lEUXlJREFnVWdvK1BnbytQZ292VEdWdVozUm9JRGd6Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdNQzQ1T1RRZ01DQXdJREF1T1RrMElEQWdNQ0JqYlFvZ0lDOUhVekFnWjNNS0lDQXZSbTB3SUVSdkNsRWdKU0F0TFNCRmJtUkRiMjUwWlc1MENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS05ERWdNQ0J2WW1vS1BEd0tMMVI1Y0dVdlJYaDBSMU4wWVhSbENpOUJTVk1nWm1Gc2MyVUtMMEpOTDA1dmNtMWhiQW92UTBFZ01Rb3ZZMkVnTVFvdmIzQWdabUZzYzJVS0wwOVFJR1poYkhObENpOVRRU0IwY25WbENpOVRUV0Z6YXk5T2IyNWxDajQrQ21WdVpHOWlhZ28wTWlBd0lHOWlhZ284UEFvdlZIbHdaUzlZVDJKcVpXTjBDaTlUZFdKMGVYQmxMMFp2Y20wS0wwSkNiM2hiTUNBM0xqazVNaUF4TXk0d09EY2dMVEF1TURZMFhRb3ZUV0YwY21sNElGc3hJREFnTUNBeElEQWdNRjBLTDB4bGJtZDBhQ0F6TURBS1BqNEtjM1J5WldGdENuRWdKU0F0TFNCQ1pXZHBia052Ym5SbGJuUUtJQ0F0TVRBd0lGUjZDaUFnY1FvZ0lIRWdKU0F0TFNCaVpXZHBiaUJXYVhOMVlXd0tJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQkRZVzUyWVhNS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F4SURBdU1EQTRJREFnSUhKbkNpQWdJQ0FnSUNBZ01DQXdJRzBLSUNBZ0lDQWdJQ0EyTGpneElEZ3VPVEk0SUd3S0lDQWdJQ0FnSUNBeE5DNHdPRGNnTUNCc0NpQWdJQ0FnSUNBZ01DQXdJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1EyRnVkbUZ6Q2lBZ1VTQWxJQzB0SUdWdVpDQldhWE4xWVd3S0lDQlJDbEVnSlNBdExTQkZibVJEYjI1MFpXNTBDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tORE1nTUNCdlltb0tQRHdLTDFSNWNHVXZSWGgwUjFOMFlYUmxDaTlCU1ZNZ1ptRnNjMlVLTDBKTkwwNXZjbTFoYkFvdlEwRWdNUW92WTJFZ01Rb3ZiM0FnWm1Gc2MyVUtMMDlRSUdaaGJITmxDaTlUUVNCMGNuVmxDaTlUVFdGemF5OU9iMjVsQ2o0K0NtVnVaRzlpYWdvME5DQXdJRzlpYWdvOFBBb3ZRVzUwYVVGc2FXRnpJR1poYkhObENpOUdkVzVqZEdsdmJnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElETUtMMFJ2YldGcGJpQmJNQ0F4WFFvdlJuVnVZM1JwYjI1eld3bzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqazFOeUF3TGpjMk9TQXdMamMzTmwwS0wwTXhJRnN4SURBdU9UWTFJREF1TnpVM1hRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1BEd0tMMFoxYm1OMGFXOXVWSGx3WlNBeUNpOURNQ0JiTVNBd0xqazJOU0F3TGpjMU4xMEtMME14SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wxSmhibWRsSUZzd0lERWdNQ0F4SURBZ01WMEtMMFJ2YldGcGJpQmJNQ0F4WFFvdlRpQXhDajQrQ2p3OENpOUdkVzVqZEdsdmJsUjVjR1VnTWdvdlF6QWdXekF1T1RNeklEQXVPVFE1SURBdU9EY3hYUW92UXpFZ1d6QXVPVFExSURBdU9UWXhJREF1T0RneVhRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1hRb3ZRbTkxYm1SeklGc3dMak0zTlNBd3xFbmNvZGVkIERhdGF8fHx8fEZ8fHx8fHwgDQpPQlh8NDl8RUR8NTg0NzctMV5QdWxtb25hcnkgRnVuY3Rpb24gVGVzdCBSZXBvcnReVlNQVUxSfHxeQVBeUERGXkJhc2U2NF5Mall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzBOaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRjZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzBPQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTkRrZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFNQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRFZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFNaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRNZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFOQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV3Tmk0NE5qWTJJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTlRVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzFOaUF3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJREU1TGpnME15QXpOeTR3T1ROZENpOUNRbTk0V3pBZ01DQXhNalVnTWpOZENpOVlVM1JsY0NBeU5UQUtMMWxUZEdWd0lEUTJDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURVM0lEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURVNElEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEYzFDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01TQXdJREFnTVNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOVGdnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXeTAxTGpFMU1pQXlNQzQyTmpZZ01URTRMamcwT0NBdE1TNHpNelJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lEUTBNamtLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdJREF1TmpneUlEQXVPVE0zSUNCeVp3b2dJQ0FnSUNBZ0lEYzRMalF4TVNBd0xqQTNNaUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREF1TURjeUlEZzBMamt3TWlBd0xqZ3pNeUE0TkM0NU1ESWdOeTR5TXpNZ1l3b2dJQ0FnSUNBZ0lEZzBMamt3TWlBeE1TNHpNemdnT0RNdU9EVTBJREUwTGpZNElEZ3lMamN3TnlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURneExqVTJNaUF4Tmk0ek9UY2dPREF1T0RreklERTBMamczSURnd0xqZzVNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdPREF1T0RreklERTBMamczSURjM0xqZ3pPQ0F4TUM0MU56UWdOell1TkRBNUlESXVORFU0SUdNS0lDQWdJQ0FnSUNBM05pNDBNRGtnTWk0ME5UZ2dOell1TWpFM0lEQXVPVE1nTnpZdU5qa3pJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNOeTR4TnlBdE1DNHlNVFVnTnpndU5ERXhJREF1TURjeUlEYzRMalF4TVNBd0xqQTNNaUJqQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DQXdMalk0TWlBd0xqa3pOeUFnY21jS0lDQWdJQ0FnSUNBM01TNHhOVGNnTUM0d056SWdiUW9nSUNBZ0lDQWdJRGN4TGpFMU55QXdMakEzTWlBMk5DNDJOaklnTUM0NE16TWdOalF1TmpZeUlEY3VNak16SUdNS0lDQWdJQ0FnSUNBMk5DNDJOaklnTVRFdU16TTRJRFkxTGpjeE5DQXhOQzQyT0NBMk5pNDROaUF4TlM0MU16Z2dZd29nSUNBZ0lDQWdJRFk0TGpBd05pQXhOaTR6T1RjZ05qZ3VOamN6SURFMExqZzNJRFk0TGpZM015QXhOQzQ0TnlCakNpQWdJQ0FnSUNBZ05qZ3VOamN6SURFMExqZzNJRGN4TGpjeU9TQXhNQzQxTnpRZ056TXVNVFl4SURJdU5EVTRJR01LSUNBZ0lDQWdJQ0EzTXk0eE5qRWdNaTQwTlRnZ056TXVNelV5SURBdU9UTWdOekl1T0RjMElEQXVNelU0SUdNS0lDQWdJQ0FnSUNBM01pNHpPVGdnTFRBdU1qRTFJRGN4TGpFMU55QXdMakEzTWlBM01TNHhOVGNnTUM0d056SWdZd29nSUNBZ0lDQWdJR2dLSUNBZ0lDQWdJQ0JtQ2lBZ0lDQWdJRkVnSlNBdExTQmxibVFnVUdGMGFBb2dJQ0FnSUNCeElDVWdMUzBnWW1WbmFXNGdVR0YwYUFvZ0lDQWdJQ0FnSURBdU5DQXdMalF3TkNBd0xqUXdOQ0FnY21jS0lDQWdJQ0FnSUNBNE1pNDJNVElnTVRjdU5UUXpJRzBLSUNBZ0lDQWdJQ0EzT0M0ME1URWdNVGt1TkRVeElEYzBMamc0SURRdU9EVXhJRGMwTGpnM09TQTBMamcwTmlCakNpQWdJQ0FnSUNBZ056UXVPRGMySURRdU9EVXhJRGN4TGpNME5pQXhPUzQwTlRFZ05qY3VNVFEySURFM0xqVTBNeUJqQ2lBZ0lDQWdJQ0FnTmpjdU1UUTJJREUzTGpVME15QTJPUzQyTWprZ01qQXVNekV4SURjMExqZzNPU0F5TUM0ek1URWdZd29nSUNBZ0lDQWdJRGd3TGpFeU9TQXlNQzR6TVRFZ09ESXVOakV5SURFM0xqVTBNeUE0TWk0Mk1USWdNVGN1TlRReklHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdaZ29nSUNBZ0lDQlJJQ1VnTFMwZ1pXNWtJRkJoZEdnS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3TGpRZ01DNDBNRFFnTUM0ME1EUWdJSEpuQ2lBZ0lDQWdJQ0FnTVRNdU16STFJRFV1T1RjMElHMEtJQ0FnSUNBZ0lDQXhNeTR6TWpVZ01pNHpNelFnTVRBdU56UTVJREF1TWpNMElEY3VNekE0SURBdU1qTTBJR01LSUNBZ0lDQWdJQ0F3SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F3SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQXhMalV4TXlBeE1TNDNNVEVnYkFvZ0lDQWdJQ0FnSURjdU16QTRJREV4TGpjeE1TQnNDaUFnSUNBZ0lDQWdNVEF1TnpRNUlERXhMamN4TVNBeE15NHpNalVnT1M0Mk1URWdNVE11TXpJMUlEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01URXVPREV6SURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TVM0NE1UTWdPQzQ1TmprZ09TNDRPRE1nTVRBdU16WTNJRGN1TVRNNUlERXdMak0yTnlCakNpQWdJQ0FnSUNBZ01TNDFNVE1nTVRBdU16WTNJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhMalUzT0NCc0NpQWdJQ0FnSUNBZ055NHhNemtnTVM0MU56Z2diQW9nSUNBZ0lDQWdJRGt1T0RneklERXVOVGM0SURFeExqZ3hNeUF5TGprM055QXhNUzQ0TVRNZ05TNDVOelFnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNBeU55NDFNVFlnTWpBdU1UWTFJRzBLSUNBZ0lDQWdJQ0F5Tnk0MU1UWWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lESTJMakE0T0NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUxTGpBME1pQnNDaUFnSUNBZ0lDQWdNall1TURnNElERTNMalU0T1NBeU5DNDJPRGdnTVRrdU1EY3pJREl5TGpJNE15QXhPUzR3TnpNZ1l3b2dJQ0FnSUNBZ0lERTVMamczTlNBeE9TNHdOek1nTVRndU5UWXhJREUzTGpZME5TQXhPQzQxTmpFZ01UVXVNRFF5SUdNS0lDQWdJQ0FnSUNBeE9DNDFOakVnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREUzTGpFek1TQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMUxqSTVOQ0JzQ2lBZ0lDQWdJQ0FnTVRjdU1UTXhJREUyTGpnNE9TQXhOeTQyTXpVZ01UZ3VNVGMzSURFNExqVXpNU0F4T1M0d05ETWdZd29nSUNBZ0lDQWdJREU1TGpNNU9TQXhPUzQ0T0RVZ01qQXVOakF6SURJd0xqTXpNU0F5TWk0eE1UVWdNakF1TXpNeElHTUtJQ0FnSUNBZ0lDQXlNeTQzTXprZ01qQXVNek14SURJMUxqQTRNeUF4T1M0M05ETWdNall1TURnNElERTRMalUyT1NCakNpQWdJQ0FnSUNBZ01qWXVNRGc0SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTXpjdU16WTVJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdNemN1TXpZNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016WXVNemc1SURFNExqa3dOU0JzQ2lBZ0lDQWdJQ0FnTXpRdU56a3pJREU0TGprd05TQXpOQzR6TWlBeE9DNHhORGtnTXpRdU16SWdNVFl1TmpNNElHTUtJQ0FnSUNBZ0lDQXpOQzR6TWlBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTXpJdU9Ea3hJREF1TWpNMElHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UWXVOalkySUd3S0lDQWdJQ0FnSUNBek1pNDRPVEVnTVRndU56WTFJRE16TGprMU5TQXlNQzR4TmpVZ016WXVNVE0zSURJd0xqRTJOU0JqQ2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdOakF1TWpreklERXhMalUwTWlCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURrdU9UUTNJRFU1TGpjNE9DQTRMalkxT1NBMU9DNDRPVElnTnk0M09URWdZd29nSUNBZ0lDQWdJRFU0TGpBMU15QTJMams0TVNBMU5pNDRNakVnTmk0MU1EVWdOVFV1TXpNNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBMU15NHpOVEVnTmk0MU1EVWdOVEV1TnpVMklEY3VNemN6SURVd0xqYzBOeUE0TGprMk9TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklEY3VNemN6SURRNExqTTVOeUEyTGpVd05TQTBOaTQwTURrZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURRMExqYzROU0EyTGpVd05TQTBNeTR6T0RVZ055NHhNakVnTkRJdU5EQTNJRGd1TWpZM0lHTUtJQ0FnSUNBZ0lDQTBNaTQwTURjZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURRd0xqazNPU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdOREF1T1RjNUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJREV4TGpjNU5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lEa3VNalE1SURRekxqZ3dPQ0EzTGpjMk5TQTBOaTR5TVRVZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURRNExqWXlJRGN1TnpZMUlEUTVMamt6TmlBNUxqRTVNeUEwT1M0NU16WWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTBPUzQ1TXpZZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdNVEV1TlRReUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ09TNHlORGtnTlRJdU9EUTNJRGN1TnpZMUlEVTFMakUzTWlBM0xqYzJOU0JqQ2lBZ0lDQWdJQ0FnTlRjdU5UYzNJRGN1TnpZMUlEVTRMamc1TWlBNUxqRTVNeUExT0M0NE9USWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTFPQzQ0T1RJZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMk1DNHlPVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09Ua3VOREUxSURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnT1RrdU5ERTFJREV4TGpVME5TQnNDaUFnSUNBZ0lDQWdPVGt1TkRFMUlEa3VPVFEzSURrNExqa3hNaUE0TGpZMU9TQTVPQzR3TVRVZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURrM0xqRTBOeUEyTGprMU15QTVOUzQ1TkRNZ05pNDFNRFVnT1RRdU5ETXlJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTVNaTQ0TURnZ05pNDFNRFVnT1RFdU5EWTFJRGN1TURreElEa3dMalExTnlBNExqSTJOeUJqQ2lBZ0lDQWdJQ0FnT1RBdU5EVTNJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQTRPUzR3TWprZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURnNUxqQXlPU0F5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBeE1TNDNPVFVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUE1TGpJME9TQTVNUzQ0TlRjZ055NDNOalVnT1RRdU1qWTBJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQTVOaTQyTnpFZ055NDNOalVnT1RjdU9UZzNJRGt1TVRreklEazNMams0TnlBeE1TNDNPVFVnWXdvZ0lDQWdJQ0FnSURrM0xqazROeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJREV4TkM0Mk9UY2dNVE11TnpJM0lHMEtJQ0FnSUNBZ0lDQXhNVFF1TmprM0lERXpMakE0TWlCc0NpQWdJQ0FnSUNBZ01URTBMalk1TnlBNExqazJPU0F4TVRJdU5qVTFJRFl1TlRBMUlERXdPUzR5T1RZZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURFd05TNDVNRGdnTmk0MU1EVWdNVEF6TGpnNU5TQTVMakE0TVNBeE1ETXVPRGsxSURFekxqUXhPQ0JqQ2lBZ0lDQWdJQ0FnTVRBekxqZzVOU0F4Tnk0NU1qVWdNVEExTGprd09DQXlNQzR6TXpFZ01UQTVMall6TVNBeU1DNHpNekVnWXdvZ0lDQWdJQ0FnSURFeE1TNDROamtnTWpBdU16TXhJREV4TXk0eE16RWdNVGt1TmpNeElERXhOQzQxTURFZ01UZ3VNall4SUdNS0lDQWdJQ0FnSUNBeE1UTXVORE0zSURFM0xqUXlNU0JzQ2lBZ0lDQWdJQ0FnTVRFeUxqSTVNU0F4T0M0MU5qa2dNVEV4TGpNeE1TQXhPUzR3TkRNZ01UQTVMamN4TlNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFd05pNDROVGtnTVRrdU1EUXpJREV3TlM0ek1qRWdNVGN1TVRReElERXdOUzR6TWpFZ01UTXVOekkzSUdNS0lDQWdJQ0FnSUNBeE1UTXVNamN4SURFeUxqVTNPU0J0Q2lBZ0lDQWdJQ0FnTVRBMUxqTXlNU0F4TWk0MU56a2diQW9nSUNBZ0lDQWdJREV3TlM0ek56Y2dNVEV1TWprZ01UQTFMalEySURFd0xqZzNNeUF4TURVdU56azJJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEEyTGpNNE15QTRMall6TVNBeE1EY3VOelUxSURjdU56WTFJREV3T1M0eU9UWWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lERXhNQzQ0TXpNZ055NDNOalVnTVRFeUxqSXdOU0E0TGpZek1TQXhNVEl1TnpreklERXdMakF6TVNCakNpQWdJQ0FnSUNBZ01URXpMakV6TVNBeE1DNDROek1nTVRFekxqSXhNaUF4TVM0eU9TQXhNVE11TWpjeElERXlMalUzT1NCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pVNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDFCaFoyVUtMMDFsWkdsaFFtOTRXekFnTUNBMk1USWdOemt5WFFvdlVHRnlaVzUwSURNZ01DQlNDaTlEYjI1MFpXNTBjeUEyTUNBd0lGSUtMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTmlBd0lGSUtMMGRUTVNBMk1TQXdJRklLTDBkVE1pQTJNeUF3SUZJS0wwZFRNeUEyTlNBd0lGSUtMMGRUTkNBMk55QXdJRklLTDBkVE5TQTJPU0F3SUZJS1BqNEtMMFp2Ym5RS1BEd0tMMFl3SURFd0lEQWdVZ292UmpFZ016QWdNQ0JTQ2k5R01pQXpOQ0F3SUZJS1BqNEtMMU5vWVdScGJtY0tQRHdLTDFOb01DQTJNaUF3SUZJS0wxTm9NU0EyTkNBd0lGSUtMMU5vTWlBMk5pQXdJRklLTDFOb015QTJPQ0F3SUZJS1BqNEtMMUJoZEhSbGNtNEtQRHdLTDFCaE1DQTNNQ0F3SUZJS1BqNEtQajRLTDBkeWIzVndDanc4Q2k5RFV5OUVaWFpwWTJWU1IwSUtMMU12VkhKaGJuTndZWEpsYm1ONUNpOUpJR1poYkhObENpOUxJR1poYkhObENqNCtDajQrQ21WdVpHOWlhZ28yTUNBd0lHOWlhZ284UEFvdlRHVnVaM1JvSURJd05ESTJDaTlHYVd4MFpYSXZSbXhoZEdWRVpXTnZaR1VLUGo0S2MzUnlaV0Z0Q25pYzdYMVppMlJKZHVaNy93cC9HUm9hNnJidGl4QUZtVmtMQ0FRalZVSUxoQjU2cXJjWnFrcXE3bUlhemErZnM1amRjQTkzKyt4Nlptd2VjYU9Jekt6d0UvZWFuV1BMMmIrZkQvL2o4TVVYaC9kLy9QUC8vdW5EZi83MHl4OS8rdVZYaDROWmNqd1krdStMOXE5YzNlSDdIK21UTDZ3eGg0Ly9qLzdWZnZOLzhXOGVQdnorcC8vNys3L1JUdzhISzc5b0R5NHRJYWE4L2kyL1B2NjF1MTgwaDFvNk5hSS8vbzE0OXd2NFYrNStLZEdmUjc5MDc5Zis1KzkvK2N2UlovUnJpL2VIdjUvOHlCeis2ZDcvLzUvVFh6R0hmejRsV0hKT0ozOGUvdlhiZTQ4d2h4OVBmcEpqWGt5bEgvOXc4dVB2anY3dlgzVGdmL3pwRDZmRFB2cjVQUzVzNDVBaEh0MEFoMmlvN3ZHNGMyK2FaNU04bmFJOW1lQnNOclN2VHViQ0RQL2g1UC9ka2tyeS9TK2ppL2FJSXQ5YkdOOWRtdDdKRkU0bTkrMFAvLzFmZi9uYnlSdjV2OE5mLzN6MHM5OSsrNTA1L1BtWTZ2M0g0NCsvb1dQQ0hqNys2WmdObnRra3EwaitaZWtRcUpiKzRmeFNhL0dIanovZWUrbkhQeHorMFJqdmpZblJtRkRvT3h0ajdaY2ZqeG42OWNkTDg3czNpK2VaWWFxTFNmTVp1amE3bU9nNzM4cnNuSW1MeS9QWkdacVo4WThoUjNCSWVRZE9xYlBmRzk0YVo3OTZkc0FkLzZwWmJEcjc5WXM3L2tRV2pWMUxQUHg0NGFmT3RUK0U0blNuODVlanU4Q0dzN3RBUHdqOGUveVBGUFFwNjcvanhRZTFqMzRZZlpSTGY2enRMN1puRCtJbjJMTm55T3VWUy9RVWMzRUk5MW43cDkrYy9HQjBmUEhYVE1Bbk54Z3Yzek14NFUzVUpuRmhLK25YK1liU3I1TnQxVWd2Yks0MnhIdGJqUDYydExkSVVmcjQ0OFd4dEJQeTNwblJQbCtpODNkbnpEZVhhVUs0STBtWFNMNitQNEh4NXRTdlRYeWtKWlQ1VDI5bERQN3BlRnJUVXZoTTNzVFp5MXg3SEpZODdkS2lpM2V4aGVhL2lRKzI4bmxOMzNSKzIzZXZsaWZaTGNWdFhSdTJOSjdRdldZL3ZGYWVPQmNXbnpaeTVEMTlCNzd4SDRBYlkxV2N2NjQ1N3AxYnZMc3pOZ2NQdVhDemI3amJ0OTN1by90OTJ3MFA3dmpyYjNsNHoxOTcwNC91K20yMy9mbDlmM2JqNHp0L3l6S1kzL3ZidGgzYWVPT3RkM0h6b2UxM3BRNXdvZ1hRMmV6cnBaMTNZZS9OejZMTmJObDBsVDhxaXpaYzZmTkwvWEdaOUR4clo4c2xmM0tBeDZNcjdmMmI0ZEtHYS8rRVMrRklHYXB2aFV0elJlQk1ZUnlxQXAvRUg2d1FQSnk2RU1LUzR0UkEzTldGa3c5M2RlRnNTamVoTHRBdWRTTUhBb2wzc1h5clQrN05EVTZFVjYrQmhDV0d1SlgxRDNnb3Z2RFZhTjMyR3lNZDZSKzhMdk9iWVZLS1MvSlhhbW01Y1lwTjd2VGxyb09jREszeDZaMnVwQmVoZzR3LzJ4aHpmSml3amowUDY1UWxaZVd4L0l0T3Nib1U0OGZScW52WEFCMjU4ZTVXcVJ6cmVjVEFqdVZvVXdIQm5RdHl1N3hhTDYzVGV5djA4dG84dDdKSTI1T3Noa3VCc0syQnZudnJFYTNFNTU1dnRxUWhiNXJ2Ti9ydDdhM08xUm5hRE5GdW1Lc3ZOei9YUUJydmxwbCtwU3M0OENwMlBhaDdzN091Zm5IelNYTVUrelNDL1RBVGhySG8rMUhzNnd6WmVNTW1yUGRsaWY2aUNjc2ZGZUdPcjR2eCtxVDEzL0hpdzlZUGZ4aC9TSVpuZTdUdHI5OU4ySmR0d3VhUlFUcVBmTzltNjl0em5MdXJIT2NwYkRZMHBwSGd3K0UxdXMzRDRzb1Zidk5qTHZtM3dpVkhmMVYzbGNscUc2OGVMYlF3dURhTzByUmpWQy94OTVlR3U0M2ZtT09JNXdPdVk3NWZmWTJjc04xY1p2VkZabTloOTgwd0tTNnpEWHd4OGxYR1hxZFA1aG4ycmZEWGk5N28zc1FsaHl1OGVPK2ZPRUoycmU0NFRKdlpZa1pzTWlTMm1oSmpZMktyT1FFTmlrOHhLU1pHeGZWbXhkaXcyR3BhWERJdUxwZ1hNd1BqMnJ0aWJHUWNYdUZOTVVxd1lTR2xxVFh4RlBmSlJxdmlDZGk2eWJyWVlsL2M1alhzcm1DVjJCdmxpb3M0emNNL2gxZXZ2R3l6UUM3eUxZMFRuRjQvMzdiWUpCY3ROMWIvNHVOeWJYamZiTFZPdGt0aEpnY3NpYUVzWnRMNGhQdG5tNjB5RU1FMklkd2cyN2JZTGllYzgyMFp2ME9iLzdPNE9MZGhidWFRMkdiUG5QRDNnL0o0Wk5FOG1tWDRzSGJQTVA5dnQzdjBkM2E3NSszWlBlNERXelcwdDRmbnB1Vk04dzJxUEJrbGR5bUZtaTVDWHg5MmcyazNtSzQwbUtxL1N2V1BSN2QvK2ZMamJqSmR5YmN3RGtrY2RwTnBIZVE5US9QRHFHQ1d2MTQ5MTFKZG5MMG1EdE8vM3lySFBrSHJmcStyN01hMTdwVE8wam92UEdiWHVYZWQrODNvM0tQMEp0Rlp5NTBTK0E2RUpQSmhIcm5ZVmV6ekVlOHF0cWpZNFJQMHhEU3UzVGtjZHYzNmJwajMrTVovaHk5My9Yb2IxM3I5VTk1REVrZGZlMGppZWRsMmRVZ2lIQzFqdjRja1RyOGV3RGg2cHhmU2pSdEhwUzdlN0tsWXUzbTBtMGRIbW5tNWEySXdEa3U0eGJpNzh0UTlMS0cvc3R0TVoxOFBaRFBSRFdXdnVxRzZCZ0JhTGgwT3U5bDBOOHg3eVJ4cEQwdDhnckhwMzdLUnZvY2xydVpZSlcwcFhYbXErVmVoZTF1YWRQSjdQdEN1Zk8vSzkxRnNJdTRSaFYwNy9nVHRPT1ZQMG83alc5YnlQa0U3UHViYnUxMDd2akpweHo5K2l0Z2VWQmlPZEE4cVBGQlFvYUpEY3c4cWZISlFZZExiK0ZZTUcwNmhUYnRaczVzMXUxbHpUVlBrclcyUk4zYVllbVBXMG9aR3ljY0NNZVhOR2tzdVhlblgzZEFTK1BEcWRYNmJHQnIxcXVzODNrdGVlN05SR0dmU2txOHJxc24zYXVyckhsUFlZd29iRlc4YkZ4TmVBTWMrVCsxR240NC9HMytDMWJPajNyQTJMeTdkVHdyQ3FydVYvKzVMbko4WXMyZEVhZXZUNGE5L1BKeDhmS0ppanBYTG1WclpSMTRPNVhPYTJqb3o2V283RVBKNHNWOEZtemU2d2EwKzN6STZzNkdMTzMwaVltZWM2WldrdjgzNkRIMGU3T0RFYm5Sa0RqQ2kxR2NZam4rLzhOUDdvT0Q5cDVjMitobEFlQ2NXQ2QrREJsOC9HeGlZMFpQVk5UVHp2dnM4NitwbHNZQ09YY1FEK2ZqcG1FRGJ6bDYrWDM2K1BQbytUSGQyUXVuWDczNXorT25DajkvLzIrRzMzLzNGSFA3Mmw4UFgvM2I0bHl2bjhwQXVsKzFiQi9VMlhGeU9YTmxEVitlanQ4WDF1cUE4TndQMFMzSStIcHkvZkZNZm1XeGZQVmJmMG9rcnlqbExaNjkwZnY3K3gvSHVHSG1nRHFUM2hzSGErbHczeTJUa25oRWtTbzYzTi9MZzYrTFpWSDBCSTMrZXZUcjFvSDNSdkpaVEQ5cUExVE5GWGQ4eVpPTkZSczRYd2R6RGZ4MFhVbHlLenpzajZKcDFpOTBaUWVQam5ETHJkazdRWVJPV3N2T0Jya0VMcjhFM3hJbWFsN2h2RGRJdmtsOUsyam1oMW8rdHRiNCtUanhzV051Wnp6S3ZodHg1U0xTUjFWa1VsOG91dk12dW9oT0gwY0N4VG9hZ084eENqRStCR0lIMDVhMkw4N0pmWk9RWkdmbEdodDRSN0I5QlRxS1ptK2lTajJTK0wyNkdMVVBIMGRSMTlMaU1vUzNwUmlHS24wZHptYm1SaG82azdrcXlRMWZTYzJpTzI3Y2RqZ1JOM1VxUEVQSStjaTlsdjRRUXh1NmxMUTZtaHdxWmdZMjR6ZEcwNVpyMUQzN05YanVMbWRQcE5tWXhjMEE5enl5ZWM1OXZ5Q3hHTHFtdEFwaW54MDYxeVFGenR5eVNxeE5RTjNCbDRxSjZ1NHladUt6ZU1HTW1McXkzeXhuczBucTdmSm01dU40d1o3REw2KzB5WnVZQ2U3dWNtYm5FWGd0bm50YUJGbTdKZ1dhMitNN0dNTkZIMlZidmhnNjJlcGg1NFhZSDIvb0x1NFB0NGkvY3JJUE5QNzJEemUwT3R2T3Z6M1d3a1FsSEUvRzdnMDIrZGdmYjdtQTdtZVh1WUJ0VDdBNjJBY1h1WUJ0UTdBNjJFY1h1WUx0TXNUdllSaFM3ZzIxQXNUdllSaFM3ZzIxRThTSWNiTW5jVklaYURsSldQL1d5eGQwL3RqNW45NDlkZk00cjlJK0ZwL2VQK2QwL2R2NzF1ZjR4R3hkU3FmUHVINU92M1QrMis4ZE9acm43eDhZVXUzOXNRTEg3eHdZVXUzOXNSTEg3eHk1VDdQNnhFY1h1SHh0UTdQNnhFY1h1SHh0UlBJcC9ESDg2NS9seEs5b0xFUEZiYk13eGU2L3EvalZxYjJmYkVQbXZ1dFJKNzYrdkhyNXAxM05QTzVIMXp0MWRaM08vM0x2dnR1ZHVHV1o5eStSOUdqUjlPMjRtUEtJNVNrSjA2bXgxNVFGNCtWQjdzOXVIMXN6NjgwM2M0MStFSmRYQlZiUGxNRjB2TFRxWVA3bWZFaTNvUjJxbnRLSGZkdmxzVnhxNFNSNitxK2NhS2FDamIwc1R6emZUN25SbFROakVtRnNHRTBoMlNjSHR1L2FjNE9kOTE3N3FYWnR2ZU5kYWw1ZGE5azE3Z0kvNWR0KzA2OWZQcjJQVHBsdmV0RFVzZnVnTDM3ZnRGL3UyUGZ2NitYVnMyM2pEMjlZbHM2UzQ3OXB6Z3AvM1hmdXFkMjI0NFYzclhWbHFmUWpEMXIzTWJmczBlYVptV3lGM25xV1lXdjlnNmFVUHVrcHFWR1NiZlkyc1g4KzNSc0tMWENPQlhXUXA3eWZKeWRmenJaTDRJbGRKcFB2R21GRDNWWEw4OVh5ckpEM1JLbm5vS054bnh1Q2NkVXZ5WWNNcWZEbDFLbHZrNmI3UmI4OW9oVis5eUJPQWhyYllFdXlyNDczM3d5WTg1UTRrTjhZUmxiOURQUXVGdmpOOWY2RHZSTCtVKzg5ZXBFaUR0NHV4MWI4K2taYStuVjdBTVRuK2JQd0psdUo2S1RNMFlrbG5DZjZ6TlhBSGVIZ20rUG55WVV4dzBSWU5JLzdGcXNDWm4zV3FpMXkzb1JuOXcrSFgzLy9sOTMvOTVkY0QrVjlhRjdRWURwZmgxL2tUbHk1L2hqNjUvUE5MV3Mvdkx0WkxiYzNtQ3h3S08rUVFEczU4UWxIVzFoUy9PemtJd1B1UFE3Sy9EejRabGR1TkMrNUF5ZDNoOE8vK0VQN0RIUDR3ZXVaU2FqajVjMVNmSnh4MDFoOUdVOG9seXVjL0RENy83dUxQNTRtTE8rOFB1bnFMZ2J6bnozZmU5NjhINW4zSW1QZjArYzc3L3ZYQXZKK2NPWFkvYzQ2K0hwYjN1VUxXMDhjNzUvdlh3M0krSk1oNStuam5mUDk2NFBQRzRlUEdQVGpuSDdKbzVZblVYUGNKc25WRDJkSXlvc0VlL3ptNWpkT1NaaGV5a095U09vU0hsUlRMSjhUMjUrZElLZGlsVmlIS2RpaW40RGgzVVlqR2wzendTMDFLRk1aRVlhbHgrcVM0ME9rZ1JPTmRUcDlXUHlYS1MzVlRvckxNT1ZEcHhKb1JSVHJXeXBUSUxpVlBpZHhTMG16YzBTOWx5cVlZbGpKbFU0eExtYklwcHFYWUtWRmV5cFNtTEhsT1ZKZWNaMFRKTEhuS3BtU1hQRjF5eWZHcW5UM0o4eU5tVHdvczJCbFJYUEtVSm5FMzlCbFJYdEowWjZiQ0o4Q01xQzZwc2FrTWliSlprcktwanZkNHRrdGlOdVhGQUNMSFlJcENOTlplczErU1dIMExNQzV5NElJdEpuS0FLQzZ4Q0pHUFk2SzB4Q3hFQVl3cEx6RUpVUUpFWllsaWppNkFwaTZSMlZRUUJ3cWQ4RTZJN0ZncXhYSnpmU1p5NEVsdWlWTWF6ek9YWVk4djdSS1dvRnh5WSsyM3hDWG96Z1JDS1drSlBLYTRlUEE2a2dZdnViRDQ4V29xWlFuTVN3L0hWQmU1RDkwQ2xNZHFGbjZiSEN4REdydDRZcE92dlBDR1JOd0RuSWdLNzVnaGtlZXBXMCtMQ2J3dThLSzFQcUx0eTJreFFYcDNWUENreExrejFsV2tsRlhhSTdUa1hPTGxPU1FxaTJmRnlUUGZoMFNWRjV0MWhoODRJckxHTEk0WVplRjZzc1l1ampobHcrSUNvSEw4RUd2dFlpdWdvbVZDRERXRlQ1Y3hsYnpLbW9TMm5qVnhjVTRlV2RBYmFSOVlIVjRHVk1RQ21hbEJVeXc4TitaYVJZK3FQR3ArRmpqTkxjYy9rd3lyQUFFeE42UHdBeXdJYTJsYktidkEyckxXODFIT2t5am9XWUczcUx3WUNNakdSZHhTdkh6R1JJbVBWNmIxYUZoMERla2FCQ2UvdFhSVTh4cXNhRXZ6eDRhWTZrVHRHRkxScGlBcDh3WkM2NFpiajNuWml3WTl5eTJHZDJ4aENZeXAvR0s0dXcvSkhCRHhHV0xSN1U0a1lneDRqK2NYZVgzeW9RVjhzand4dGhuby9FTmp5bUl6MEVrYXdTcmw3TkVnaDNKRno2cHFFRmk0cVlsSFZXOEtkSEF4bi9UT0FkeWlBN2tvVlVBdjlHbzVpRkkwcGdwcUZWakVMZUk0Rzk3RUI0T29rdGdPWGk2RU1WVVc0NEZHRjlIZ2kxZ1B6RFN3SUdoQVJhUUVtTVhYYnRXMUE0amtUSk9yQnozS2lmMUEyNnlpWjNreElHaGpCOEIzMGozWWd1Q2pCTDFSN21jK2p5SzR4OVRDNEtNTnZUQ0xEVUduWkFYU0lWMHV5NEdMOWlFWnJteEYwT0dkd0tPaUVRdUJMb0lJZG12a3RFcTVldEJGUUxZckdSSVY2ajJXYkZmNm1QU1JDaFpXbEVFVEVWckpaTHZTTFU1RURuQ0JiTmZFaWcyU0g1bXVwTTRSVVVFc0tMd1ZTTEZCRDZwaVJ0RGRpNjRjc2wzWlJDREZJWUxaa2ZFYWcyZ1pDVXlQckZjMkpVaC9BTmFySmZPVmJRbFNEUW9ZUGRtdmJFelFBa1dpSVFPV0xRVytxTkhvRTU5NnZIR1FjTWlHWllPQ05xRkg0eXBpVWJBeWlaNVZ4YVNnR3hHOWtjeFlOaGZvSmpOZ3E1SWRHNXljUmhsUk9iRXFIRllkR0hKYmJoL0VMckpreGE0d2NLL21xRGFEWFBwanFzUlpYSHgwTy9UR3JLWkZRRmFoelVWdGl3Z3ZDN0puMmJqd1l0UU5xY2lnWmNPQmIzd2diTEpvdlJDaFk1a3NXall2ZklLSFZoSDlrQWVQekFzeWF0bThJSFlob2loMkE5MzdTS2NocTliTlpWM0VYY0VLRUxKQnlLNWw2NEx1T3FTUmtXSEwxZ1VwaThEWXRtVFpPdGxsWUZ0WDBZdG1HN1p5ZzBpNTZUSjZueGZqZ204NndGTXlicTNhWWdWUnhXNWNCTUF0dWdTczJtTG82S0lUWGhvSldhaHIwZjFsNVp3SGtxYVBqZHdZWVAwNXVpM0p0T0JMckFBaWJqSGNiUGd4a1dNcmdJZ0FEeHhObmk0NUlpcm9TWUhOQ2hwVFFBT1BmTUJVNkZaelBPcUNGZ3RSc0FaR3JBSW1walBTSEVITVZmU3lJallGVFJGRXZCM2RiMnhUMFBDQjh1VEk5R1Z6Z2ExcE1IaStCYjNZeWNBUTRBeHVOaXJvTHhBUGRyUmQyS2lnS3hNbzA0NCtycklCRXlLS1lpN1lncWVZSk5MQXh3SjZWaGFqZ282WURCWURIeHRSamlza2F5dXFCU3Y1UUFWMmRJVTNld0hOa1laZHRCa3QwQ01kWGZSRjdpL2dobkpPRmd4ZEZJQWtpRkhoTXg2NXFBSnM4SUQxNTVMR0d3emM4YVF2U01EQllxcWlFUWZoeFppcWlrMUJKZy93SkR0dWhHL2xXV2c1ME9XVzFMZVowTE9jaEIzd0JlMzROczBpbllxZUZjU3E4TkRZZGw0MFlMNVYwZUNUUkI1Y3hvL0tFbm9na2FOSGlYT1FGY2tJRmp5elNYYVlCNDhLMGxHTy9VSm80NU5jMkdxZzdRZ2N1STVrek5FSE9nRFFiaVd6TmtZMVJjSGd5YXhsMjRMT09LRFdPVEpyeGJhb3lNM2h5S3hscThIQWNJNGp1emJLeVd6UTRJdVlGa2JVaHpGVkZkT0NiZ3d3UXpKcmc3VEpBK2FhSTZ1V1RRWWlBdnFhSTZ1V3d4REdvTEN0aStJUGwxR0JHWkpkeTRZRnUxM1I0T1dpRjhzZFVTV3hHUXlNN1RteWJUa1lZUXJTSXgwWnQyeFpZTys1SS9PV0xRdGVYT0JaU2V3MFhxakFuSFpKMWg1ZlpNRCtjTWxwUk1JZzE3SWo4OWJyam9WdkRJdGFmdWhJSXV0V0FoY1oyWWN1SmJFWjZFaENSM2lTdUFZWkRZQ2txRjJCMTBPU0hjaW5LWEFZT0RKdG5WcGhhRkJrMnJKZHdkY2RPQ2pKdEhWeTI2R3poaXhicXhjR1VPQWRtYlpzV0xDRER3MHJpbUhCUnlGZ0JKbTJiRmh3SEE4eFFpek1pVXZWa1duTDhRajI5QUtpS25ZRjM1eGd4UmM1UUpnUndCSGdDanR2bWZIb3pDWEwxcFR1N3gxVGVRbEhlSWNNTEZlQ2hpTXE1QU9adGtiMXU0cW9rZ1l0QWp6ZXlMUTFhclNpVFUybXJWR2pGVEdpeXVHQUZpa1p2MVVEUE1EdDRNajRaUU9EVkhTMGVjajhGZE9oSXBlcUkvT1g0eEYwMTZGanNubzFNQUkwVnNqOFpRT0RIYTlnYVpFNXh3WUdkcnc2OXFhSzN4WHNNSFp2VnZHN29rRVZOaS9vcFhEa2xjOVpOc3pIRFBVMDRpSjJMUmlUcDl1eWlDODRJaUxIb1lnS3RTUFBVVmpIdGlZUW55ZUpGTFgvZ2ZIa1NVa3BJajJQcGlmSk1oTHpySUFxU3lpQ1ZwVkJMeXdhaXBEY2dqRlYxVkNFUjBsMlhOZkt4Z1VITE1BYnJkV0FSVUhHazZjdHcyWURYYjZJcVR3Z0RUR0N3ZHNndG9XTHlFNzJWbFlMWDc3QU0rYXR4Sm5sV0VOVVdhd0dNbXJBRWVLdHhDclkrWWY0VU1XMndHZXlaeDNGYVZ3TkxHWTY5SkxlQWhrOXk0bmQ0S0YrNFozWHpDWURWNm9lMlh5RkFjdklrMlJpdTFuUkc1TW1OemxnQlhzU1g5U01IQ1JyVnpTOWlWZlBtS2hxZWhOWThONUljcE5IcWpLRGNVaDJrMFBKTnA2dVUwbHZNc2lKNkwzTVMwS2ZhRmhCVEF0MmlZT1Z4VEZ5WFg0Z2N1MzFJYnlVUVZUSnMwVnV4UU5UMExPS1JDTVNYRElNdFZWblFSTFA2NjZJMW8wR0gyVFVjb2lBNWNkYVdKUUR5YUkzZW9sR2NFWUhJQXBxV0xnRlBTbUtYVUduSlRxMWdyQ0pyM3QwaVhFNlhCWGJOcUpoRlFsR2NOQVBVVlV4TE5oRERVUk54cTNUYUt4QlZKWnRpNHJYS1JtM3BObXlJeGR3aTJ4YnNobHFRWTVjVDZhdEpEb1pGTFAxWk5xNm1aWHN5YksxNmdkQUp3aFp0cExvRkpIVzdXUFJSS2VNbGdNWnRoS0tRQzRtVDNZdG14VzBzTkFFeWE1bHM0S3oxY0NCbEp5bU9TWGtSZk5rMTFyVmdnR3p5S3cxZGJyQnlLNDFiYk9pS1NheEsrZ3lzR2p3V2UyS3ZLQVhGalVZS2xLVmZSTE55RXJyaGpFVldiWnNWdEQ1RER3ZFBsdk5jZ3JvZEdCdnFjZEthZGFTQjUvUUpVZTJyeVE1RmJnRnlmYVZKS2VLQXJhZWJOK3FlVHNaRFN2MUxDZWtoV1F0ZS9ENEZpRGJ0Nm9XZ3JaOVpxZ05DWitDS1JZaldVNDQrOVNUN2N0aEM3cXMwVjFldFBiQlpUaEZNbjRsSURFWlY5Q0FCUFJWK1JJbHpjbGhpNENNWHc1YmtCNklicWNpQlJBV1g2MWsrM0pBd3VLanJjaFM0T3NKYWQ1azJZcDFVVkNjenBObG0xdFFESXlMTE51c09TbG8zVlF0ZzBDTG1jemFyQWFyUTFTUlRRdEcxUVBDSWJzd1MwNHlvcEZrL0FxZEY3NUtGUVJIYXhFM0t5dUh0Y0R5SkdQRXFtQzNNcWdZNHVzN3FHbVBudVhFckRBQmJmdGd0QkRDd0F5bXdLNWk5ZFFuUUJRMUdtR1JUaHFNV09QaTVNMkFLbXZNSWlLTk9oZ3RodURJQm5wamxXZ0UzV0FnWVNWWWNZSHdEUWJTS1lNVmU0OVYxNFNveEJuRWFqQXFXTE5hRStFS1VzWUMzZlJCanpZUVB3eFdzbUVsMUlXZWxkUzI4TWhKRXpoWFdhc0MwUEpTNDE3U1BSRlZsWUNFejBndkNFN1d1MFEvd2Jqb0ZHMFhGS0J4WWxxUTdRRE92K0MwT0lLb2dPNGFTTWdjamlBcWg2aWlKam9WZEVRRXRvaUNlbWNCVWRZOEovRlZqNm0wUUlKOStxaXVza3FlRTdUZEEzM2NvaEVKVVVsY2w5YzhXczNlYWN3Q0pxY0hyd1VTRmlibEJLOEZFaFpXakFYV0hMejZaOUc0a2dRa3NIODJzS3BpNVlSRHU0eUU3RFFpaG9iVkNpUUNVbklEclNxYlo3bENnUk95azFTN29NSlh4Mi9pNUNQMFBzL1dCYWY0Z0tFSHFZNmdLOWFnSjRsanRrS1BTQ0RUMXZLREFETzFRSzlHZUg1d0RWdmh1YUVySlVoZGhOWUVEWW5JcU9VNGhJR3BiQ0ZLaVl6VThZRFZRbFl0bXhWYW9UT204bUpXMEZXRzlxQWs0Y0pzTUNMUlFBUmVLMlQ2VnIxWTBhT1MyQlVXWnA2R0tNNXd2bGZCWW9sYUZzR1pPV0Foa09sYlZRTUdzZE5BdG0vVndBNmtzbUpXT01sUkdsT3g5MUNVZkRDc3BHVVJuTjhDK01EZ3cxbWR2T2haVWN3SzcrRnFJTnUzYUVJc0dudnV4Uk5vS2FkV0ZwRlJBbE1nMjdmWVNVcFJJTk8zekRLS0FsbStiRlFFYUVVSHNtdWwrQnF2MHF4MUVjRkNabVd0aStDU0cwQVVKUmJoc2FTejVDOUl1UkNRZEpZRWQ3bFVBVXZKcnMxYTZJVEdyblVSRGt1bkdJMUZKR1M2aDJJMUZnR3pkRU1SdjdOVXBDQXFPYkY1VXlNTHBFaGxCUHVYVU04Q3NtdVQxcG9nZHBXa3RrV0ZoMm5KWWx2QVNGY2d1elpxc1lsSEwyejFFUTZlOFZWVWFURWh3WXFvc3VtNUdoWHNqQ3JSVlRZUFVZTUg4Y25XaUlraytZTHpqTkhJU1NWbkduVDhjZTZ0Qkd1QjV6bndoU3JGSmdtOXJXaU9rNFU2VWRXNkNMWWp4MVRSR0UxeWlzakhHNDNWSktlTTdJQkk0ZzNxWEFmTEtySjMxMnJxTENEU3VnZ0xDMUFqamRxcjY2V2dGeWJOY2FxSTg1RzFnWmJZaDZpS0dCVnV3bFN0aTNCUWhZcWFZaXkxanFoM2lOVWNKM2liUitzV2RhZG1RT08xZU1Lam5STnRLNHVJa0ZzMmFvb1RyR1dJV2xRZ1JpWjZWdFlzSitobGk3Wm9sbE5GL3NaSVFwWXNKMWluSDUxcFdVNGdMVFk2cTFsT01Fa2hPZ21jaXZNWjdCOWFMMWIxRmFCR1JUTGtyT2J0QUlNaE9pMk00THhzTkM0NXNLUmtFaEJsaVVZNG1LTEZUZk01eTRsWUM2ZFlKV2FSVVhJSTQ3bEwwWFZBdVZDUm93S2FsQWc4VVpHcm9jVDNCVWk4bWhZdzJoSkpkczIwQUxkMDlGR05CcGo0RzcxVUxxTFZUa2NSWHhTSVFLb25BakxYSXl1UGhXMDlnNFlzZTRYdVMzUUtCYW5oclE3bGpjUWc5ZUdjQlFWZXg5a0JuZ2NlMEpNOEd4UVZWb3hGYmhrMThjaEdzblk1L21Bc1BEV0MzTWtTZlFVeUNWSUJLcTV5c09DQytFYlk3ZTRSbFJaRVlCZCs1TDVSV2ptTVJzK05vNXc2V3dIZm96aWNKSVlPeHNXdG8zU3JBNXJRNjZ3ZEdudlVPdXVJM0U2UkRGcTJKeHlzdG9sazBJbzlZWkQ3STNMN0tPMTBBanRhVlRVb0FsUmxrdFpFWVBkbzVBNVMyc2tGbkdaazBDYjFhWUxjbVVnV2JWTHpDMmhya1N4YWFkamtrUDg2SmkySndLMEZJcmVSQ3BwaUF4WTk5NUhTZEIyRG5sVzBhWk5GR21sTVZiT2JLdkk5eGF4VkVUN0RJNVNNMnFqVm15RENHclBVclV1dEVPQnFsc3A4YVlDQm5oVWtXdUZnZjZlWXRTckN3ZlRIeUEybDNLeUlKSEpIS2IxU2daa1d1YVdVZHNsQkw2eTlMQnV4dm1oWkJIZHNBVVJXb2hEWTF4ckpxQTJhQ3dzTTVGaTgyaFVCSGwwbHFGMEJzODlpa2JJSXNtZlE3Y09kcFNSWkZKQmsxdTF4YzRGWXhMRFVCa3hqb3NwM1FNWG5aSlY2Q0w2andjN2h4bEtCaVdCalBNZjZVb1Y1aUpFYlM3bEpUbTBVZE52WjFWcTFGb0t2VmpTb3RDWTJvUmRtVFd6Q1Y2dm1JVWxFRzhpUEhjbFJybFp3bVNkak5FYmgwQUdmakpaRDBOVUtGa05paDBYVGFqT2c4b3RtQ1hoRUZNU2NjTkJsbVloUFZtOWdjTGNtbytVUURsYmFKQ09CaDRsOW1VeFJjd0ttbHlSdUx0VU1UUEFzYmk3bHhNSUVnWjlrdFI0Q251L0pTbVdqR0pnRlVIbXRtaWpvVEU1ME5rclZSRVgzVHVLbG9GSEZnTWFsOVJEQllxb3NjWWpna09HUnVMbVVwc0lDYXloWmFldkRIV2xBKzRUa2pEYXRzWWhFVzdwR3BLQW5Ub25SenBIQXNrck9iZWo4bXRnOXFqMFIwUXVEdG42RmJ0bmt0QjRpb01oSGNrbWJPR1hrNlU2OEliU1pJWHBmNmQxZkRYcGg3VTJjMFBuZ2pjWWhJa3FKUyt3Y2lLSXdBN3MrcVNOY2poRXdlbTR1cGM3aWdKNGxtcktrU0tKbmFWa0U3S3FVYUo5bU1Wb0RJc3BzWG1nVjBKaElhczhLckZCTlhzSkRPYUFFalJURUJFdXcwVk1LVWhHUjhHVVJ4UENJTUVrNXNicHR1Zmx1UlUraUxjcGRmTkd3STZ1aEVlWUxKKzN3SE9IZG00TDBtSnc5cWJEaUdEMHFsMGhCK3Q5Tm5oU2xpUTBUQVJvcGcrQldVT2hCbk1KTmpBUmFhSXBpMFVmWXpDeEZhYndRQzRyekpqSm55WkxnNGxXd0NhSVVRQ1M4ejdtZFZKQ1d3V2pnaFptWUloNTRaWEVrbURtUXVKMlU1U2ErNk81TFVnR1JMVkpDVTVMY3FnemRPNG5tUlZkZURuQ25rQmxMSmdRWlFjQXFTMGtLOTNLQmgwV1M0b2NDRTBkVGttNEViSkdnSnhVMkg4alVRQ3VjdTBoeGQxckFiekpmeVh3b0JkNzhXY29lS2g0MmNkb25kcWVoaTVoc1Z6WWZBb3BIcEN4eHQ1cWc2cGxsc2RXQ1RKcVVXODJEd2UvanE1enROVGp5b3ZaRFFFNitSSWFyMDBvNnhFOWFBRTV6WFNHVjdaWUJpQ1duNHJwbEFLbThaaS9Cb3V2RTNhTTBrVDhocXFqMlEwRUhQbmVQRXM4Y0NQQ2tva1VQenFHT2k2bUlENUFOQTRPb3Fwb1BHZDVudElhdHR0OXdpTXFLK2VEeGZWMWROd3lRQnM3dG85UXlBSHVIdTBmTmZFaXBSclVlS2xJOHRVR1RaRHlBRlYrMTZDRkFXejl4V0ZmN1dxTUxncnRIcWFvTHhKTzVra2E3aEJkRVpjVjQ0RXZYQWlvbjNSbEI0SVpJSklrcGVoUll5OXBoaTFzdkFoVWcwNVpuNHlGbTVEbkk3QXhJMGxnUjZKM1phTjBEM1hJR2pVdFNqTGxwWWtCdmxDUlFicG9JRk1ac3BKRXNOMDBFWm5YbU5sTFNEUkVOeTJyZFE0TGx1TmxLNHdxbVFxd25JNWZOaHdUMTVrem5GWnNQQ2E4YUsxM0N1R2NpdUF5ejFicUhiQUJKbHFCRGhnbnhXVnJQTVZGRzg2dVN4WlJoZzk2c1FVcWJvU002T3kxNnlEQ2NsWjBXUFhDekMvUkdjY0pJdDBmUTBwK3piNzFRQVpzemM3REVDUlhpaEJPRUVLWUNIcHVzZm1ydUw0bFdvSk91QUV3RmRNaXNmZUdaQ3RUVVpPN2JsYlNqSmRpdzNFY3FDaFZ3ejJXdjFRL1pBME0rY3hzcEo5MHhFWjRFdDVHeVFvWEV5RlZmUWdSVWxzeFIvaXBVNkVqeVd2eVFBM0xiWnkrOTBMaHBKeHg4bGFCRGp1aGV5ZHhJS2dnVmVCU0hscndRb2JNNWFPMURocFVibWZ0SUNSRUlIZVVnZGo1VFZmUkN5V25tdHFUb3RndWkvekVWV3FkQlN4OHlUSHJJM0VjcUNCWGlWcFdZUTA1SUM4emNSOG9wRlhnaE41S3kybmtWYkorb3RROU1CWWhFTnhKdWdiMVBGaTNuTXJHb3dXbER0N1RYTlIvUjRKUGtNdkdaQkdRZHRmWWh3MHpVekRhMjA1c01QYXVLalpHd3FzR211TnpvYU5razBkcFlod0RXYjA1YSt4Q2hXcGFUWUlpd251VFFzNlN5bDd0ckF5bHlHeWxGeS9Ib1VZS1JJam9sZWxZV0V5UEFUcFE1U2VrRE53RkFMSzJheXhUZzlaT041akxCTGt1WjcybHR3NEVPVkZwVlltTWtxSTVrcjhFSFZMcWJ1WkdVWnFxamRjcU5wRm9VQmowcmFTNFQ3RUtldVpHVWhsUVJ0NHJtTW1IMWdLeGN5V1V5a0tvWXpXVXFHR0hJYWpwVFJzY2JONUlLU29TbzFoSUlVQnlWdVpHVU5xVkh0MkxSQ3ZxSHg0TDlseDJkMFNzdUk2MGROZ3J0QStIK29iTEdGZmNQMVZGZWlmdUhLbHBXM0Q5VVg3TGkvcUZpaUJYM0Q2V3JkOXcvbElPOTR2NmhST0NPKzRkU2FUdnNIMHF1N0toL0tJTjVSZjFEUkN2cUh5SmFVZjlnaWxSSC9VTkVIZlVQMGF5b2Y0aG9SZjJENGZxTytsZFFZTG1qL2lHaUZmVVBFYTJvZjhnbHQ2TCtJYUtPK29kb1Z0US9STFNpL2tFdllVZjlRMFFyNmw5QmZwV08rZ2RkSVpwQkJ1c2VPdW9mSm1xb2Z3bEJJM1hVUDB6VVVQOVFFNDhPK2dlYkI5eUIvaUY5ZkFYOVEwUU45UThTZGRRLzJFMjNvLzRoN0tRRytnZEpWc3cvb09mZFlmNEJWMTdIL01ORURmTXZvNFNQanZrSC9la2Q4eStpM05xTytSZlFreHJtSHdRU2E1aC9mRzJPYVJUeUw4QW1BQjN5RCtiMWQ4aS9qT0l2SGZJdm9sQk9nL3p6MEtmVElQODROUUVRTmNnL2lETFdJZi9FNWh3UmRjZy9oK0dHT3VRZkxQSllJZi9nK3UyUWZ4WUcwRHJrbjRYR3hRcjVWekZnWVlQOFF4ZCtSL3lEc2JFVjhjOWhVTU5XMEc1UWJWcEQvS3NRVHJRQi9sVjRLemE4UHlKQ0tCb0s5MWN6aE8xUXRMOWFNTHlnZ1AwWkF5Rk9HdGdmY2Nxajl5bllud25JdnVwZ2Z5d2h4S3JhNms0Z3pGZ0QrN013bjd1RC9VMmdDaHZZbnkzSUJkUEIvamlPT0VIN2N4NGo5Q25hSDJkY29Ra3EycCtiUVBRMXREK0xoOTdnL21EeitoWHViekt1Mmh0aElTQ2hEdmRuNExidmNIK0FvbUg5UlRpL2p2V1hVVlJpeGZxRHlia2Q3STliQVNMb1BRWDdJeE1FUVdjMXNMOElzem83MkYrMDZQNXVZSDgwTEhSaU5iUy9VQ0FFWm9QN3cxcEZoL3NMQVNQbXRiSjJtTEhRNGY1Z0M1dU85dWNoUEU1SCsvTUJZd0lxM0orM0VOSlY0ZjRjekZ2dGNIOE9HbjRkN3M4RkRKcW5jSC9zYWdPY1Y3Zy9QZ2dSdEszaS9VbXZHRVMxbHJXajgxc1IvNlNzSGF3YmdmeVQ4Z1ZBazdWZVBVTnRSVEgvNU5wSFlJV3RxdDFqckx1RyttY2hlS1dpL21ITXBBYjZWMkZmeUliNXh4bjFnRWFMMnZGSm80Qi9QQ1JFbERvb0IyQm5nL3Vib0hRMXVEOERVYWc3M0orcDhIQm9jSDhXRlVSM3REOEw0NGNkN2M5Q1U3aWgvZGtLMWJxRzl1Y3cybTVEKytQK3pZQkl3ZjRjQnJoc1lIL2FUbmxNMWNEK0pzTnFZSDhCd2d0MnNMK0VjZndVN0E4djVBYjJGeUFHU0FmN3d5MmVPOWhmQ0NoTTB0SCt1RWNTd3Q1VHRMK1FNWTZmb3YxTnJycUc5aGNxY2tWMHRMOElyY3lHOWhjTlJFTnVjSDhSSW5GMXVMOEFtdzUwdUw4QUV6azczRi9BSUpFTjdpOEU1UC9vY0g5aEF1U1hPeXdIZkZaWmRLR2lyYUY0ZjZMQUljQTdMV3YzRnNQaVdXMmZXMUFHUzRQOGsvNHpVOHcvMGVRUnhsNVFMSEVEUVVVVTlXOEN4c3F3ZnpOb0g4WDlZd3N3b2FFcjhKK0ZYYzFYNEQrb1k2ekFmeGo5cXdQL1JZaTQwWUQvREt5ejZjQi9Cc0llZE9BLzR5Qndvd0wvR1pqUzJZSC8rTzRFUktrWHNLT2hLK3dmYm52V1lmOE1ETzkyMkQ5NHYzYlVQeTYvQXRKcHFIODJJVk9sb2Y3WmdvSkpIZlhQV1JUdTc4Qi96dU5uS2ZDZmc3QU9IZmtQdCt6b3lIOWE0VE9tS3IxK0hjSVdLdktmaDJwMVIvN0RSMkJIL3NNWnNCMzVMM2dvb0liOEZ5TEdHbFRrdjVBaFZsVkQvZ3NGQWhnMTZMOEFuWVVkK2kvQ2RKS08vY2NoTy9Rc3dmNkxzQXFrWS8reDZZM0E3QlQ3YnpMNGh2M0hzVTJFeEtmWWZ3emJCNGdVK28rZUNPSXdIZm92R0R4RmhmN3pHU1ZITmVnL25IUFNvZjg4VE5qczBIOE9BMjAxN0Q5WGtEKzBnLzl4L3h4QXBOaC8zT2NKdlZDeC81eEZTbmpIL3NQdC9EdjJIOFpoN3RoL0ZqWUs3dGgvMWtJRTNvYjlaeW84U1JyMm40RzkyVHYybjRHYWM4Zis0ODdYZ0VpaC80eUgxMktEL2pNQkF3UUs5SitCVFRVNzlOOEUzS3RCLzVrS1pkMmcveGdCZTQ3K1oxR3BYQWYvNDQ2Z0NEOVB3ZjhzeENQbzRIL093TXRNd2Y4Y3JJWHM0SC9jaFI4UUtmYWZ3empaRGZ2UFZhaFZOdXcvajZGdUcvWWZXNmVBU0tIL2ZJTFNhZGgvSHJyYmo3RC8wT0FWK3cvM2Z1bllmeHlOUkdDRGl2MFhZTGZuanYwbmJYN0hSQXI5cHdBMlk2cFc2bDRnWEo4aS93WG9qdW5JZjN5TW83SFg1dklFRkpyQ2xPRTlVTmRDZDNSa05lUy9nTlhBaHZ3WHNMWFNrUDg4Uk1ycHlIOCtRVjQxNUQvdm9Ua215SCtUNXZNTittOEd6cTNZZndMcmdvQVNxMEtMQndqZG9PaC80dUVDdUF3Sy95ZTVtZ2o0em1rUmU4S29mYjRiR1JCTFVCRUFMV3pJMEJBQUxheHBXUkVBb2RkalJRQ0VIVWc3QXVBRVFxb2hBQnJVb2JnREFKcUljZThVQUJCM1N1OEFnS1pBbmlvQUlMMFhJU0UyQUVBTGpkd09BS2hkSmNkVUNnQm9NWjVIQXdERXZaVTZBS0J6R0w1UUVRQWQ3S1BRRVFBZFRHSHJDSUN1WXFTOWhnQ0lRSzQ3QUtEM0tHN1hBUUE5ck9Yb0FJRGNtd0ZSS1FDZ3J4QnNxaU1Bd3VZVVJ3aUFFTDZ3UXdBaVRiZWpBQ2E0SWpvS0lFWVM3U2lBR095bm9RQkdtSFBSVVFDeGw3V2pBRWJZTDdlakFESkNISHFqb2dDR2pORUpCUVV3Uk14VFJRRU1IcUp1TlJUQUFIMHRIUVdRUGYyQVNFRUFQZFIwT3dpZ2gxMEtPZ3FnaDlEdUhRYlFaVlNxMW1FQVhZS1FSZzBHa0VFVDBlZ1ZCdEJaZUZvMkdFQ0x3ZE1hREtCTkdDelE5dnduNEpCcE9JQnNzS0M5b1VDQUU1eThEZ1NJVDVJR0JKandEQnNRWU1SVUt4RGdKaHhBdEdFN0VHQ0J3RnNkQ1JERGMzVWtRUEM2RGdPSW9jd2FEQ0JzUzNnRUE3Z0pCUkR0c0RzVVFIUUwzNkVBSXVUVk94aEF0SzQ2RENETTNscGhBR0dMd3hVR0VDWS9LdzRnaG1WdU9JREJZb2cvQlFJTStEaHFRSUNjakRvSEFvUkdXOGNCREJtcXNBMEhNTUMwckk0REdDbzgyUlFIa0NPWWN4ekFnRG92ZGhqQWdER1NHd3hnZ0Yya09nemdCTEc0d1FENkNpK3hCZ1Bvb2VuVFlRQTlGcUxDQUNLczVZWUJpUE41T2dhZzFvSVBxUm9Hb0lPUVFCMERVQk1JeDFSYUR1OE14Q3h1R0lCOEhJSGwwR0FBYllCNG93b0RPT25Fb2ppQWd0V0xpTFFhM21RTVlLaVZFU2JDczFTaEFBVU1FUUNYZEN4QUI3RmdPaGFnQlNHNUZRclF3aHFwRGdYb01PYWVRZ0hDMnRvT0JXZ3dVaytEQWpUUXFiaENBVTR3RVJzVUlLd3k3bENBRmpiWDdWQ0FiQUFDSWtVQ3RCVWxYcXhJZ0E3aHZuVWdRT1N2N2ppQURycVBPdzRnUisvUUJCc09vRU0yeUlvRENEdGFIZUVBb3JYVmNRQWhHRkdEQVF3R3NsUmhBRGt0RTlBMEdFRFlqV0dGQWNRWVBCMEdFRmE2ZGhqQWdNRWNHd3dnNTFLaU4yb3RQRGIrT2c2ZzVtV09xUVFITUVDODNvNER5QTAwd2VBYkRtQ1k0TzFwTFh5QW5waU9BOGpXSFhxalZrMTRpRVBXWUFDNTdTVWdVaFJBancvVGhnS0lhODRiQ3FDRDlXRWRCZEJGaUIvVVVBQWRyS0ZwS0lEU1ZCL2g2UWtNSUlkb0VLQ2dWc0xiQ004SHhRSGt3QkZ3bkRZZ1FBbENvZkxjdENnR0ZEcHh0UjVOaTFiR1JGb0pieUxFSXdxdGJpSWc1WHRGQTRRdGNGWTBRSWRyaXhzYW9JZDF3eDBORU9YT0tCZ2dyR25wWUlERVVGUTUzY0VBSFlSeTdHaUFNSW44Q0EwUVFVcmR3UUVpZUxFT0IraFExc0lLQnhnZ3BtcUhBNFNXU29jRHhOZDBnd1BrNHdFQi9UVTRRT2ltWGVFQVlYUEtGUTRRdG1Mb2VJREJRS0N1aGdjWVlCcFl4d01NTUUycUF3SkdaQnV0Z0lDb0FtM0ZBNFI5d1ZjOHdBSWhuQnNlSU8xdDFBbWdBUUxTM2thTHF3RUNSck1GRURCZ2dNZ0dDQWlqaVIwUU1HRE5yUUVDaGdoUDB3WUlpTk5yT2lCZ01DaVZxZ01DY3JjcEJFR29sUk0rWURoREJRVDBzRzFhQndUazFGVEFWQVVFWkZVSkRVc0JBYlV0MnBoS1N5Y2NxcTN0ZUlCMGNTS05SZkVBMlJzS29xb05FRkJTTHFhSWdIeHpJc05ISVFHbExRb2FGNmRqU1RVRG9CRk1RS2tHUmUvTFdtUGhJRXZ2VUFFaE1HSXJuNEJkN2xkVVFBT3hIVG9xb0VYZXU0NEtpTEVmT3lvZ203cUFTT3NuR1BZUHZWQlJBWEUrVDBjRk5CVmllRFJVUUR1Wm9xSUNXdGhFdTZNQzJrMm9nQk0wcDQ0S2lBV2txSUM0WjJ5SEJYU3dFVjJIQlhRdzg2TERBbXBYd1RGVmd3V0V5WllyTENEVUYxZFlRTGo3VjFoQW1OTFRZUUVyQnVsVFdNQ0FBclFkRlZDYjZZeXBGQlV3d05xM2pncklOeitDMzJ2MUV3bWlyelZVUUZ4WjJXRUJaMVFLQ3hoZ3VWYURCY1NZRXgwV2tHR3RFT2Fkd2dJR1dNM1FZUUU5OUYxMVpNQUp5RlJEQm1UdEV4QnArUVFHVUduQWdOWmg1QjJwKzBySTVtendnSktaaXFEL2l0WndRMlRvQmhBb2xSOElRMDhRQXVYY1F1MkhySm9aSGdXUEdrWWcrd3dSaXFlQ0JGcnQyanVtMHZJSm1FcSt3Z1JHQ0Y1NUJ4TUlwOWhnQWpFTVhZY0poS2xHSFNiUWVDaWdCaE9vT1U1aktvVUpOREJWb3NNRUdoaFhhRENCQm5ZUjdqaUJPTXUxNHdSYWozeHFIU2VRK3pnZ0pFVEZDYlFZa0svaEJPTDZqNDRUaURHV09rNmdnNjA5RzA2Z3d3dTE0UVI2aXgrbE9JRWVRd3MzbkVBUEhmZ2RKM0J5MzNXY1FOaGhZOFVKaERIYUZTY1FWb2QybkVCZzMzV1FRQzRlbUlNRXNrOEo5U2hUa01CbzRJbmFRQUlqcklMcElJSFJZZmcvclorSTBESFZRUUk1cXdJOVMwRUNJd1o1VlpEQWlMenVIU013V2d6R1ozb0NGTVRaczczbEUycVAxMEFDSi9kK0F3bWNxRWtOSkRBWS9DeXRuL0FZVFZ0UUFnVmhBTFd0a3g1TTB0c0R2VkNBQWpuVENEMnFhaTAzREpvMnBFQ0JiVUNOOGdRcVVGeDBZSWFLRmNqdVBnakw1OVhLZ01rU0RTMVFVb2dRbGRaUFdCakVYT0VDS3dLazdtaUJHWldSckdpQkdLSzhvUVVLT04rSXFJTUZHZ3VScEJwWUlEYWFPMWdnRndOUHdRSVpUZ3UxT3d5OS94T0VGRlN3UUlPNjUzYXN3QW5NU3NNS3hCcFh4d3JFcGJzZEsxQmhDNFpVRFN2UVFtMjNZUVZhMklDMll3VmlaYmRqQlRvUDRUNGFWcUNEWGRJN1ZxQ0R3UFlkSzlEREJzNGRLNUJPRzRUbDFiQUNQWFNyZGF4QUQ5TzdCU3ZRdzhEamloVm84SU5zejRGQ2dKd2RLeEJDcXE1WWdSSGRCVWRnZ2VoUnNlZEFvY1hjd0FLamdTZzRDaGJJdWdHQ01GU3d3T2kyZ0FWR2g4YmVzQUlqOUpaMXJNQm80V3BvV0lIUlFNeWdoaFVZQ2hSMXd3ckVqYTRhVmlDK3FSdFdJRi9DQ0ZoSXdRSW44YUdHRmlnSittaUtWVzBNdkNBVUx4Qlg1VFc4UUVHcUJVUmlJVTZDbUEwd3NHYU1UOGk1SjlWQzJTaGlZTUU3UjlzKzU0cUhKSWlCR1FLSE44UkFUdkJFc0lLQ0dKZzgwbWc2WW1DRmE2cEJCaWFJOGFhUWdSRWVvUTB5TUVKOFFrVU1qTWc5MFJBREkyeHgweEFEWTRhTFhCRURJeXdiNjRpQk1QbW1Jd1k2MUUrc0l3WUdqUE1uMVJJSk5tMXVpSUVKZXJNNllxQkI0R2NOTU5CQkdMVUdHSWdhSWpXOHdBeTdTRFM4d0Z4UTJtdkhDNFJKUGcwdjBNRUhOY0RBZ0xFQVJaa3EwQ3ZUQUFNTERJUjF3RUNZOWRFQkF6RndhQU1NeEFlS0FnYldncUVBRlM4UXVteFh2RUNvcVhlNHdJaGgrVXczSUZBMzhUdTRRS1NwMzhFRklnMzFEaTRRU2ZrT0xoRHgvUTR1RUNtZksxNGdLRUk0d2d0RTI3ampCUWJjVmJ5dVdCNEltSy9oQldMRnN1TUY0dEYzdkVDWThicmlCUVpVWmQ0QkEySDdxUlV3c0VCVnZTTUc0cU9oSXdhaTJQWUtHSWczWWdjTWhFMVZWc0RBaEk2SERoZ1lZREZ3YnBpQ0NJdXBBd2FpM2o4clhpQ0d1T2w0Z2RDcVdmRUNFd1NJYTNpQk1VT0F1SVlYR0dFSnlJb1hDRk5SVnJ4QWkxWjh4d3YwRUQrcDR3VUdkSGl2ZUlHdzFmYUtGd2d0L2hVdkVCYlRybmlCME8vZThRSVREUHNlUVFZaVdKMEdHV2p4Q3h0a29FT1h3UW9aQ0F0TlY4aEF3UGVPRjRqeHREcGVJTVo5NjNpQkVBQjZ4UXVNK0kwTkx4QldOYXg0Z1JqVHJlTUZScVFjcm5pQkdLV3M0d1VtaklEWDhBSVR1b1ZYdkVBWUgxb0JBMkZaNFFvWW1PQXVhNENCR0dxdUF3WmlmTGdPR0poUXB0QUtHSmdnSkdMREMwd1ljNi9oQldKQWlnNFlpTEo2Vjd6QURCZHF3d3VFYVNFclhpQSttanRlWUVhcThJb1hDTXNQVjd6QWpNRU9HMTVnaGxCbWQ0Q0JhSmQxd01BSUFWRTdZS0JINnM4S0dHalJnbWlBZ1FtbVhuYkFRSVdQR1ZNcFlDQmZMR2lLQ2hpWVlCNWFCd3lNc0pWeEJ3eU1DVE5DQVFNamJIVFFBQU1qN09YZUFRTTFoaittYWtVU0VZTVBLbUJnMkFRWTZERWlYVU1NWlAwVWlMRWhCbm9ZUysrSWdkN0FNMXdSQTEyQndLTU5NZEJGK01LR0dPZzhpdGVzaUlFR1NyRWhCdUkycEIweEVLY0xkTWhBNjVFWnVFSUdRaTlxaHd5RXRlOE5NWkRqSTRoYnJVNGlZVDRvWXFDQjZUWXJZbUJDTy9ZbEFPL1pnNkgvTEZmUmNoUEN3L2VYNGVsT0h2ZnRELy85WDMvNTIyQlNSdjQ3L1BYUGc4OS8rKzEzNXZEbjBXKy8vemo2dFcvTTRRdDcrUGlud2Vja1dKbUlrei9ZMHZyNEl4amh4ejhjL3RFWVQ3WlorR0JNTlBSM29UODhmYituLzAvNi80SCtOaCsrL0RnQ0FQejY0MHlDUTFaZExjTWhxbUdYSVBHSHU2ME1CR2dIeUljajNFTXpRRDIwNXZEUGwzK0IxWkc3UDBaSWlIUzlPam9oTGcrU3NTcmQ4S2o2RHJOeHdLQ3RLNWZ6QlByM2FQV2l0VHRZdVhqZDNxMWFiNlN2Nm5qZDNxMWF1a0NNL2FyOTdVZXI4K0xhM0xJeWI0UmhsdFNGcXprVzNqTEhIQmxNVjNNc3ZtV09lVklqcitaWWVzc2NDNlMwWHMyeC9KWTVGc204dUpwajVTMXpMSkdwdFpsalliOHJIWHRJcitmWUU5eVZVNTIyYVlzRG5mYSt5amxnckQ0cURsSEYvL1NiejFjc3B6TWhkcjZXcVRneWFWL0pWTHpQcjJVcXdhZlhNcFhvNDJ1WlN2TGh0VXdsZTM4alV3SHVMcmt2MjR5NGcyQ2hTYjB0bDFjZHU3T2tucjhUUm1kTStJYitMdWYrTWZmTkxmbkZsa2gvdjN5M0dNbnh4OUZuaitvVTIrQWRkbFlReGo1L3AyelFnMS9XZnJIbVVaYjVEVEtOMjl0dloxdDhHYWZEdHJWdHM5dlg5dW5YdnJidmovVElRbjRaYS92bCtodWMxdXR1YzJtOVZhZU0wOTV3MjN3eWI1aEp4Vy9qVVh6RFBOSWFzam1QMGh2bWtVM2JlSlNmMmVjcGZoei9BR1oycEljOXIzY3RNZUQ0YTVsSnlLOWxKcTltZGVYNlNpWVMwaXVaaUhVdmNTSm5xdlUvSEg3OS9WOSsvOWRmZnYyckNlR3Z0bjQ2L216MHllam55SDY5eS9VS2t1U2FUczRrYlBtdUx1bjczakFzWk1HRVBYV1MzWGVPM1hlS25UbkRHQXdqbmZ4NTN3L0dRenRkTjV5b2JDcjkrTlR2OWQxbG5wOE1leXlMYlJ3eWgzUUxIQkxGNXRHNGMyK2FaNU04bmFJOW1lQnNOdWFRVCtiQ0RQL2g1UDhaMHp6NS9wZlJSWHRFa2U4dGpPOHVUZTlrQ2xoUnZlVENQMWRIVDVUUVM2b25kMzczdW9ya1g1YXhUaTBIVGhnUnV2aFQ5ZlBJSysrTmliRWxuWEk2akQxVlFvOVV6N0hDK1N3elpHQjVrK1l6ZEcxMm5Gb2I4ODNNamxHZTgzeDJwZ1ZISGw2TzRKRHlEcHhTRjY2dnU5ODh5eEtlM2ZOM3Y4cnRXQzRrR1YvWThXY1h2SkZRekk4WGZ1cGMrNk1IYSs3Uk1EaW5EV2QzZ1g0UW5QQkNtcWZKVTlaL3g0c1BhaC85TVBvb2wvNVkyMTlzeng0a3VKWm56NURYSzVmb0tlYmlFTzZ6OXA1Q2cxU1p1V2Y3NkFaYkxrVTJ0MWpyNDJqbXlENi9ZSnVQN2ZMN1c0eit0clMzU0pPNVlKb2ZuUjladzQ2Y2toL2RKUlA5ekR5Zm1lYWJtRUhySVBPZm52WFdFUHpUTVlhYnZpY0IxTjNBSG83UU1udXNhOUZhcm1xd2QvOHZuNytubjc5N090WTk3VHFpcTNZYnF5U2xtWk4wbVQzdlJvN0QxOEFTeCtYQWZ1c1MwbFR2STc3VVY4dVhVclJ0L0JhdXZOZHZVeDZBRzlpOHZPWjQ1eTZUTHVYSkNYL1JHSjdlNWR0dTg5Rjl2dTFHQjNmNjliYzZ2TmV2dmRsSGQvdTIyLzM4ZnIvZ3NzRHVpaTN4NjlrOXY5VXZqektYeHQ3NGk3NTQ1SW0vNnM3ZmtxMTBrcW5rQnRHeEMvNzZ1YmQrSTk4MnFRV1B5a1BwNUpPa2wrd21WcnB2bnA1THo3TzZiT1htU3ZqYU96bmlTN3YwNmppSytQcTQ1QmlKMlcxZlB5dVg0amlPK0FxNU5GVVZUbmowUVZYTHk4ckNKL0huMHozUzF5a1VESUVkcHlianJsQ2NmTGdyRkdkVGV1RUt4YWtiZ2Uzanl6dlZMY25jYVJndlZRMHBrdTVuNkRzTkFtYS8rODNocDVlcHZ4UnVzYjc5K3RudTROQ2Y3ZXJPK2VCNmdzdlJSVjYrM05XZGU0UHJxVktOUzN5bHYvdHlWM2RPaG5iejZrNUszUDl5VjNiVzM5aVZuZUZUdnIxWlpTZnFuZWp6MjNTUXNCSlh0bXNZYTlPbk4zUGFtMGhiK3dyTndmVHZOOE9oRFJHVTAwVDk5dDMxcS9CbU9GV3pPaENlYnkwOWxlN0FvR0ZtajcwYy84YXVQUXlmOHUwUE54dDdJZTNodzVkN2FHVVByZXdhdytQN0djSzQ5T2pyWFZ1NFhXMkIreGNudjBkV2puOWpWeGVHVC9uMmh4dVBySmhCUVRjSk00UTc1U0tNSWlyWkg1NHpzV08vVjE4b2g2SmdGVzVkakdtL1NlOFA3Z1hlcE5jWHpUMUtIWWc5cndNcGpLTWpYSlovMFMxVGwyTDh1THpsbnVyRzUxZ2VHZ2lHOFZaR2E5VXdDTTU2VHQ2TFR6OW9BUWxqUFZWVTZuWkIzSFB6N05KaXY3Zk1MN0g4WGcrYnROajdTL25JTkQwTHlCa0dLdXNmaDZCVk9Cd2Y3bkZpamd1emg1ZXJkUGlxa3JabThmVHo4NnNyTThqUUhWckErVnZqM1V2WDRpYnVuM3FmOG1SYm9RMjF2WWpIR1ZqRmMzR3JqZzZweXdmVTJlRTBPcGcyZEI4NkV0NVJqUlEzbWhXSk5Da0lBMzJUU215U3pKcXFJUkw5b1BTeGpodlV5ZTgyU2N2bi9MdnZtb0JpKzMwR2ZuamZubS8xWnhMTjlIZTFYUEw4MnNaM0lRSEVrVTV1Y1k0SWJlV2piWDVlRHNaZjl3NWN0RFkrKzdnRVo0RmpmRDUzNVZsd2NUVnQyditYMXRGNVlvTm5BTCtMcFhkYlN3cy9kZWM5L1d5NVA3TWRGbEtldXB2MDI5dWJuYXRnNFpZTmMvWGwxdWZxR1prb2t3NHhuK3RYTFFpWjdnNjhVRzUyM293ZFpyYk1tdy9jMDhMWko3Zzl2WU8zNThTcEUyL1lteE9NWTl6SFM5NGMvc2hMTmpEOUl6WnZ6dnJ2T0hoWUhIbHoxZzl6NlkrMi9mVzdOK2VGZTNPRy9obHpaNTJNQWg5c0dFeHRjY01JblNNN3AzKzk3a0RUaGhMZmh5dnl2UjN2aDdzaTkzWHppdDVXM25wNGpTNmlrQVRwY25jdDZ0ZDUwbXRjU3RtZHIzZGZaN3FjZDB1Mk80ZnV2czQ0bEF1cE9zL0tJZXlHdlZhOUdSYVliMnNLdDBIWDNhcnRqdlhkclJvdjFIay9SZXVkNkwzWGE3NWozWGVyOW50Si83M1lMUS9yd0Z2YnA4LzE0Q3RhdzRJdCt4aE5ZYS9UaWJkb3hWdjE0bzJhOFViZCtDbTY5ajZ2YUx4ZnJKM0Z0azZQMVRmTHFzSW16QldzQ3MvWkMzcWI1ZlVFYk50a2dUMmtEWGFiSzlGZHdkS3BUZllwVnRuaDFXOWc1ODJTekZXSFhXZzhtL1N1ZUFPOHk2UWtoU3M0bDQ1VzNZZkhYM1ViVUdpOExVdDFrblJ3czNoazF5cFcyMjd1cDhPaWVSbHNpOHY4RURqaDNLYmo4K1ZBMHp5em5zUWRYZU5WeHl6c0FNZGZuM2hJekxqNnNBYjlzTUhMYnREMzM5a04rcmRtMEkvUk1EZTFkbmxidHRLMnNxZ3RoVkdITjJBRWJXbktjbkxOYk9pdmRuajltcnpQUzY1WGNLMDNzeW1Qajl6MGdybVdNeDBUVjYyMmVxUTBmdGl0bi9WcnQzNXUxUHJoQStEOWJ2MmNmajJBOVRQcDhYUWoxcytnMzlOdSsvVGYyVzJmTjJmN2dHQm1kRWRWbUo4YnpOeHRwQXREM20wa3RaSENKOWxJL3ZHMTFwZTd4N2ZrODEyVGEvUUdPTFlwdzIvbjJmVTVmenZQcnM4Q2ZCS2VQYTE2UFd5SnRpdlkvWGQyQmZ2TktkaFYwNFBzTUgvUDBqM3VEbGNHSS9iRUxWVzBFKzJaSzdTZ0IzZGczSkNlVFNkSnZ1cFdldC9pRUwweDJic3ZkMTE3MTRGMlhmdjhhOWUxZDEzN2FYWHRjVVBCWGRudXY3TXIyMjlOMlhaZkErVjVMN25aZm4zSHhkUzk1T2JTcCtlZFhjZ2N1cEdTbXpsUzJCQXI3RVdaZlp0UXd6NnRYc2RBM0xERDRTMkVZNjZ0b1pnQVpCME9lNzVhSCtTRmR0L3Z2OXp6MWE2Ti9IRytYOWp6MWRhdlBWL3RlZG4yeWZscUdSWHM3Zmxxcnl4ZkRYMDYvbXo4Q1Q2dytqRVZzMTlNU2VuK01UVTc3dnJ2bDRPNXZrc2VhWWd4NnNLaGYxVVZKMjZYTi9kNW1LbTNZN2pVK1JtWFZnM2R3RU92Z3ptNGRQa3o5TW5sbjE4eS9uOTNVZFBlZWdzRnk2MTJmUWdIWjl6MTZ2d1dKeEYvSFR1SzR1aWVZN0svRDArOWZ4cCtNanIzU05ML1BQam8zLzBoL0ljNS9HSDB6S1hVY1BMbjRWKy9IZEFTQjUzMWg5R1VmSW55K1ErRHo3K2JuYzFEcnU2OGw5VmJET1E5Zjc3enZuODlNTzlEeHJ5bnozZmU5NjhINXYza3pMSDdtWFAwOWJDOEp5c2RzWjQrM2puZnZ4Nlc4eUZCenRQSE8rZjcxd09mTnc0Zk4rN0JPWCsxN2ZuOGFxNzdCTm02b1d4cEdSbDM4dWVMdXhGdVVFYmhZV1VrTWNIWS92eGsrUVRMa1VYTGdDZmpqUlFjV2VCS2hHaVNVeHBBNUJjYmxjZ2lvbFJuYnd1TDgwcFRFRkhPUWxUQWs2SkV6NWtvSTZMU3hqMCs2RU5hdkhLcEZFUlVsVTBGUENrdmRLRllSYUVaRXJWM0lZb3UyeExHUkhXVnJVTkVxVEZwdkpXajZjSXREaEZOaFJ0dEYyNnhpS2dMZDB6alZ0a21SRlNVU3hrUStTN2JIQkZSbCsyWTN6RjAyYUxYeGVtNzRnYlp4clFZNVZHR1JFMjI2SFY1bGExSFJFMjI2SFdsQ3hlOXJxekNCYStyeS94QmRSWHVlRWpKckJzWEVqWGhvaWZaVmJqak1iVmpFc3dzdVNYNjZidjhCdUVTVWQrNDQ2MlVRaGR1OW9pb0MzZE1FMWZaRmtTVTAreEJxWWsyVlVUVFJRdGVsdGQ5aTJpYVpOSGJ5aXJaaklpcThpaUJJZFV1WEVDVXpRYmhadE9GbThaanlyWUxOd1ZFbEtZRHowNHl4YXhjOUlDb1NUZU9tY25JU2ZxZ2lHaWFlTWZIWkE1ZHVyRWdvaTdlTVUxY1FweU9PbmJweHZFMnlhbExOd0taNUM1ZE5PN2NwWXVlVkZicFdrU1V5bFJ3dFVzM1JrVFVwVHNtS3FaSkYvQ1NhSnAwNDNqY3hhN2lkWWlvVHRsVTNDcGZpNGlhZk1OWUtzV3Y4aDB2cHhLNmZJRWZrb2lhZk5Icm9xQkdUMllYdTN5QlVGSVhMeHBTV3NVTEpwZWJlQU9rYWVJTllFaGw4WG0ybjRpb2lSZU51M2J4b3RmVmRmdU8xMEExWGJ4Z2R0V3U0bzJJS00ya1cxMlhMbnFiNjlJTllOeCtGVzlFUkUyOGlDaDA4VnBFVXhyUm1DWjI2UVpJMUtUcng5S3RxVXNYRS9YTkMxNlhWK21PYWNwaWxFbStJcUs1Y09zcVhFUXpsNjAxWmhWdWdWUjVPbkJyeUxhcVc2aTZnQ09nY2wzRThGbHVsWEVDVkg3ZHdnNVNOU21EcFdCTjRBdERxTkRvNHlyb0RLblNmUENwaTlwN1NOV0U3UU9neWwzWXZrQ3EzUFlFWWxkWmhSMGdWUmMyZWxaZGhaMGdWUmMyWUwwMXE3QURwS3B6ZmxtN0NodHNJZnA0dnF0VlJ4UWlRT05YV1Z0STFUYzI0S2tOaTV0dkRhTHFzZ1pFY1JWMWdsUk4xRkE4YVJXMWhWUmQxR2hjbVdVOEhWZGVSUTMyb2kycnFNSFdzTFdMT25oSU5kLzhqSTRjcGl1UXFGS2VIUFRXMlZYVURsSjFVWU94TzlkbEhTQlJFN1VESzk3NVZkU1FhSDZLdU5BRjdRcWthb0oyaU8reEN4cU9QWFZCd3plbUptaUgrSjRYMjVobElWVVROQnhXNlpKMkVWSTFTY054MVhWWFk2b3VhaUFnYjNnTHp1WklWUE1YZXJ2S09rQ3FMbXRBNUZaUmcvUEIrMVhVSGxKRkhid0ZDOEtIVmRZT1VuVlpJMjdGTG11YklGV1ROYVJLWGRad2pvbTk2L0lzc0xwODdySzJBVkxWK1JSTGx6VjhWT215dG1qd2RSVTJlR013aTRuVEtRYXpDaHVNSzloVjJKQ295ZHFDUXltNFZkWU9VblZab3lsNlByTm1LNEtvdXF3QlVlaWlOaGxTYldCVzdLSTJCVkkxVVJza25zUm05bFNJdVl2YUpFalZSRzNBNGdxbGk5cFVTTlZrRGVkWXU2emhHeXQ3WjJlamoyYVZ0WU5VVGRhSXE5R3V3ZzZRcWs0WFYzUmJoRTFVTmMrSDVWZGhnelVZdzdxdkhhVHF3Z1ppakxFTEd5MHZvdW9iRzRneHBuVmpRNkltYTBTVVYxRUhTRFhmMXJHc2txNlFxa2thRWRYMUJQZVFxa2thU1NlWkxtbDA4eWU3U3JwQXFnM1hkWEliVHZEa3R0eldpVTdkS2JlSXFBa2F2UzkwUVNNZGo2aktoaGZHOWE0dWtLcE8xYVNVMk9hWnZqQjFTYU1aNWsyQ0xxdWdLNlNLODJXYTZpcG9ENm5TWEJOa0tLM3BlVVJFZlVzaktydUsya0dxTG1vMExMZUtHbE9WT2J1eVgyVU5pZnJ4amFZWTF1TWJEU3V1c3JhUXFzc2FFQ1UrWkdaTFBxZFYxR0FKNXJ4aFV4UFJmRlBuMGlYdE1WV1ROQnhWWlEvTDdJQWdxakszdG9ycGtrWnY1S0x5UEYybnhYWlJBMGtYMXlXTkRwc2kwY3ZwQzMwWE5SeThYMFVOMkZYQ01yY2VpS2p2YXJBZ1NseGxEWW1LbmZNaGRWR2pZNFNvUk5RV0JmUnR5U3BxQzBsRXpnWXFuYVdJbkUyQnZwRlNwV0dNaVNoamk2bFkwTVpEUVZjamd1WW9CS1lpUWRlTTB2WnNwU09YUTBNTzB4QWpxNGNIV3hVM0U3MFQ1TFV3RVVtWkdJWThVdlFpRWpJdGlJcUpTTWEwbGtHdWphMkJSVndzeWlOaElub1JiV21EbmtSSHJjVDJ3VHFvaVNYTVJCRVNrWUQ1YlVoeW1lWEwwWFpNUktPaExRaldlQ1ZPYzRBWXZxeXd5R2poSmNTa0t0SWxPNlpDSXBJR3NRb0UyQnd0V3BJdXZYUkN4RHZZV0RBNXg1OTZpVUJob3Bva2hnT09mY2N0bm1TZmcyUEYwYVkwTFgwM1FTbzVxdU9TMFFTREh0VUZqajNJU2UwczJuaU9UaFE2ZmRseG5CT2t5dG9FRTNpN25Va3NabkdZRmtqRlo3VTNLSWZQTWN1ak9CMTlnVlFzYVErRFJZN08xdURVWVJvaEZjdWFPK29qcXNxeWRna3lsWS84SUV3RkZqdFRzYXlkUVJhN28zdElaSjJScGNwVWlkZGdRSmUzMDZ1V3J6WVE2MklxRmpieEl3RmhXeS9DNXBVUklCVUxtM1lJcUhoeU5HemUxUlhsbWpOUktYd2hPY1Q1eUZQanJBY0xpVWpTMWVHUjAxSExxU0VPU1RDem5QbW05SkNJeEV4UFFsdUh0aktwRWhXbXRqTVJDYmxHdkJJcXk3aG1sR2JHUkNKaWcvUWxSeXRUUkV4SFZvQlVJdUlJUlV6SGtBKzZxREJWS2JKQUlaWEVhbm14cHdDcGVEOXJXSE5NNVdVL0c2U0RPaGQwUDhONkFhYUtXVUppSUFISzBjZldTb1FLSFVaRXhmdVpJMEZvOEVuMnM0ZlppVXpGd3ZZQjVZbzVKeHVMb3hib0ZpT3FJdUVJaXdaZlJOWSt3Yk9iRDlxaXd3SkVWWTl1NkZ4aktqbTZLNG9STStLNUh0MlF5TElqV2FLdEJWS0pxQTNLZDNSZURIQmVnVGxES2ptNkk3d0d2TmVqRzhiS21VcjJkVVYxTkk1WTdwcFdreUZWRWYwSVZHUTRIM1ZiUThPTHFmam9oa3FpbytYQ1IzZEdEbk1tNHFNN1FBMkRsaWNwbXRWaEpoUVd0Qmd3aUliRVhQQzk1Q3RMbVlnZ242b2MzUWJGbzEyUVU0aUdaREVSbVcwVmxoTzVZRmtlRlZQSVpRcVNWVjF3S2x5RHNrdVlxcWpSaVZTaTRHVWptd2lQVUtLaVFmTXRnZFRmRUZpK0xaOW9UQlZsSjdOdWtTRVY3MlRhbzFBeVNROXRnd3hycHVLZFRHZUhSWE5rcUZaVklTdWtJakdMTG8wNFVXUW44NkdWSUZXUm1Ec2NmTlZET3lKM0xWT1ZkZ0VBcW1qWVB1TlFjOEZVTE94ZzBCYU1WbVJOeXhVZEMxSENmL3lvQklsWTFMNUNyVHg2RVRVZE5CbFRwU0NYbDBFekRDSnFOblV5cEJKUlo2aVZ4eWlpZGg2ZWFrU2xKa1ZFUkVsRXpXcytRS3JDTzRPMkpKcGlGbEdUTFFQOEZrd2wreHFmTjdHSXJFMUFqaWtYcThoYVRYTkVSYStxRlI0UmlRNWNQZ1JCNml6VGtLUko2UVlEVDVibFhEMGNFUkh4d1kySG5lUWlyZmljU1Z4SldRMWNMa2thbWxXWVFzOUVKT0lhVVEyY1M0RWx6SmUzZzBRaVlJL0tUVnlLS3VDTW41WDA0TGFRNVltMVdYR1VnTldaNkp3NlNBWmhnRVJKclhYa1ZFcEZqMjFzaHhOVmR0TWR6MjNtMGxRakp5cnU5VW1uS0JoV050SVJNRmk0NDdPTWh4TkMwQ21hcmV4bHVpNlE3a3RVTE9xSTc1d3N6ajdPU2tCV0lUZU04NUpKNENBUmk1cU9OalQyd0pLbU15dGdJcFoweE82OEhFWFNkQnFoZTRLb1dOSmMvNG9tbUVUU1hBQ2JJQlZMbXFpUW9aQ3ppRHBoZFl5b1dOUjhiS0hSaXdlVnFlRG9pNGhhQzJySFZGVkV6VlNBOStxMGJna0hpSXBsblN6VVFvcGxZV3NKTHlKaVlTZDRqQlFKYkRJUjZJWEFWQ3pyQk5OSlhmR0MzWkpnT1IxVHNhd1RiS3pnU2xCWmV4UkJZeXFSdFllbmZJa3Fhdy9xNzVsSVJPM2hFaXlKQzF1WUNpMUJEUm5JZ2tpUVNyWjFSdlovS2JLdDhiVkNSQ3pwZ0tNQ1pLR3hxSVBEWTYrc2NMTWFETll5MzgreDV3OGpLcFkwSkxIYXp6V2dWQjZtWWpHYkRPZFhwVFJwWnExVmNlWlZXRDdzU0pNaE1aY0E5UUl5d2tuS2RBeWltNjdLRlpld2lzVWVUUzdJQitFeHBpRVp4NExDa2E2Szg0cjdGa1JJUkJLT01Jcm8yTTBjbVFoZEZGV2FjYytlVktSdkx3enZNbEhSZ2FOVlIrZnM5RzJWeFl1SlBDMFJFdStNeUxKNDUwUWszaGtSWjVoZ29UQk44bE1pUHhjdkUrWDU2MElUNzRTb2lSY1J4UzVlVEZUU2xDZzE4V0thT2lmS1hieUlxSFR4WXFJNEgzZGxSOGFjYUM1ZmphRE9pZWJ5dFhhRGZObkFtQTVjTTM3bVJIUDVraUVkTnRETTVVdTN4VnkrN0U1Mkc0amluRTFwZzN5SmFJTjg4eGI1NWkzeUxWdmtLM0hvR1ZIZEl0KzZRYjdPek9YcnpBYjVPcnRCdnM1eHhzbWNhQzVmamxMWERVUnorYnF3UWI1RU5KZXZpM3dUem9ubTh1VndqOXRBdEVHK2VZTjg4eGI1Rmc0UXpvanFGdm5XRGZMMVpvTjh2ZGtnWDI4M3lOZXp2VFdqY1J2RTY5MEc4WHEvUWJ4RU5CZXZEM1B4RWsyZGN5bHVFSzlQRzhSTFJCdkVtN2VJTjI4UmIrRXlsRG5SZkhKMWkzanJCdkVHczBHOFJOVEU2d0NSNVJRaFZ1Z3RKRkw1eGdDSVhKTnZRbVB5VGI0VjByQjRLL0tqK1JCRXZCVnEyRVNVSEJORnhJSEk0azBCUlc2WUtFdHpMRVNUV0x6WkkzY1BFNUY0YzBHZVZ4L0VFVmRnNUpDSlN1UTBSSWVlVkZpODFTS0RuSWxvWGpXaW1JMFBsY1ZiQzdKOWZaUjh6OVpXQTFGeGUwRFMvb0g3ekxNanRmU3VEWWlxZDZNRFJGSkl4dlgrU01ic2t4V25PT0JuOU14dXpuaEptQ29YeVhncGFGUkJlanU2aWdLZVRGVTA0US94S3JLWUpVaVpJRlgxNGpoSHh3Yjdpck5HRnRIZ3MwaGFDendSRmZkNERBbGxnbm4xS0hNeFlzUlVMT2tJZTJsNTJ1eTJPY1VUcE1yaW93WVpCVDRaa1hXQ3lTeE14WTBlRSt3SDRKTVZXU2VQbkRsTXhiSk9NRTNQSjhucTVIb3F0Qlhaa2VxbFZDcWlOM29SZHNwNDlFRklFSytDQ0pwN0RJSkZRME5tUVd1VFFVVEZndVl1ZzJDUDBjUlkwTm1nMEExVFpTR0N3OHJTOURFYkZFSm1LaFowdG5EM0pMbEptUXF5WFpKcHBlWUt2YkdLb0RQYytrVEVjczZ3QTVkbkRpU2hBdEY3eng3ZTdPRzltN1hiY3ZZb2JkTm5iYmRNVkNDZ3lWUXNhTzZUaUo3bFZkQUIzb1paV3k0VEZkSjJzalpkcHIrQTM1V3BSTklCM1NsWnV5NXpiMFpJSkhLT3lJL3RjMUk1UjlUVGhxbTRDMlNPeU9mdnN6WmV6akQrNi9sMjRyRUZSS0tDamxnNDJuc1plN3VaS3VuUTBYMVl0UHR5amlqbG5xbVNNc3VpWjJrRFpsb1ZJRjdtdFlhRlR4cVAzcWc5bUJOZU5FVXl6emhXaWE2Nm9sMllJejdoaTdaaDVycDc5Q3p0d3h3aWlsa29sb3hCU1hndm9ZRjlCNEN3TkU0WHd1M0NPVHFkaU9EOFN2UHpEV0NFZERvcklDNEQ0eGI2dzlQM2Uvci9wUDhmR0Vqdnc4c0FLUnlpQTl4QmVId0JNRHhHQ0I0ai9JQVJlc2NRdTBPcSsrLytHS0VLQ1BKWUdHQUtLTzdZNkd6OERyTnh3S0ROU0krTFc3K2ZEdTl4WGJYZVNGYnllTjNlZzlEOHF2M3RudzlEOTNrWlJsZm8xUXdMYjVsaFpINWV6N0g0cGpsVzdmVWNTMitaWTQ0VXRhczVsdDgweDhnZ3Y1cGo1UzF6ekVlL25XUGg2YTdLcVlMV1ZKK0JnblpmZnhvd3RnRWJENkdtL3ZTYno5ZVNwak9wOGJYTXhJYjZXcWJpakg4MVU0bnB0VXpGazhIMFdxYVN3bzFNQmZnNzVJNXBNNUpJaS9kdnpPZFJ4LzRNeVhYdmhORVpFNzZodjh1NWc4UjljMHVPa1NYUzN5L2ZMekpFSzIyS3c2TjVSVGE0QngzZkwra0Jkc29HM2ZGbDdSZHJIbVdaM3lEVHBQeCtNOXZTeXpnZHRxMXRtOTIrdGsrLzlyVjlmNlIzYklzM3RiWjkzZGYyNmRlK3R1K1A5TWhqOGpMVzlzdjFQem50NGJUTllmZFduWFRFcE9JM3V1amVNSSswNDhpY1IvRU44NGpCb3Jid0tEMnplOWV6ejhvL2dIY2swc09lMmRIRFBhRmZ5MHhDZmkwemVUV3JLOWRYTXBHUVhzbEVySHVKRTVscGpmaHo5T240czlFbmwzOSsrYWRqSyswdVdhc21ic2FiamhiUVdHaDN2K1U1OWZ4SVV2VHpKUlcrbnF2UEo4TGgzOGhSU2ltNUcvU3hYRlpaWE9iL2xuSFlrME9WRklCNHJBRDhsbjdybHovKzlhZkQ5My9qZjV2RDM3Ny82V1JnMW5HZXdDY1A2dDZOelkybk12L3BlWkdHNEU4WWNWODdPZEpJenJVUUsrblZNa1N2Zll3TWI0K1BKeHp2bm5SdmpLdWFSY2lPY2UrYXN6eTNETUlQOUozdkhPZVNiZmorN3Y5ZFZDZDdmSCtzdWF6YXlraERRUzZBMWV5bjY1dDd4SnJUNkFaVytqQWJMNmw1SjhyZEpaWHVQanZwYjI1c2svS3BQbmZNMDFNdFRqQzErNGNoS0hPRnNjeG9xLy9QRVg1ejd4ZVBsTDZ4cXZmcy9JZ05lQm56NU4xOW50UVRsa2lRcHEyekdHK1JEWlg3VEVuZkdjZ0k5OVdSM0cxTDNlVy8zL0dHdThXSkMyU1pGZndwT0hQenphMnVjTTdlejJZK1EwZXlkRGU5bHhsZWhkc3JUZVpKYTlXVmxwbkU4MzNYY2diZnQyL09WUHB3OWZ4SFdzdVd5eUp6NCt2SzBBemNTM3Y3ZFhFNEQzcC9DaHVQbmJ1R0JqQmduSDJFaysyaFowREhXT1NsanFiaFh2NDByTGI2UmJQSUQ3UkNMLzMwL0dmdEoxLy85SWNQLy9uVEwzLzg2WmRmL1g4KzBPOEpDbVZ1WkhOMGNtVmhiUXBsYm1Sdlltb0tOakVnTUNCdlltb0tQRHdLTDFSNWNHVXZSWGgwUjFOMFlYUmxDaTlCU1ZNZ1ptRnNjMlVLTDBKTkwwNXZjbTFoYkFvdlEwRWdNUW92WTJFZ01Rb3ZiM0FnWm1Gc2MyVUtMMDlRSUdaaGJITmxDaTlUUVNCMGNuVmxDaTlUVFdGemF5OU9iMjVsQ2o0K0NtVnVaRzlpYWdvMk1pQXdJRzlpYWdvOFBBb3ZRVzUwYVVGc2FXRnpJR1poYkhObENpOUdkVzVqZEdsdmJnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElETUtMMFJ2YldGcGJpQmJNQ0F4WFFvdlJuVnVZM1JwYjI1eld3bzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqazFOeUF3TGpjMk9TQXdMamMzTmwwS0wwTXhJRnN4SURBdU9UWTFJREF1TnpVM1hRb3ZVbUZ1WjJVZ1d6QWdNU0F3SURFZ01DQXhYUW92Ukc5dFlXbHVJRnN3SURGZENpOU9JREVLUGo0S1BEd0tMMFoxYm1OMGFXOXVWSGx3WlNBeUNpOURNQ0JiTVNBd0xqazJOU0F3TGpjMU4xMEtMME14SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wxSmhibWRsSUZzd0lERWdNQ0F4SURBZ01WMEtMMFJ2fEVuY29kZWQgRGF0YXx8fHx8Rnx8fHx8fCANCk9CWHw1MHxFRHw1ODQ3Ny0xXlB1bG1vbmFyeSBGdW5jdGlvbiBUZXN0IFJlcG9ydF5WU1BVTFJ8fF5BUF5QREZeQmFzZTY0XmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpNZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJOQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpVZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJOaUF3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmpjZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzJPQ0F3SUc5aWFnbzhQQW92UVc1MGFVRnNhV0Z6SUdaaGJITmxDaTlHZFc1amRHbHZiZ284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRE1LTDBSdmJXRnBiaUJiTUNBeFhRb3ZSblZ1WTNScGIyNXpXd284UEFvdlJuVnVZM1JwYjI1VWVYQmxJRElLTDBNd0lGc3dMamsxTnlBd0xqYzJPU0F3TGpjM05sMEtMME14SUZzeElEQXVPVFkxSURBdU56VTNYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtQRHdLTDBaMWJtTjBhVzl1Vkhsd1pTQXlDaTlETUNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDBNeElGc3dMamt6TXlBd0xqazBPU0F3TGpnM01WMEtMMUpoYm1kbElGc3dJREVnTUNBeElEQWdNVjBLTDBSdmJXRnBiaUJiTUNBeFhRb3ZUaUF4Q2o0K0NqdzhDaTlHZFc1amRHbHZibFI1Y0dVZ01nb3ZRekFnV3pBdU9UTXpJREF1T1RRNUlEQXVPRGN4WFFvdlF6RWdXekF1T1RRMUlEQXVPVFl4SURBdU9EZ3lYUW92VW1GdVoyVWdXekFnTVNBd0lERWdNQ0F4WFFvdlJHOXRZV2x1SUZzd0lERmRDaTlPSURFS1BqNEtYUW92UW05MWJtUnpJRnN3TGpNM05TQXdMall5TlNCZENpOUZibU52WkdVZ1d6QWdNU0F3SURFZ01DQXhYUW8rUGdvdlUyaGhaR2x1WjFSNWNHVWdNZ292UTI5c2IzSlRjR0ZqWlM5RVpYWnBZMlZTUjBJS0wwTnZiM0prY3lCYk1DQTNJRFV6TUM0Mk9UazVJRGRkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMFY0ZEdWdVpDQmJkSEoxWlNCMGNuVmxYUW8rUGdwbGJtUnZZbW9LTmprZ01DQnZZbW9LUER3S0wxUjVjR1V2UlhoMFIxTjBZWFJsQ2k5QlNWTWdabUZzYzJVS0wwSk5MMDV2Y20xaGJBb3ZRMEVnTVFvdlkyRWdNUW92YjNBZ1ptRnNjMlVLTDA5UUlHWmhiSE5sQ2k5VFFTQjBjblZsQ2k5VFRXRnpheTlPYjI1bENqNCtDbVZ1Wkc5aWFnbzNNQ0F3SUc5aWFnbzhQQW92Vkhsd1pTOVFZWFIwWlhKdUNpOVFZWFIwWlhKdVZIbHdaU0F4Q2k5UVlXbHVkRlI1Y0dVZ01Rb3ZWR2xzYVc1blZIbHdaU0F6Q2k5TllYUnlhWGdnV3pBdU56VWdNQ0F3SUMwd0xqYzFJREU1TGpnME15QXpOeTR3T1ROZENpOUNRbTk0V3pBZ01DQXhNalVnTWpOZENpOVlVM1JsY0NBeU5UQUtMMWxUZEdWd0lEUTJDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURjeElEQWdVZ28rUGdvdldFOWlhbVZqZEFvOFBBb3ZSbTB3SURjeUlEQWdVZ28rUGdvK1Bnb3ZUR1Z1WjNSb0lEYzFDajQrQ25OMGNtVmhiUXB4SUNVZ0xTMGdRbVZuYVc1RGIyNTBaVzUwQ2lBZ01TQXdJREFnTVNBd0lEQWdZMjBLSUNBdlIxTXdJR2R6Q2lBZ0wwWnRNQ0JFYndwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjeElEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOeklnTUNCdlltb0tQRHdLTDFSNWNHVXZXRTlpYW1WamRBb3ZVM1ZpZEhsd1pTOUdiM0p0Q2k5Q1FtOTRXeTAxTGpFMU1pQXlNQzQyTmpZZ01URTRMamcwT0NBdE1TNHpNelJkQ2k5TllYUnlhWGdnV3pFZ01DQXdJREVnTUNBd1hRb3ZUR1Z1WjNSb0lEUTBNamtLUGo0S2MzUnlaV0Z0Q25FZ0pTQXRMU0JDWldkcGJrTnZiblJsYm5RS0lDQXRNVEF3SUZSNkNpQWdjUW9nSUhFZ0pTQXRMU0JpWldkcGJpQldhWE4xWVd3S0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCRFlXNTJZWE1LSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdJREF1TmpneUlEQXVPVE0zSUNCeVp3b2dJQ0FnSUNBZ0lEYzRMalF4TVNBd0xqQTNNaUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREF1TURjeUlEZzBMamt3TWlBd0xqZ3pNeUE0TkM0NU1ESWdOeTR5TXpNZ1l3b2dJQ0FnSUNBZ0lEZzBMamt3TWlBeE1TNHpNemdnT0RNdU9EVTBJREUwTGpZNElEZ3lMamN3TnlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURneExqVTJNaUF4Tmk0ek9UY2dPREF1T0RreklERTBMamczSURnd0xqZzVNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdPREF1T0RreklERTBMamczSURjM0xqZ3pPQ0F4TUM0MU56UWdOell1TkRBNUlESXVORFU0SUdNS0lDQWdJQ0FnSUNBM05pNDBNRGtnTWk0ME5UZ2dOell1TWpFM0lEQXVPVE1nTnpZdU5qa3pJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNOeTR4TnlBdE1DNHlNVFVnTnpndU5ERXhJREF1TURjeUlEYzRMalF4TVNBd0xqQTNNaUJqQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DQXdMalk0TWlBd0xqa3pOeUFnY21jS0lDQWdJQ0FnSUNBM01TNHhOVGNnTUM0d056SWdiUW9nSUNBZ0lDQWdJRGN4TGpFMU55QXdMakEzTWlBMk5DNDJOaklnTUM0NE16TWdOalF1TmpZeUlEY3VNak16SUdNS0lDQWdJQ0FnSUNBMk5DNDJOaklnTVRFdU16TTRJRFkxTGpjeE5DQXhOQzQyT0NBMk5pNDROaUF4TlM0MU16Z2dZd29nSUNBZ0lDQWdJRFk0TGpBd05pQXhOaTR6T1RjZ05qZ3VOamN6SURFMExqZzNJRFk0TGpZM015QXhOQzQ0TnlCakNpQWdJQ0FnSUNBZ05qZ3VOamN6SURFMExqZzNJRGN4TGpjeU9TQXhNQzQxTnpRZ056TXVNVFl4SURJdU5EVTRJR01LSUNBZ0lDQWdJQ0EzTXk0eE5qRWdNaTQwTlRnZ056TXVNelV5SURBdU9UTWdOekl1T0RjMElEQXVNelU0SUdNS0lDQWdJQ0FnSUNBM01pNHpPVGdnTFRBdU1qRTFJRGN4TGpFMU55QXdMakEzTWlBM01TNHhOVGNnTUM0d056SWdZd29nSUNBZ0lDQWdJR2dLSUNBZ0lDQWdJQ0JtQ2lBZ0lDQWdJRkVnSlNBdExTQmxibVFnVUdGMGFBb2dJQ0FnSUNCeElDVWdMUzBnWW1WbmFXNGdVR0YwYUFvZ0lDQWdJQ0FnSURBdU5DQXdMalF3TkNBd0xqUXdOQ0FnY21jS0lDQWdJQ0FnSUNBNE1pNDJNVElnTVRjdU5UUXpJRzBLSUNBZ0lDQWdJQ0EzT0M0ME1URWdNVGt1TkRVeElEYzBMamc0SURRdU9EVXhJRGMwTGpnM09TQTBMamcwTmlCakNpQWdJQ0FnSUNBZ056UXVPRGMySURRdU9EVXhJRGN4TGpNME5pQXhPUzQwTlRFZ05qY3VNVFEySURFM0xqVTBNeUJqQ2lBZ0lDQWdJQ0FnTmpjdU1UUTJJREUzTGpVME15QTJPUzQyTWprZ01qQXVNekV4SURjMExqZzNPU0F5TUM0ek1URWdZd29nSUNBZ0lDQWdJRGd3TGpFeU9TQXlNQzR6TVRFZ09ESXVOakV5SURFM0xqVTBNeUE0TWk0Mk1USWdNVGN1TlRReklHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdaZ29nSUNBZ0lDQlJJQ1VnTFMwZ1pXNWtJRkJoZEdnS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3TGpRZ01DNDBNRFFnTUM0ME1EUWdJSEpuQ2lBZ0lDQWdJQ0FnTVRNdU16STFJRFV1T1RjMElHMEtJQ0FnSUNBZ0lDQXhNeTR6TWpVZ01pNHpNelFnTVRBdU56UTVJREF1TWpNMElEY3VNekE0SURBdU1qTTBJR01LSUNBZ0lDQWdJQ0F3SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F3SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQXhMalV4TXlBeE1TNDNNVEVnYkFvZ0lDQWdJQ0FnSURjdU16QTRJREV4TGpjeE1TQnNDaUFnSUNBZ0lDQWdNVEF1TnpRNUlERXhMamN4TVNBeE15NHpNalVnT1M0Mk1URWdNVE11TXpJMUlEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01URXVPREV6SURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TVM0NE1UTWdPQzQ1TmprZ09TNDRPRE1nTVRBdU16WTNJRGN1TVRNNUlERXdMak0yTnlCakNpQWdJQ0FnSUNBZ01TNDFNVE1nTVRBdU16WTNJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhMalUzT0NCc0NpQWdJQ0FnSUNBZ055NHhNemtnTVM0MU56Z2diQW9nSUNBZ0lDQWdJRGt1T0RneklERXVOVGM0SURFeExqZ3hNeUF5TGprM055QXhNUzQ0TVRNZ05TNDVOelFnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNBeU55NDFNVFlnTWpBdU1UWTFJRzBLSUNBZ0lDQWdJQ0F5Tnk0MU1UWWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lESTJMakE0T0NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUxTGpBME1pQnNDaUFnSUNBZ0lDQWdNall1TURnNElERTNMalU0T1NBeU5DNDJPRGdnTVRrdU1EY3pJREl5TGpJNE15QXhPUzR3TnpNZ1l3b2dJQ0FnSUNBZ0lERTVMamczTlNBeE9TNHdOek1nTVRndU5UWXhJREUzTGpZME5TQXhPQzQxTmpFZ01UVXVNRFF5SUdNS0lDQWdJQ0FnSUNBeE9DNDFOakVnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREUzTGpFek1TQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMUxqSTVOQ0JzQ2lBZ0lDQWdJQ0FnTVRjdU1UTXhJREUyTGpnNE9TQXhOeTQyTXpVZ01UZ3VNVGMzSURFNExqVXpNU0F4T1M0d05ETWdZd29nSUNBZ0lDQWdJREU1TGpNNU9TQXhPUzQ0T0RVZ01qQXVOakF6SURJd0xqTXpNU0F5TWk0eE1UVWdNakF1TXpNeElHTUtJQ0FnSUNBZ0lDQXlNeTQzTXprZ01qQXVNek14SURJMUxqQTRNeUF4T1M0M05ETWdNall1TURnNElERTRMalUyT1NCakNpQWdJQ0FnSUNBZ01qWXVNRGc0SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTXpjdU16WTVJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdNemN1TXpZNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016WXVNemc1SURFNExqa3dOU0JzQ2lBZ0lDQWdJQ0FnTXpRdU56a3pJREU0TGprd05TQXpOQzR6TWlBeE9DNHhORGtnTXpRdU16SWdNVFl1TmpNNElHTUtJQ0FnSUNBZ0lDQXpOQzR6TWlBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTXpJdU9Ea3hJREF1TWpNMElHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UWXVOalkySUd3S0lDQWdJQ0FnSUNBek1pNDRPVEVnTVRndU56WTFJRE16TGprMU5TQXlNQzR4TmpVZ016WXVNVE0zSURJd0xqRTJOU0JqQ2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREl3TGpFMk5TQnRDaUFnSUNBZ0lDQWdOakF1TWpreklERXhMalUwTWlCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURrdU9UUTNJRFU1TGpjNE9DQTRMalkxT1NBMU9DNDRPVElnTnk0M09URWdZd29nSUNBZ0lDQWdJRFU0TGpBMU15QTJMams0TVNBMU5pNDRNakVnTmk0MU1EVWdOVFV1TXpNNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBMU15NHpOVEVnTmk0MU1EVWdOVEV1TnpVMklEY3VNemN6SURVd0xqYzBOeUE0TGprMk9TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklEY3VNemN6SURRNExqTTVOeUEyTGpVd05TQTBOaTQwTURrZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURRMExqYzROU0EyTGpVd05TQTBNeTR6T0RVZ055NHhNakVnTkRJdU5EQTNJRGd1TWpZM0lHTUtJQ0FnSUNBZ0lDQTBNaTQwTURjZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURRd0xqazNPU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdOREF1T1RjNUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJREV4TGpjNU5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lEa3VNalE1SURRekxqZ3dPQ0EzTGpjMk5TQTBOaTR5TVRVZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURRNExqWXlJRGN1TnpZMUlEUTVMamt6TmlBNUxqRTVNeUEwT1M0NU16WWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTBPUzQ1TXpZZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdNVEV1TlRReUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ09TNHlORGtnTlRJdU9EUTNJRGN1TnpZMUlEVTFMakUzTWlBM0xqYzJOU0JqQ2lBZ0lDQWdJQ0FnTlRjdU5UYzNJRGN1TnpZMUlEVTRMamc1TWlBNUxqRTVNeUExT0M0NE9USWdNVEV1TnprMUlHTUtJQ0FnSUNBZ0lDQTFPQzQ0T1RJZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMk1DNHlPVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09Ua3VOREUxSURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnT1RrdU5ERTFJREV4TGpVME5TQnNDaUFnSUNBZ0lDQWdPVGt1TkRFMUlEa3VPVFEzSURrNExqa3hNaUE0TGpZMU9TQTVPQzR3TVRVZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURrM0xqRTBOeUEyTGprMU15QTVOUzQ1TkRNZ05pNDFNRFVnT1RRdU5ETXlJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTVNaTQ0TURnZ05pNDFNRFVnT1RFdU5EWTFJRGN1TURreElEa3dMalExTnlBNExqSTJOeUJqQ2lBZ0lDQWdJQ0FnT1RBdU5EVTNJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQTRPUzR3TWprZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURnNUxqQXlPU0F5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBeE1TNDNPVFVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUE1TGpJME9TQTVNUzQ0TlRjZ055NDNOalVnT1RRdU1qWTBJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQTVOaTQyTnpFZ055NDNOalVnT1RjdU9UZzNJRGt1TVRreklEazNMams0TnlBeE1TNDNPVFVnWXdvZ0lDQWdJQ0FnSURrM0xqazROeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJREV4TkM0Mk9UY2dNVE11TnpJM0lHMEtJQ0FnSUNBZ0lDQXhNVFF1TmprM0lERXpMakE0TWlCc0NpQWdJQ0FnSUNBZ01URTBMalk1TnlBNExqazJPU0F4TVRJdU5qVTFJRFl1TlRBMUlERXdPUzR5T1RZZ05pNDFNRFVnWXdvZ0lDQWdJQ0FnSURFd05TNDVNRGdnTmk0MU1EVWdNVEF6TGpnNU5TQTVMakE0TVNBeE1ETXVPRGsxSURFekxqUXhPQ0JqQ2lBZ0lDQWdJQ0FnTVRBekxqZzVOU0F4Tnk0NU1qVWdNVEExTGprd09DQXlNQzR6TXpFZ01UQTVMall6TVNBeU1DNHpNekVnWXdvZ0lDQWdJQ0FnSURFeE1TNDROamtnTWpBdU16TXhJREV4TXk0eE16RWdNVGt1TmpNeElERXhOQzQxTURFZ01UZ3VNall4SUdNS0lDQWdJQ0FnSUNBeE1UTXVORE0zSURFM0xqUXlNU0JzQ2lBZ0lDQWdJQ0FnTVRFeUxqSTVNU0F4T0M0MU5qa2dNVEV4TGpNeE1TQXhPUzR3TkRNZ01UQTVMamN4TlNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFd05pNDROVGtnTVRrdU1EUXpJREV3TlM0ek1qRWdNVGN1TVRReElERXdOUzR6TWpFZ01UTXVOekkzSUdNS0lDQWdJQ0FnSUNBeE1UTXVNamN4SURFeUxqVTNPU0J0Q2lBZ0lDQWdJQ0FnTVRBMUxqTXlNU0F4TWk0MU56a2diQW9nSUNBZ0lDQWdJREV3TlM0ek56Y2dNVEV1TWprZ01UQTFMalEySURFd0xqZzNNeUF4TURVdU56azJJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEEyTGpNNE15QTRMall6TVNBeE1EY3VOelUxSURjdU56WTFJREV3T1M0eU9UWWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lERXhNQzQ0TXpNZ055NDNOalVnTVRFeUxqSXdOU0E0TGpZek1TQXhNVEl1TnpreklERXdMakF6TVNCakNpQWdJQ0FnSUNBZ01URXpMakV6TVNBeE1DNDROek1nTVRFekxqSXhNaUF4TVM0eU9TQXhNVE11TWpjeElERXlMalUzT1NCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQlJJQ1VnTFMwZ1pXNWtJRU5oYm5aaGN3b2dJRkVnSlNBdExTQmxibVFnVm1semRXRnNDaUFnVVFwUklDVWdMUzBnUlc1a1EyOXVkR1Z1ZEFwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjeklEQWdiMkpxQ2p3OENpOVVlWEJsTDFCaFoyVUtMMDFsWkdsaFFtOTRXekFnTUNBMk1USWdOemt5WFFvdlVHRnlaVzUwSURNZ01DQlNDaTlEYjI1MFpXNTBjeUEzTkNBd0lGSUtMMUpsYzI5MWNtTmxjd284UEFvdlVISnZZMU5sZENCYkwxQkVSaTlVWlhoMEwwbHRZV2RsUWk5SmJXRm5aVU12U1cxaFoyVkpYUW92UlhoMFIxTjBZWFJsQ2p3OENpOUhVekFnTmlBd0lGSUtMMGRUTVNBM05TQXdJRklLTDBkVE1pQTNOeUF3SUZJS0wwZFRNeUEzT1NBd0lGSUtMMGRUTkNBNE1TQXdJRklLUGo0S0wwWnZiblFLUER3S0wwWXdJRE13SURBZ1Vnb3ZSakVnTXpRZ01DQlNDaTlHTWlBeE1DQXdJRklLUGo0S0wxTm9ZV1JwYm1jS1BEd0tMMU5vTUNBM05pQXdJRklLTDFOb01TQTNPQ0F3SUZJS0wxTm9NaUE0TUNBd0lGSUtQajRLTDFCaGRIUmxjbTRLUER3S0wxQmhNQ0E0TWlBd0lGSUtQajRLUGo0S0wwZHliM1Z3Q2p3OENpOURVeTlFWlhacFkyVlNSMElLTDFNdlZISmhibk53WVhKbGJtTjVDaTlKSUdaaGJITmxDaTlMSUdaaGJITmxDajQrQ2o0K0NtVnVaRzlpYWdvM05DQXdJRzlpYWdvOFBBb3ZUR1Z1WjNSb0lERTVNRFlLTDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlFvK1BncHpkSEpsWVcwS2VKenRYVnR2MnpZVWZ0K3Y0TXRlQ3BqbC9RSU1BNW9yTUdEQXVoallYcnMyYlZZazN0SUVLN1pmdjBOSnRraUpGT1ZHaVMyYk5PUUxMekxQcDNNaFA1UFdQZm9lTFJibzVQclRuNnZUdjFhUDE2dkg3eEFpV0V0RTRMRm8zbW5MMFBzN0tGbFFRdER5UDNqWHRQekR0VVNuNzFiL3ZIdUFYSVJvMVpBaXByQ1FTbTllcSticFptMURncXhaMXg2cTc3ZVFiWVBoSm0wakJjOWVvMDZ6WDk0OTNuaGwwQXh6anI0R1dRVDkxUG44T1d4QzBNOWhCYXkxQ3A3UnI1ZWRVeEIwRitSb3FUR3hrSDBiWkY5NW45N1dIYjllZlFpNzdlVjNVQmlIRUFHTVpvQVFkSlU5SHpvZE1YdENoaUxTUU1DY05HQlhnU3dPOE52Z004UEtLTDUrSWJYU2VqVjBSekd1WXVJRklnVENYZDcrKy9mTlEvQ043b0crZlBMeVhsOWVFZlRKcjNXeTlJc3Z3RTFRdFB6b3cyQ3cwclVXVmU4a29oWWJBdEF0N3pyZnR2eUFmaUNFNlIrWEhlUzRia3N2dXFYQ3RvV3FXNmpvcHBDenNQQjhHUU9vQThOWTYyQVNDeWZUTmpaU1BVSjhheHkwNHM3T0tWWG95elVLaWorK0dxSE91VzYzSFRmSWhGM09OdzJrSnQzV09hVnFoU1E5MFYzcUsxaWRBalZycWw3UW5ySTFIYXpQWDcwQWhzdTdhQWZpMnRhVVkwM1RPcmV1STFSUzg5WlZCdlN2VHVkZHdkSzZXS2Y4OVdtdkVPZFlVTEE1MWI5TU9lMWNuK2hySkxmcnl0ZTVuMk5uNkxyMWRlVktBem9PZlZPR0picUxsR2pLSzJjQ3hiZVI0cXRlWHRwQzZyVEhHSUNvZ3lCVTVTK0hBaGdtalJrbXRJNTNmOU5QMW5OaWRmcnRGVnBGc2s5K1I2K3ZiZ2g2dUVIbnY2TzNXd3FUanVRUlVTZXpub1NicTFXWnVWRXpWa1JFSFY3YTVVV2QzcERiUTRqWEtnVXZYRk1zRll6VUdZLzVQOThEa3JPWVg0cDRwcnh2R210UXphekFhcXl0NUlqRUFCNktFblVaUjFRa2RDc0lrNzIrUDhFVjFEMFhRbUFwcWxISnpIb3VMY1hNTXJvUFBkK05yU1pPMUo1cTRjSkxBcDR4VUErRGlKcHZTY0lZQlRLdkJEa3d0MFhCR0t5SjBRVUlxalcyVkJlVlFFeHBUSmxpQlFrdUZjejlpMHBBSUpTRGdmQjRrSkJjWUMxWjBRbWtHTWRXMGVJbXFoa1FWZFllSGhKVER0M2lOTklXTTZ3a09oUE9yRnBLaVRKc09PY0pZc21mV0hFYm4xakIrTktqTE1WenpiN3lVV3hvekR4V08rUHNTSW9mU1RFa1NZNWttQ1VaNG9xeWJGR01LY2xieG14d1NmSkhlUWJwZVpFQnEyUnhxNHh6U2VQWXBDU2Z0R2FVYUpKUjJzSDRjUXZMUzNxK2NlelNrQmRNK01GaFR4aXdURWJEb01lcUpNczBobWVLK3JveDNtNjhLWTdqbThhRVdqNTVxTjFXaWh6M05BOHBjanpVYnFUWXBaMG5UemFPbVJwN0FYTEFqaGhSSnNBZG95UjVnTGRISmNOVUhTOHdPZWJxZUpISk1WbkhpMHlHMlRwZVlISk0xL0VpazJPK2poZVpIQk4ydk1qa21MRkRRZVpsZVRReEp4NU5ZY0xkaEQ1TG83SHpKSTNtTGRGU3FVclpGVmlGYS9NYUZLNHQzbUMrWEJ2ZkFkZkdDdGZXVDAvazJnUmhtQWxMQzlkV3BjSzFGYTR0a0xKd2Jla2FoV3RMMUNoY1c2cEc0ZHBTTlFyWGxxaFJ1TFpVamNLMXBXb1VyaTFWbzNCdHFSclB3clVObCtZeDl6WktZOU1IZXN3ME13M3ZWcnNpV1dwWFpOUEZhbGM5dHNQYkl2blo5SnNWZHkyMmdnazg1M25aS1RrODJTbkJhcFR3UExHUlZmS1dSMDF0ZHZXV05YSUdoNFNxWmdJc3A3TE45UlRSNUxZdFo1ajJoY0RLSm1Md0dGKzZHZWRnYXBPaGZNalpOaUh2bWJhUVphZmFCSmtuazJrRGdlU2JTRFEyUUtMNSs4RnRuanlMMjc5TDA1Qm4rd2lNR0FXTW1SaVlsL3g1ekFnc2FXcE9VYXgyVWF5MmwrNFB3MnIxaksyV2FvNDFZeVhZOWl2Y0Y3TTlhTE5WTXpaYnBoaTJQTVhHRkxOZEZMUHRwZnZETUZzNVk3UGxrbUVxaXRHaXdkTmNGcVBkcFB2RE1Gb3hZNk1WZ21NdXpBUXpXN2FmWnZzeWExYlppRFdyOEtSenkxVXBuMnlSNlpSYUlqbkRVbXBadE1SUHU5TVNzWmRhb2hqRldpbFd0TVJQdTlNU3VaZGFvaW5CVmd0YnRNUlB1OU1TOVVKYU12WHZjRS84R1k0Wmk3a2FNKzdabjEwdlk2NG51NmdQVHVIYW51MmxCeERNTFl3bTR1Q3c1enk1MmNpSVRTMHBVN1Y0KzVmUXdzQ2g0VGlGUTBFanZjN2J5MHNxRGNQV0duTjRsOVNzeldrUDNHUzZMRlVTejQvbnBxKzNkME1OOStmeVJubkw1Tk1CdTIzRjNiMC9QTDBnYmlPTWdYRWl0bHdIVjl5MTBMTDZBM3VZY1FRQmVoT1c0OEY0VEQrbzluc0JPaVY4blhvTnJSNnZ2NnpRK3dmM25xQ0g5NnVnWTVSSnQzL21XenZWVVFhQ0JYTjczb1JiRzROaEhoNEEwVlY0VDgzN3NaOXlkek9KcW92Vk95b0E4MkJycE8ralFLRXR2SUpESWJ4ZWF5Tk43V0NrYWh4TzQyeXFjdmYrcFAzTUpOUnpiVTU4ZzlpWVFVcjVoNXhKRzVJSmd0QkFPcmRDR1BZZXd6Q091T2xFZnlEVmhkT3RnUUx2cG5UcXBoTmR2KzhXUExXZVhEVGUrN1FHVWRMNk16MXpnRDcxcmhLN3dFTVNtT1psTVhuVHhjUUdrSWlMTnFoMUkrSThZTEFXYTdjcUxnTUVPL091TzYzMW9IcDk0d3h1am9KVDZWYkR1RDJldzVLVGk3bHFPRlVDYTVLWGtKMjZlNERNMlphcCt4TTJtNVh6alZ1TTZZZ250eUlFampkdTRnakhTWE5BWUtDblc4dWZHcldNQ1JhYUdXd3NqRVNvRHBkTVp5Q05EREsvQlViV2pBaXFrU1IwSUFFY2ZRWURuMW9DY0dQdXRtcURZckQ5RndQMFFMTmhLZlJFR2hyTDdlYzFPZWVyRCt2NzRmMFBJS1NpOHdwbGJtUnpkSEpsWVcwS1pXNWtiMkpxQ2pjMUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOellnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pjM0lEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tOemdnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pjNUlEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tPREFnTUNCdlltb0tQRHdLTDBGdWRHbEJiR2xoY3lCbVlXeHpaUW92Um5WdVkzUnBiMjRLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F6Q2k5RWIyMWhhVzRnV3pBZ01WMEtMMFoxYm1OMGFXOXVjMXNLUER3S0wwWjFibU4wYVc5dVZIbHdaU0F5Q2k5RE1DQmJNQzQ1TlRjZ01DNDNOamtnTUM0M056WmRDaTlETVNCYk1TQXdMamsyTlNBd0xqYzFOMTBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDanc4Q2k5R2RXNWpkR2x2YmxSNWNHVWdNZ292UXpBZ1d6RWdNQzQ1TmpVZ01DNDNOVGRkQ2k5RE1TQmJNQzQ1TXpNZ01DNDVORGtnTUM0NE56RmRDaTlTWVc1blpTQmJNQ0F4SURBZ01TQXdJREZkQ2k5RWIyMWhhVzRnV3pBZ01WMEtMMDRnTVFvK1BnbzhQQW92Um5WdVkzUnBiMjVVZVhCbElESUtMME13SUZzd0xqa3pNeUF3TGprME9TQXdMamczTVYwS0wwTXhJRnN3TGprME5TQXdMamsyTVNBd0xqZzRNbDBLTDFKaGJtZGxJRnN3SURFZ01DQXhJREFnTVYwS0wwUnZiV0ZwYmlCYk1DQXhYUW92VGlBeENqNCtDbDBLTDBKdmRXNWtjeUJiTUM0ek56VWdNQzQyTWpVZ1hRb3ZSVzVqYjJSbElGc3dJREVnTUNBeElEQWdNVjBLUGo0S0wxTm9ZV1JwYm1kVWVYQmxJRElLTDBOdmJHOXlVM0JoWTJVdlJHVjJhV05sVWtkQ0NpOURiMjl5WkhNZ1d6QWdOeUEzTVRNdU5qWTVPU0EzWFFvdlJHOXRZV2x1SUZzd0lERmRDaTlGZUhSbGJtUWdXM1J5ZFdVZ2RISjFaVjBLUGo0S1pXNWtiMkpxQ2pneElEQWdiMkpxQ2p3OENpOVVlWEJsTDBWNGRFZFRkR0YwWlFvdlFVbFRJR1poYkhObENpOUNUUzlPYjNKdFlXd0tMME5CSURFS0wyTmhJREVLTDI5d0lHWmhiSE5sQ2k5UFVDQm1ZV3h6WlFvdlUwRWdkSEoxWlFvdlUwMWhjMnN2VG05dVpRbytQZ3BsYm1Sdlltb0tPRElnTUNCdlltb0tQRHdLTDFSNWNHVXZVR0YwZEdWeWJnb3ZVR0YwZEdWeWJsUjVjR1VnTVFvdlVHRnBiblJVZVhCbElERUtMMVJwYkdsdVoxUjVjR1VnTXdvdlRXRjBjbWw0SUZzd0xqYzFJREFnTUNBdE1DNDNOU0F4T1M0NE5ETWdNemN1TURrelhRb3ZRa0p2ZUZzd0lEQWdNVEkxSURJelhRb3ZXRk4wWlhBZ01qVXdDaTlaVTNSbGNDQTBOZ292VW1WemIzVnlZMlZ6Q2p3OENpOVFjbTlqVTJWMElGc3ZVRVJHTDFSbGVIUXZTVzFoWjJWQ0wwbHRZV2RsUXk5SmJXRm5aVWxkQ2k5RmVIUkhVM1JoZEdVS1BEd0tMMGRUTUNBNE15QXdJRklLUGo0S0wxaFBZbXBsWTNRS1BEd0tMMFp0TUNBNE5DQXdJRklLUGo0S1BqNEtMMHhsYm1kMGFDQTNOUW8rUGdwemRISmxZVzBLY1NBbElDMHRJRUpsWjJsdVEyOXVkR1Z1ZEFvZ0lERWdNQ0F3SURFZ01DQXdJR050Q2lBZ0wwZFRNQ0JuY3dvZ0lDOUdiVEFnUkc4S1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNE15QXdJRzlpYWdvOFBBb3ZWSGx3WlM5RmVIUkhVM1JoZEdVS0wwRkpVeUJtWVd4elpRb3ZRazB2VG05eWJXRnNDaTlEUVNBeENpOWpZU0F4Q2k5dmNDQm1ZV3h6WlFvdlQxQWdabUZzYzJVS0wxTkJJSFJ5ZFdVS0wxTk5ZWE5yTDA1dmJtVUtQajRLWlc1a2IySnFDamcwSURBZ2IySnFDanc4Q2k5VWVYQmxMMWhQWW1wbFkzUUtMMU4xWW5SNWNHVXZSbTl5YlFvdlFrSnZlRnN0TlM0eE5USWdNakF1TmpZMklERXhPQzQ0TkRnZ0xURXVNek0wWFFvdlRXRjBjbWw0SUZzeElEQWdNQ0F4SURBZ01GMEtMMHhsYm1kMGFDQTBOREk1Q2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdMVEV3TUNCVWVnb2dJSEVLSUNCeElDVWdMUzBnWW1WbmFXNGdWbWx6ZFdGc0NpQWdJQ0J4SUNVZ0xTMGdZbVZuYVc0Z1EyRnVkbUZ6Q2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNQ0F3TGpZNE1pQXdMamt6TnlBZ2NtY0tJQ0FnSUNBZ0lDQTNPQzQwTVRFZ01DNHdOeklnYlFvZ0lDQWdJQ0FnSURjNExqUXhNU0F3TGpBM01pQTROQzQ1TURJZ01DNDRNek1nT0RRdU9UQXlJRGN1TWpNeklHTUtJQ0FnSUNBZ0lDQTROQzQ1TURJZ01URXVNek00SURnekxqZzFOQ0F4TkM0Mk9DQTRNaTQzTURjZ01UVXVOVE00SUdNS0lDQWdJQ0FnSUNBNE1TNDFOaklnTVRZdU16azNJRGd3TGpnNU15QXhOQzQ0TnlBNE1DNDRPVE1nTVRRdU9EY2dZd29nSUNBZ0lDQWdJRGd3TGpnNU15QXhOQzQ0TnlBM055NDRNemdnTVRBdU5UYzBJRGMyTGpRd09TQXlMalExT0NCakNpQWdJQ0FnSUNBZ056WXVOREE1SURJdU5EVTRJRGMyTGpJeE55QXdMamt6SURjMkxqWTVNeUF3TGpNMU9DQmpDaUFnSUNBZ0lDQWdOemN1TVRjZ0xUQXVNakUxSURjNExqUXhNU0F3TGpBM01pQTNPQzQwTVRFZ01DNHdOeklnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNCbUNpQWdJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1VHRjBhQW9nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lEQWdNQzQyT0RJZ01DNDVNemNnSUhKbkNpQWdJQ0FnSUNBZ056RXVNVFUzSURBdU1EY3lJRzBLSUNBZ0lDQWdJQ0EzTVM0eE5UY2dNQzR3TnpJZ05qUXVOall5SURBdU9ETXpJRFkwTGpZMk1pQTNMakl6TXlCakNpQWdJQ0FnSUNBZ05qUXVOall5SURFeExqTXpPQ0EyTlM0M01UUWdNVFF1TmpnZ05qWXVPRFlnTVRVdU5UTTRJR01LSUNBZ0lDQWdJQ0EyT0M0d01EWWdNVFl1TXprM0lEWTRMalkzTXlBeE5DNDROeUEyT0M0Mk56TWdNVFF1T0RjZ1l3b2dJQ0FnSUNBZ0lEWTRMalkzTXlBeE5DNDROeUEzTVM0M01qa2dNVEF1TlRjMElEY3pMakUyTVNBeUxqUTFPQ0JqQ2lBZ0lDQWdJQ0FnTnpNdU1UWXhJREl1TkRVNElEY3pMak0xTWlBd0xqa3pJRGN5TGpnM05DQXdMak0xT0NCakNpQWdJQ0FnSUNBZ056SXVNems0SUMwd0xqSXhOU0EzTVM0eE5UY2dNQzR3TnpJZ056RXVNVFUzSURBdU1EY3lJR01LSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ09ESXVOakV5SURFM0xqVTBNeUJ0Q2lBZ0lDQWdJQ0FnTnpndU5ERXhJREU1TGpRMU1TQTNOQzQ0T0NBMExqZzFNU0EzTkM0NE56a2dOQzQ0TkRZZ1l3b2dJQ0FnSUNBZ0lEYzBMamczTmlBMExqZzFNU0EzTVM0ek5EWWdNVGt1TkRVeElEWTNMakUwTmlBeE55NDFORE1nWXdvZ0lDQWdJQ0FnSURZM0xqRTBOaUF4Tnk0MU5ETWdOamt1TmpJNUlESXdMak14TVNBM05DNDROemtnTWpBdU16RXhJR01LSUNBZ0lDQWdJQ0E0TUM0eE1qa2dNakF1TXpFeElEZ3lMall4TWlBeE55NDFORE1nT0RJdU5qRXlJREUzTGpVME15QmpDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQlFZWFJvQ2lBZ0lDQWdJQ0FnTUM0MElEQXVOREEwSURBdU5EQTBJQ0J5WndvZ0lDQWdJQ0FnSURFekxqTXlOU0ExTGprM05DQnRDaUFnSUNBZ0lDQWdNVE11TXpJMUlESXVNek0wSURFd0xqYzBPU0F3TGpJek5DQTNMak13T0NBd0xqSXpOQ0JqQ2lBZ0lDQWdJQ0FnTUNBd0xqSXpOQ0JzQ2lBZ0lDQWdJQ0FnTUNBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURFdU5URXpJREl3TGpFMk5TQnNDaUFnSUNBZ0lDQWdNUzQxTVRNZ01URXVOekV4SUd3S0lDQWdJQ0FnSUNBM0xqTXdPQ0F4TVM0M01URWdiQW9nSUNBZ0lDQWdJREV3TGpjME9TQXhNUzQzTVRFZ01UTXVNekkxSURrdU5qRXhJREV6TGpNeU5TQTFMamszTkNCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lERXhMamd4TXlBMUxqazNOQ0J0Q2lBZ0lDQWdJQ0FnTVRFdU9ERXpJRGd1T1RZNUlEa3VPRGd6SURFd0xqTTJOeUEzTGpFek9TQXhNQzR6TmpjZ1l3b2dJQ0FnSUNBZ0lERXVOVEV6SURFd0xqTTJOeUJzQ2lBZ0lDQWdJQ0FnTVM0MU1UTWdNUzQxTnpnZ2JBb2dJQ0FnSUNBZ0lEY3VNVE01SURFdU5UYzRJR3dLSUNBZ0lDQWdJQ0E1TGpnNE15QXhMalUzT0NBeE1TNDRNVE1nTWk0NU56Y2dNVEV1T0RFeklEVXVPVGMwSUdNS0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ01qY3VOVEUySURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTWpjdU5URTJJRFl1TmpjeklHd0tJQ0FnSUNBZ0lDQXlOaTR3T0RnZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURJMkxqQTRPQ0F4TlM0d05ESWdiQW9nSUNBZ0lDQWdJREkyTGpBNE9DQXhOeTQxT0RrZ01qUXVOamc0SURFNUxqQTNNeUF5TWk0eU9ETWdNVGt1TURjeklHTUtJQ0FnSUNBZ0lDQXhPUzQ0TnpVZ01Ua3VNRGN6SURFNExqVTJNU0F4Tnk0Mk5EVWdNVGd1TlRZeElERTFMakEwTWlCakNpQWdJQ0FnSUNBZ01UZ3VOVFl4SURZdU5qY3pJR3dLSUNBZ0lDQWdJQ0F4Tnk0eE16RWdOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lERTNMakV6TVNBeE5TNHlPVFFnYkFvZ0lDQWdJQ0FnSURFM0xqRXpNU0F4Tmk0NE9Ea2dNVGN1TmpNMUlERTRMakUzTnlBeE9DNDFNekVnTVRrdU1EUXpJR01LSUNBZ0lDQWdJQ0F4T1M0ek9Ua2dNVGt1T0RnMUlESXdMall3TXlBeU1DNHpNekVnTWpJdU1URTFJREl3TGpNek1TQmpDaUFnSUNBZ0lDQWdNak11TnpNNUlESXdMak16TVNBeU5TNHdPRE1nTVRrdU56UXpJREkyTGpBNE9DQXhPQzQxTmprZ1l3b2dJQ0FnSUNBZ0lESTJMakE0T0NBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURNM0xqTTJPU0F5TUM0eE5qVWdiUW9nSUNBZ0lDQWdJRE0zTGpNMk9TQXhPQzQ1TURVZ2JBb2dJQ0FnSUNBZ0lETTJMak00T1NBeE9DNDVNRFVnYkFvZ0lDQWdJQ0FnSURNMExqYzVNeUF4T0M0NU1EVWdNelF1TXpJZ01UZ3VNVFE1SURNMExqTXlJREUyTGpZek9DQmpDaUFnSUNBZ0lDQWdNelF1TXpJZ01DNHlNelFnYkFvZ0lDQWdJQ0FnSURNeUxqZzVNU0F3TGpJek5DQnNDaUFnSUNBZ0lDQWdNekl1T0RreElERTJMalkyTmlCc0NpQWdJQ0FnSUNBZ016SXVPRGt4SURFNExqYzJOU0F6TXk0NU5UVWdNakF1TVRZMUlETTJMakV6TnlBeU1DNHhOalVnWXdvZ0lDQWdJQ0FnSURZd0xqSTVNeUF5TUM0eE5qVWdiUW9nSUNBZ0lDQWdJRFl3TGpJNU15QXhNUzQxTkRJZ2JBb2dJQ0FnSUNBZ0lEWXdMakk1TXlBNUxqazBOeUExT1M0M09EZ2dPQzQyTlRrZ05UZ3VPRGt5SURjdU56a3hJR01LSUNBZ0lDQWdJQ0ExT0M0d05UTWdOaTQ1T0RFZ05UWXVPREl4SURZdU5UQTFJRFUxTGpNek9TQTJMalV3TlNCakNpQWdJQ0FnSUNBZ05UTXVNelV4SURZdU5UQTFJRFV4TGpjMU5pQTNMak0zTXlBMU1DNDNORGNnT0M0NU5qa2dZd29nSUNBZ0lDQWdJRFE1TGprek5pQTNMak0zTXlBME9DNHpPVGNnTmk0MU1EVWdORFl1TkRBNUlEWXVOVEExSUdNS0lDQWdJQ0FnSUNBME5DNDNPRFVnTmk0MU1EVWdORE11TXpnMUlEY3VNVEl4SURReUxqUXdOeUE0TGpJMk55QmpDaUFnSUNBZ0lDQWdOREl1TkRBM0lEWXVOamN6SUd3S0lDQWdJQ0FnSUNBME1DNDVOemtnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJRFF3TGprM09TQXlNQzR4TmpVZ2JBb2dJQ0FnSUNBZ0lEUXlMalF3TnlBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURReUxqUXdOeUF4TVM0M09UVWdiQW9nSUNBZ0lDQWdJRFF5TGpRd055QTVMakkwT1NBME15NDRNRGdnTnk0M05qVWdORFl1TWpFMUlEY3VOelkxSUdNS0lDQWdJQ0FnSUNBME9DNDJNaUEzTGpjMk5TQTBPUzQ1TXpZZ09TNHhPVE1nTkRrdU9UTTJJREV4TGpjNU5TQmpDaUFnSUNBZ0lDQWdORGt1T1RNMklESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05URXVNelkwSURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnTlRFdU16WTBJREV4TGpVME1pQnNDaUFnSUNBZ0lDQWdOVEV1TXpZMElEa3VNalE1SURVeUxqZzBOeUEzTGpjMk5TQTFOUzR4TnpJZ055NDNOalVnWXdvZ0lDQWdJQ0FnSURVM0xqVTNOeUEzTGpjMk5TQTFPQzQ0T1RJZ09TNHhPVE1nTlRndU9Ea3lJREV4TGpjNU5TQmpDaUFnSUNBZ0lDQWdOVGd1T0RreUlESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05qQXVNamt6SURJd0xqRTJOU0JzQ2lBZ0lDQWdJQ0FnYUFvZ0lDQWdJQ0FnSUdZS0lDQWdJQ0FnVVNBbElDMHRJR1Z1WkNCUVlYUm9DaUFnSUNBZ0lIRWdKU0F0TFNCaVpXZHBiaUJRWVhSb0NpQWdJQ0FnSUNBZ01DNDBJREF1TkRBMElEQXVOREEwSUNCeVp3b2dJQ0FnSUNBZ0lEazVMalF4TlNBeU1DNHhOalVnYlFvZ0lDQWdJQ0FnSURrNUxqUXhOU0F4TVM0MU5EVWdiQW9nSUNBZ0lDQWdJRGs1TGpReE5TQTVMamswTnlBNU9DNDVNVElnT0M0Mk5Ua2dPVGd1TURFMUlEY3VOemt4SUdNS0lDQWdJQ0FnSUNBNU55NHhORGNnTmk0NU5UTWdPVFV1T1RReklEWXVOVEExSURrMExqUXpNaUEyTGpVd05TQmpDaUFnSUNBZ0lDQWdPVEl1T0RBNElEWXVOVEExSURreExqUTJOU0EzTGpBNU1TQTVNQzQwTlRjZ09DNHlOamNnWXdvZ0lDQWdJQ0FnSURrd0xqUTFOeUEyTGpZM015QnNDaUFnSUNBZ0lDQWdPRGt1TURJNUlEWXVOamN6SUd3S0lDQWdJQ0FnSUNBNE9TNHdNamtnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0E1TUM0ME5UY2dNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTVNQzQwTlRjZ01URXVOemsxSUd3S0lDQWdJQ0FnSUNBNU1DNDBOVGNnT1M0eU5Ea2dPVEV1T0RVM0lEY3VOelkxSURrMExqSTJOQ0EzTGpjMk5TQmpDaUFnSUNBZ0lDQWdPVFl1TmpjeElEY3VOelkxSURrM0xqazROeUE1TGpFNU15QTVOeTQ1T0RjZ01URXVOemsxSUdNS0lDQWdJQ0FnSUNBNU55NDVPRGNnTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0F4TVRRdU5qazNJREV6TGpjeU55QnRDaUFnSUNBZ0lDQWdNVEUwTGpZNU55QXhNeTR3T0RJZ2JBb2dJQ0FnSUNBZ0lERXhOQzQyT1RjZ09DNDVOamtnTVRFeUxqWTFOU0EyTGpVd05TQXhNRGt1TWprMklEWXVOVEExSUdNS0lDQWdJQ0FnSUNBeE1EVXVPVEE0SURZdU5UQTFJREV3TXk0NE9UVWdPUzR3T0RFZ01UQXpMamc1TlNBeE15NDBNVGdnWXdvZ0lDQWdJQ0FnSURFd015NDRPVFVnTVRjdU9USTFJREV3TlM0NU1EZ2dNakF1TXpNeElERXdPUzQyTXpFZ01qQXVNek14SUdNS0lDQWdJQ0FnSUNBeE1URXVPRFk1SURJd0xqTXpNU0F4TVRNdU1UTXhJREU1TGpZek1TQXhNVFF1TlRBeElERTRMakkyTVNCakNpQWdJQ0FnSUNBZ01URXpMalF6TnlBeE55NDBNakVnYkFvZ0lDQWdJQ0FnSURFeE1pNHlPVEVnTVRndU5UWTVJREV4TVM0ek1URWdNVGt1TURReklERXdPUzQzTVRVZ01Ua3VNRFF6SUdNS0lDQWdJQ0FnSUNBeE1EWXVPRFU1SURFNUxqQTBNeUF4TURVdU16SXhJREUzTGpFME1TQXhNRFV1TXpJeElERXpMamN5TnlCakNpQWdJQ0FnSUNBZ01URXpMakkzTVNBeE1pNDFOemtnYlFvZ0lDQWdJQ0FnSURFd05TNHpNakVnTVRJdU5UYzVJR3dLSUNBZ0lDQWdJQ0F4TURVdU16YzNJREV4TGpJNUlERXdOUzQwTmlBeE1DNDROek1nTVRBMUxqYzVOaUF4TUM0d016RWdZd29nSUNBZ0lDQWdJREV3Tmk0ek9ETWdPQzQyTXpFZ01UQTNMamMxTlNBM0xqYzJOU0F4TURrdU1qazJJRGN1TnpZMUlHTUtJQ0FnSUNBZ0lDQXhNVEF1T0RNeklEY3VOelkxSURFeE1pNHlNRFVnT0M0Mk16RWdNVEV5TGpjNU15QXhNQzR3TXpFZ1l3b2dJQ0FnSUNBZ0lERXhNeTR4TXpFZ01UQXVPRGN6SURFeE15NHlNVElnTVRFdU1qa2dNVEV6TGpJM01TQXhNaTQxTnprZ1l3b2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQm1DaUFnSUNBZ0lGRWdKU0F0TFNCbGJtUWdVR0YwYUFvZ0lDQWdVU0FsSUMwdElHVnVaQ0JEWVc1MllYTUtJQ0JSSUNVZ0xTMGdaVzVrSUZacGMzVmhiQW9nSUZFS1VTQWxJQzB0SUVWdVpFTnZiblJsYm5RS1pXNWtjM1J5WldGdENtVnVaRzlpYWdvNE5TQXdJRzlpYWdvOFBBb3ZWSGx3WlM5UVlXZGxDaTlOWldScFlVSnZlRnN3SURBZ05qRXlJRGM1TWwwS0wxQmhjbVZ1ZENBeklEQWdVZ292UTI5dWRHVnVkSE1nT0RZZ01DQlNDaTlTWlhOdmRYSmpaWE1LUER3S0wxQnliMk5UWlhRZ1d5OVFSRVl2VkdWNGRDOUpiV0ZuWlVJdlNXMWhaMlZETDBsdFlXZGxTVjBLTDBWNGRFZFRkR0YwWlFvOFBBb3ZSMU13SURZZ01DQlNDaTlIVXpFZ09EY2dNQ0JTQ2o0K0NpOUdiMjUwQ2p3OENpOUdNQ0F4TUNBd0lGSUtQajRLTDFCaGRIUmxjbTRLUER3S0wxQmhNQ0E0T0NBd0lGSUtQajRLUGo0S0wwZHliM1Z3Q2p3OENpOURVeTlFWlhacFkyVlNSMElLTDFNdlZISmhibk53WVhKbGJtTjVDaTlKSUdaaGJITmxDaTlMSUdaaGJITmxDajQrQ2o0K0NtVnVaRzlpYWdvNE5pQXdJRzlpYWdvOFBBb3ZUR1Z1WjNSb0lEVTNOamtLTDBacGJIUmxjaTlHYkdGMFpVUmxZMjlrWlFvK1BncHpkSEpsWVcwS2VKenRYZWx1Sk1lUi91K25xRC83eHdEVGVSL0F3c0NRMWdnd3NNQ3VOUytncFViU0doUnRTd01idTArL0VaRkhWV1ZHZFRlSDNjMXVva2NpV1ZtUlYwUitHUmw1UmYxaityZnA3bTY2Ly96VC96dy8vTzM1eStmbkw3K2JKaW1DbXlUOGQxZWVRdExUNHk5QXVWTlNUcC8rRDU1S3l2L0dsTlBEOTgvLy9QNDNlRHROaWhLcVNYdGhuUS90THlYZlRqWW5sRk9LTmZhdStNc1UyczBwZHFkQjVwS1V1ckpIenlwSUlaTldVN0JPS0cyWG1YWFovZWYzWDM1ZTBHb2w3dFIwWjBCWTNrMVJCK0ZqY090TU1DTCtOLzM2MCtvdEpuYktDbThtZ3duVDlPdm5hUlhqeDk4dmd2K1Y2L0w1K1llK0pydHJpVldMMDcrNm92L2NoZis2cnJDYy9tT29LM0R3bDI5WGI2MFNNb0xrcExCcFdyTWNvekNoa3A1V3BBUVMxOEJ0SVNhVll5b1JqVkV0YUpEMnVFNllTYzZJT09SWlNFNDRDMW0zSXB6SHVLVXlPZkRJc1pCSjZ6eE5FbFpEalFyUnhCeXpGRkdEWnN5emtESUxUeXlwTU51S3lLSll5WE9kNTdwTnY3c1lYQWlISFdyeHU4ZUkwU0I4ejRQRUJDZTg1VkZpUWhBNnpUQXhJZWE0VlhRMXpBQ2wwamlrTkZwdHgxWk9hZVpTSnc0c2xSY1dMYUR0Z2x6QVJic2N0NVpUd3h4Z0NvMUZUS1ZWdmxzNVJTNHIrYjRUMEdncEJiRG9RMEsxdUFhTmRrb2tYMmxQSGMwSXIrQjFvV3BuS1c2RWpvWENhMkdOMU1jdWJhWWxBd1BDa0craFdSRXM1VnZMU1I1ajF6cmwwQ1BMUzZhdDgxVUp3T2htcWtvaHh5M2x0TEFaODYyMHpNc1RUeXQ4eitVVXVhemsrMDVBWTBBU0t2S2dzUWE2bmVGQlk0MFROczZnc2NaVDNDcThGbVpBVTJrY2FCcXROT1pjVG03c1dpY09OSlVYRGpRbUF2OTZCbzJCYWxQY1VrNExNNkNwTkE0MGpWYjRuc3ZKY2xuTDl6cEF3NXN0UWJqSnE0aUt1TE5hUUdTbWt0YlNpV0NvVWVObFl2UVVVMHVoVVZZMXFFYmxYa2hHd3pEVDUxbElSaVJzdUZZRUFBWGlsc3Jrd0NQRFFhWjBvSE1pV215elRMU1dJcFlDU2tnekdSSWxWLytKb3hRK1cvWlpDa3RKWGdjZzltc1JHRWlEblJ6TUMyS3ZSS1FTMmhkU0p5V3BSY0lCSVJPdHREa205QmdVVnd0RGorOGxYMGpRK0hySXRKQkE2QTZicnhVU3dXWnAxYUhBSThzRWticGVEamFuakZDblREUW01SmlsakJhMlk2YUZSRXc4OGFUQzcxd0lpV01sMC9lQ0U3RExndWJWaUVIcFJWNlBHSkIwTXJNaU1kZ01jZTVoTGF5NGlVV21jYnFrMFVwZm44dkptcURXaVZNbmxSZE9vUmh0aGZTelJqRmE1N2kxbkJyV1hMNlp4dW1WUnF0OHQzS0tYRmJ5ZlNlZ1FidkxLUjQwMmtIblNUeG8wTjZNZGdhTmhsa0Z4cTNDYTJFR05KWEdnYWJSU21QTzVlVEdyblhpUUZONTRVQ0Q5bVowTTJqUUhxVzRwWndXWmtCVGFSeG9HcTN3UFpkVDVMS1M3enNCalZVQnRPcmtJR2szSHFFK0RVVG9CZzdRd3c3WFA1QmtVVjlqTENVTWpVVTFiQWFqSWhNMHpFS0hEQXZKQ1VralVTc0ExL2hhUlNqd3lGYWVTRjJtQ3UxaEhDUnlKc3JtbUxXTUdqWk1wcGtFTER6eGhNcHJLd0lGTWN2eE9wREJHcTkzd0VVSURCcm05MzJmRWJaaUFmcE5XRUNoQnMzUXRlazlBNFJLS1czVThxWVdMRFZnVUhDM0pEMTFwRlVlZDEwSmQ4dTZkSm5PMVgvaUNZWE51NlVJRnZLN0RoUWNZTEhDaEkxRGhBVnRtQ3luSDhDUWRLbnFCMmx5ck5wbmFualFENFhBNllkS3FuMjNGWkM3ZHFrSWc0eGFlUVlaYUVSYTFmU0R3YlhUQlRKYWVFUkdKUTNJYUlUQzYxd0VDR0loeC9lQ0RGcGdHSUdSdkZDY3FvRFJOZFora2xLT1V5UlZnejBveW5zR0U1VlNtcXZsVFkxWmFzQUJJdGVad3dQWUltR0dnOHp4S2hwS2tBRkRwb3hZS084ckZHcnVpSVFtdDNjQ0JJMnJ4NUZCQWxyZHlqQlFJUE03Rml6ZzlwUmF5YXFFeldEd1p3SURoMGFxRGRZS3lNMVpLc0lnb2xhZWdZU0dpYVhXRFJNYXVqZkZMR1cwOElpS1NocGcwUWgxakd4RjRQZzV5L0dkSUFOVnMrY25KTmFEOGNUUFI2d1BXY0oxSGNoSGpOcFdpVXFRbVkwVUVqY1pxYVM2V05YS0tFdFp1VHJzY2xobWdwMit3Z3doTFJiRURPZ2h2NWk5bGlBM2VjMGtkdTVhU0hYcTJzb28wbGpLOURwd3dwcWF4bTZ0aENXM3RSQUdpbjJ4RGdhQ1dTNkQxZUM0Q2xZb3pDSllwWlQxcVpZL3JWNlZlckFyWU5zTFlOQlkxcmIxTDZFaUtwN29vV2NiMUVzQ1dpN1FDNk1aRFllZ1ZGU2hBRmxNUnRYMXNwU2NYd1NIR3FuTjFiTkdrZExhdVFnUUd5Z2NNMWNwS09FRFBBd2pabVlCeUVwNU5YTllGdC9lM2RxYlVscFl4d3huR2pTL2M4eHdwbUgwMGJMT2duVE1zYXFLcitGaEhsUUkzRVNva3VwUTB3cklJMUdwQ0RPYzFjb3p3NWxTSU1EVWhqTWxVNDVaWjFzMVBBNW5sVFFNWjQxUWVKMkxBRUVzNVBoZWtKRzN4RGlkcFowWFhyRktTenRVTWsxcmFaZEU2WCtrdGxwNDFGdVZ4Q2l1UmlxYWF5NkVGRSt0RHFPN0toT004bExKQ212YTZyM0tlM3l0akJhMlRLYVp4T2lmUmlyOHpvV1FPRll5dlE2Y3NNTVpIdld5YW9xNGJUSXN2bG82OVZGb3ZaRlpUb2dVcXJZeHh3VzFUSXV2Tld5WlJkSkN3Mk5lWTc2RkJnTU5MYjYyY2hTZEJxdDF5cUZIbHBkTTY1b1Q3S2lBaTZLRnFzQ1FvcmlsbkJhMlRMNkZsbmw1NG1tRjc3bWNMSmUxZkk4TWxHK2YvdmZ2UC8rMnJrODlma2ViVFRhZnpZck04VHRKLy9YSDcvN3c3WGR5K21tZDVmMm5kWlNQbFArbkg5Zmw1aE9FOUVkaG4vZzBGdmZwaCtuZnBUVHBqNS8rMnNIYk42cjI4S1BnUjhMUHgveGpWSi9pbTArOHNBYUJIQzR1R0Z3TW5zdTh5ZXNnZWVFbWc1RUJUMVRBUUh4UjhncWp2TUE2bUNYMmNhU0RYZmpXQXNXREpRckVlSlBuY2VRSjQ0U1RNc0EwRnJkNEwwbWVJQXdIMG5CUVBmZ2ZKamZ3OC9FNEFoa09keThCWm1Ca3NpcFA0blF2am4xeTNSSVlMN0pCYUZ0aTJ5KzRwZWowQU1WT1VMdEY5WVpjb2wyS0dlUGZpS3ZyWmorekgwZG11NTdGUlhCcFJwcStWbkhOb05CV09IT0l0SXFLa1dhWG1ua1Ivd3ZhMEs5ZVlGZVlmQkxrMHJRUUNNdWlCZ0wxREpPWXJJMGl2Q3RoKzFDMDFKbHNDU2RqdWtBcE9XYnNDNDFzNDFxQUtMUzNFQ0R1NkN1VEYwWHN4UWhQVzhad25kVlhGWnk5bjhkQjZyMW9NTGpUQ3cwM3dQRiswbVVKN1pUV3dVNDloZlBGaTVPR2psa0t6aFNjUEdUYzJGaWxjd2JKcUxxbmVqbHlNUWJuaGJtLzJLcHMvSXdjZWhjTGl2enBaYVFCUGFpM0wwdEsrcUhZQWlGTENxWG1WSkZNUlpZdTd4NFdhdnNNRXNQdE1aZjhKYzVQWkpIQ2ZaYVVEUXVjWVRpVnY2Uy96ekJ2MGJkcHkyM2FjaFhpZWovVEZ0d1JzNjRjVmJvZ2pRNDZ4M3dvK3NnV3pWMjF1OHE2NjV4ajRpNjloUnRHTWtsL1UxdzN4WFhwNHJvdXhiV3oxK0Y1S1JrRDdleHhiaWYrY1JVZEwrVzV6N2ozTTExaEI0U0p0b2tIWUVyWlAxNS8vekZDKzBONDFad3lNWEdoVFJJWDQ2VTdmMjlnT3Vna0FpcmNBRDFRNGxHdDNub1lENnk4MVRyTGNhd0F4Z2ZPeTg1cUZGUjJSelBBYkhDOGl4Q0ZlNFI0MVowTzA2d1BKQnpsdkFuYlM5UXhUcUJJNW5TU0UxRk5RZEtCdis0RUNsN3V6UzRrUEhmcVJ3TXBDTnVmM1ZsemMvOFZEb04ycnJhQ1hhZWpoaHBMSVVQMG5IV3MzZ1RURDh4T2JMOWFmVUdRSDA4amVTdkNobHNjbnk5bFd1WTQ4N0VncjA0RGVZWk53S3duWHN6SXBjYmRJaTlDejZYSGUrNVpBT2ZGdS9GR3BJUUtIZWVDM0ZMVlRhRWZwTkNOUzNqK2xmZjZsSXpBMDBmUzRKVGp5bFc2QVpWdWdGR0o1NzhIUnBPd2h2UzJHcThRYUJvSDBubng3ZlQycVp1TGdQWVY2ZlZERVFJeTUvc0JFaVRqT0loYUtlQmlGRHpoa1VydnZBRGhHUWNXdDgxNnNUOEFmbjBkQngyalpTVVBBMFF2R2JBN1hCNGJoc3NTVG9vVUtaMDBaKzA4V25xaGxZZDZlVEJHbzdUVGJYRDRxc0ZCYTRDejMvRHVCalFkVDJ2OG5BM2pkRW1FdDM2UVQ3cVZ4cGcvR2wyaHZJbjlvMzBFMVFLanNuY0JaaXBhVDdkQjRpUTl3QnBTZmx3UFFJZU9EaDMxa0FWMTVUM0FhT0xDVzRYVDk0NVJ3TDdPMXpiVGNEbGI1M3VaWVhTSWVlSVpMeGh5Rm1jQTNsdDJVVlhlbFB4QkVMZUtYUEx5M2hoaGRvV2VEOUczM05YUEFDeEFOWmxzeUF4ODRra2pVdkl3NGVsdU81ZlRrdGFNdEZOUGNrSHM3dUloZnZWS0hxK0JSN2VoNVBIdUZMYSt4bzV3NVQzQUJObzhSQ1Z2ek1Db1FiOE8yQVhzY0JNYnp3U0JEakQ2NlBnLzFhSmRYclBpdkNYZ290M2swbmhsOHhxWDdFd2tWaFRESk16TFhBVHdqa3QyVVdmKzFYbTFXUUN4NDBXMjZUWlFmOTFTWFZEc2ZXbDZiOFpMNmxlb25nek9vekl2REk4NGZnK2FpZFF6eC82cHpVLzBxSHZCZUw3NlVSa3ZIOEtvelByM1JhOExBVnBkRDFma3J3NzB4U3AxQm0yOTBSazZvZDc0d1NhbHpWWm5GS3I1aXh5VHVZWEVJSUxaY01TTG96SU95MzY4Sm45MVRRcm1FdW14Uk5md2Z4bG9rUVptUDFwWldpUUFmSUpwZHJpV1JxWGxzUTBuN1lWMlNsdnJyQ3VFM2hSZWVEWVpZNHNXQ0FNcmdkTU9UOTdkYksxYTdOZkEydk1ERDc1K0Q1WldVVkNNb1VYWHJVWTd5K3UzTWJPTTNNRHhkRHZQY3F4cEpPN3ZlZDdPSWh2WE00N1FISGxYZEVZRTlMcUVIOE55dUQ2bUpyejFpVUF4d3VrVDdYeWViWDZ0UERsa0F5TXI5VG8vQ1pVN2l1MVZ2aklvTTBOaU9PdU9FSWc4SkdoSEIrMlliTGhwL3E4MGFOQXAzNFpqTXBoc09rdmdEdGR2MEFDRFdoRlNkZWdaRFZZWVMvanVaeGZhZStyNjZJWFhueFhnS21yOG5ocFlVOUFNVWlZLzNlYmRKK2tBWU1wN2ZxVkpSZER4aFA5aEorVHE4SzhpQU45bElQZVROQlVDbnZray9UNDRWNHVLWEtRYk90dHpWZzN2Y05JSXNBNzQvYThrOVUzRmYrMmNOZUEyQ090ZkVIMmo0Q2RJdlJ4UE5GMGR4dEZYdC9iQWpFYWQzVy9xQS9kVGNJd0pnMS84SVM5OWdMZnpIbXRSZUZYRlNUVUZuREZIZFR2SG5zVnpqQzB4UmVzVExPaVR5VENSNHhHbnF6UGFrMFhUSExIYld6V2c4SzNoRVo5MDd2UjZkQ0grRllEZnVySzA5WDVYOXhqMVJRLzJCZEJIa004QXQvaEptQlhBRitBdUxtL3E5V1M2cnJ4OExtNXdiTDI2WE55ZmtNT0t4UlZtaXZPaGhOWDhucTVGaDg1MXcwT09zMHhQZWJvU0RvdDB6Vy9SWEErcXJ5M3BNTStQU0Z2MlFOQmlNaTd1cHExdThxM2Mvc2hsdWFuNFRNTG5lcTNiWlRjdlMxa003bCtLbnlYNmF4ZDFYY2l4bFdHTFk2dUgrUjNLUmEydXlqWHRzYVU1ZGwxQW5iKzdIcVZIT2F4VTZhNytXbE5hQzRNSCtsV1hheVVzVVhZUkxZd0VmV2JkcXgzYVMwcjErOUYwSmN6MEErcjhWdUdYR3lZYWRQQURRSlBDR2Rqaktxckd0ekhBRTR3T0N2Y1JJbjRkU09GZDUyVk1nNXNwa04vNnJBYjZaNGVrWnIzYVpSQURFRmV0N2JoSVRQU25JR0RPQVpGSnQrQnlDZlFsMEpoQzBmWEhaUVZnZXBTdmFQK3lldWt4aWZIdzVEQU5ucHhGbFVOenNHVnloeCs4ZDVQRjRpWGVRWnVmbHRFazhoTFJnRjNXVWVIK0FYM041V2tWTnlpSW05WW5QaXhXQkp1cWw1UUUrZW4rUktQRWlTL0U5dXZYRGc4Z1lDWnJDNW80amYwQkF3Q1Y3ZXUyeUdENWVvbkhIMmVWdTZWd2Q5c1gwQm9hSlkwZXM3RmxUQWZhMFhwWTJRNmM1YkJRcStqTDMwRHJLZ2RBK05SMWxLcGZxMTc0VVBSaTBXc3V6djFmL1dsdFBTeHNoMjNMNFEwWmQrUWphQS9qU3QxK1R2ZnpZc0FjWklCc0R5Ukc3aDVJaHZ2Wk5hM3Z4NUE5OWk2ZVRudjFGd2hDOEt2ZnZhR0lWVnNiaUdnYVNyenMvbklUZVB1VyttRVNrcE8vQmdsUnp6K1pkSHBEcEdkeXphSmFNYmlQR3ptdHB3TW84UFhncFBHYjNxYitrUm0waXhpaEE4WjNISHNMRmw3YjJkVHV6blptYlk4MmdkcFM4NzFQSG1nQXFXYnF4NTY2dzRGTjU3eG1kcitablU1bTFkZmVWWGR3K1B6TmE4ZlBEVHRZU1RCTXRSbnQ0QkZ4SzNtam5leW0zbkxXdXZ3aXF1eU1PdGRoakJhaENCQmtBRk9NeDFVZGxlK1c2T2tWcGlMRE9sQVNGWVp5QmhzUjgwZUlsOVE1NDJXcTE5aGttM3BQNGQxaVJyajdWb3oyZ2Ywb2EwSWM2TmV3WDA5dHlkVlg4WUJwNnJSVlZ2T3VuNTdpdjZQNWNEeUxQSEFEaHZ3dzdaUUtlWEV1Zm5SUkVncC9mSjJndzdNcjcvQXZTRTk5VTk3Zlp5bGhYRldsaUQveXhIN1Jzck5uNlVjVUh1UzlaNi9raitqSmgvNGZoYjlMRitjNjd0TEhoWXNYT1JVck9yaXUyN2pacFIwUDlPTTdUVHFuMktQS2ZsSDN5WjVnclFxRVA1ekk3ZEhyVFUwVnJsSFpMbXdBbWt1N2JtMnhXeVBjWng4Y2NYVytEbVc0YWVqRHFFVDJXUXFjcmJEZld1RHNoZjBXQTJzekhHUTFzSGJEUVpaRHY0ais0eUdMNkMvUTNqSnVDUDdDMUlnN1FIbS8xcUs0Y2tXN3c4SlkyUmpGQzMxZGxDZGI0bjdEeG5DTWpSR3o3YkZ0WTd4R2pneFdaN1NpK3pDWk9MUWUwaHFIdGNkV2l6QnRzdDBxQjlrZFE2UEU5ZTdIU3l5RVFlVDdoSDdCQW92b09HNFR5Q3Vid1JhYjRiNUFPQjVCTXRzMndnc2NLbTZPZENERDIwajNGaU1kYnNsbHdZdWtuYi84NFU0SkZXQmlzV3ZFSzF2RmRkdTFLUW8xajNSMW01Z1V5bktFdEtjWUJYZHFiNFdINDdSQ2RNc1F3aDRWUHZTZ1ZWWkNCNnU0WVlCMnA1M0QzN2dTS1h4d3JNNEMzUkluTlY3K3BWTHd0Z3JSeXE4YXBFU1BUSHlnSmZSMDg3UkZpNzVrSXpGYUxwd2VINW1haFJyUDRKWWZKUzVQYkFLaVVaWlBQSTFLenRrMkx1aHB6T3ZuRFVHcDBiTVgvaU12VlpsSWg0QndmM2FybW5LcmpqSm5rMy9sU0pKbDB5REI0djRveGFXbmpTWWgya2FURUMxWDFwUXRWSnVXZkI0aWxyN3JiaXNvL0hjNHN1WGt3TVFaOVJNSjZpQmtPOXhzTi9qckY1NG1XWmpHc0Uwd28ydS9YSitBeU15dGtuRE4zMjgxZmFSdjV3cHNrd1JKWEtTSFI2YUNMc2NKQ0Z4S1JVOGJHUlBOa2dNS2pFb25iQnY3YjltTU1MZ0ZqOGN1ak1kRENsL2JsZ1pYamphMGxHdzBybVYweURUcVhNVTBTR3pUVU56OHE2NVVQZklWa2F5Q29kd3Q5VnJNcER5eGhSVWFwS0JrVk1HWnhRdG9MM1Rqd1kxTXQvYTZ6UFlDdGNQNGJ5TTUzZHJyQXRzTFArSGcvYTI5eXIvenR0ZXV5ZXZGVFlDVUFUTXR5blRJUEVoOUtEOHFyMXhGVStZN1IvM2FCb1B2TmgwSllIVjRPdjR5UVBzUVlKUERJVGxnT2gvd0V5YkJFNlRUQXMwY2hTYVhNUU02UEJwVitmdzIzVTNETENOZW9QZDQ2ck9QSGNtWDFlaXRDbytMb2t0clBIT0pwenZ4N0dOK3lHYzkrM3d5U2FFdFRVZFNsVVlmRkhRSlN0Rk5wejVCUU44TnltTCtIbytVNDUxWGwydWJIL3NFbEVzbTBTSFhuRmJSSTFzQ09TSE85WkNsYW5LajlwTFlrMmh6Wm80eFA1SktIMU9qUVVtU2ZCb29NZVg2MDdWZGFnR0R0NXpZVmlwekZqeWtTdE14azJyajl6RjdySzJXUTNaMzlFdnJ5Z21FNzkxaFhUa3NkZ0lOdjZKM3FzVmw3VVZLcU5hRmxkcStabmtDMllaV2xhK3dKQ2tqZzhqVU9MUDU5Zk0wNnY3ZmQ2K09OVmc3RWIyay9oOEJuNjlqZ1ZZS2NRNTVWZzZnMTRmMHF2VWhuSWRyenNxQTlqQW0vOHB4T1BPQUZDOXBIWnVqMGhQR1psYVBrRVFKNkZlTFNRL2M4bEROVHRaaStIelBaOXc1a0toSFMwY0d6MEplMFgrOG1CVmU5bWNYK1hIZG10YXVLUW9uWnZyQ2pNdzNGREFxUFZCc1RtNUVDK1hYSEZXUGZ1YXBBalUvV1l2WnlQaDhjZzR3TzdXNDFHZXNqUytYY3pLczFheFFEcEhNQzAzQ2RMeXdhY0ZNOTdjWVZ0ay9IVms0VjJXeGF1dXl4OW1YV0t5aGJGNnBlVStWTG9qSmNnRGozQWRoK1BmODIrMmhkUjRIa3pmZFVkeHR1TStwakZqNzY5MitOb1VwZ3FQUFM2QlZ0UnhrMnVEQ0kreVFlcXdQK3dCUzFCSXBmNEJVWHo3Lytqdzkvb2JQY3ZydDhYbFZNYVdoVjVtdnJsUi9tM0VubUY5MnM5SGs0VXVXSjREZVpQekcvVWFUUDE5bzZtZFo5WHgzc2QzZFd4eTVhUGNoUzFqWFRhbjdvOS9QMDFIaTl5MnhqbTk3MUxzVEowMDdFcDVUMkxyVFpJYUQyNllSbDRleWxqdDQzRzdkaFY1MDZ1VGhhS05nbjB3KzlESkpLNUhnMmJYNXZ1czFpaUVsRVVJZUgzWUpRdjlwMGU3MVMvYXFYSUR6MThpNGNuaGhFcWZ4dXprZnJ5RmZEWWY0b1R1NW4wUDlrSGZocjdjdnF4alEwY0UrUGovazB3bDBRQ2NVVzhmUEIzVm9pdjl3MWp0NFFhT1hUVnprQ1d1WGVIdEVPdlUrQkY1NUc0aHpsckZjL3pnK0tJN05BYWd4bk83dFpFTmZQaHVBZzZDUDNSaUgyOC9qdS9MbW0rY2ZIdjcyL09Yejg1ZmYvVCsyMTRlNENtVnVaSE4wY21WaGJRcGxibVJ2WW1vS09EY2dNQ0J2WW1vS1BEd0tMMVI1Y0dVdlJYaDBSMU4wWVhSbENpOUJTVk1nWm1Gc2MyVUtMMEpOTDA1dmNtMWhiQW92UTBFZ01Rb3ZZMkVnTVFvdmIzQWdabUZzYzJVS0wwOVFJR1poYkhObENpOVRRU0IwY25WbENpOVRUV0Z6YXk5T2IyNWxDajQrQ21WdVpHOWlhZ280T0NBd0lHOWlhZ284UEFvdlZIbHdaUzlRWVhSMFpYSnVDaTlRWVhSMFpYSnVWSGx3WlNBeENpOVFZV2x1ZEZSNWNHVWdNUW92Vkdsc2FXNW5WSGx3WlNBekNpOU5ZWFJ5YVhnZ1d6QXVOelVnTUNBd0lDMHdMamMxSURFNUxqZzBNeUF6Tnk0d09UTmRDaTlDUW05NFd6QWdNQ0F4TWpVZ01qTmRDaTlZVTNSbGNDQXlOVEFLTDFsVGRHVndJRFEyQ2k5U1pYTnZkWEpqWlhNS1BEd0tMMUJ5YjJOVFpYUWdXeTlRUkVZdlZHVjRkQzlKYldGblpVSXZTVzFoWjJWREwwbHRZV2RsU1YwS0wwVjRkRWRUZEdGMFpRbzhQQW92UjFNd0lEZzVJREFnVWdvK1Bnb3ZXRTlpYW1WamRBbzhQQW92Um0wd0lEa3dJREFnVWdvK1BnbytQZ292VEdWdVozUm9JRGMxQ2o0K0NuTjBjbVZoYlFweElDVWdMUzBnUW1WbmFXNURiMjUwWlc1MENpQWdNU0F3SURBZ01TQXdJREFnWTIwS0lDQXZSMU13SUdkekNpQWdMMFp0TUNCRWJ3cFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqZzVJREFnYjJKcUNqdzhDaTlVZVhCbEwwVjRkRWRUZEdGMFpRb3ZRVWxUSUdaaGJITmxDaTlDVFM5T2IzSnRZV3dLTDBOQklERUtMMk5oSURFS0wyOXdJR1poYkhObENpOVBVQ0JtWVd4elpRb3ZVMEVnZEhKMVpRb3ZVMDFoYzJzdlRtOXVaUW8rUGdwbGJtUnZZbW9LT1RBZ01DQnZZbW9LUER3S0wxUjVjR1V2V0U5aWFtVmpkQW92VTNWaWRIbHdaUzlHYjNKdENpOUNRbTk0V3kwMUxqRTFNaUF5TUM0Mk5qWWdNVEU0TGpnME9DQXRNUzR6TXpSZENpOU5ZWFJ5YVhnZ1d6RWdNQ0F3SURFZ01DQXdYUW92VEdWdVozUm9JRFEwTWprS1BqNEtjM1J5WldGdENuRWdKU0F0TFNCQ1pXZHBia052Ym5SbGJuUUtJQ0F0TVRBd0lGUjZDaUFnY1FvZ0lIRWdKU0F0TFNCaVpXZHBiaUJXYVhOMVlXd0tJQ0FnSUhFZ0pTQXRMU0JpWldkcGJpQkRZVzUyWVhNS0lDQWdJQ0FnY1NBbElDMHRJR0psWjJsdUlGQmhkR2dLSUNBZ0lDQWdJQ0F3SURBdU5qZ3lJREF1T1RNM0lDQnlad29nSUNBZ0lDQWdJRGM0TGpReE1TQXdMakEzTWlCdENpQWdJQ0FnSUNBZ056Z3VOREV4SURBdU1EY3lJRGcwTGprd01pQXdMamd6TXlBNE5DNDVNRElnTnk0eU16TWdZd29nSUNBZ0lDQWdJRGcwTGprd01pQXhNUzR6TXpnZ09ETXVPRFUwSURFMExqWTRJRGd5TGpjd055QXhOUzQxTXpnZ1l3b2dJQ0FnSUNBZ0lEZ3hMalUyTWlBeE5pNHpPVGNnT0RBdU9Ea3pJREUwTGpnM0lEZ3dMamc1TXlBeE5DNDROeUJqQ2lBZ0lDQWdJQ0FnT0RBdU9Ea3pJREUwTGpnM0lEYzNMamd6T0NBeE1DNDFOelFnTnpZdU5EQTVJREl1TkRVNElHTUtJQ0FnSUNBZ0lDQTNOaTQwTURrZ01pNDBOVGdnTnpZdU1qRTNJREF1T1RNZ056WXVOamt6SURBdU16VTRJR01LSUNBZ0lDQWdJQ0EzTnk0eE55QXRNQzR5TVRVZ056Z3VOREV4SURBdU1EY3lJRGM0TGpReE1TQXdMakEzTWlCakNpQWdJQ0FnSUNBZ2FBb2dJQ0FnSUNBZ0lHWUtJQ0FnSUNBZ1VTQWxJQzB0SUdWdVpDQlFZWFJvQ2lBZ0lDQWdJSEVnSlNBdExTQmlaV2RwYmlCUVlYUm9DaUFnSUNBZ0lDQWdNQ0F3TGpZNE1pQXdMamt6TnlBZ2NtY0tJQ0FnSUNBZ0lDQTNNUzR4TlRjZ01DNHdOeklnYlFvZ0lDQWdJQ0FnSURjeExqRTFOeUF3TGpBM01pQTJOQzQyTmpJZ01DNDRNek1nTmpRdU5qWXlJRGN1TWpNeklHTUtJQ0FnSUNBZ0lDQTJOQzQyTmpJZ01URXVNek00SURZMUxqY3hOQ0F4TkM0Mk9DQTJOaTQ0TmlBeE5TNDFNemdnWXdvZ0lDQWdJQ0FnSURZNExqQXdOaUF4Tmk0ek9UY2dOamd1TmpjeklERTBMamczSURZNExqWTNNeUF4TkM0NE55QmpDaUFnSUNBZ0lDQWdOamd1TmpjeklERTBMamczSURjeExqY3lPU0F4TUM0MU56UWdOek11TVRZeElESXVORFU0SUdNS0lDQWdJQ0FnSUNBM015NHhOakVnTWk0ME5UZ2dOek11TXpVeUlEQXVPVE1nTnpJdU9EYzBJREF1TXpVNElHTUtJQ0FnSUNBZ0lDQTNNaTR6T1RnZ0xUQXVNakUxSURjeExqRTFOeUF3TGpBM01pQTNNUzR4TlRjZ01DNHdOeklnWXdvZ0lDQWdJQ0FnSUdnS0lDQWdJQ0FnSUNCbUNpQWdJQ0FnSUZFZ0pTQXRMU0JsYm1RZ1VHRjBhQW9nSUNBZ0lDQnhJQ1VnTFMwZ1ltVm5hVzRnVUdGMGFBb2dJQ0FnSUNBZ0lEQXVOQ0F3TGpRd05DQXdMalF3TkNBZ2NtY0tJQ0FnSUNBZ0lDQTRNaTQyTVRJZ01UY3VOVFF6SUcwS0lDQWdJQ0FnSUNBM09DNDBNVEVnTVRrdU5EVXhJRGMwTGpnNElEUXVPRFV4SURjMExqZzNPU0EwTGpnME5pQmpDaUFnSUNBZ0lDQWdOelF1T0RjMklEUXVPRFV4SURjeExqTTBOaUF4T1M0ME5URWdOamN1TVRRMklERTNMalUwTXlCakNpQWdJQ0FnSUNBZ05qY3VNVFEySURFM0xqVTBNeUEyT1M0Mk1qa2dNakF1TXpFeElEYzBMamczT1NBeU1DNHpNVEVnWXdvZ0lDQWdJQ0FnSURnd0xqRXlPU0F5TUM0ek1URWdPREl1TmpFeUlERTNMalUwTXlBNE1pNDJNVElnTVRjdU5UUXpJR01LSUNBZ0lDQWdJQ0JvQ2lBZ0lDQWdJQ0FnWmdvZ0lDQWdJQ0JSSUNVZ0xTMGdaVzVrSUZCaGRHZ0tJQ0FnSUNBZ2NTQWxJQzB0SUdKbFoybHVJRkJoZEdnS0lDQWdJQ0FnSUNBd0xqUWdNQzQwTURRZ01DNDBNRFFnSUhKbkNpQWdJQ0FnSUNBZ01UTXVNekkxSURVdU9UYzBJRzBLSUNBZ0lDQWdJQ0F4TXk0ek1qVWdNaTR6TXpRZ01UQXVOelE1SURBdU1qTTBJRGN1TXpBNElEQXVNak0wSUdNS0lDQWdJQ0FnSUNBd0lEQXVNak0wSUd3S0lDQWdJQ0FnSUNBd0lESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ01TNDFNVE1nTWpBdU1UWTFJR3dLSUNBZ0lDQWdJQ0F4TGpVeE15QXhNUzQzTVRFZ2JBb2dJQ0FnSUNBZ0lEY3VNekE0SURFeExqY3hNU0JzQ2lBZ0lDQWdJQ0FnTVRBdU56UTVJREV4TGpjeE1TQXhNeTR6TWpVZ09TNDJNVEVnTVRNdU16STFJRFV1T1RjMElHTUtJQ0FnSUNBZ0lDQm9DaUFnSUNBZ0lDQWdNVEV1T0RFeklEVXVPVGMwSUcwS0lDQWdJQ0FnSUNBeE1TNDRNVE1nT0M0NU5qa2dPUzQ0T0RNZ01UQXVNelkzSURjdU1UTTVJREV3TGpNMk55QmpDaUFnSUNBZ0lDQWdNUzQxTVRNZ01UQXVNelkzSUd3S0lDQWdJQ0FnSUNBeExqVXhNeUF4TGpVM09DQnNDaUFnSUNBZ0lDQWdOeTR4TXprZ01TNDFOemdnYkFvZ0lDQWdJQ0FnSURrdU9EZ3pJREV1TlRjNElERXhMamd4TXlBeUxqazNOeUF4TVM0NE1UTWdOUzQ1TnpRZ1l3b2dJQ0FnSUNBZ0lHZ0tJQ0FnSUNBZ0lDQXlOeTQxTVRZZ01qQXVNVFkxSUcwS0lDQWdJQ0FnSUNBeU55NDFNVFlnTmk0Mk56TWdiQW9nSUNBZ0lDQWdJREkyTGpBNE9DQTJMalkzTXlCc0NpQWdJQ0FnSUNBZ01qWXVNRGc0SURFMUxqQTBNaUJzQ2lBZ0lDQWdJQ0FnTWpZdU1EZzRJREUzTGpVNE9TQXlOQzQyT0RnZ01Ua3VNRGN6SURJeUxqSTRNeUF4T1M0d056TWdZd29nSUNBZ0lDQWdJREU1TGpnM05TQXhPUzR3TnpNZ01UZ3VOVFl4SURFM0xqWTBOU0F4T0M0MU5qRWdNVFV1TURReUlHTUtJQ0FnSUNBZ0lDQXhPQzQxTmpFZ05pNDJOek1nYkFvZ0lDQWdJQ0FnSURFM0xqRXpNU0EyTGpZM015QnNDaUFnSUNBZ0lDQWdNVGN1TVRNeElERTFMakk1TkNCc0NpQWdJQ0FnSUNBZ01UY3VNVE14SURFMkxqZzRPU0F4Tnk0Mk16VWdNVGd1TVRjM0lERTRMalV6TVNBeE9TNHdORE1nWXdvZ0lDQWdJQ0FnSURFNUxqTTVPU0F4T1M0NE9EVWdNakF1TmpBeklESXdMak16TVNBeU1pNHhNVFVnTWpBdU16TXhJR01LSUNBZ0lDQWdJQ0F5TXk0M016a2dNakF1TXpNeElESTFMakE0TXlBeE9TNDNORE1nTWpZdU1EZzRJREU0TGpVMk9TQmpDaUFnSUNBZ0lDQWdNall1TURnNElESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ016Y3VNelk1SURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTXpjdU16WTVJREU0TGprd05TQnNDaUFnSUNBZ0lDQWdNell1TXpnNUlERTRMamt3TlNCc0NpQWdJQ0FnSUNBZ016UXVOemt6SURFNExqa3dOU0F6TkM0ek1pQXhPQzR4TkRrZ016UXVNeklnTVRZdU5qTTRJR01LSUNBZ0lDQWdJQ0F6TkM0ek1pQXdMakl6TkNCc0NpQWdJQ0FnSUNBZ016SXVPRGt4SURBdU1qTTBJR3dLSUNBZ0lDQWdJQ0F6TWk0NE9URWdNVFl1TmpZMklHd0tJQ0FnSUNBZ0lDQXpNaTQ0T1RFZ01UZ3VOelkxSURNekxqazFOU0F5TUM0eE5qVWdNell1TVRNM0lESXdMakUyTlNCakNpQWdJQ0FnSUNBZ05qQXVNamt6SURJd0xqRTJOU0J0Q2lBZ0lDQWdJQ0FnTmpBdU1qa3pJREV4TGpVME1pQnNDaUFnSUNBZ0lDQWdOakF1TWpreklEa3VPVFEzSURVNUxqYzRPQ0E0TGpZMU9TQTFPQzQ0T1RJZ055NDNPVEVnWXdvZ0lDQWdJQ0FnSURVNExqQTFNeUEyTGprNE1TQTFOaTQ0TWpFZ05pNDFNRFVnTlRVdU16TTVJRFl1TlRBMUlHTUtJQ0FnSUNBZ0lDQTFNeTR6TlRFZ05pNDFNRFVnTlRFdU56VTJJRGN1TXpjeklEVXdMamMwTnlBNExqazJPU0JqQ2lBZ0lDQWdJQ0FnTkRrdU9UTTJJRGN1TXpjeklEUTRMak01TnlBMkxqVXdOU0EwTmk0ME1Ea2dOaTQxTURVZ1l3b2dJQ0FnSUNBZ0lEUTBMamM0TlNBMkxqVXdOU0EwTXk0ek9EVWdOeTR4TWpFZ05ESXVOREEzSURndU1qWTNJR01LSUNBZ0lDQWdJQ0EwTWk0ME1EY2dOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lEUXdMamszT1NBMkxqWTNNeUJzQ2lBZ0lDQWdJQ0FnTkRBdU9UYzVJREl3TGpFMk5TQnNDaUFnSUNBZ0lDQWdOREl1TkRBM0lESXdMakUyTlNCc0NpQWdJQ0FnSUNBZ05ESXVOREEzSURFeExqYzVOU0JzQ2lBZ0lDQWdJQ0FnTkRJdU5EQTNJRGt1TWpRNUlEUXpMamd3T0NBM0xqYzJOU0EwTmk0eU1UVWdOeTQzTmpVZ1l3b2dJQ0FnSUNBZ0lEUTRMall5SURjdU56WTFJRFE1TGprek5pQTVMakU1TXlBME9TNDVNellnTVRFdU56azFJR01LSUNBZ0lDQWdJQ0EwT1M0NU16WWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTFNUzR6TmpRZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNBMU1TNHpOalFnTVRFdU5UUXlJR3dLSUNBZ0lDQWdJQ0ExTVM0ek5qUWdPUzR5TkRrZ05USXVPRFEzSURjdU56WTFJRFUxTGpFM01pQTNMamMyTlNCakNpQWdJQ0FnSUNBZ05UY3VOVGMzSURjdU56WTFJRFU0TGpnNU1pQTVMakU1TXlBMU9DNDRPVElnTVRFdU56azFJR01LSUNBZ0lDQWdJQ0ExT0M0NE9USWdNakF1TVRZMUlHd0tJQ0FnSUNBZ0lDQTJNQzR5T1RNZ01qQXVNVFkxSUd3S0lDQWdJQ0FnSUNCb0NpQWdJQ0FnSUNBZ1pnb2dJQ0FnSUNCUklDVWdMUzBnWlc1a0lGQmhkR2dLSUNBZ0lDQWdjU0FsSUMwdElHSmxaMmx1SUZCaGRHZ0tJQ0FnSUNBZ0lDQXdMalFnTUM0ME1EUWdNQzQwTURRZ0lISm5DaUFnSUNBZ0lDQWdPVGt1TkRFMUlESXdMakUyTlNCdENpQWdJQ0FnSUNBZ09Ua3VOREUxSURFeExqVTBOU0JzQ2lBZ0lDQWdJQ0FnT1RrdU5ERTFJRGt1T1RRM0lEazRMamt4TWlBNExqWTFPU0E1T0M0d01UVWdOeTQzT1RFZ1l3b2dJQ0FnSUNBZ0lEazNMakUwTnlBMkxqazFNeUE1TlM0NU5ETWdOaTQxTURVZ09UUXVORE15SURZdU5UQTFJR01LSUNBZ0lDQWdJQ0E1TWk0NE1EZ2dOaTQxTURVZ09URXVORFkxSURjdU1Ea3hJRGt3TGpRMU55QTRMakkyTnlCakNpQWdJQ0FnSUNBZ09UQXVORFUzSURZdU5qY3pJR3dLSUNBZ0lDQWdJQ0E0T1M0d01qa2dOaTQyTnpNZ2JBb2dJQ0FnSUNBZ0lEZzVMakF5T1NBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURrd0xqUTFOeUF5TUM0eE5qVWdiQW9nSUNBZ0lDQWdJRGt3TGpRMU55QXhNUzQzT1RVZ2JBb2dJQ0FnSUNBZ0lEa3dMalExTnlBNUxqSTBPU0E1TVM0NE5UY2dOeTQzTmpVZ09UUXVNalkwSURjdU56WTFJR01LSUNBZ0lDQWdJQ0E1Tmk0Mk56RWdOeTQzTmpVZ09UY3VPVGczSURrdU1Ua3pJRGszTGprNE55QXhNUzQzT1RVZ1l3b2dJQ0FnSUNBZ0lEazNMams0TnlBeU1DNHhOalVnYkFvZ0lDQWdJQ0FnSURFeE5DNDJPVGNnTVRNdU56STNJRzBLSUNBZ0lDQWdJQ0F4TVRRdU5qazNJREV6TGpBNE1pQnNDaUFnSUNBZ0lDQWdNVEUwTGpZNU55QTRMamsyT1NBeE1USXVOalUxSURZdU5UQTFJREV3T1M0eU9UWWdOaTQxTURVZ1l3b2dJQ0FnSUNBZ0lERXdOUzQ1TURnZ05pNDFNRFVnTVRBekxqZzVOU0E1TGpBNE1TQXhNRE11T0RrMUlERXpMalF4T0NCakNpQWdJQ0FnSUNBZ01UQXpMamc1TlNBeE55NDVNalVnTVRBMUxqa3dPQ0F5TUM0ek16RWdNVEE1TGpZek1TQXlNQzR6TXpFZ1l3b2dJQ0FnSUNBZ0lERXhNUzQ0TmprZ01qQXVNek14SURFeE15NHhNekVnTVRrdU5qTXhJREV4TkM0MU1ERWdNVGd1TWpZeElHTUtJQ0FnSUNBZ0lDQXhNVE11TkRNM0lERTNMalF5TVNCc0NpQWdJQ0FnSUNBZ01URXlMakk1TVNBeE9DNDFOamtnTVRFeExqTXhNU0F4T1M0d05ETWdNVEE1TGpjeE5TQXhPUzR3TkRNZ1l3b2dJQ0FnSUNBZ0lERXdOaTQ0TlRrZ01Ua3VNRFF6SURFd05TNHpNakVnTVRjdU1UUXhJREV3TlM0ek1qRWdNVE11TnpJM0lHTUtJQ0FnSUNBZ0lDQXhNVE11TWpjeElERXlMalUzT1NCdENpQWdJQ0FnSUNBZ01UQTFMak15TVNBeE1pNDFOemtnYkFvZ0lDQWdJQ0FnSURFd05TNHpOemNnTVRFdU1qa2dNVEExTGpRMklERXdMamczTXlBeE1EVXVOemsySURFd0xqQXpNU0JqQ2lBZ0lDQWdJQ0FnTVRBMkxqTTRNeUE0TGpZek1TQXhNRGN1TnpVMUlEY3VOelkxSURFd09TNHlPVFlnTnk0M05qVWdZd29nSUNBZ0lDQWdJREV4TUM0NE16TWdOeTQzTmpVZ01URXlMakl3TlNBNExqWXpNU0F4TVRJdU56a3pJREV3TGpBek1TQmpDaUFnSUNBZ0lDQWdNVEV6TGpFek1TQXhNQzQ0TnpNZ01URXpMakl4TWlBeE1TNHlPU0F4TVRNdU1qY3hJREV5TGpVM09TQmpDaUFnSUNBZ0lDQWdhQW9nSUNBZ0lDQWdJR1lLSUNBZ0lDQWdVU0FsSUMwdElHVnVaQ0JRWVhSb0NpQWdJQ0JSSUNVZ0xTMGdaVzVrSUVOaGJuWmhjd29nSUZFZ0pTQXRMU0JsYm1RZ1ZtbHpkV0ZzQ2lBZ1VRcFJJQ1VnTFMwZ1JXNWtRMjl1ZEdWdWRBcGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqa3hJREFnYjJKcUNqdzhDaTlNWlc1bmRHZ3hJRFEwTXpBd0NpOUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVUtMMHhsYm1kMGFDQXhNemswT0FvK1BncHpkSEpsWVcwS2VKenRmUXQ0Vk1YWjhNeTU3UDF5ZGplYjNXUnoyYzJTUU5pUURWbHlXUWpKSVNFSUJEQUUxQ3dRRExBcU54VzVYd1NoQklHQUZTaW9vUFZLS1ZXTHk2VTBJRmcrYTZtb1ZGdTFSVnVyV0dxVmdsSzFsa0wyNUgvZjJiTWhnUDIrdjkvelBkL3ovOCt6TXpremMyYm1uRFB2L1ozM0hCWkNDU0Y2c3BMd1JKcTJjTDczTzN6TDc2SG5NVUlNZWJmUHVlUE9FVU5QM1FIdFkzQk11bVAya3R2bnYvOEhuaEJuRmlFRG41NSsyNVRvVitUT0hZVGNDT09rZkRwMHBGbjBJK0Q4SXB6M21uN24vTVUxT2I1U1FocGhmdC9YWnQ4OWJjcVhQL25UZTRRcy9aU1F3cGZ2bkxKNFRtYTc0ZStFN0h3ZTVudm56TDF0enZjK3p6a0U1MjhRb3BQRmN5U2RFSEVIY1NmTG5ra2dpWjZ1VDd2V1h5bVZNVXBoMTkvWmZLSWNUc3prVG5hZEY1OGlabTU0MTEvNUNESER2TC8ydkZQWGVTRkU3R1FuZVk1c0lLdklJbVZQY2tTbkhrTGl0RjN0bnFmV3MrQzRCM0EzbGZ6cjlGdkkvMzZLa2Qxa3M5cmVEU3NqUGRxUGt1bmQ1dytUamVyS1ZyTjZLN1N1elA3UDAwZVFueVJuNkV1VXUyN3Nmc2lFL0lMOEhQQXhra3dnWThYZmk3K0h2bWF5Q1k1MmdQbEtlcE9WQ09WaXNvZ3NKVlBnV0tXT3JXSTRJbXpzVGxadmdiNHRnT2NueWNQMGJUS0t6Q2RSZ0tvN2FmemtCSmtKYzBmQmZXYVFWOG5UOEt3VlpCYlEwOGIxSWphZWRIMEJkN2dEOFA3ZlR3K1NhZVFoY2t3NW9ud0pUNCtTaGVSZTdodmdEMExNd2tOZFg1SHhaQmlzWVJZWnBaMmg5Q2RueUpFcmx3b25pVTN6SlBLTVFzaXo1Q0NaVGJEdWdQckZmMzhoWFVTWkZyOHp2ckRyTzEycnhjL0VQd2t2Q2VmNHFKQkI3aUwzQVdVZkpUOWtyYzJBcmQwa2xWSXBsVklwbFZMcC84ZTBHdXpvVnJLMWEwM1hIdEpFQ2pWcFpBL1kyV0ZLczlnS0Zua041RW5NOHY2UVBBSSt4bW55T0drQUQrQkExNmRYM2VVeHNOZW53U05wQUI5dkRDSHlUV3VpRXlkRXhqZmRPR2IwcUlhUkk0YmZNS3l1ZG9oY1V6MjRhdERBY0dWRmVkbUFVR24va21CeHY2SkEzOEkrdlF2eWUvbnpmTjdjbk93c1QyYUcyNVh1VEhQWWJaTFZZallaRFhxZFZpTUtQRWRKRVhYSDNIWE45VE5qR1hXdE1aTi9xRi95eGt4akxvd094b2pkNC9QYnZLRmdwSjg2S3lZR1lzVFJFRXRyYk41TDVNcElUQk80ZHNxWUdKOHZmZW1EaTBkN3ZQVXhJUi8rL0NPblJHTjltcHA5ZnVtM251N3hDRndUeTZ4cjl2azhNUzRmL2tiQUVQeU5uT0tOeHFSRzZQZDVFajBqWXFTeEdZK09ybzhyb1pOVStpSlFOalhIY3BLbmtjaTNMUkljN0s1ajF5eHpERzJYOXBveTZvYkdTTnBlWXZvNFJwdzQ3VUlsdUtKVnNUNEJXSWdFTFhZM0VvelJ0QzlqMUJHanp0R3c1S3NmZ1pkOVZQa3RPS2lQenZUWFIyY0FScU90VjNCNklZRlJuN2ZkMjk3VWJBdEJreTI2SWZicTJPYTlSa09kdis0MkEzUVExa0gyR296UVk4UU91TVdjdmRSVVRWbURNOVVQM01zUm5SblFaOGZsMXVNeE15WnZhSVdHZnlqZ0RVWWNWMFk2dW81dDdEbEU0TEpreTVGb0pSWVIwOVRGdElsRmVHZkU1Q2t4c3NHN3QraFkrOFlPaVV4dERaaWkvdWlVU2MweGZncE0yRXY0L1BycDQyTlpEWTBUb0FzZUJVZnJkQytTZXlncmtIamUrdW5lZGpqSHVhMVErb2NpMGEvcWowNi9yUlhaaExiNmg4S1l2cTU1cmUrWUoyYUh1ajVtQzhUTU1NMjg5SXlIYjY5M3ovRGlhWHY3V20vc1NWaHVqMUVmbHNBRWJsaDZlNzBmbmdZM3E1OVppeVFKZHBPTmNlT0lLQ09PdkdHS043Wnk2c3dFNzAzWm1PUi9YN3NVTTMzakErb0FmZUJLZHFHS3ltanJURnp5ekNrSVp2MU1iL3VHMnhpb0d4bG93Sy9lK3BsRDhjQUxnZnZKVFhEMWhPYjY2Zjc2S3c4RXdLSEI1MTk3cmM4WHl3amdoZTN0OWJqRUtWRllmV0xKTUhCbC9TZ1RuZ0NGOWRURjVQR3NJdU1aRGVDSjhwU2hFYlZMblRBQkw4T1IxcUdSaUM5QmQ1Z2EwK2F2Rll2OTNuYThvelkvbGhhUWZLL0EyTEYrUlExTnpmVkRQUXo2R0ZmWFBQaTgyM01lMmcyTjNkM1VEWFBhZytjOUNSdzFqUE0zakUxd3dmUmswVG8rSWNCY04rVmhxanFmM2ZXazIzTVMyc1A4dzFyYjI0ZjV2Y1BhVzl1bmRIU3RuT3IzU3Y3MnZTWlQrNXo2VmkrVGZBcjloemQ0WXNNMlJtSlM2M1E2RUlpTS9EYXNxU0htR0RzUnlUUE1PMzFLUWxuVStIMlZIcDh0a3B6VCtLK0dWVGtEamdlK1J6bHJsODdCMmt5Z2tUemVZYWhlT2tBcmVHSlN8RW5jb2RlZCBEYXRhfHx8fHxGfHx8fHx8IA0KT0JYfDUxfEVEfDU4NDc3LTFeUHVsbW9uYXJ5IEZ1bmN0aW9uIFRlc3QgUmVwb3J0XlZTUFVMUnx8XkFQXlBERl5CYXNlNjReSllvcHJPU21acENEYVl4bldRSHlNUTV1N2tGSjRTUDU5VFBHcVFnQ2JsUVpCdlhlV0xVWGJ1THpvUXh0NkpESlZEaUpyUnpibkRqM2txbWVmVVFPQm9CMnJUaHlMRG5pdkFsSFZpWkh1aTl2OVFPdDNBM2ovZ3VlN3NuUDdUYS8zUnNPTXZ3emRSdU5IUnNQTUY2c2pPa3FWWEk3NnBwNUQ2ZTJPQStQTFVNQTFGZFZ6QlZnRnlKT1FFdTJTMzd2Vy82WUZJaUpkYzNIUEZVUnIyUUQ5VVpoenZBQVNnMW8wYmY4SnlqcVRwSW14V2hWaktaalB3RmR5bFE2NzZxRXdXN204ZGEzdDZyYzFSTXMxUUJFcDM4N2JEQkg4Z040bnNSOG05MlBFTDdCVkpxcXFmT0hvU3g1ZklrWkl5TXhDK3JqbU9VY0syQzlucnBtTDJnZmtOYXhyT0d0OTA1SFlzZThyVU9aR29oNGVuWjNkSDNVT2hUVkhpd1pwM2hVdG9ZeWdkcXJlZTMvbnNOWEFvZXYyaGlaRHR3ZGsvc0NCTjR5ZUN5VGx2SE5LcFlxUGFvVTRiTkdJQ2hYajNkak1Ubm5ldXcyakwvcXJNZDkwU0Q0WUxpeVcvYkhOOGVHQlpLM1NwemZFUEQwUEIxK3pmQ0k1REFCVEhodEl4Q3BZSDhxUFZmMUFYM2xSQmZva2VXZXBXaFBPRnE3MTAvWGpkMHIwM1hqSmpTRGhhczlKQkhpWFRlK2VSOUh1YnJXMnNqZVhqRGVmTWdMemhEcjViQVhPL0hFaXlla2djSWQ5M0U2TnQ5elNDWmtKUnNWV0FjN245WkJDZXZUSmZzb21kYkJKZnFreElNSzJJTmt3c0dJa0JpUms3TUY2Tk1sK2xheVBwYjJFb1JmTm9peVR0YkxKczdNZWZaUzdOb0hQWWNwSVhwSzlwdW9tWHIyd2xWTnJMdURydHlybHoySkdTdGhocHhZNGJxYnJqejZwZ25OKzAwRUxtTWxQS2dXRTZCN0pTQzhFV1FKbmpFeEppRVJ3YjJLZVROUGVOb2xWTmV4U0FCVjJwOVJEODRBTnRtYlQ5YzE5b1JwVWl5dG9XbWlKMFlqL2FCdkZ5RkNtN2lROEVSTE1tV2psdklDNFVWUkw1RGdTWHM0ZUJLcW1wUDlTMEkybnkzZlovUHQ0di9ZZVpBN0dCOHBMcnpVdmxVWVEwVFMySFZXSTRzeFlpUXU0aUc5U1lpOElKZG11UG04UGsyUlBFdFdWbkZUSk11aEliWEUzaFFoR28ycEthSVJhdHczdXJsTWQ2WTduODg5R2pDWk5hTURIVjMvUEdpRXV2OVIwRFVmeVduUWwrODJRYUdIM3Z6OE1sNS8xTm5SZFU1T2h3R25EdnFjMXFOOEZwendXVENMNytnNnN4ODYrV0FnRURqOURodzJXSDJQZGpnWWJDRTFBZUtXWGdsQXlWcG5zQkhzWDBMekNzb0dsSWRLd1ZYVzhIa2FaMXA2cUJUYzZvSjg2cWVPZnpGR3QyNk5IWDU4KzQrT2JyajFydGt0azJmTzRHL3BuUDRnLzNEQjF0aVJ4eDU1OXVpRzFqdFpOL2Y2ejUvWmQvS2w1NTkvazF2MHdMSWxhemZldTJSdDg2Vko0czVMamE4OHZlL05ZejkrN2sxdTRjWjdGNjE5WU5uU05xRENvcTdQTk5YaVBsSkhiaUYza04vSldjMDMwa21qS0I5cG9DMGphV01GYlNxbkU4MTBwR3drbzhkMmRIMHFtNkNSUFpweXVkUW9TSWk1U2RBaGpoaGpGd3pCeXNKZXR3WEZyS0ZaTFE5RnNnVEQwRzBSZzRNTVBoY2hqb0VqYUtVWXNoYU9LQnBuSDNOYkw4SG5DbjFSNVB1aXVmVUxsNnU1aUxmT2tha3N6eGluQS95TzA1bXdBT1NPVzIwTm5nYWNBbVpiN0s1dzhEUm1HN1FRdjNna01KdzRiSGJpQ3J1RE5sZTRmMG5nMXNrdExRRWFhTUZFYm0xcEVmT0t1ZDRXM2c4VllMZWltQzhiVU0yRlNuTTR3TEkyaDNlVjJ3SEZ2VVBwNmE0MEN3Y2RnUE1LcDBhVFgxck53V1M0MHBtV3c5RUJ4WncvVDZPRnBxdThYUHhCK0phUjlRVjlacXg4SkRMN3dNb2I5anlSVXhYTURrZlgzVGhtVmN1QTlldnI1OXphMUdkc2sxNzNoSTduQ3VTYmd2NkJnMnI2NUZUN2V0M1krYjFSSzJjMzl4cDh4NHhGWTJwbWppNHF2V1UrSFp3ZkhwWTNkUUhONkZlVnQrSmVWMjY0YVVDZ3NUcS9mTWFPNlBiMzZ0TUhOVXdzdjNIcCtFQ2djVTc5NGljcVBXTmE3eHAwRDVXMkZkVDVmSU1LSjNiOCtMRWhKVGVVdUNUVEl4YkxkMzBWSS9yY3VuYnFzSnlNd2VQdUdqbDBlcjJmajVjT0szYk9uRmc0dkxyRVZyUUFOTkZHNVRCM3M3aUQ2TWtRT1NCS1JqcWFZbEhKVVExUHZPSlpEVDFMaUZHSHROQkpRQXZkV1Y1SzhQdHBScERUdnoxTmFtcUFsMXNDQWVvbk5vbUdvT0RHYjFGZW8rVmJsZVBLWVRxVjAzSjZlcGZTcG1nVkk0Rm5wa1BueCt5Wkl3OFJUZGVGL2ZCQUFvWmVOa0tqUXMrZURJSjE0U2Y0b0xNNmNCbGtNejVhWjZTYXN5STVTL0dwVE01T0I3b2Y3dWgrK0xOYmFLVnlmQ3NVaCtsQytuZjZUM3F2c2lYK2ovZy84ZG05bFl1MGlwd0JqcStYczhNOERSUEt5ZncrZ1hnQlF0SUhIa05XY3JJdFl6algwWFYyUC9SaGpRcUNDNHEwQlNVNzh5UUlzdlJONWtsOGJrcys3M2ZRcWljWExEaWpwTkZ6K0lSTjlCSzNqMXNHVDhpU0pZNk9pOXdJNXNRTEExNUthYkFGMUVHd0pRRFgrc3A4M0w3NEg3azhlbWtWWGplbjZ5eHRKSytEUHN1U2JVUVRtMGdjK2hkeStTRFA4VUV6UFBvZVFEUmM1K3FoR0Q0c0hqS2tPRmhibTE1YlhGeFhWMXhjQy9mcE90Tmw1L3NCZG5tU0lac1hVVW9rRUV3S3Axd3dTSmphQ2JSUTBEQjh2M2pqZG02UHVPT2ZpelhyUUNQZjNQVVh2aE0wZ0VUY3BGQjJrdlUyVzZaenZXeXdPblpFckZyUnRTTWlacWh5Qm51Y3pQT0EvL053c3pST28vSG5GUlNBUU5uTHkwTmVYdko1YlhEd25VT1c3Wjg3KzBmenEycVcvbVFCL2ZsdTVRUGxKTzFIQzdtM0R5aG5memJ0MW9OVS85d1I2djM1dExpTmk4WTN4MThFSEp3aGhIdEhQRXdzSkZzMm03V2tuZXEwV21yV1VqZlFHUjRZb3NIengwUDlTMkFEYk9HMVpkVjhSWWg3WjZkanhNVGJTc3FYTEpoZVVDMzh6dEcvcEs5cGx6VlVVKzlEck41SkNQOHhRTldYVk1rNU9ZNzFCdWd0eWw0diswaTJ4WnU5UGVKMUd3eWlSZHdSc1dnQk9Cc0p1WU5NaDRTVE1OckQ1MHNCVENiem9CUEtBRWFtTDZBTjZzRG45S0VLcWFqbWVhSHdodGJLa2ttM2pQWFhQN2VzK2FHN2FucmZ1SGpzYmF0SDUzS3ZkVzdvTTJuYjdERXpaSStRVnp0MWlEZXpXTzRkcTdzaE5IVlR5MDN0UytjTUhINTdKREx3ZXpkTTJyaGl4WTJWdDk4K0E5YTlES2h4Q05aZFNPYktROUxYWnpwNjhicThQQjFaTDF1dEFWMUdKclZtVWlPZm1lbk9kdStJOUxJN0hQWWRFWWZEa0swdDExR2lrM1JlSGEvbmRUcURhRkRweGtCRGZZaDRaQkJlNmFJQUpVQnJBMmhkWVVaVUMwRGJ1d3hzVGpWWEp2bjhaU0d2YllBdkQ2Qm53RXVpTTRmbkQ0MVljM2pPeVNXYlgyeFlja3RRbWJQb0hqcFYrZktSTmV1UFR0Z3lQYXg4UE9MZUNTSDYwSlFuN3FrZUU1dGJNUHgybVdac29McXZiMytpcVhUQ2lsSEtuOGNLdW9ybVJVQndvRFlSRE1DeEZ1SWsxWElPVDhWMmpTeFpOQnFyU3lmb3JMb2RFVDIxV2F4V0RYU3BqR0FQaDBLNGZxQVMyb0JRS0ZPS2x4NkhsZHRDVHIvTmIvTWhiMUFmY0FuZjFOSHhkSHp5NUdNdmJBc3B2ZWhuRGZjdnVVdmMwVG42SWVVRk92YTdNLzkyOFIvM2RJN21YbHI5cTkzcmtGOTJBdDVQd0ZyOHBFa3V5bXJQZExrU09NL1g1UUtHYzNNTmJyZG5lOFN0c1NPYWdRTGZqbUtHWDNjd3dKYVh3T3oxZUIxUXdEaktBVHpFSjdpS1B6Rjh6WkY1cjA3WnNuM004dWJna2YzWnNqdzRvei8zY1B3ZjJkN2hXWE1QTEI5Q0Q4NTRkbWx0MVo3SnhVM3o2emMrd2ZFQ3o3MjVWWm5JOFZWM1A0VzR2QnZXcndEZmVNa0FNa3p1WlRlUTlUNWZlU0FEQkRtcllFY2tNeXVyeEdxM3AxblRtRkNYOUJCcXRuclVxdUdFZkplaWdOdkN5VlVYcXdKZTZuS3lkVHREYk1sYVZURFFNQ0pVdkRKMDhhNHBzNTliVkQxdSs2azFXeWZjdmF4MXgxMkRoR2xuSmo4OGErRHVnaHVtMXc2ZVBpclFkOVFNdWZyMjRYM29MMmZFVnQ0dzRVZGZiMytSOW45dlllR2o0WnUvLzhkMSsrVUZUeTl1V0R5K1gvR05Nd2FOWE5WYUVSeS9BR2t6RldUNVM2Q05uZlE3UkxUMGZ0a3VXM1U2VUZoRXN0bWs3UkdiUm9mc2tSUmZSSDA0RTlGdTRUbE82eSszMjBGU1FlM3lYL3BhcHMrZWZJTVVzemZjT2pNNkxpUGVuOThrRGdvLys4N1hTcWZ5OTFVcnFaSFN6MS9kSHRnS0R5UVR1ajVqZXRGUEtrZ0RtU2dISzlmcmF0dnRvdE91ZzB3eTF4Y1hqKzYxWGlaT01UUjRjR2hIWlBEZ1FuTnU0ZlpJYm9iNWhoMFJzNVowK3lYSUVWaDE2eFpBYnhpWEdaYk9TN0JPQjJxU2dvS3JmUktuaXYwS0ZjRmxLc0lkMTV4UDZGVTNyYWJscnNHenQ5NTh5OWJaVlhkTnJKNWExMnZvc3VmdXVQM1plK3YzRlRiTUdnSXVScUJ3MU16YTZobWppMEw1UTI3dTMvOFd1U0JmdnFXMDdKYWFQTG9wUEMvYTVCN3d6TFFiNzU5YVVUbjEvakhUbmhuZ2Jvck9DMDkrN083cTZyc2ZtMTAzZTFSaDMxR3phNnRtTkJZSFJzL2lJcUZiaHVRWERMbWxkRUN6REhVemN0OWs0TDV6VjdqUFI5YnJYSkpVSGxndnUrd2wyeVBBZVFVaXNtR1c5anE1U1dJb0hPaWhlVVBkQmlZcE5INU5naFVUS0xxTys4Nk5lZWhVKzNkbkwxbzdaZnZNU21IU21Vazc1bFRYTC90UmRQWVA1MWJ0RFl5YVVUM285Z1pBd3F3aDRkc2FBcnovRjhySmQrOHUvWDVkNC9hUE5oOGFzbWpudEpteCs0YmQ4c092RGVQV1RTa0wzclNnZnRUaWNVV0JFZE1RTm1hZmhYUzIzNmlTMHpVa05sRWptZXl4aVNhSG5uZStrR3NOV2prcjdCVFFhY0FhblFack1JTTVEZmVjRG9kVlBnQXlYK1hhWDIvTmcyck5WNEpabDJVdzY1Mzd1ZzA4eHp5WUpyWU9LNWttcDF1dDFHcWlKakd4SG90czNTZnBYK0RWZFdBdDI5Q05NcUYvWTBML3hyVFNvcm8yRnRXMXNRUnRiSlhvMlVCMW1uazN1RktLeXF6bmNoM2c3WHdjSERJa1dGeGJXd1JPejVVbHhwOVArRDhjK1pSV0MxdjUyV3huRjVLdEd2R2xpSWJqNkVzUmpoSlJnSjNDQVhpMElFSUQxeUFHNFpFZ0FTU0lPNlBqcW1NRSt0c25iTzBjenorUEIvZHBXL3czYmFBQnFFVHVFMllMbytET2RiSnBNYmh1Nk50b1lRRDIvTExSUkViUDBWQ05oZ3JnVFg3MEUzVG9SRTU5RGhjTXZCSU1oRWd3Qk40WFBBODJCK0FGbGJFc3pPN2N5YlhGNytVbmNVR2xjUnV0MU5Eb1Ewb093SUpmeWRoQjQyZ0IxMi9KUmVDTDZEUlVMOEdET0ozZVlLUkdzOFhLQ3laZW9DWllIRTl4UkhBYnpYUVVyT2pUQTlnd3dkSll3NGhyREdQTFl0WWJCTkZvd2wyT1NiYW5EemRwWkoyVjQ2Mzg1Z2hZT2JCL09xdkp5SE1XdlJtY2swVWlCVWhGM0hOWkFNUlJ4TTFLWWhPRHRoQ1Fxd1gzUkNRWXJBR3pUaVQzSzlJcm1kSUhnY0FyZHJZRGd0MVBnRzJEMWg0N1pqbDJURm9MaFhqc0dPNkpmSDdleC90cHlNRVg5UFpydEx4b1AveEkvTWtIWCtRSzlqeHgybWdVRE9ZUDZSWUZqZVdEM0xTYzJzSCsrUGRSSHg0QmF4MEVuRmhCRG5MSkgyU1Qza3cxUnRpL0F3SUVYR1V4MEVUbnR0bmNteU0yV3dZbEdac2p4RTZselJISzZ6Tk1HZ1JhZzh5b1FXWmNuZzJPL243b1k3VXBVY3RCR01yT0ZuR2F1UHcrSjNYaS9pT3grM2I2YkJtSXVBenN5c0N1akJWQTdvdDRENmkvd1h2Z3VZejdkK0xEL1NveWRlQXpPRXJaM3J6bHMwQTQyV01MWDYrZTBVTW1pTEtXa00zSDJGN3JUSWRLOFBNMnRnbjNKZXNqOUpIRDc3Zk4zN3hIdVhqaTB2UHRqeXZuLytQTTFtZVVYZUtPZzF1V0hpZ1FiSWUyZHB3Uk9hWC9taVcvanUrSWQyNWNxcUFkbTl6MXFiQVJ0S1NUYkpldDlRWTZndENSUExXNnFJblhJNU9ZZ0l0NE55emNZQ1JPN0tpRHR0UHA0QnliSTV5REdHR2UwV2pXbVRkSGRBSXhsaUJMMVFBdkdsMFNJbGRDckVuTFJRbmFJaUpKZEJpWm5ER0ljUThOWW5ERldWRmJnWkF0eE5nRkFTZXdyOUg0dmJDWElyNkV2Y2RtcUxSQzJQakVlZVZYeWliNk9LMSs0LzRkaC84QkxuM3VaNmNlcnhwUDI2bE1tK251UWZ0dlZnNHE1NVJMeW9sVzFBYkFMV0sxS2tFUHl3V0VoNTBJbFVTaVoweWhRNllRa0p3Q3JsUkFjZ3JMelIxZFh5TVp6U3BybUZXeVFuMVdkc01VczltbVIxRDFDS29lK1VpL2d0RSt3UU9LeWdNS1JtWklrdFNKdUF4cmRxdGloSllnbWIwSUtwQVZZUWF5YnVTK1VTWXFUN3p6VzVwSkI4WVBpanZpOWNvQjVVNlJ1L3dRTGFaT3JqZFFFU0RqRHdCa1JqSkhIcUFCZURTd1o5NGNLTkVZT0dvQXVPeWNDT1FDNkFRZElXYU5BUmRzd0FVYmNNR0dGVlNGRHVwTHVHQld3d2p0eWEyaEVHN2F1amtVR2tGWXRnOFVwRk05K0FOeEhYY3EvaGFuaVYvaUdzVWRqeWoraHhXRHVyNnRiSmQ5aDF5RWE3Rnk0Szl5bkU0THZpdXdEaThJc0xNSDR3cHIwT0M2TkxndXpRcHRSOWRsWEpkV3hUcldhQ1cwUVdOaUE5eTlOblZsMEFRME1zM05sZ1RlTjc4MXNhRGQzQ2xnZituaCtCcjhiRERCK2VnZlpKQTlzcDRZcUJXVWhzaDRmaER3dk51MU9lSjI2MGlTMDYzR1hDTm51TUxyTHBkVE1ocUpnRlFXa01TNFlMSUNST1J6WENqV2NoN1RFWjZySlFHRmdJbURkTFVrcUxBd3IvZGFrUWpad3d6WGhHblBmSTN2VzhTQm1hbHpwNVNMeWtsbERmMEJyVHY3eEo3UC82YThRWFArdm51WmNweCtQSFVwM1VpSDBkSDB1VkdIN3dJT3VxaGNVRTdVMFMyUEpPZ2pmTW40WjRrOFhBZXFYNmNSZGNBLzFDN2FEYnlHMXhPRWdXaXVBSG9mQlNPREhHTkhkcUZtbllBekJKd2g0QXhoaGFncVFsR1ZJREY0amVJTG9PeERTaklTMEFyb2hWSFdrUERsN25qbTd0M2NKN3U1NzhibkFzdHY0SmpYRGV1a1VSWlBrQTZTRlJUNG1vZGIwT0JwZG5tSVJuZnZobEZLMHJvKzVRTFFNcEU3WlJlR255bTE2b0c4R28yT0J6bm5IVVplUk4yT3NWTlJKQ2owQklXZTZCaHdCamZLaDhwelVGOUNuak1ZTEdZMW9KcWdWSUQ1OTBpbnBQQzJnSU9vdW9jMlc0Z0xuUHJKK1BMeW0vKzBtK082bEQrN2QvV21xL2dkS3JhZmh0Vko1REU1YTdtRkZsckNGZzZnNlVzSGdoZmhOb0VPbFREd1pVbmFiVFRnTWpQbEJvdEVSUkhGaG9kTktKWG13TzF3TUFNaElIYURpRlJJMkNxa2dvZ1NkRUdWSURCREtFSTZKajlKS05Cc3Q4QUdOb2kwWUdZYWpUU0xVdnI4Rkl3eEkwbW92SUtHcVBEMDJmaHZjN1hDN3QyQ3hjMjVmeDNmem0zS044ZEJwY1lucDN1NGUrS05LbzM0blFDZFNPNlg5VlJnMm9kaGU3L0VtT0dDeWhUTXdyTGF5T3BQOXh0WS9kRitQYXVQeVc1RDduQlIxRjdIV1ZUbExLaS9aREJSc2FldVVwVXIwNjAxQ1EwRlRNWHZqTHQzYzdLNDQ1S2lybElEakVVODVMRHNYSnBKRnpob2dhUGN3YzFOcCtrTTArWWs4cG0zVTRHdDlFd3E2czBhdTgxdTU0WHJtQ1lUT3pKUkxwQjdLTldvZWhRamh6VGJnZmgzd1lERDNFTWZJRHpTQ2h2QWdmRFlWSTZ6b2VNTHl3K1hBaXpvQnJlRUdHRGhCSW1RUEN6ZUJ4U3lEYWdBZDRreVNxVTdrVlkwM2NXb3BabjdRNHZnZGlqcFRZckxtUzdvbnY0ajdRaFpOWUZNK2grLzRWK2UrNE1wZlMvdkU0YVZUTHY1NTUyQWxFNzN2UERDZ2Z5WkJHWkU2Q0VPOG1QWnZNaEU1eHJwWW80dXA5U0lFZ051d0dpclRzWExSWENPMEllMFUxSFFHM2c5dFY2dkoyelVodml3MlJCVk5yd21Bd1pzVHFPb3c3azZuS3ZEdWJvVmVoVVAraVN2SnN4cGtxN2hVaFViN0FUYzV3UXlXQkN4bTEydklLR2d6QllTNVYvRmM3THNHdDN1OTdsZjlUTUxodDNDb2tDdytPSExYNHM3TGo4NkxMTjZHLzlsWXEvNHFmZ3MyQUxjVDYyU2M0Z2RQQUtIeGdSMlZMald1QzkzcWl6c1ZIY3VXRE1uMGVzc2NYSk9aNFlWcjdEaUZWYTh3cnFjUjBYSm8rWlg0OVVaVjR3WDg0R3U4UVRFaEhwbkpWWDFPNWFjb3J5cGJLWUxhUzB0cExPVWpjbzdIeXVmVU1jSDU2aWtYSFRUTGRBL2dUNm16RkdPS2s4cDA4VlM1YkR5RDhoSDZRRHFwRm0wWFBXQmhFS2dyb0hZeVNhNWNKaUdjbFpxRWt4a2M4Ums0ams3YndUMXlHdVJsN1c2Ym5XeFhFTDVSTFpGWWNoQjFrVklKQ25OUkJIYUJMTWp0SFFGcDBvbjFGOHpLbklDQzFsZjVmZjJBQmpQd2JTeDJCL2FhL1J5aWVyZVNqNVE2YlQ5azdqeWx5K094dmI4VklseE9mR1B4UjBmdmZHRzBzbWRpUjk0WWpQTll2U3IwZVFEL2RKSUwxSXVaem9rd1dZeStUSUVoMFIwT2lmelRiTTNSK3pBMHpYSHV4MFlESDJBM3BPT3N5Mlk2TzFkWUpNcXluMWVWN3BOMG9KUStmSmhTNnpWMkNRWDZQT0tjcHZVdXdBbzhOYWhuNzU0aEE2aGZRNGVQRnhVU3I4SEpQbHk1dHlQSDNoZ2Zmc0g1OWF0YTJ0em56Z0JoSmg0OGxldnZvcUVlS08vWC9ud05aOVkrc3d6UUl1THp6eTFZd2RRSTN2SG8wbHFIQU5xWkpIZTVFVjVZTDJWOHJLRmduTmtFbDA1T2wwT3JGeG55RGJDMm8wOE5iajBOcVJMUXBLUUxyMlcyNVp3ZENtbDNGV1dvb0Mxc2ppYmdPYUI2YW5Dbk91Y1ZJTXFiUWJWNXpPb1BwK0J2VEpFU3NFV3VNVlZpc1pBZmVVRk85WnJkaWRBTmRweUsyN2ZpbmsvQzNZbUE5TE9ITjVGYmNuZ29uRHMxUXUrNmlFTndmYmQ5UG5KVHl5bzdUZHV3WWhlWlNYQjdQamVNeld6eGhSdGU0QnVxYnl4MUJWL1hOd1JiSDJ3dFdINTFIcUhJQlZXM2hEa3g4VXZGdHh3aHp4dkZVQ3pwT3RUL285QTZUTHlHOW5aVUVaSEZ0TmgrWFJvSmgzbXBBUGM0TGoxUlU2RnVnK3pNR1IwQm1Ma1ptalljRlJmNU1nVDNQMHo0VTRlMkxwNDNMSWJrT3NXd0VFQURQZnZyOWtjNmUvd2VJcnlFR3Q1aU9nOFJIVGVjb2VERm1GZkVmWVZZVi9SY2owcVJDdEt2cDdxOVJWVWw3QkNUS1RWZDRScXBiNTFaZjRjeVhSTEo2RUZ1TEdwKzJMVjRMWlVsTEhYZkJoRzY1MThINWdNY2VJYnZpc1J1Q1Y1dDg2WTJlL1I3YUVKeTI1bytFNXJ4YzBiOTdlOE0rVytYMWJjZFhONVllTzhodEh0MHdlUGU2RGo5cnpvOUphQngzTktmUFo1c3dmZWZNT1FYZ1ZqSmk5cW5McDVjbkhvYUxOclFOT2dpc2JhNnZ5QzhiZmYyemp6ZTVNS2pjNWN3RXdoY0tXSjdaTld5RVllbExzR1BIWU4ybkRHSU9Cd1hKTFoyeW1SV01DMDE3NHBvay9DSVhvNFJBK0hpT0JXOE9nYzg4azNaanl2MStsbEpBR1k5bjI0RXc3WXV0MWVoaklxZmV3T0ZqTzFnRjVWRFhQaS9jeXZOU2xUZHl2VCtEK0ozQ1ZGNU5CamZSYTg5M2RoaldheVZPN1BHZXdHMkV6WWRaeFI0UFRvcnB0NGtiL2VGc0hHRk4rekc0MElnUXNHakZZdFR0TGlKQzFPMHE0UVlLOG02OUhqUUxkZTZGNWcwdkNneTlxdHIvRDlFamdYaVVwNE4vNWgvSnZkZEQ2OVl6YzNOTDZUcStmdjdIeGN1WUUreTk4REs3WURWajloUHZhcnNtR1prYzRYMEs3Q1V0N2FiNktqamVqNG1CTTFiQnpvYUtFRWVnV3ZHUXM0RFJ0cHVVRG5hNm0yRDBvM3VuWE02YnVpcEkxYWp1YzVJMUlCYnRLSklvMDFDN2taKzZBaVFNY1MvL1VMa3NUYURTRnFad0hKOUZNYzc4MVRIbmZsR0k5QTE3QVVRUVpMR3c0SHV2Mk9RSkpqOGRWZDB1RVFQb21mUHhTLytDSjl3R0VRZEJsMEczaGF0NE9WZmJCaWVGVzljRGY2WEptRWFGdlI1NkpEWk84eUQxMlNTUmVtMFlWbU9zOUVGK2pwTW81NnZNQWdtVmlrb2RqcWdVMGNHSHd3czhnWkdXMUM3QmlnWWRCaDRFbWZDRVFSZkIxTVJyTUFITzVrd2VxUTBRVGpYeDRWdXg0VnV4Njh3QUhvTkNGMlRZaGRreHRPZ2JWZkJhd0QvSzVLTEsyc2RHRVliNVNWbFd6UDVsSk52eFVma28zY1JVV3J3NlV4R0hsRG1nTk1xVXR2c0xxODZDTGhBNkYyc2U4NFlDVldCTXFxY2ZGR1FyS053V3p3QUFDL0NXOE9NQjFLL0NWOW1rUlNmZkdyVTBzaTBZVFB4M3kvYnA5UHJiV3R5cXhmS084NUJFR1Rwdnp1NThxa1E3Uy9ReFRGVERyNEtWb2k2UVRCUmZPUlBJSzc3c2FSd3k0RFYxNCtVTjlRTmxFWWRmbjU4T2dCTnd1TktyKzJNZ203VGZiTjAxQkJUNm5JMjgwZ1dYb09wWVpEcWVFMENWbFhJeDFZeStsTTNFWHpja0tzR3VaTWEwU3ZGU0FPSVU5OVprdEtQZnF6YVA1UFltZ2RJQUpodjhKT3JVcnYzVXJvWjNTSUpwczNaTkZHOEZFWHh6L25MUHpHK0dMVHFMeHliaDJzMFFkcmpMSzR3aTdaWW9JMXdxYVVldGtURWZIOXNWVkc2Z2xzRXgzRVQvaUI0a2lSTTRsWllwSEl1M2lSQ2dMZEhCSHNSS2ZWYVRFTW9XR2VKem8wS0VhYXBBZERUU2IxTEExVnZBbmgwMnFwSmhHMkVQRGxEbjRMRWt6dU9oSTJzdWFLalVTQ0JRS29NU2krcGNXd3NoRHQ3T0FIWFA0MVB5VE9DVVNjZTduZ2thRHc5aVBvRlV3QUc3ZGFjSU0zazB1ZWxaczBFb1V0ckNSb1dMRFY2SHdvWXBTWUZzdXlVeWVmSldadGk0anBWbGpvY0t2VmJEZHZpOWdscjdYRXlsbU51ZGVxd0RiS0pmWk5YNnRSbnM5bEYwSkVmZGFNMVRxRVVvZnFJS2lqT25STFB3dGRjZFpnaTlpU2pFc0VWQTJkVU9ESnVJVFB6OTZJRkpSSitmbVNuNzJnOWRxMFdrM3lneUYrOVU1aDFsdmJmMHliYU9qdFE5c2UvZ1dkc2ZNZmMrZlBpaXg5NHNtT3ArK251Y0VBRlZmc2JsVytzelZQR250SHc2M1ByVVpzN0FKTlAxNDhCN3ZsYk5ndkI0aUJTaHJlU1oxVzU3YUlOVjNyMFh1MlJmU1NRSzZONXE1MnE0Nm9HeDBkRTZ2L0pHZkNrTnVkcStIc09OMk8wKzA0M2Q3R0xKVU5UUmFIakV5WnA1N2JJOHgwbGVlcVlxRGJVZ0VDOHYzT3hGNDVWR3AzU21DbStlNHZwZng1R2pwRzJMbFRXUExaTHo2ODlON3JzMzl3MzdZZlBiNzJ3VDFidDRybjRxMXZLT2Yvb25RcHIzTWpIcnh2NzVuWG4zdjVsOERicmNBRlU0RUxuR1NOUExHWnAzcHJocFV6RWllNExTeit1aTNDcGJOdzFMYUlUaUplMEdmQWkwaENJd2RMbndPMkR2dU0xKzQyVjR2NFdabUlFMFYvanhBVTJqZWdjakRRNHlXWUdvUHFYNEplWGo3UWxwUU5JS3BMa3FCcUJkKzY4T25mSzEvUnZDL1gzakgzTzk4L2NmU0oreGNHYjZEWmY0clRVT251eHRNL1BmQldCS2tJMEFpU1NzVkg1VXFyQnFpWXhSaWE4NGdlNUdEcXREaU5RRk9qWkNVMjg3WGI2ellxSmpqM29zcTVGK1MrakhOejNRaWdHd0YwSTREdTFUcVVEcDBGbVJtcHJldEp4Sjc4M0UxRVZvRWZoa1JVbVpoTEFBclU1QlBrUzVCU2tIWUtjei8vajc5UTh1N2JyVURQblNzZWV2NEhHOVkvdCtjNGRaeFhhT2t1YnVubFB6MTg3L04vZUhudnllTUpxUGtQZ0laMmtrRmUrSWxWQzBCck1MTFJ6MmdaanUrR3dFeEdNaklFcTE0QUhrNjNwZ05IUy9lQmpVOUhvNDdrMDJySmFnZDdhd09ZY3FqV3pLR2FJUWRhTTNURUhBNVBCdE5ZRkJHVzhFTlhteEFOSnR4MW1ySlJIcTdaZ0FVK0s4VXczUFd2SEZnd0R2MTZYem9TMk5tTkRidXpkd0dpUXN0L0VPOG54SGI4ZVBQYVA3NTNrVnBQblBqRGJycDI4ZnluSGZSM3p4MmV1Mk1xZGNXL29QMlV6citVZmZmeFhmZWo1UzhERm5oU3c0RkdhejlFSkVEQVFIeWo0SVJlblVrMG0wM2JJbWFyblFQTlJRRmdaTTBnWEdRaUp0R2lSN0QwQ0pZZXdkSzNHZFNkS0tzVDI1WlBaQU9MejZVN2crbTBwVWVNTGxTS01Xdndab0pYdml1d3NXQnFEWkliZ0hFNkU5OW8rTXRDN01XaWkzdXlaUER6Rnk0ODg4SUxoemMwRkltVFBPODl2ckZ6SXo5LzQ2Nm5YclFqUlpVY1FRS0t1a2srZVUyV0RBTGxyUllnYXkvR3l6cDhwY2pjaFE0R3BCWGpWNXdXUkRYTDREZjdBY3gwbDlXWjdjamVGb0U5cWpNai9Ub250VTB2cWhFUUJJN3RNQUlJdDc2MzRNV3BYcHpxeGFuZTFSSlNXRUpHbDVEUnBXRHZLNHplUTNPN1FzbUE4bFZhQzhtY2VNZENibTNKbDN3c2J1bTFxZXd2MlpIOXk2NWwvL2labDc3NzQrL1RwY0tDdi83c3M4dnZ2eGtGSWZqQnNrZWUvOEc2OWg4M3hkOFl2ck9WYnBuekNyVjlRa1U2WU5kMzQyOCt2SFRQQjc5ODd1UXJ5QVc3Q09FdmdnNndrWWZrUHB4RTRVOFNxRlB2TkFsV0FWbmZRSzQzV0ZkaWZVbkp2eWpuTU1sM21LNk5JTFhwdVFUeUZCVjV5a0VXUUhKYy9iTGdXaVZlazR6Zit2dzJDWUZWWTU2QURmN2l6czhYZzV3TEM5K25FN2d4VkQ2ME9YNEVWUGJNbDVWYmdSczJBVmkzaSsreDk5OWpaRC9SVEp0SUxGYXpmaXB2TnZGVHUwcXV0VWx0Wm5WdFpuVnRack5OU2pBczdoUmhDM1NhQUhNZXYrYk52QVBXYzZtb3VycW9YMDJOZitkT1VhZ3FMaDQ4dUxpbytsSW4vbWpCRmN5YVFMZEtTMDEwa1pFdTRlaHlBMTFCcVNucEVWUDBqOW0zalhtNERlTU1JbldLVG9OVlF3eEdJOFZRQVhvM1JNWXZJRTJvV2pBNmJyb3VzTjhtQ29rQWJ0ZEJaajRzRExrSkM0bHZOMXZVWUhJTnVnZHFQSm05eHNNSW5ScE9CamVQdi9pSlVvVW1rZTc1blpKUHp5bHA0cm5PR3ZxdVlrL0FRMGNDUER3WktJTmg0TDZWTHhTVkh4Z2l3VGNWcmlDU2ZZbkozZ2lNQkhTZFM5eFJNeDdrTnBkOGNIQ0VpWTRRYUE2QStGTjAxWDJVendMTktoZmhxL1IwYWhKRVo3cEhNTHZCc0dhN0pZZlZRTzMvMmVQUHlWbjRmQXZzUVd2VGJEalJoaE50T05IV1pzZXRabi8wTWl6b1pYaXVEY08wR1F5SVRvTU1XeEY0a29uMytneHRKUWxiRkFoSUxBenNWcUVxQmY2NG9BTG9Eb1pDTlRYNDNaa3J4RXcwWE5FU1NJU0VDMVFlN3VabDluMVV1Z3NaV2pOKzU0eDdaM3h2NTJlek53THU3L3oxak1leTUzNU1tN2hSeno1eTdQNTRCOWRLaTMreU9kNGhrS2NQTDdqMUhXRHlKSGN4SzRaeWE3c2l0d1pyVW5LL0RVSGYvQXU1VGZ1L2x0dTBmeUczcXRoK3E5d21ZSFdpNEM1N0NrQ2MvNGZkKzdqaGROaWhCeENxWjE5Kzc2VHFqVFFDUkJqdlhTLzdNMlFqTjVyWXQwVkl1Z1pza1VhNmxrcXJld1I5TDdBdFFTTFkyOUgxUithR1lOUVhEWlhWMEIzMVhaMkkrcUl4NHpPK0plcUwzdGJWNzM4REl2aFhMTmJyVENNOXY3UG5tdjZrL0kxbVh2Z3pwY3BmUDNpODQvQmpUenozbkp2bW5xY2N6Vk0rdWZSMzVUMSsxKytPSHZ6TnIxNDY5aFo2ekVxaGdMeCtsY2ZzU1hyTWdsV2orc3ovbnNkc3YzYlQ5Mjk2ekZkWm9LVEgzRTJ4LzhSalB2N0hTKy85Y2s2M3h4emZKdjd1d0xkNHpHaWJDNWx0UnJpM3lXVUo5NUo2ZU5YQmhOMlI2bUNhYlpickRlLy90SVBwQ2wwSGN3RDFYdy92c3V4NjczTFdWLy94R1NXbmZqTVpEZXQ5VzUvZnRYclRjMG9odC9aVmNEQzdhSDh3cVNlM3JkanorMS91UGZHTGhHUnlSMkQvS3BISUlXSUNsZDBiUWRZNmRWWkNESnlGdlI0a2RzTzE3OVhidEIxZFg4a1dEQjloQ0Vnclh2MUtNSXc3dlpPbHBjR2FwSnZVTFZyTVJUb1NHRHZqQVNDTmYxTkV6dU1uK0k0L0YvOUdJRy9QWG1KQmJURWRmRjRyVUtHWVBDVm5hQXNvbjA1NXZZbnE4ZTBRNkkyQWhFdTBJMzdMc0dXb1pQNVNIMnVPa05iUGxaR1dzUzJTSmhIY3hsUGV5Rk8rSDc4dDBpL2Q1ZXFUczlwcUpYMVc0eHRDRm1Id2lpVWlKNG9sQktsQnN0VFBLMndzK0lxUjErNnc2L0ZFMkJVYUdHOWxYZy9ia3QrS0FWZkErMzhaYnAxKy8xT244bXR1NmovMGpucC83VjBQTkt5WmNjLzNpa2VXWldkWE5vYUd6aDVWV0RkblMrUGorYkZwbXdyRFJYNkhwNksrZWREd3V4c0tpbmVOZEJhVWVmdVU5ODFMeTZ5b24xQTlhczdJWG9paFFOZFpicFVZQkcvNFhua1F6N2cwTGMzTzJYRkhaekJvTFJvajdKcTNSYlJBUkROK00yUUc4aGwxMTc1V2FoUFVBTDZndmtzVjhOc0RZeUptbVhSL1M0UEJRTkw5UThQYnZhMERMT0JuTlRibStWYXdieVhZZm81Yk5mQlc1YXRZYkNmbEZHWFkyT3ArQmk4dDRpWnZ2RlNtL0hwai9HZDNOT2V4ZjFjQU5QNFlYQThiMExoOGhJYkNIMjltaExYeTFLU2hUdDRrbWxEbUpLdk9TcThUdGZ1czFJckI1RVFvclZQOVNyR1RDWnpWNnJqMjg1UTJyYUU3U01zeFZuVmNLM0JYUGlkSXlGcTNTU1Rxamk0UnAwWGRBbHU2ajNjS3QvOVcyZkxNeGNXUDduejZNRDNBUmVNSGxTTjdIK1RHQUd6QXhQenJHTmNoeTJUekV1WklMYUowb1VCWmFOYUlJU1dCaFpqWUM2Nk1aRUJvSVd6YjJPZFBSaTNQT1htck1Sa3VNaElwOFpHY1dUQ3BvVmIyWW9JSHlyQVlhMm1BZlVjZVp0SFZaSWl2WjJpVmYxMlovcFJ5N3dFcVpHc0ZRem9JRWVra0FvbTdtd2FQcnViUXU4SGZ6b3JCbWoza04zTDZZZzlkbEVZWG11Z3lBNTFQYWFXZVZwaW9CeFdia2UwWjJhZElCdldjUS84RXYyTktROHlhMkI2THZjZkRGbXhuam1FVU00MVp2V1F3MXBUNG9nMWNTSFFvUGQxWU1TVURiMi9KZmhZK1plaXdzcExUV0YwT0Q5RWFqRlpEendCb2Q4Q3pPOVpKQXQxQnp5dWhUdldyUVB4QWtLSEVrYXpGbUhMeTJiZE5nc0RiLzd4VGVlMzVkd3lDanJlZWUrZ2RnNmpqckc4aG9yZ1ArcGIxQ3NkOTBGYjg0YUpTbm5SMjVsZjBMdU1GTlNiTmI0R1dnM3drTzVZNTZEd0xYV0tpOHcxMEdVOFh3QjRqK2ZXZUJmRmhTcDRaOEl4UG5qRmNtVlVwTktrMWUxdnVRR09KVzNDS0JaRlV5NEk0eFUyOGJHT3Z6eVgyWlFjcitjUTdkbWpaTUM2dFFUZmNDUTFlWTNNSVJyUFZTRGl6a2VQQWp1RmJGQk4rVHdoWVJNbnUrVHI4MjJQR2V1NEtIaE9JcFB3V1pUZHQrdGtKUjZZZzlqMTVsTFlvKzM1MlBOMHBVR1N2UzRxR2pzb042dXVWQS9RYnpxQTgzYnVRN2tHY1daUWMvbDNBV1Jyc05nem1ORXJNVk1QUk5HU0VJdmJwUkVJOHZDd21qOXhxTlZrbHhnWVMrQWo0Q2M2MkNKK2xZUkppU2NvUDFSaDVVMXBTYU5LU1FwTnV4a0d6U1JVYTB4V2hZZEIyZnlvRjduQ2dKaW4yNnN1SjVMYzRGVmRDNC95N1N1R0tNM0tnck9qZTZpWmx6a0hZQVVrYTBVcjlBcms4U1huWi9EMzcxcGQ1cGZPY3RjWTlnRThIbjJJMnY0cDdTSHlXZVlxVnNvL1lUMFdJQlV6cHFZaEc0UFcxemxONjZ5bmVxcWN1M3AzQjY3c0dNc2RkT2cyT2UvYy9zUHpYLzdpU3JwcjM5SlB6NWovejlMd2hreVlNR1RKNUVyL3FtZm56bm5oeTd2eG42SUZKUStwdWJhMnRuVWpZRGc4RS9QR09zbTlPYjd6Vld2VjM0dEd4bjBsNTRlOVZMMkI5NnU1aFdaZG5kUjYwS29acEJIL3BqNnEvb3dLMTd1bTRRb2oxNjh1ekx2M2FxblNQSk5NYXNTOTZFWkIrQ2I1RS8wUW43eWZQSkNkb05wSkd6UjFrRWJhNW1XUWpIT25KTVhxRTlPWkRaQlBVYy9pY3JqTkNJOEYzQjFqZkNjY3lPQ3h3N0lUamJqaW13akVCanNrNEg2L0ZlNGhMeUtmaUVpb2w3eWtXa25UaElYSkUrSnBNRmgrRDJrU084SitTSStKeU9OOURqbkErT0g1UDBvU2QwUDhLT2FJTndsZ25PYUxSa2NuQ01yVStBZGZKWkluUW54U0s5NUZuaFl2RXJsMkNzazZJTUp2WWhVMzQ1dURiRTNoVEU0UURaQmUvajdRS0IrRUlrbFp1RlNsajdiVmtGNzJBdTM3QTBTWFczcVU1UTNaaHZ4Q0RjYmdPNTNHdnd2VzNrZW5jUVJLQXNVMzh1OFFpdmtyYy9QTWtrLzhRTGN6L213bFU0bXlTU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbVVTcW1VU3FtVVNxbjB2NXQ4MStSWDZTdVFGYTZLNVR1NTlkeVB1Uk84a1IvQWJ4STB3aWpoZVRGVHZFbjhxeWFpK2I3bXZPYTgxcU1keC9JSHVoVzZyL1ZUOUh2MWx3MnJETzhhUGpOV0duOW92R1JhYTZibWhlYlRsc0dXMzFyWFdkK1hRdElCMndiSUg5aUhYNVhmZERRNDlxWDFTOXZyVEhjZVNNOU9ud0w1UlBxWHJrMnVmN3FudTg5a3RHVDhNTE15Yzd0SDY1bmlVYklleWJiOGorYXhxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6S3FaektxWnpLcVp6Sy8xdVpzTjhzVGZ1SVRDY2krNTZUSXhJSmt2c0pFUzJHU2RoeGlIaHA5UUc5bTQ3MGR0Q3FaR05Bc2xHYWJBU1RqZUprb3lqWk1DVWJRckxCSnh0VXZzeGFYYXhVV05uSnlxOVkrVGRXWG1EbEY2dzh6OHF6clB3REs5OW41U2xXdnMzS2s2eDhnNVd2c2ZJRUsxOWw1WEZXdnNMS2wxbDVqSlZIV1psWTJWNVd2c0RLamF6Y3dNcDJWcTVuWlNVcksxalp4c3JWckx5UGxTdFl1WnlWVTFuWnlNcmhyTFJnR1h4Sk9BL292MUhBbjVTV2hiL0tVL1RtOEljZnBidXkzbmtYaW1YM3BudVczWnZ4Njk5QWUrRWlLTzZjQThYc3U2R1lkVmU2WjlaZDk4M05uTDhnelpsMXgwd29icDhCeFczVDB6eTNUVjl6VDJiR3ZQU2xkUm0rSlhBTUNwUEFRRGpDMjRibkJvOEluNUNneUJOTzVQYzd1bkkvZWtuNEJ6ejdJMVo2aFF2N3piYXczQ0djM1dkTUN4L3FPaVo4c2QrVEY2NFpZaGEraHZFSGhhK2dMRkhMTDlpYVA5MXZsTUlsUitsTmNMWVNTenArLzdaZXVUVS9vN1hRWTZWRHlKTndjRjBmSGZoYllRQnVUZVg5ZytzU2RhOCtXTmZzTHdvbWFsY1cxb1BsOUlKQStKTy84QUg1TDBYRllma3ZIdWdlbjVzYnh2L2dKLzExdno4c3YxZllOenl1aVFzMGZjd0Z2REdqT1h5SWNzQklIaTRRN3pRRUxyOGdCcjZFa1ovL2dndkk3N3N5d3IrSEUveGQ3WTlMK3JPYjJEN096Z25MdjNXNXduOTlpUXU4dEFOR2FkdSs3UWFvVmlXcWxZbnFQdGtLOWFOd2JJZEpPN2FKY0p1UGZ2cDVXbnA0eTJZZTI3THBhMGQ2K053MkliQVpZR2EveXozTm5SRytmUnA5YUJ1WG1MQXR2MCs0c29JRUt0cTZjb0hiRHk3bkFwMi9Od1FPMFdwYXRROFdDQ0sxTDdkWEdNUm4zM0s0SnkzZTM4WUgzZ0xaK1FtVlQ4SGljY0g2Vi9MeXcvTExzR0FFNDFpbUIrdWZIcFBzNFpOdjREcU8vZlFFb09XMVYxbGJUcjhBR0RtN2dndVVURFdaTkhWN1grQUNMNnhJWU9CdHE1M2Q0bWp2UHVFajlINnlIa1EvUU5mc2F6ZXdLN00yNXVTRTE3Y0xnZlkyUTJBRHJHUFZmVFN3ZklVUVdOR1dBSGZJVklCdWFoc05ySU5qTFJ4cjRGamRKZ1ErYS90bkd6ZWpqZlp1bzU0S3A3dmM2U3h6MmdjNHJTR25xZFNwNysvVWxEajVvSk1VTzRjVTBKRzBnVGhKSXgwRi9ER0hqZ1NPR1VnSEFhZFUwakN4MEhKYVFTekVTQ3ZKSURnYTRIZ2REZ0Y2eXFHbm5FeUVneWNTSFFqWGFmYnhYYmxEZk5SQWpYQzlqdXJoZWczVnd2V3pxQTd1Ym9SeUVCd05jTHdJeDEvaHVBeUhCa1lNY0NjRDJRQUhUelZ5SHR5b29MZWxUMjlyV2JrbFZHN3RHN0FVQmF4NWZrc3Z2elVuMStMTnRaS2YwZjd3MlA2Z0RQdkRBZ2d0a1ZmU09YMC82c3VSS2lyMWtudk42ZlZrTDhFcTJVeDZnOUdrMGVwTXZDQ2FDT1ZNQlpxc1hBM3Z6clh5TmZ5SFBQOEUrWkJ3VmxldUsramlyV201YWNFMDNrT3p6VzV0cHRrcHVjeDJJYzBjOU5DaXFyNVZmYW9LcW5wVjVWVjVxM0txUEZYdUttZVZ2Y3BhcGEvU1ZQRlZwS294Tko3RzdBMmtZWHh0ekFFb2JSaFhHd3NGR2pwNGIxT3NOTkFRMHpkT2JONUw2WGNqMEJ2ajFuVlFNajRtck92Z29MTFhUWmpZM0VFemNIaU41eEJna3NRYVd0YzhFQWtFc21QUmhuSE5zWlhaa1ZncE5qWmxSMGhEckhSc3pPT3Z2ZTVYenVleEFsTHl2RWM3c0xkUFFYMnNiLzJVV0ZGOTYxQTJPTCtEYXVwbmRGQkQvWXdwVVBxSGRsQmQ0cndWV3Y2aDZpMDY2RURzcmF5ZkFkMlZPSXVkbDdQemNuL2lYajFXUWVmTlh4RDRUMVAzYk5Lai9WOGxlTWE4K1Vub3NNVjZZKzVZRFdENlcyYnYxU1BXRzV0cUcySzZKamdhSjhZeS9YRHlLcHlVdzRuSlg3dVhjSFhqOTNKWWFLQ1lPTEY1aUpOV2t5aXRnbU1BSEtWd0JPRW9ocU1JRGhNY0FodzhIRlMrTWRvVlZhS2QwYStpZjR0ZWlINFJQUjg5Ry8xRDlQM29xZWpiMFpQUk42S3ZSVTlFWDQwZWo3NFNmVGw2TEhvMGVpQzZOL3BDZEdOMFE3UTl1ajdhRmwwZHZTKzZJcm84T2pYYUdCMGV0VVFELzNhS0JQNGI2ZjhBNmJwc1h3cGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNqa3lJREFnYjJKcUNqdzhDaTlNWlc1bmRHZ3hJRE13TnpZNENpOUdhV3gwWlhJdlJteGhkR1ZFWldOdlpHVUtMMHhsYm1kMGFDQTFOVEExQ2o0K0NuTjBjbVZoYlFwNG5PMDlDM1JVMWJYNzNNLzhKL1BQVERLRTNNbVFEMXhra2d3SmlRUnpTVElCTW55U0VId3orY0FrQkVqNENEWW8vb0Q0VEpRTzJJb3hmaEF0ZFZtZldwZTlnVmNOdExUMGxWcjF5YXZhMnNwcSs2VGFnbFVTbzBWbFFiaDUrOTZaaEFEMnRYMXJ2YmZXVyt2dW5YcytlNTl6OWo3N2Q2L0NDa0FBUUEvZFFJTjE5YTFidWUxek85Y2laVCtBWWRiYUxlczJMYXAvZHgyTzM4Q25lZDNHMjllNlQrLy9BTUNWQjJDczZWalQydjRYc21rckFJY1BGSGNnd1ptaVQ4UDVDemlmMXJGcDYyMmRVM1J4bkw4Sk1QM1V4czJyV3pmOHRQTjJnQm9SNTdNMnRkNjJ4VU1NeHdDNlR1RjZic3ZYMW16WjhPa1VIWUI4SEhNZGV4WThBT3crU0ZOYUhFOEdCbVE2d05pWlJEdjJJTFlmQWtqVHh6NVgxb04wNVBKcW5EdW9oV05EZEQwNGNOMFEvRjJnU3o2TVBQaysvQW5lVXNnSGsrekg0V0Y0Q3Q2Qk8vL3FBU05rSXduQlB3eWtnVlNTQXVKWHh2TkpHZUVueHFXRWd3Y24xcmxKQ3RHQUJKL0JuK0VVL0FiN0N6ai9BNXlIZjRPUHZ1SmdjWktNTGxKRC9PUUNqTUlYMTZ4N0hSRklJYkhDTDJFWDdJSHQwQXMzNC9nek9EMzVET1djVktWTlZ5YmI0R1Y0QWU2QXU1UE1aNkU5T1hvQW5vRWY0Ym9VTWdOOVlhT21nWTJHc1UvQUJtZmhDTWJiKzhoL0VQN3ZvUjB4L05lWTJrNnBnTXhGaTA0QWN3SnNtZ055QkYwYUl6ZWd6Ui9DT3pIWWQ4TUhhTWxKSUsyVmxqSkJzSS9QeDRiSURXUUptWUxyVHNKL3dIRnM3NWMrazNaZDJuVHB3Tmc5WXplencrenZtRGZZRlBweEpnM3VnMWZRbS9lZ3JkK0hFUmdERlZSUVFRVVZWUGovQ3ZmQUQvRnQrZEJZNzlpTFVBL1ROVTU0RWFxaFdvcXdNZmdtZmwvMFFqTTBRRFd4RWpOMGsweDhxNGFoRS83MXFsUGVnWFpTQVRkQkY5UWx2dndRRHNQTDdGSUFZVVZ2ZTFOanRLRisyZElsaThNMWl4WXVxSzZzbUMrVTN6Q3ZiTzcxcFNWemlvdG1Cd3NMOGdPenJwdkp6NWllbDV1VFBjMmY1ZU15cDJaTThhYW5lZHlwTHFmRGJyTmFVc3dtbzBHdjAycFlocVlJekNRZTBWTVpDYTBYMHlwam9zbGY1YmR5b21ucHlKS0FDSGF2ejIvamdvSG9kY2xWSXN1TDRBaUx6dHJJQUFnbFVWSERYNzFrcVVobld6L3o0ZVlsWGk0a010bjQ0NjlwYlJmejZpTSt2L1hYM2dsK0ZQZUk2WlVSbjg4clV0bjRzd2haK0ZQVHlyV0wxbHFrKzd3SnlpSVJhaVB5TXpqMmZna1NvY1FYeGJZK0lrNGRuMGFqWDZYa1lmd3dPWGFWbWt0SjNEcGdTcXVzRXNFNUFLYjNSWERKeTBaSzhIT2tUTXpqVVJFcmpwVFRJQ0FTNTJjaWNZakV0UVJWdmxLRXZPMVV5VmZZSU5TKzNoOXE3MFNMdHNjdTIzUWtZVkVmRitmaTlSRmJFSWVLMG1IeDFicklnTkZRNmE5Y1kwQUNLQVFZTUJpUllwUUplTVNXQVdLNmdTZ0R5aFM2Zm9BQ25Sbk5aNWZWRGNuUGVsSFlIY09CdndydGhoekhaYzdnMkxFOWsxbUEyOFpIanNRb29ZU29xUlMxQ1NXNFRsRm9GV0UzTnpEeldIelBvQlhhWXJ5cDNkL2UyaHdSNlZaY01BQjBkcWlqUVp3U3JtMUVFb3JDSjliQnllNnVVaHJaZVZ5b2c0dmpYRjRidzlaZkpUdjlDbnA3eDVxWUhDWWs1cTlDbnI0eWNwL3ZtRmUwWXg4U2JieG94bVhtTy83b3BlTWhUeWNuVCtQeCt6anhBS283aWV1VFd3d0NENm9lRC9sUkdoNFdXbDhodXlRdzRUWWxHaGUxSzg0UmRyZHlZbmZiK2tUc3RlNFpqMzlmM0NxYXZ2Q2hkOUEvdUZQWm1EUmxlMnk5clBMNlZ2bWFvZlZjZlBjYTVhcDdsS3RodkhLaDlWWHlJMi9FNkljVnVMc3hFdXJ3aHk0THhJdmpnTTYrZXEvUEo2Yng4c1o0UENTcjJOcU8yaWRVUnNabC9lV2M4UElFOWFrVWhRYWxnd2JGQnloUmFLMktKa25KQlkzeU5wa1RxNHBHZlFtLzQxSlJtMzBmTzh2UHhlVVR0ZG1pazdmNmppUHYySFV6dy9XUlVKVlh1YjFJVlVibURYbThRemdPMTA2UWlRZlh4QU5EM29TTndzdjk0YnBFRkhTTU43R0dSQUpURTU3SHBjbjF5cWtuUE40VE9LNzJWOGZpOFdvL1Z4MlB4VnNIeDdyYi9KelZIeDh3bWVKYlFqRk95WHlDOUNPN3ZXTDFucWhvalhXUTY5SEpjcnhWMTRkRlIxMlQ3SjVxcnFNMVVTeksvYjRTcjg4V0hWOVQrOWZZeVR6RGlNZTRsL01zYmoyTHVwbXdJbm01YXJtOERHSlY4SXJXRWpsTlVaTVZFY3lEMVVyTUtnM214M0k4M0N0bkNoM05EblV1VHhvSW96RVpNSExkcTB0UzhSQ2ZUODZoM1lNQ3RPRkU3SzZMSk9ZY3RIa1BnaERnMFhjeG1YTnNuT05hSVhPNnh6a1QyMk4rOUpVbnZQeHZ4UFRrZUk3Yi9IYXVOS0RZWHltMzdlS3hCcnpqK1JKUlY1SjB0Nk15UW51cDVJankwdkxJd0dQNUtoUGR2TEpSdGdsV3lialZ6NzNwRjYyOHlGWkdqbm5Mb3B6Vmh1V040SnFGdkp3MVdFWGY5TDlHNU5vSlRxdEl5a1NTS3RNQmE2bFMwbWwzQ1RJbmdvY0x4V1BKNkpwOHJlUUxvTDNqcSsrR2E2eCt2SjQzc2Q1bTk4czNmRU1wYWNsS25WMHQ1NUxYbDFoUkV4VlQ1SG9zcHB4Vkd0VFhXeG5oc1BwZ3R0WXBBeTdFZGNqT0ZybFlsVklHb3Q3SjVNR3hVN0VxdWV5aHl2SVNiektzc1UyWTlzcFkrL3NqdkJzai9PNDkwUTZNYmxHWWdUZmdpbENza2kwTmthU1ZTcnpKTEpKbExaS3ZjaVYvd29yamE2NjFicmpoaXRta2MrVVhnZy9aSlJPNTN4QVJxL254b3hMekJieDM4blRoVmV4RjQyeEFTM0MyUmJKUjhmMVQ0cjJDaHY0VkVpU3NJOXU5ZDhqdkU0cFVEUGpKcnJvQmdleGEzaGpCTjF6RllTc0F0NnNoY3BBaVZHV3NJam93RGZtUnd4eCtEQ2xVU3FiS1JIbkN5Uk1JRXp6eElLVlQxbnNQQ3dEZENwZFJDTXA4OVNBQmhhWWJweEZZUFVnbGFOYUVvQnhGa0FBVWNwZ0VSeGhmelNCTmw2QjFLelFGQmtDK3YyQmdCWjJnRjB5VW1mSU9FSmwwRUNsSENJQ2V3Q0VUTVJQdkFPNnFWOGlEcEh0QUwzZ1RLN3B4aFpEUWNOZUt5NkpYTkVZT21RQzNLUzBLcXBBQnpkMk5CcS9GWEVJWlRlSlUyWW40ZVNWeTZhOTU0MWE1WEl0UlhpNXBmNUxyWUNlR3lVQTIyVlU3K1U3Tm9qTmMzK1FWU2ZRNnBEMER3UFN3dHdJTldrZ1hqRnBDTTBDenJKNkJ3QWw3YWVBRWR1VW5DdktETnA4dDIyZnpQVVAvNStoTDFFdVhhdGhiTDhRZllwYmlDYzFqWjhndkdCTVl3UTB6QlkvSkxqYVpIQm9RbXpRdVBXM1I2OU00Uzc2RnNnUmE4RGhiMEJhRUFBK2VjcjRnbjJUbEZNMHVEaGJpRjZxR25qUW05cVVkRzJycjFuVTJKSHZxcDZ1cUZ6YTNMRmpVZkdsYUxERnFBZlJlemRnWjVsbjJJTGlnUXhCb2c4TkFtV0FLVURUamREb3B4dVEwVWFDMzZpa2o2M0k1S01mZUtPVUFJekhTUnFOWlo5NGIxVEVZWmNaOEkyVTB1cTNiMmNBUTZ0Y1NERUE1YjRPZ0o3QnFaVXR5aEpyaXBLVUZWclcwWkd2OEhOaXM0Q3QwMjNMOFdScVhNelZZT0lkNTlvbEwwa3ZTdmVRNXN2enRCeDRZZlAzOFI2OGNmU0s0bVBTUVNoSWhMeFJKcjkwb25Yenp5MlpBZXowTndPNW45Nkc5clJBUXBvQytMNG9GVk5jWFJkTnY1OHpFYkxicmQzQ1FqMHNETFlwU1E2aFR3bVRvQms2V1R0dUNoZmpobitOL21veFNvOUlxNlR1SEQ3ejl5ZEN2MlgyWFF0S0F0SVhwRyswYVBYbmlZOWxLS0kvK0E4clR3L1ZDRnNYMlJTbEtwN1hyU0Y5VVJ6Tk1RaEFZS2MwT1RwdXZwYlFvcm5EQ0VpZ1Z4N0t2MFBjSnBQOGdhY2hiVWtBNlNzOWorcVFEMG9WTHY4VFRFM0l1NElpRkxrRlBHTHlQbmFJQjN4dUhiSm9sU205VitnOFBwU1I3YzdJM0tmMnBROFprYjBqMmVxVS9KcVRvcHkwRTBESTdPSkpQS0pLd0NqOE9VQzVieHBkUTdzTG84NlNTY3JEN0xtNU0zaDMvZzJjZmVLRlk0SEtjeFU0cTEwRHl0TVJtdDlOTU91d2dKTU5odG5aenRud2JaY056UytXckR3Vkw4VXk4TS9wOE9ySE5udVBYYUltUDVPVDZVMTJ5RUpMcURoYlBJVDZ0UnZxSlNaZm1sRVRwdlBSOFNxYmVMUDJlbkNUWmZxdkdPNVZra3hOMDQrNW5lNjRmTGFCL2x2dnRYeDBZUGNQdUczMXg3YnB0RWJwV2pnT01YdmJuR0wxeTNrd1gzR0RmR3dXSHhyUTNxbUgwMnprWGNiblNMTnZwd0ZVUndDYkNUMmxKTXY3a1NLQXA2UTNwTGhJbklSSWtkMHJicExlZmYvWFZwLzdsK0kvU3lGNVNRUnJJMDlKTjBzdlNpMUliOC8yeHQ5ODUvK212M3pzdld5Z1Q4NzlQaWNickJEZHRKNndHSTBSRG94ZFpha2MrVFdoYXI3TXBLZ1FMQStQSlVYNDVJREFFMWtrL2xEcVpyVXpmeFUxTUg5SEtweG93eHBmaXFVWW9FREp5aldRT1RVcUFHTFVVVFZOWlVBaFVEbDFNWTlpWmFTd0pBVXl0QU1aWmFjTGtlclQxdUkzWnBaSmRlbER5a0diQ2UxaU4xa09tcy9zdXJFVkRwdGZkVUZsTHY0K3k3T2pqODRxUEZ3a0Z4VjVTN0NTNStHTW1PVWFTWnlneFVFVjZrcXNqSlJUSkpYTUlOUjMxb0EzSnNNOHdLdkpSZkVMMk9LQU9OUHBibzZWUkYwZlMzNG5lb1QwdjlVcjdoaDBNbzdlZGszWkw5NUhXMTgwYURaTkdHTkw0c2RuQU1MWlhaQ1hwUnhkRzI4cEhPMURaMEx4MVM1cm9sMGZuRmExWlZrY2ZsYjFmT25hR1BzbWtZZTNLaEwxQ3RVN3IwVko2VFpxR01xYTdDZTBtRnRyb1hoQUZvOVZJbVZsamhvTzQ2QXcyNDVFb205cHJzWmdkNWtlakRxdkZtQXE5aVp3Z1BrdjZ2YnJBVUduQ1ZaZkxHQjhSSEptV2dLWGNzc3l5eXJMWnN0UHlUY3UzTFBvV2IxU09KOFdaNkY2c2J6eklSUzYvZ0t4c2dSYWZyOGl2OFdOTnRtWm56L1puYVl1S2k0T2NqUzNTSmdPT1BpbTl3Nng3dmYrN3BKV2t2dlR5ZHlyK3RKSzhKUDNteUw2d0VOM1M5OEp6OTVNWnM3S2YzVFNjTlZzS0h3OTVuTnVLUTNmS3QxNklGVHNEYjIzRG1HOFI1Z0JMZ0NJbWxtVnA0aVpQUnQwcE92ZVRDL04xOUNOUlhXcUs4OUZvaXJWY1F6UWFZcnVYcytmYkticzl6VTE2aklGRWhScXlZWk5NREd3Q3ZNME9wWEs1bGk5Q2ZLbSt3amt1dkFRVXpZWmdvZDBsWDBTalpUSXV0VnVKL3JudWIzeHdYaG9tZWUrZStsejY3Y0hGbTAza21mZHEvN2lZT0w0WUl6T2tMLzQ0NzNjN1Zpb2FTNW5NemFoeE91U2l4ak42TlJvZHJYczRTazh4WjF1eSs2T1cxRFNMTzlPVjJSOTFXVm0zeDB0RGo5RTRuYzI2eDQ1bFJLNGw3Z2xYbENlN0NiL284eldDcGxZVDB6RG9qZnlDYkV6cnJGeWJrcytLOWFraUt5cnVEaGI1aUZ6cXg1T2R1UmxmTlQvL3hlMVBmdnVBeUd6ODVmSFRCTjc2UVF0RHlxUlh1NW83Yi92YTZyYmJiNUUra0g0K2x4aWFuOXRiOXdKeGZvaVJXZmpBdGt0bjYxcS8vblIvZC84amVLL05tS2EvWmM5Z2hsb2dUMGcxdTFJc0dsamRwQUU5cmFkTlBadzUzMHlaTDJjOTJyajh5amUyUTY2RTJiVnIxOWJXclZrVGxvNlRNdWFwVmFFRmpZMExGalpmWE1uSVZhQVhhMHViNHUwQ3dVdjBMb1BGeEZnWU5Kb1ZlZ2h4bUhROW5ENWZUK21UcjV5aENVTUZsWG91KzBzcHVLNmdISDFNbS9TejUrdlhLNUp1ZnBjMFVLWERPMW92NFNmTlV6K1FHaFBTYUI5angvdmdXMVhyMGxrTTVmajlhTFltVTkxbTBQUmNmc01sUXVkRVM2RnlyWnpKa2dyZHRLOTA4YnF0aXFEd1R3dW5VQjlrUHZMUGtwdUJINzFwUWprVm1Ma05lS3RDdUUyWXFaMXB5MkpTQzNvSllRcVlSNk1GcWIzcDZSbXBHWTlHVTYzcDZWa3pleE1TdGJOSlZvOHRNSFI4UEd3blphZHhjL3JPZENwZFFLTXM1aWVscGN3enk4a3RrRm9TSTF1SUJwa1k0ZTdTL0lJNXR0UkUyWjlGNWM2aWkyYmZRS0ZQM0s0Y3ZFY0s1WEpPcGR4VGFaY3poZkpuVlN4OVBOVFFPak5VbnpPdnBkd1gzdjd0ZjZyYVUxWDI5WXJNT1RNODA2NWY0QzlmdXloMzJUM2ZiWDdPU3lBd2ExWmdhdDVVajhWZFZOMWNmdU5keTdKZHpuTit2OUhsYzAzSnkzQ2JVbWRYcjV6ZmRIZGR0dXpiNldObnFCRjJEamlnVFNpeDBKazBaZFE0NE9Hb3cySFRVcmIrS0pWcU1HaFRORWF0VnZOd1ZHdkJVaC9BVERacmpEcExEOGVRR0xPRm9SaXMvQmhnR0dJdGdmRTBrYjhRUFlIeVpDN3ppVzh2K2F2TFp2TVhCWXV5YlVHWDMrYkVieTVxcFBwKzZlQXp6NUM1cDAvdkxDd3laWk1tOHM2ZmY5OG92ZlpucWUxQWhxempMVmh0NmpFU0UvSG5vazJzcVI4THFGVm5zU2dCYUxnY0VNcHJIOHFERSsrM1JBVkVxVDVaV25FUnZ1bnFwWit4dHh5WDlwTzVMNnhZUytidS96NzVIclgrMHNHVDI5WlNOUURLM3psZ254eDhaZVBzZ2xXV3NzL0JxMVArTis3M1BpLzdudHkvdTdsNjZzVU5vOSt3U0liVnVGYXZySWZFUHQxVGx5UUF5N21MR3k2OFlaRW1PT1BReU02UXY5TkIvbk5kb0lvU1JQb3orREg4THdMRlEvUGZXc05JVU1PZWxyK3ljRHc5MFYrenhnMVBhNTlOOERRMnFMbUdMOHJmSUdpNkc4R2dNMXoraytYL1Z1NVNLSjBZbjRPRlRBTXNIQjhydWxmTDllMnFQYitSSzhSbG9BUFFTL2RDQlowQjA1RjNDNmlnZ2dvcXFLQ0NDaXFvb0lJS0txaWdnZ29xcUtDQ0NpcW9vSUlLS3FpZ2dnb3FxS0NDQ2lxb29JSUtLcWlnZ2dvcS9HUGcreC9qeW12d01Id0tuNUxzU2JpWkhDVkhLWmhBSHJHVit1RzFTTTlKNGdPSW8vUW9NMnNDMXlUeE1YWUtleFA3SFJWVlZGRkZGVlZVVVVVVlZWUlJSUlZWVkZGRkZWVlVVVVVWVlZSUlJSVlZWRkZGRlZWVVVVVVZWVlJSUlJWVlZGSEZ2eDlCK1oyWnpvY2hLUDllVjVCL1M2OFZBbkF2RHQ0MktMK3o4c2NRWUladzBUTG1MTFlDODdHd1FtOHVmZTlVcW52S3I5N0I1czY3VXIxMzNwWDIxdHM0dm5VYk5wdTJZTE54TXpZYmJrcjFicmhwNTlmU3Q5N2lkRTFadHg2YnRaM1lyT2x3ZXRkMDlONmNudGFWZWtkbG11OTJmQUx6VGN4cENMQlcxT0FVOHlXS1NyUWNNM0xJYkNzVkJwbVBEaHFkcFlmSGpqR2ZIUEptbFpiUE56UG5rUDlONWkvWTVpZmJUeFFWUHp4a3RKYVdIeVVWT0xPUStYQ0F6QmZNMVBrdktmN3pjeXgvN2t1R0h4dzdkdWhMdjc5VS9vM29HVjg2VWtzL1BFUHpaMDVUdkhEYTRTcWQvUk95L044cHZoNmZxcU5rTXpUZ1E1SE5aT1BCc2N3TlB5WTNBU0dieUFaVWxDY2J5WWFETkI4K2dsTkNkZ3BWK3huK1c0K3gvUDdIR1A3eHh5aCszMk1hL3JGK0E5LzZCTU0vMFVmeEQvVXgvSU43V1g1dkg4MzM5YnN5cmF1NTFkU0NKeW4rMFg1TDVpUDlOUDl3UDRYS25SSlMrclB6U20vc0o2LzFrNzk4b1ZYMC9jTHRMVlg2RkV2cFlkSkpPb1FaTlA5eG5PRS9pdFA4YnV5L0h0Znc4UjQ5Zi9kT3duZnZZUGlkK0d6Zm9lVjM5TkRLbVhQYlBHbWxiVDJFMzRYUGZmamMyOFB5dlQwYS9wNGVMZStkNC9JVXUxeEZMdnRzbHlYb01oVzY5QVV1VGI2TERyaGdsaXR6dm9rc2d3QStGS2toWVhCQkxWbU0xdDFDYW9RQUdmblVNdnhKeXRtaGxBM0R4RGc4ZHpnOC9JUGhpOE9zY2FScFpQZkl4UkhtTEQyV21aT2JrcGRyeWRGNCtNTmtMVmtuT0N3eitKU1p2Q1hMbnpMTmI1bWFtY0psV282UVZ0Skd0Z2lyVEJhcnphUTNHRTBhcmM1RU02d0pDR1hTMEo1TUMxMU9MNlBmbzVsdndYdEFlVW1HMmFOTk43dXNick9kY1pvRFhqS3piRVpaWGxsTzJiU3lyREt1YkdxWnQ4eFQ1aXF6bDFuSzlHV2FNcm9NeW1xRERVUzBoeUhjVUNFNjhDcmg1UlZpa0E4UDBseTlXTWlIUlgxdFUyU0FrRzlFa1NwU3V3WUpOSWpNcmtFS08zdGxZMU5ra0tUSjdGN3ZZZlE0aU9GWTcvMVJuczhRMitWL2NhVTdJeW9XeW9NSE1xSVFGZ3ZyUksrL2dyOGF1cFNtNnlycVFGNU9TSndSYWhWbmhtSlZ5b0t0NHRtUU9CTHFiQlZIL0ZYaWNLZ1RKekZ4MkovZzhwTU9JUHhYQVhSdHZTeHZrdkN1UkROT3dHbVhvazNYVm14RmoxaU9OcmxXNmE0QnZXeWYydnFLc0tpcng2ZTJTVXozNCtSVm5CVGp4T1N2d0hyeFg3Rk1NODhLWlc1a2MzUnlaV0Z0Q21WdVpHOWlhZ281TXlBd0lHOWlhZ284UEFvdlRHVnVaM1JvTVNBek1Ea3hOZ292Um1sc2RHVnlMMFpzWVhSbFJHVmpiMlJsQ2k5TVpXNW5kR2dnTnpBMU5BbytQZ3B6ZEhKbFlXMEtlSnp0ZlhsOFZGV1c4TGx2cTMxUEpaVlVTS3BTU1lBVVVKREtWbEFrajJ3c1lVbENnaWtpa29RQUlhd0s3VTVBUUlXQ3Roc2F0SWtPVGJmZGpqTitEaStvVEtDbkZSUjM2VUZiSGJ0MVdseEFVSU0wbzZLU2V2V2QrNnJDcG43eitmODdKM2M3ZHp2M2JQYytrNThBQVFBZHJBY1dyQXR1WHVOWjhPTENzVWg1Q0lBNXZtalY0dVVQMXMzNUFJQmRCcUF2WHJ6c3RrVjl1aHdyZ09uM0FQYWRYUXZiTzFudGg4VUFuaktjVTlLRmhCU3pialMyVjJFN3QydjVtbHNmK2NyYWdPMmRBQ05QTEZ1NW9QMmp1ei9aQWpCdERiYkhMbSsvZFpYck92MStnTlc0SGs2NmFlR3ExbnNQL0EzYlJ3RzRPUDg1cEFMd3ZlQWF5cmtnMk9FM29BQUhsQUlRUHgzZmNqa0hrRWZHdjFMR2czd29NWkk1RmgvZ2Z3c21aa3I4TXpZQ0poejNHZll1a21kaWJRQytCL0svRGRXMHljUWxtdnVUNU8yd1RTblhZZG9HajhCTjhLTkEwb2dXZmpwOEIyZmhYNUwxczNBYTNvQy9LL1VCckw4RzBVdmpqc0V6MlBkN09BaDltRDhITDJDTndtclkvYjl0UVhLSUdZc3Z5Tk1rL0wzT1B5QUNYSUJUOERCY2o2c3Q1Ti9sMzRWSFlSa2NnQVd3RC83MWlyRmZLUG1YbU82R1crQmV1UCtxbFhxUzViWmsrYnlTUDQzcFBjWUUwMkVOMnQ2bmw0Y0xQanpQWmxpcm5HRUpuTVQ5OXNBT1JaODJKaGRzTE1TL2dNZmhIdmpGcFpWL09yeUY2Vm40V3Y0UCtUeDBJbTZITzVtdjBUN1FzTG43NC8rRFBMWEF6MkVUTE5Zc2tjZWhsTjZEZjhBZ1BJbWFmaEUrZ3FmUUFyZkFDdmdLUGtQNVB3RzljRE4zREd6Q1htcE5zVGljZ3hPd0U5Yy9nU2Y3STd4T1ZwTnA4RHU0azU4cE5uVzJ6bzAwTmM2YU9XTjYzYlNwVXliWFZsVk9FaXZLSjRZbmpBK1ZsWllVRndVTHg0ME5qQms5eWw4d2NzVHcvTHhjWDQ3WGs1MDFMTk9ka2U1S1MzV21PT3cycThWc01ocjBPcTFHNERtV0lUQ0t1Q1JYVlV0TnQ1UmUxU1laZmRVK3EwY3l6anczSXlDQjNlMzEyVHpCUUdSMGNwVEUreVZ3MUVrcDlTMTlJSlpGSk1GLzdaQ1pFcHRuUGUvRnlUUGNuaHFKeThNZjM3VDJUbWxFWTR2WFozM2JmYWsvZ25Pa2pLb1dyOWN0TVhuNE14Vzc4R2RhdTZkVHN0WWozZXRPVUtaS1VOOUNVMy84d3pJa1FwazNnbmxqaTVRMTFJeEVmb2hKdE9iNDRXdlluRW1pMWo1amVsVzFCQ2w5WVB4UUFpY2RkcTRNSkFoTEkveklpQlZyeW1vUWtFaktlWWs0Sk9LY2dTeGZ2UVdkZHFMc0IyUlEwOW50cStsY2doTHRiTHNzMDNNSmlYbzlVVSswc2NVV3hLckNkSjMwVWtOTG4wRmY1YXRhcUVjQ0tBVG8weHVRWXFBRVhHSlZIekdXRTZYQ0dHdkc5ekdnTmFINDdKVGRHcHE2SlhGckcxWjgxU2czN0hGYzd1bVBIOTUyWlJmZ3RLR2FJMUZMTUNFSlZaSW13WVJuaVNTMlM3RFYwemZxY0hSYnZ4VTYydnpHVGw5bisvVXRFdHVPQS9xQXphdnBhcEl5NitybklnbTN3dFRXNWFIcXJsWXlxanhQVFpjbmltMDZ0ZzF6WHpWVitsWDB6cTZGYmRSTVNKdXZHdnQwVlMzM2VnKzdKVHVXTlpMTkw1bHdtT24yajkxc3RNYTF4RU9iMGVpOUhta3ZzbnRGcjVmbWFBUXVaRDFhNDhQZGNMR2E3a3Fxa3NBbHRTbldPTFZUVVk2NHRkMGpyZS9vVHRoZSs3WWgrL2RHclpMeGF5OXFCL1dETTVXSlNWRjJ0blZUbHJ2YjZURnJ1ajNSclF1Vm8yNVRqb2IyNnFucHJxYUpUa1RyaDJhY1BiZWxwc3RYYzNsRFBEaFcyTHhyNTNxOVVycWZUb3hHYXlpTDdaM0lmWUpsN0xqTVAvVUp0NThnUDFXUzJLUVUwS1RvQUhjVTI2c2pTVkp5d0Z3NmpmYTBWVWNpM29UZWNhaWt5YnVYSCtQelJPbUttandweFcvMUhzVyt3Nk5IMVRXMjFGUzdsZE5MVEZYTHhBR1hld0RyZGZXWHlNU0ZZNktCQVhkQ1JuV3pmWFVOQ1N2b0dzcmFtaElPekZ6U1BBNU5qbGRXUGVaeUg4TjZyYSsyTFJxdDlYbHFvMjNSOXY3NCtnNmZ4K3FMOWhtTjBWVTFiUjdGOHduU0QyMTFTN1hiSXBLMXJZdU1SeVZUZTZ0dHJKTWNEYTFVUGJXZXJ2WkVzS2p3ZWN2Y1hsdGthRXo5ajNVbi9Rd3RIdTJlK2xuVStqbnlac1NJNVBiVTB2RFNqMUhCTFZuTHFKc2lKODB0NkFjTEZKdFZNdlNQMmJpNG0zb0tHOG1yV1RJN0tTQzB4cVRCMExqWGtLVGlJbDR2OWFHdC9TSjBZRU5hMzlDU2FIdWd3NzBmeElBZmRkZEdldzRQOVRpYmFjLzZvWjVMMDl0OHFDdFgzZXoveGFhdnRPZW96V2YzaEFLSy9KVncyeWtkYnNJemZsTW1hY3VTNm5aVXRiQnVKbGxqM0N5dDZmMFl2c0pTbWwrWlNHV0NVVEpxOVhtTyt5U3JYK0tyV2c2N3d4R1AxWWJoamVDWUtYN3FOUmhGai90ZUpqUjJRb3BWSW1HSnBGSTZZQ3hWUWpxYlZvYWRsNHpIVXhOdFMxclhsY2RLWGdDZFhUOThOaHhqOWVIeDNJbnhOcnVQbnZBMUphUWxJM1ZlTGZVbHR6Y3hZbHBFTXRONExKay9WekxrMTEzVjRzSG9nOTdhb0ZROE5aNHVxbXpKMDFhdGhJR0krMHB5Zi94RVd6VU5lOGd5SGVKT21qWG1DZEZlYld2Ly94YStIaTM4cm0yUkxyUnVTU3pBRTNpS2NWdkZXNXBha2xJcWN5ZTlpTzQxbFI3bDZ2NUxVaHdhODMzcDFqVmQxYnBpWFhvaGVMRzc3Skx2TjdWSXRmNmhwUkx0eVg3M2xjMHAxM1JQSGVvR2xJVEhOcFVLRmUrZk12ZFZOTlN2bUNCaEhGbnJ2cDNlSnd4VTl2bkk1b1kra1d5ZVBiZmxJSDRuZURZM3RleG5DRlBWVmhucHk4Vytsb01lQUZHaE1wUktpYlRob1Eyb0k3amFma2FyakhjZkZBSFdLNzJjUWxEYUMvb0pLRFR0RUkzQWduNG1RYk1tTnNwWE5oS0J3UjR1MFNNT2plYVFwazNRMWlzMEJmcUFubDNVODZKVzFJbEd4c1M0K3dnbDdVZktJZnhFMGhGNHdraE14TjJIc3hvVmNqOVozNmNUM1lrUjYzR0VtT0J3Yy9QbHJadm50anhoQkp5bTVMaFJKUVVVOVhvVWRqMzZFZTdSU2w5VmtpZmpaWGZVU3FPMEZQSFRTSGFTaHI4bDFhUHBlNVhCbHlkd20vaWI4U3ROQXhtaVFVTllEbGllMTNFUU9HWVBCWTVoVVhGczNOaWd6V3ZMODlxOGo3Qi9IenpBSEloTjQyLytMcnFUbTRsQ21zbzh4eGJpSzlvTTh3L2l0OVZ4c2RCb204THlXcjNKREp4V3A5UE9qbGgwMlRyR3l1cU1MTU9BMFFqbVZrRXdhQTNhU2kybk43SEdLWWJBUUZyb3FOOW1KeUZYSUZsQXhkSDVOOHpEQnFTRlhOWTNqNDRiNnlkOG1vWmxoNWZtbGZKc2tNMWpDK1d6aCsvYnVmTVhSK1NCRUNHZUF4NUN1RkRnWkFmaDVNR09rNEc5aThrSStaM0YrRUVDaStPZmtpM3dEUmpBTHVwQWtGckJvZHZIQmdhZ3dqOXViRnBPZm5GUlNiQVFuOEhDaFhCVFUzaGljM1Bxck5LeSt2cXkwbGs0Ty81dTNNNHV3Qk95WUhxU1lNNEVrTHZBdUxHRStBaTdJRmIzRjJZLzMvdnRyY0ptbE9mTStHa3VsOThQZXZ5ZXpCTWQyaTAyMHhhUkZReTlFVUVEbHQ0SXBPT2U0S3J3NCtNall5QXdNRzRzbjhQWXJCRDBZTVppNWkyMFdabVJKeTRTNFFMNXEvelZYK1dMQkFaZFpBV1pTKzRrOThTODhrNzVMdDRXT3hJN3hmaVlFanhiSTZweE1YOElqSkF2MmdVU0ZSbFdNQXFhM1JGQk1Hb1lGMVJVQktsTUlaVFlFZG0yK1d5Q29Da3VaMHVaeGFjcnRzOGJ2MnpKMGhCLzZMdGFicy9vQ3RjTGpvSWljU1NWV2dkK241L0NzNHlHTWpFVHZGdk1vN2FJcVNTVm1FZGxaanA2STVrYWRoUVp0VHRDY0ErL0RZSjRLTHFOblc1MEZIZUtvYzY4M3VLaWNxNjBuQzB1R3NQNGNwUmRnNFZaakRQRnpHak1yTlBwWlU4TjNwa3Z6dWxZTkc3TTlKSXNYOFdjWU11QnBsRnoyN3JEN1h0V1RmVFBXbFV6ZnZYMUllYmVsZFczTEpsM1hjUEk0WFgxa2FKUWMyaFlZK1A3M25GZWEzREJ6cmJydHQ2NkRJTjdjN09mcDN6ZkVUL04vaDM1OXNJTllqQTlJMjJMeWFZem1YVDRpVGRzaXloQXVsNm4xL1ZHaU1lV29uZFpyQnVtNi9XZUZBL2JHL0drcDZDR1VqUkpEZEhEb0RuYThVUkQ4a01CMnROQ2dVREFPbkFVdjZoS2kxT0RoZmgxNWZVVkJ6MVk1R2lLRlR1eThzNVV0Q2JPbDNQSE51a1hqOGxiVjNhVE9sbis1Ym9kTHo1elNqN3g0SlB5M3dmZUt2N2J5ZzBydnp4MDZzM0ZmMjQ4Zkw5OHNvR3ovSEhia1FHMG9TTDB5ZFdLUnptZ1ZIUTdvbHFXOEZIUkluQmFoM1ozUkVlc1pvZERNQXNDVlM0NnFUMFVERklGSUlQQmpGamhDOVNxaUMzbzlLR2l2VlRORHB2QWFOZzliNzMxUWV5V2xvT1A3U2pVTFg5ckh0ODcySEZFZnA1TWVHN0JKLzg0djNLd2c1bDdWSDd2SnBUZmcvRlQ3S2U0ZnpxTUY3T3NVVENZblNnM081V1ozZTR5dWxCVXJuU2paWGZFS0Z3bHFwQmkxTEdqZ2FNRGwyV1Q3OHZST0x5bzU0U0hnUy9ud1o5djM3SC9xWDhaM3hka25vM0ZYVFZsSDM4cmYvVHRHOTczNSsrNjgvYk5SdWI4Qy9KdTd0TlgzNUxqS0l0RjhVKzRrYWhMSDVUQ0pESEhBZEhjTVZ2Y1cwUjk5c2plaUp0M1dMS3plWXNsdFRkaTBmREIzZ2lmZmhWSGl1NFV1MCtZSTBHejgrV01ZWXFMN0NXVW56Um5QdktIcGhpa3pTeEdvMWlwR2Mweml3a1dsalBjeU1rOWp5OWM5dFRHS2ZNZk9iR2g0ZTRSd1RWMVRmY3Rua0NFTWYvVWZjTURTOGQvT214Q0pCeHVMYzhlRnA0bmhsb21aSk5qeS9iZk5ibnBrUXNQdjBpS2ppOUxkYnlla1Z1OThValA1TWFKcS85d2UvbWlxU1A4dFhNRHdhVXRvWUpwQzFIV3RhaHJUdEYxbm1nVERJSUIvUmlNSnVQdWlDbWgzNlJpOFNob2QzZ0NRYzlvZkNVWlRLbTMyTXR4Yy9kdWFNdjRIMWZrMWwxTnNRajdOSi8vQi9sUDhpSDVxY2Q3U1JDeFpNOExHSzlhNDJlNHRLUU02NkJaSEZVVzFUcnQwVXFNdjVXUUVSM0Q1MFpGY1BMQmlSTlJnaE1uWnB1b2JMUFRUWk43STZacm5JRVdvYVNXQnhTV3JBUFBXMUhkanFKeXBqUWZBMms1ay9CdlFaUEZPcFBpTGsyS3N6Z3BYc2MxN2Riczhoc3E1cTJZdFBxaDYrZjkwMnB4Uld2NWZORlQyeU4xTDltM2J2S0h1Wlh6UXFYWFYrWFRzbVJlVmY0NFQ4blVnb0twcFo3c2ttbiswZE9LaDVGZmxxL3BtT2txZW5qQnJIczZTc3M2N3BtNTRPRWkxNHlPTlJVM1BMU3l2SHpsUXpkTjdLak94U2QzdUxSOVNzSHd5UjNNek5FelFoNXZhTWFvMFRQTFBON3hNK2hOT0FjdGpVcHBKRXlFS1dKZVFZR3pLS3IzUUZSMHVrTzlFV2VxZ1UvTmM3djV2THhBYnlSUHcxdC8wTmhzd1dSZ1A0clNvZXBLWVFTQmltQjRjUmFySE5sblpoTVdtQkRVOXl3dWJkN0Q3L2FNbkYwM01jVlpQblZXWHZQV2ptTE9QbUg2dk9LNUQ5NDBhZG9HYVhINzR4dG5uTStyYkMwWmU5MmsvTHpLZVdXRnpSVzVyUHUvNUZkZW1xKzNPblN2bTl4T1UrV0dJK3M4SVg5R3hacEhGcTE2YWwzTjFOOE1aa3k1dVduTThDbUx5cXU3SnVmbFZjeWhaMWJ1UmM2QzkySWFlRVNiM1NpMTJxM0orNUYxN3JNRUJrS2g1Qm12dmlmWkg3Z3pKMTU3ZDdKcGwyOVJCbXdBZkIxYU9sNkRNRWNjeTFyTUpzN0k2WFZhaGlNR2d4RWp0NDNuaUlYZEViRllCSjFaYitKNHcxTGpIVWJHS0xEWUFSaDFLLzU3M2xHTXY3WlFnRW81RUxBRnFWdllLQWtUdlcxWVJPSjFzUG5EZllLRzVldmtpM2ZGWHJ0VEhtVFNpYkgrUloyZTB4bWVKOHZsWDJIdzI4V0VNOHREM3RoUjlNSTVlR3Z2UnQwN29WTDBnWk1ZOEdaeU1JN3RFY1lCQm1Ka0RRYVQxclE5b3VYQVlFaXpydVdwN1FlQ3lXc3ZnTytVeTdWeFkvTUVud2Z3TnZjV1luang1UUFHdldCaEtiZjdkLytRWDVJM2szOG1WY2UzYk45M1JuNmZtTjk3ZFZlNGlVU0pTRnJJb3hNK255Ty8vZTJBL0VrYlNxc1BwZFdWbEZhZW1BSzY3Ukg4aHRKdWorQURiYTBKTDdRZVVKZ1l1S1FlZktMUk40U1h0UVVMb2RqcTdTTjcySFI1aW56ZjNxY3ZrclRZQmI0M1ZpTS9LUy9uamwvOGxxUU1rZ3Q0YnR5RmZSdDNNVUNkT0VLcnhWQUVZQkwwUFNJUmNFT0xrQzB3ZGxZUUNNUHdLQXVXNkhGLysxVkdUOTlvaXNVWFVvbFFqVkExMkREZ0p4TDc5dUM3TEI4N1F3WmtCMVBLOTc0aWQ3OHN0MEJ5NzMvSHZYVlFJZzZqNjFzWWxEdkRhRFYyTFVGWnM1UVpBeVAwYUFMSnhSTWJZNVZ1aXI2VjJBTHZPUGJmWTZmSldkbCtsaFc0NDNMRHk3RkhjVjBDemZIVHZCVzFtZzV6eGFBcmJYdkU1ZExDa0Y0dGhtd0RvNytzMmJRMHA5VmdnQjZuMDQwS3RocUZHWHpBcjBpNE1HREQ0bHBsQiswMEhsSnRlNi9SdGgyMWpmZXVsN2Vla0Fma1orV2J5VDR5L1l1SC8vRHhTZm5kd1hkMkxwUGZZTndkdDVOdHBKYk1JSS9WZnJWQ2Z1UGNCZmxraURTL2xKUUxkeGI1dDhJb01VMXZ0aEtlcHlKaHpSWUx3UzhmdTU1WEpJS1N4bXVmR21GRjB2WUpHajFLSTJnTGxwUVNMK0hPeXEvSXBreUJPM3VXTTZhU0Q4aXcyREhtbDNtbVdEbGF3ZzJwYnViR1dQMlFIbDdGL1hod2kyYkNVUTB6K0FXZzRYcUlZbUgwRGxKMGlnYkd2anA0Nml3eml1KzlHRWpNNUcvRW1RNFlLVHJOZHNKek9qMnJJeGJvc2RtY0JsN2JvOFA0UVZVM0VBcEM0RW8yVTUxVWJTUTFMWmhmYkF2eU44cURzZGtaTmtGN2lqaVord3N3S3B6a3NrYjR4end3MklSYlhSUmRvYzBzL2NXUm90RURxRkVhcjZoWDJORXJISUp4ZTBUZ2RHdWR6blRMV3ZZYXIrQVR5bEZ5a3NNbzJyRVhXeGtXVURwYjhVbGRTOGFRRytWNzVQOTgvc0s1Wi85ODloTVgyVUVxOGJIOWtMd0tyOUxmeWwzY3QvTGZ6bjBodjBkU3Z5TUUzN3FLYjNKTDhkejBqVDlhZEJsaFI4U0lueloyMXJBandyS2F0VlpyaXBIME1BbXpIYmhrdGY3RTA5dGJ5TkZuRUhWVCtuUWtld2JJRXhlSVZmNzQvRE85dS9mS2YyTzBzVy80M2xPdnZ5NS96Znc1OXVWOWQ4VWdHUTk0M0RNVGh0TVlsWmFsMVdidGlHaTErbUdHWVRzaUJuVE5ORjN1V2h2SlpHd2NqTXpTOWVoeGUrdnphWVZVSGhBSVhuV0RLNUZ5RE90VEhvaERyM0ZuRnB1R3IwYmxXczczOGJ6ODZjbnNDUk9uakc0YklPOHMvTmVleWFObi8yenE4UEZGd2V6WXIxOG9uVmVkditGMnNyNjRibXhxN0JEZk83WjllL3YwZFF0cUhWeHFjZG5rQUZzcmo4a1Jydzh0WG9OV2tvdlNtcXBFc2hJeGswVXJFZERYQlJaNEJyOERXYjRTelp2cFlWbWRsbm9aVlo1ZkNlNUQzeFNLbjlOM3JKZWJLbmVlbFJkeWVSakJ4bkxIWDhHMTk2STkwTi9nbU1BcjJoa2Q5V3NqeTdQUVl6QllORDNja0Mwb0ZreXNHQi9SaUJNRkQ3R2pzZmZPa2lra2ZKYXBqdjJlcVdHWER4NlY1NUlIMkRycUZXYVV0MU9KakptaTBhQmhXSll4ME4vaXNBSDByMEFoTmVkUWlINEM0blZEN1JoZGpuZkdZdkxYc2tBNDBtSFRjWnBVMHMzM2ZyY0lMZmh3VVUyb2tpdUhSRXhpZjhhNThLWXBFNGNwZDR0eTAreUtNS2xLS05vVjBhS1RHNndiOFk1SmhEd2w2bHh6ditSQWNSRmVLa3JFRVp3cCtOSXVaZGZjOGVqSDhta3llbkRiMHFXMy9lby8rbmF0WFJtWVRJWjlGQ1BCY2UvVXYvamIzL1JIRWg3RWplYy94K2d5RERuSVl0eThlMWVFVHlWT3M5UGczQlV4V0MxZ004RW1RckpkRzdVSitRV0R5V2VvSzFHZzlmaUtmY2dFZlVZakV5Z1FWbm5uSnpncDRjYWY1bGFkK2ROSEYxLy96eHU0MHlmdlc3RmgxeTl1dTJYbnY3MUFIQU15S1h5RXVmM2k2WHVXLy9yWi8vUFFVL3NTSExIZm9VVHNHS2ZiUlRNSWVBdmdsY09sa3djaTZmM3hkOFI4bTMzRGRFdDZkanBqWTlQVGRSWWRkMzlFbDJwSnZUOWlzV28wc05IaGNLZVRqY2FrdXhVR3ZuYy9YYTVTWTBxbDBuSmVrcUhkT1p4K0ErQnI0YnRZTGZmUE8zNi9aZHVwRCtVNGNiL3h4cWtUWk0yaXpxMVdjdVMrM280L3R1QWwrZ1VaTFo4L1Y3ZDI2NDZia2ZNTnFORGQvUHRvSXhZb1FtMEtDeUpJc2JCZ3RwaDBIYXhvTXJJZDhiSEdUWGhkV3hYajlwTU1sM1VBYmVlRjVBMTJ4U3ZLZ1pHYkdFTU5EYUVKalkxbHAwOXovelV0RkpvK1BWUXk0K0pJamxyT0F4Z0d6bkIyMU54SU1WWGoxRm9BOUN1WmRRekRtSlZyUWRpa1hBczBZQitiVjFnWXFLQ3VvMmlGWGdwTzVRc25qVGxUTUd0eEZGZlArZmwxRlY3VzV6MjBWMDdsNEMvTGJuUFFQZnp4TTh3VGZBQlNNTVo0VTFMc2pKMGFwbDZ2TVFzR2pVYllGZEZZNkFQQkpCaTBsazNvWHNIQ1lHSGdrcG5TcStlU3FTYmVRVFliZmhvWGx5b2ZvNHFaTWs5VXI1VGZmdXl4MDE5OVZUbGpndCtRUTdLWXFnTURsZkxyQjJSb25aa0R5dDhOOEh2NjNmY1d6WnR2Q1g4RjdzU3Z1WitKUFVML0ZnRGVXZGt3OCtMU3dmc3RzbjRCMEw4d0lNbmZ2V0twL1YxTUJyQjhlWEhwZHg5WTVFczlReERoQytoLzcwTG92VXhrMTlQWSt1UEEzZ1pUcjJ5VHM3Q1luUlYvbDdzUlpySmwwSWhsQjZZN3VJZWdDTXNIdVZ0Z0VUY05hckhlaXZVNWRQeVByYzNQcDY5aWpJL2Z3QnorVDlESDVXTGlvWS9mQ2MxWGp1TStnajcyRFBScEZrS2Y0TU5raEdidThRVGYzTVZrMlEyNS9GN1l5K2ZRMlBYVGdIME8xM3NEazNqMXZrd2F0ZkgvTnpCZlU4dkU4bVB3Z3dvcXFLQ0NDaXFvb0lJS0txaWdnZ29xcUtDQ0NpcW9vSUlLS3FpZ2dnb3FxS0NDQ2lxb29JSUtLcWlnZ2dvcXFLRENUd2Z2aitMcUpPNkFSK0VEWWliZDVCVkd6OVF6aDVuejdOMXNuQ3UrQ2pjaXZzYkYrWW44Q3Y3bEJBcEV5RUs4VHVnVjNoVGUxSXhEbksvWnB1bi9VZnhHTzBtN0o0bHZYWXM2RGVJMEZWVlVVVVVWVlZSUlJSVlZWRkZGRlZWVVVVVVZWVlJSUlJWVlZGRkZGVlZVVVVVVlZWUlJSUlZWVkZGRkZWVlVVY1dmaHZUL2tKbnlBRXdIVnZuYlNRYXNFSUNGQU94a2ZURWxpQTN2bjBoTnkzenpMY3p1dURQVmZjZWQ2YSsvZ2ZXYmI4RnMrU3JNbHEzRWJPbUtWUGZTRmV0dXlsanpzeFJuNXVKdXpCWXR3V3hoVjRwN1lkZmROMmFrcjA2OXZTcmRleHVtZzZTZXpOcHZ6ZTZjbEVvYVlBMG1CcXJKTEdqQzFJbnBLQ1lPS2tnbDhtWWhrMkF2SmlaKzRvbC9qUFNIRGhLUlROelArc1YrTXZGQXZqOTBxbEhyNzQ4ZkZ2MU5ibmZvMVpkNXYvalhrUVdoMlkyTXYvRkR4dStSREliUWVhdzg5enpqRjQ4WVRLRWpoM2xsdk92RGRIZm83Yi93L3MrZVp2eFA5ekwrM1poNmQ5SE9FNkx4YkVwcTZGZmJCZjhPVEpUZy90SnNEZTM1TmVOL0FOTmplOGoyWGJuWnY5Nmw5ZCsvUy9BblRtUExYalBKaG53VFBNVTBQTVUwUE5jMGxPa2FjZ01RTW9WTUJnZGtFN0ovTFlNVHlrazRjWVR3L3V6Y1VEOEo3Ri9MK2Z2Sm1QMmJXTXJjRTBkejhrS1VTZHRoa3lsMDdEVWMrbkptWnVpVmw1UmVNZjBjbnVQVEhzWS90c05vRktwMFQ1SytmWXgvSHhMbzNML2dGRnIrYWZnSVpRM1B0cXlzMEpZbzU0OXUwdnUzNGdaM3JTUCt0VDJjdndmckE1c1M1eHZmNFVvUGRXd2kvczJZN3NWMHp5Yk9memVXRzdFOHMrbmJUY3lTVFdUNEp1SXVkYnBLbk01aXA3M0lhUWs2WVl3emUxSUJtUXNCVEF4cEpuUEFDZlhrT3BUQ0t0S001eDVQSnFBR3kwZ0l6S1NFbElJWkRLUU1KbUNxdy9RcUpnNHBKVWdwZ1ZaTUxGakplSnduN0dmajJaTzhSRThNT0Y5TGREaGZJQnFjdjVSb2NYVUQ1aE13MVdINkk2YlBNRjNFSkdDUEhsZlN3MVpNTEJIRVRGd29mN2g1eEhCTGdkODh5bS9KOFpsemZaYXNiTE1uMndMUGtIRzQ0VGp3WUVMekoyUEZUV1JWd1lrQ0JzTEVtaXZtcnNyZG04dFpyRGFqVG04d0NocXRrZVY0SXhER21DOWtaZ3VzSzl2Q1ZyRHZzK3h2NEgxZ0xHblphWUUwMXBLU25SSklZY2ZwZ3lZM0dXWnlhVEpNVG11YXljNmxtQUp1TWlwY0VCNFJ6Zy9uaG5QQ25uQlcyQjEyaFoxaGU5Z1Mxb1dGTUJ1R2NIMndpVWoyT3FocnFwUWNCTXZabFZMUVg5ZlBlaHFsUW4rZHBLdHZiZWtqNUw0SVVpVm1jejhhbk1SdDdtZXdzRmZOYlczcEorbTArMjczUVpRalNIVnRkLzg4NHZjUGt6cnBQNXUyZmxoRUtxU1ZYdzZMUUoxVTJDQzVmWlgrYTJGMUlrY1lJbHl1OTQzSXI1RUthdHFsVVRWdDFVclhtbjRpMUN6cEovcWFKZTJZKzZyN2lUYlJic09hcnpxNVFEOFpUNmxsTlV1UVhFWkhLZTBTcFYzaVM2eVYzTnBQVnEvNW1mLzdzUHFhSms2QTc1T3ZHVUo3SlpkVWdZSzh0cmRQUnlWYTMxaFpKMmtiTWRXM1NoaytiTHlFalJKc0dIMlY4SDhCNmx4bUZncGxibVJ6ZEhKbFlXMEtaVzVrYjJKcUNuaHlaV1lLTUNBNU5Bb3dNREF3TURBd01EQXdJRFkxTlRNMUlHWWdDakF3TURBd01EQXdNVFVnTURBd01EQWdiaUFLTURBd01EQXdNREU0TUNBd01EQXdNQ0J1SUFvd01EQXdNREF3TWpJNElEQXdNREF3SUc0Z0NqQXdNREF3TURBek1EUWdNREF3TURBZ2JpQUtNREF3TURBd01Ea3lPQ0F3TURBd01DQnVJQW93TURBd01ERTRPVGN4SURBd01EQXdJRzRnQ2pBd01EQXdNVGt3TVRRZ01EQXdNREFnYmlBS01EQXdNREF4T1RJeU55QXdNREF3TUNCdUlBb3dNREF3TURFNU9UUTJJREF3TURBd0lHNGdDakF3TURBd01qQTJORElnTURBd01EQWdiaUFLTURBd01EQXlNRGM0TlNBd01EQXdNQ0J1SUFvd01EQXdNREl3T0RrNElEQXdNREF3SUc0Z0NqQXdNREF3TWpFeU56Z2dNREF3TURBZ2JpQUtNREF3TURBeU1UTTVNU0F3TURBd01DQnVJQW93TURBd01ESXhPRFF6SURBd01EQXdJRzRnQ2pBd01EQXdNakU1TlRZZ01EQXdNREFnYmlBS01EQXdNREF5TWpNek5pQXdNREF3TUNCdUlBb3dNREF3TURJeU5EUTVJREF3TURBd0lHNGdDakF3TURBd01qSTROemtnTURBd01EQWdiaUFLTURBd01EQXlNams1TWlBd01EQXdNQ0J1SUFvd01EQXdNREl6TXpjeUlEQXdNREF3SUc0Z0NqQXdNREF3TWpNME9EVWdNREF3TURBZ2JpQUtNREF3TURBeU16a3hOU0F3TURBd01DQnVJQW93TURBd01ESTBNREk0SURBd01EQXdJRzRnQ2pBd01EQXdNalEwTURnZ01EQXdNREFnYmlBS01EQXdNREF5TkRVeU1TQXdNREF3TUNCdUlBb3dNREF3TURJME9UY3pJREF3TURBd0lHNGdDakF3TURBd01qVXhPRFFnTURBd01EQWdiaUFLTURBd01EQXlOVFl3TXlBd01EQXdNQ0J1SUFvd01EQXdNREkxT1RJNUlEQXdNREF3SUc0Z0NqQXdNREF3TWpZd056RWdNREF3TURBZ2JpQUtNREF3TURBeU5qSTVNeUF3TURBd01DQnVJQW93TURBd01ESTJOemswSURBd01EQXdJRzRnQ2pBd01EQXdNamN5TXpZZ01EQXdNREFnYmlBS01EQXdNREF5TnpNNE9TQXdNREF3TUNCdUlBb3dNREF3TURJM05UQXlJREF3TURBd0lHNGdDakF3TURBd01qYzRPRE1nTURBd01EQWdiaUFLTURBd01EQXlOems1TmlBd01EQXdNQ0J1SUFvd01EQXdNREk0TkRJMklEQXdNREF3SUc0Z0NqQXdNREF3TWpnMU16a2dNREF3TURBZ2JpQUtNREF3TURBeU9Ea3lNQ0F3TURBd01DQnVJQW93TURBd01ESTVNRE16SURBd01EQXdJRzRnQ2pBd01EQXdNamswTmpNZ01EQXdNREFnYmlBS01EQXdNREF5T1RVM05pQXdNREF3TUNCdUlBb3dNREF3TURNd01UTTRJREF3TURBd0lHNGdDakF3TURBd016QXlOVEVnTURBd01EQWdiaUFLTURBd01EQXpNRGd4TXlBd01EQXdNQ0J1SUFvd01EQXdNRE13T1RJMklEQXdNREF3SUc0Z0NqQXdNREF3TXpFME9EZ2dNREF3TURBZ2JpQUtNREF3TURBek1UWXdNU0F3TURBd01DQnVJQW93TURBd01ETXlNVFl6SURBd01EQXdJRzRnQ2pBd01EQXdNekl5TnpZZ01EQXdNREFnYmlBS01EQXdNREF6TWpnek9DQXdNREF3TUNCdUlBb3dNREF3TURNeU9UVXhJREF3TURBd0lHNGdDakF3TURBd016TTFNVE1nTURBd01EQWdiaUFLTURBd01EQXpNell5TmlBd01EQXdNQ0J1SUFvd01EQXdNRE0wTURBd0lEQXdNREF3SUc0Z0NqQXdNREF3TXpReE1UTWdNREF3TURBZ2JpQUtNREF3TURBek9EWTRNQ0F3TURBd01DQnVJQW93TURBd01ETTVNVEV3SURBd01EQXdJRzRnQ2pBd01EQXdOVGsyTVRBZ01EQXdNREFnYmlBS01EQXdNREExT1RjeU15QXdNREF3TUNCdUlBb3dNREF3TURZd01qZzFJREF3TURBd0lHNGdDakF3TURBd05qQXpPVGdnTURBd01EQWdiaUFLTURBd01EQTJNRGsyTUNBd01EQXdNQ0J1SUFvd01EQXdNRFl4TURjeklEQXdNREF3SUc0Z0NqQXdNREF3TmpFMk16VWdNREF3TURBZ2JpQUtNREF3TURBMk1UYzBPQ0F3TURBd01DQnVJQW93TURBd01EWXlNekV3SURBd01EQXdJRzRnQ2pBd01EQXdOakkwTWpNZ01EQXdNREFnYmlBS01EQXdNREEyTWpjNU55QXdNREF3TUNCdUlBb3dNREF3TURZeU9URXdJREF3TURBd0lHNGdDakF3TURBd05qYzBOemNnTURBd01EQWdiaUFLTURBd01EQTJOemc0TXlBd01EQXdNQ0J1SUFvd01EQXdNRFk1T0RZeUlEQXdNREF3SUc0Z0NqQXdNREF3TmprNU56VWdNREF3TURBZ2JpQUtNREF3TURBM01EVXpOeUF3TURBd01DQnVJQW93TURBd01EY3dOalV3SURBd01EQXdJRzRnQ2pBd01EQXdOekV5TVRJZ01EQXdNREFnYmlBS01EQXdNREEzTVRNeU5TQXdNREF3TUNCdUlBb3dNREF3TURjeE9EZzNJREF3TURBd0lHNGdDakF3TURBd056SXdNREFnTURBd01EQWdiaUFLTURBd01EQTNNak0zTkNBd01EQXdNQ0J1SUFvd01EQXdNRGN5TkRnM0lEQXdNREF3SUc0Z0NqQXdNREF3Tnpjd05UUWdNREF3TURBZ2JpQUtNREF3TURBM056TTFNU0F3TURBd01DQnVJQW93TURBd01EZ3pNVGt6SURBd01EQXdJRzRnQ2pBd01EQXdPRE16TURZZ01EQXdNREFnYmlBS01EQXdNREE0TXpZNE1DQXdNREF3TUNCdUlBb3dNREF3TURnek56a3pJREF3TURBd0lHNGdDakF3TURBd09EZ3pOakFnTURBd01EQWdiaUFLTURBd01ERXdNak01TnlBd01EQXdNQ0J1SUFvd01EQXdNVEEzT1Rrd0lEQXdNREF3SUc0Z0NuUnlZV2xzWlhJS1BEd0tMMGxFV3p4RE9Ua3pNelV3UWtSR1FVSkRRelEyT0RKRk1VWkdSREJHTmpZMk5VUkdNVDQ4UXprNU16TTFNRUpFUmtGQ1EwTTBOamd5UlRGR1JrUXdSalkyTmpWRVJqRStYUW92U1c1bWJ5QXhJREFnVWdvdlVtOXZkQ0F5SURBZ1Vnb3ZVMmw2WlNBNU5BbytQZ3B6ZEdGeWRIaHlaV1lLTVRFMU1UTXlDaVVsUlU5R0NnPT18RW5jb2RlZCBEYXRhfHx8fHxGfHx8fHx8IA0K</inboundTemplate>
        <outboundTemplate encoding="base64">PGRpY29tPgogICAgPHRhZzAwMDIwMDAwIGxlbj0iNCIgdGFnPSIwMDAyMDAwMCIgdnI9IlVMIj4xNzY8L3RhZzAwMDIwMDAwPgogICAgPHRhZzAwMDIwMDAxIGxlbj0iMiIgdGFnPSIwMDAyMDAwMSIgdnI9Ik9CIj4wMFwwMTwvdGFnMDAwMjAwMDE+CiAgICA8dGFnMDAwMjAwMDIgbGVuPSIzMCIgdGFnPSIwMDAyMDAwMiIgdnI9IlVJIj4xLjIuODQwLjEwMDA4LjUuMS40LjEuMS4xMDQuMTwvdGFnMDAwMjAwMDI+CiAgICA8dGFnMDAwMjAwMDMgbGVuPSI0NCIgdGFnPSIwMDAyMDAwMyIgdnI9IlVJIj4yLjI1LjMyMzMxNzIyODg3NDcyNDc0NzIwNTQ1OTI5NTcyNDE5ODY0NDU0MzwvdGFnMDAwMjAwMDM+CiAgICA8dGFnMDAwMjAwMTAgbGVuPSIyMCIgdGFnPSIwMDAyMDAxMCIgdnI9IlVJIj4xLjIuODQwLjEwMDA4LjEuMi4xPC90YWcwMDAyMDAxMD4KICAgIDx0YWcwMDAyMDAxMiBsZW49IjE2IiB0YWc9IjAwMDIwMDEyIiB2cj0iVUkiPjEuMi40MC4wLjEzLjEuMTwvdGFnMDAwMjAwMTI+CiAgICA8dGFnMDAwMjAwMTMgbGVuPSIxMiIgdGFnPSIwMDAyMDAxMyIgdnI9IlNIIj5kY200Y2hlLTIuMDwvdGFnMDAwMjAwMTM+CiAgICA8dGFnMDAwODAwMDUgbGVuPSIxMCIgdGFnPSIwMDA4MDAwNSIgdnI9IkNTIj5JU09fSVIgMTAwPC90YWcwMDA4MDAwNT4KICAgIDx0YWcwMDA4MDAxMiBsZW49IjgiIHRhZz0iMDAwODAwMTIiIHZyPSJEQSI+MjAxNjA1MTk8L3RhZzAwMDgwMDEyPgogICAgPHRhZzAwMDgwMDEzIGxlbj0iMTAiIHRhZz0iMDAwODAwMTMiIHZyPSJUTSI+MTUzNzA0LjM0ODwvdGFnMDAwODAwMTM+CiAgICA8dGFnMDAwODAwMTYgbGVuPSIzMCIgdGFnPSIwMDA4MDAxNiIgdnI9IlVJIj4xLjIuODQwLjEwMDA4LjUuMS40LjEuMS4xMDQuMTwvdGFnMDAwODAwMTY+CiAgICA8dGFnMDAwODAwMTggbGVuPSI0NCIgdGFnPSIwMDA4MDAxOCIgdnI9IlVJIj4yLjI1LjMyMzMxNzIyODg3NDcyNDc0NzIwNTQ1OTI5NTcyNDE5ODY0NDU0MzwvdGFnMDAwODAwMTg+CiAgICA8dGFnMDAwODAwMjAgbGVuPSIwIiB0YWc9IjAwMDgwMDIwIiB2cj0iREEiLz4KICAgIDx0YWcwMDA4MDAzMCBsZW49IjAiIHRhZz0iMDAwODAwMzAiIHZyPSJUTSIvPgogICAgPHRhZzAwMDgwMDUwIGxlbj0iMCIgdGFnPSIwMDA4MDA1MCIgdnI9IlNIIi8+CiAgICA8dGFnMDAwODAwNjAgbGVuPSIyIiB0YWc9IjAwMDgwMDYwIiB2cj0iQ1MiPk9UPC90YWcwMDA4MDA2MD4KICAgIDx0YWcwMDA4MDA2NCBsZW49IjIiIHRhZz0iMDAwODAwNjQiIHZyPSJDUyI+U0Q8L3RhZzAwMDgwMDY0PgogICAgPHRhZzAwMDgwMDcwIGxlbj0iMCIgdGFnPSIwMDA4MDA3MCIgdnI9IkxPIi8+CiAgICA8dGFnMDAwODAwOTAgbGVuPSIwIiB0YWc9IjAwMDgwMDkwIiB2cj0iUE4iLz4KICAgIDx0YWcwMDEwMDAxMCBsZW49IjAiIHRhZz0iMDAxMDAwMTAiIHZyPSJQTiIvPgogICAgPHRhZzAwMTAwMDIwIGxlbj0iMCIgdGFnPSIwMDEwMDAyMCIgdnI9IkxPIi8+CiAgICA8dGFnMDAxMDAwMzAgbGVuPSIwIiB0YWc9IjAwMTAwMDMwIiB2cj0iREEiLz4KICAgIDx0YWcwMDEwMDA0MCBsZW49IjAiIHRhZz0iMDAxMDAwNDAiIHZyPSJDUyIvPgogICAgPHRhZzAwMjAwMDBEIGxlbj0iNDQiIHRhZz0iMDAyMDAwMEQiIHZyPSJVSSI+Mi4yNS4xNDc4MjA3NDE4NjU5Nzk5NzA3NzA1MzAzMTM1MjAzODcxNTcwMDU8L3RhZzAwMjAwMDBEPgogICAgPHRhZzAwMjAwMDBFIGxlbj0iNDQiIHRhZz0iMDAyMDAwMEUiIHZyPSJVSSI+Mi4yNS41NjAyMTg0NTI2ODA5OTI3NTgzNDMxNjUzNzgyNTMyNjUzMzMzNjwvdGFnMDAyMDAwMEU+CiAgICA8dGFnMDAyMDAwMTAgbGVuPSIwIiB0YWc9IjAwMjAwMDEwIiB2cj0iU0giLz4KICAgIDx0YWcwMDIwMDAxMSBsZW49IjIiIHRhZz0iMDAyMDAwMTEiIHZyPSJJUyI+MTwvdGFnMDAyMDAwMTE+CiAgICA8dGFnMDAyMDAwMTMgbGVuPSIyIiB0YWc9IjAwMjAwMDEzIiB2cj0iSVMiPjE8L3RhZzAwMjAwMDEzPgogICAgPHRhZzAwMjgwMzAxIGxlbj0iNCIgdGFnPSIwMDI4MDMwMSIgdnI9IkNTIj5ZRVM8L3RhZzAwMjgwMzAxPgogICAgPHRhZzAwNDBBMDQzIGxlbj0iMCIgdGFnPSIwMDQwQTA0MyIgdnI9IlNRIi8+CiAgICA8dGFnMDA0MjAwMTAgbGVuPSIwIiB0YWc9IjAwNDIwMDEwIiB2cj0iU1QiLz4KICAgIDx0YWcwMDQyMDAxMSBsZW49IjEwIiB0YWc9IjAwNDIwMDExIiB2cj0iT0IiPjwvdGFnMDA0MjAwMTE+CiAgICA8dGFnMDA0MjAwMTIgbGVuPSIxNiIgdGFnPSIwMDQyMDAxMiIgdnI9IkxPIj5hcHBsaWNhdGlvbi9wZGY8L3RhZzAwNDIwMDEyPgo8L2RpY29tPg==</outboundTemplate>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>DICOM</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="4.0.0">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="4.0.0">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>false</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="4.0.0">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="4.0.0">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="4.0.0">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="4.0.0">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.dicom.DICOMDataTypeProperties" version="4.0.0"/>
      </transformer>
      <responseTransformer version="4.0.0">
        <elements/>
        <inboundDataType>DICOM</inboundDataType>
        <outboundDataType>DICOM</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.dicom.DICOMDataTypeProperties" version="4.0.0"/>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.dicom.DICOMDataTypeProperties" version="4.0.0"/>
      </responseTransformer>
      <filter version="4.0.0">
        <elements/>
      </filter>
      <transportName>File Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>false</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="4.0.0">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>DEVELOPMENT</messageStorageMode>
    <encryptData>false</encryptData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>true</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>PATIENTID</name>
        <type>STRING</type>
        <mappingName>patient_id</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>ACCESSION</name>
        <type>STRING</type>
        <mappingName>filler_order_number</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>ORDERTYPE</name>
        <type>STRING</type>
        <mappingName>order_type</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>MSGCTRLID</name>
        <type>STRING</type>
        <mappingName>message_control_id</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="4.0.0">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>false</enabled>
      <lastModified>
        <time>1697777101666</time>
        <timezone>America/Chicago</timezone>
      </lastModified>
      <pruningSettings>
        <pruneMetaDataDays>30</pruneMetaDataDays>
        <archiveEnabled>false</archiveEnabled>
        <pruneErroredMessages>true</pruneErroredMessages>
      </pruningSettings>
    </metadata>
    <codeTemplateLibraries>
      <codeTemplateLibrary version="4.0.0">
        <id>10e63131-3e24-4419-a268-ed823aba5790</id>
        <name>Molecular Designs Code Templates</name>
        <revision>39</revision>
        <lastModified>
          <time>1695240089339</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description>This library contains code templates created by Datica Mirth OCI channels and Molecular Designs</description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>5cc5d7df-228a-4d24-b774-681c717e1876</string>
          <string>2e0d9b6c-294f-4506-8632-dc4622b4f651</string>
          <string>57fa694a-2758-4e52-b725-967a74786d1f</string>
          <string>5c763fad-3eae-4e87-b944-0dbfe25814e0</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>8cbc4731-752e-4e2e-a61d-018ed3e0cef0</string>
          <string>ed58a744-1f83-44aa-ad23-feef56e2f5e6</string>
          <string>4a98f7b0-d1f3-478d-ad65-550f8287fe24</string>
        </enabledChannelIds>
        <disabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </disabledChannelIds>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>b1789859-2c5e-4720-a617-17bb12289034</id>
            <name> Perform sFTP Put Action (ip, port, user, pass, filename, msg)</name>
            <revision>1</revision>
            <lastModified>
              <time>1687559459553</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc: Perform sFTP Put Javascript to connect over SFTP and Put a file on the remote disk
	Name:  Perform sFTP Put Action (ip, port, user, pass, filename, msg)
	@param {String} ip - provide the IP address
		  {String} port - provide the port number
		  {String} user - provide the username
		  {String} pass - provide the password
		  {String} filename - provide the filename
		  {String} msg - XML presentation of the message to be sent as a file
	@return {String} return response (Success or Failure)
*/
function sftpPut(ip, port, user, pass, filename, msg){
	importPackage(com.jcraft.jsch);
	importPackage(java.io);
	importPackage(java.lang);
	importPackage(java.nio.charset);
	
	function toByteArray(str){
		var bytes = [];
		for (var i = 0; i &lt; str.length; ++i) {
    		bytes.push(str.charCodeAt(i));
		}
		return bytes;
	}
	
	// testing vars
	var debug= 0;
	
	//create object.
	var jsch = new JSch();
	jsch.setConfig(&apos;StrictHostKeyChecking&apos;,&apos;no&apos;);
	var session = jsch.getSession(user,ip,port);
	session.setPassword(pass);
	session.setTimeout(10000);
	session.connect();
	var channel = session.openChannel(&apos;sftp&apos;);
	var ioexception = new Packages.java.io.IOException;
	channel.connect();
	if(debug&gt;0) {logger.info(&apos;Connected to SFTP: &apos;);}
	if(debug&gt;0) {logger.info(&apos;Home Directory: &apos; + channel.getHome());}
	channel.cd(&apos;/&apos;); //Folder on the SFTP server where file will be found

	var filename = filename;
	var filebody = msg;
	channel.put(filebody);

	channel.disconnect();
	session.disconnect();	
	return;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>f435d6e5-73bb-4515-8a35-5c6409576e03</id>
            <name>contains_number</name>
            <revision>16</revision>
            <lastModified>
              <time>1670430449839</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc: This script is used to evaluate a string if contains a number

	scriptName: contains_number
	@param {String} arg1 - arg1 description
	@return {boolean} return true or false depending if isNaN() - if isNan() -&gt; return true otherwise -&gt; return false
	e.g., write_msg_to_disk($(&apos;rawhl7&apos;),api_error_directory,$(&apos;ark_uuid&apos;));
	History:
*/
function contains_number(text) {

	var scriptName= &apos;contains_number&apos;;
	var debug= 0;

	if(debug&gt;0) { logger.error(&apos;DEBUG::&apos;+scriptName+&apos; verify text: &apos;+text); }

	if((typeof(text) !== &apos;undefined&apos;) &amp;&amp; (text.toString().length&gt;0))  {

		if((text.toString()== &apos;DETECTED&apos;)||(text.toString()== &apos;TRUE&apos;)) {
			return false;
		} else if(text.toString()== &apos;NOT DETECTED&apos;) {
			return false;
		} else if(text.toString()== &apos;INVALID&apos;) {
			return false;
		} else {
			var arrText= text.toString().split(&apos;&apos;);
			if(debug&gt;0) { logger.error(&apos;DEBUG::&apos;+scriptName+&apos; arrText: &apos;+JSON.stringify(arrText)); }
			// curObservationValue.toString() !== &apos;NaN&apos;)
			for each(strElement in arrText) {
				// if(debug&gt;0) { logger.error(&apos;DEBUG::&apos;+scriptName+&apos; element: &apos;+element+&apos; isNaN(): &apos;+element.toString().isNaN()); }
				if(debug&gt;0) { 
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof element: &apos;+typeof(strElement));
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; toString: &apos;+strElement.toString());
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; element toString() !== isNaN(): &apos;+(strElement.toString()!== &apos;NaN&apos;)); 
				}
				if(strElement.toString() !== &apos;NaN&apos;) {
					return true;
				} // end if
			} // end for
		} // end if 
		return false;
	} // end if
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>96be75c3-dddb-4d84-83e1-7484a54f6d7f</id>
            <name>Convert HL7 Date Format to ISO</name>
            <revision>1</revision>
            <lastModified>
              <time>1665512795175</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Converts standard HL7 v2.x date format to human-readable ISO date format
*/

/*
	Author: Datica Inc.
	toISODate: Returns an ISO-formatted date string with specified timezone offset

	Arguments
	---------
		Required
		--------
			hl7DateString:		An HL7-formatted date string (ex: &quot;yyyyMMddHHmmss&quot;

		Optional
		--------
			timezome:			A timezone identifier string corresponding to one of the java.util.TimeZone values (ex: &quot;US/Central&quot;)
*/

function toISODate( hl7DateString, timezone ) {
	var isoDate;
	var dateString;
	var hl7Formatter;
	var isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;);

	if (timezone) {
		isoFormatter.setTimeZone(Packages.java.util.TimeZone.getTimeZone(timezone));
	}
	
	if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString.substring(0,13)) &amp;&amp; hl7DateString.length &gt; 14 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssZ&quot;);
	}
	else if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString) &amp;&amp; hl7DateString &gt; 0 &amp;&amp; hl7DateString.length == 14 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
	} 
	else if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString) &amp;&amp; hl7DateString &gt; 0 &amp;&amp; hl7DateString.length == 12 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmm&quot;);
	} 
	else if ( hl7DateString != null &amp;&amp; !isNaN(hl7DateString) &amp;&amp; hl7DateString &gt; 0 &amp;&amp; hl7DateString.length == 8 ) {
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMdd&quot;);
	} 
	else dateString = hl7DateString;
	
	try {
		if (hl7Formatter) {
			isoDate = hl7Formatter.parse(hl7DateString);
			isoDate = isoFormatter.format(isoDate);
			dateString = new String(isoDate);
		}
	} catch (err) {
		dateString = hl7DateString;
	} finally {
		return dateString;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>f4574fa7-05b8-420b-b6a2-a1cb6e3fe1f5</id>
            <name>Convert HL7 Ethnic Code to Ethnicity Coded Element (CWS) data type</name>
            <revision>1</revision>
            <lastModified>
              <time>1684362812785</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Convert HL7 Ethnic Code to Ethnicity Coded ELement (CWS) data type

	@scriptName: hl7_modify_ethnic_code_pid22_to_ethnic_coded_element
	@descName:   Convert HL7 Ethnic Code to Ethnicity Coded ELement Data Type
	@authorName: Jeffrey Ritz
	Parameters:
	@param {XML} pid22 - contains the XML HL7 representation of the PID-22 element
	@return {XML} newEthnicity - returns the modified XML HL7 representation of the PID-22 element
*/
function hl7_modify_ethnic_code_pid22_to_ethnic_coded_element(pid22) {

	var scriptName= &apos;hl7_modify_ethnic_code_pid22_to_ethnic_coded_element&apos;
	var debug= 0;

	// 2023-03-07 JER - Added code per Streamline Issues List - 20220306 item# 3
	// https://phinvads.cdc.gov/vads/ViewValueSet.action?id=2088950C-6EF8-E111-B875-001A4BE7FA90
	var newEthnicity= new XML(&apos;&lt;PID.22&gt;&lt;/PID.22&gt;&apos;);

	if(typeof(pid22)!== &apos;undefined&apos;) {
	
		for each(element in pid22) {

			if(element[&apos;PID.22.1&apos;].toString().length&gt;0) {
				var pid221= element[&apos;PID.22.1&apos;].toString();
				switch (pid221) {
					case &apos;H&apos;: 
						var strPid22= pid221+&apos;^Hispanic or Latino^HL70189&apos;;
						break;
					case &apos;N&apos;: 
						var strPid22= pid221+&apos;^Not Hispanic or Latino^HL70189&apos;;
						break;
					case &apos;U&apos;:
						var strPid22= pid221+&apos;^Unknown^HL70189&apos;;
						break;
					default: 
						var strPid22= &apos;U^Unknown^HL70189&apos;;
				} // end switch
			} else {
				var strPid22= &apos;&apos;;
			} // end if 
			newEthnicity.appendChild(strPid22);
		} // end for each
		
	} // end if 

	return newEthnicity;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>f3cf4590-3887-434e-bd9f-e94556abaaee</id>
            <name>Convert HL7 Ethnic Code to Ethnicity Coded Element Data Type</name>
            <revision>2</revision>
            <lastModified>
              <time>1682526446368</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Convert HL7 Ethnic Code to Ethnicity Coded Element (CWS) data type

	@scriptName: hl7_modify_ethnic_code_pid22_to_ethnic_coded_element
	@descName:   Convert HL7 Ethnic Code to Ethnicity Coded Element Data Type
	@authorName: Jeffrey Ritz
	Parameters:
	@param {XML} pid22 - contains the XML HL7 representation of the PID-22 element
	@return {XML} newEthnicity - returns the modified XML HL7 representation of the PID-22 element
*/
function hl7_modify_ethnic_code_pid22_to_ethnic_coded_element(pid22) {

	var scriptName= &apos;hl7_modify_ethnic_code_pid22_to_ethnic_coded_element&apos;
	var debug= 0;

	// 2023-03-07 JER - Added code per Streamline Issues List - 20220306 item# 3
	// https://phinvads.cdc.gov/vads/ViewValueSet.action?id=2088950C-6EF8-E111-B875-001A4BE7FA90
	var newEthnicity= new XML(&apos;&lt;PID.22&gt;&lt;/PID.22&gt;&apos;);

	if(typeof(pid22)!== &apos;undefined&apos;) {
	
		for each(element in pid22) {

			if(element[&apos;PID.22.1&apos;].toString().length&gt;0) {
				var pid221= element[&apos;PID.22.1&apos;].toString();
				switch (pid221) {
					case &apos;H&apos;: 
						var strPid22= pid221+&apos;^Hispanic or Latino^HL70189&apos;;
						break;
					case &apos;N&apos;: 
						var strPid22= pid221+&apos;^Not Hispanic or Latino^HL70189&apos;;
						break;
					case &apos;U&apos;:
						var strPid22= pid221+&apos;^Unknown^HL70189&apos;;
						break;
					default: 
						var strPid22= &apos;U^Unknown^HL70189&apos;;
				} // end switch
			} else {
				var strPid22= &apos;&apos;;
			} // end if 
			newEthnicity.appendChild(strPid22);
		} // end for each
		
	} // end if 

	return newEthnicity;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>d7a12547-25f0-4062-b86f-5fdf6eaa4dd1</id>
            <name>Convert ISO Date Format to HL7</name>
            <revision>1</revision>
            <lastModified>
              <time>1665512795228</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Converts ISO date format to HL7 v2 format
*/

/*
	Author: Datica Inc.
	toHL7Date: Returns an HL7-formatted date string with specified timezone offset

	Arguments
	---------
		Required
		--------
			isoDateString:		An ISO-formatted date string (ex: &quot;yyyy-MM-ddTHH:mm:ssZ&quot;

		Optional
		--------
			timezome:			A timezone identifier string corresponding to one of the java.util.TimeZone values (ex: &quot;US/Central&quot;)
*/

function toHL7Date( isoDateString, timezone ) 
{
	var hl7Date;
	var dateString;
	var isoFormatter;
	var hl7Formatter;

	// ISO Date Format: yyyy-MM-dd&apos;T&apos;HH:mm:ss&apos;Z&apos;
	if ( isoDateString != null &amp;&amp; isoDateString.length &lt;= 25 &amp;&amp; isoDateString.length &gt;= 22) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssZ&quot;);
		if (timezone) {
			hl7Formatter.setTimeZone(Packages.java.util.TimeZone.getTimeZone(timezone));
		}
	}
	// ISO Date Format: yyyy-MM-dd HH:mm:ss
	else if ( isoDateString != null &amp;&amp; isoDateString.length == 19 ) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
	}
	// ISO Date Format: yyyy-MM-dd HH:mm
	else if ( isoDateString != null &amp;&amp; isoDateString.length == 16 ) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddHHmm&quot;);	
	} 
	// ISO Date Format: yyyy-MM-dd
	else if ( isoDateString != null &amp;&amp; isoDateString.length == 10 ) {
		isoFormatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
		hl7Formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMdd&quot;);	
	}
	// None of the above, return original date string.
	else dateString = isoDateString;

	try {
		if (isoFormatter) {
			hl7Date = isoFormatter.parse(isoDateString);
			hl7Date = hl7Formatter.format(hl7Date);
			dateString = new String(hl7Date);
		}
	} catch (err) {
		dateString = isoDateString;
	} finally {
		return dateString;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>060b8f26-61b5-4185-bc65-cff05085bfe2</id>
            <name>Filter Non Detected Observation Results</name>
            <revision>3</revision>
            <lastModified>
              <time>1678138972714</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Evaluate the OBX-5.1 values for Detected vs Non-Detected result values to determine if needed to filter the observation results
		
	fileName:		filter_non_detected_observations_results.js
	name:		Filter Non Detected Observation Results
	authored:		Jeffrey Ritz
	created:		2023-02-22
	desc:		Evaluate the OBX-5.1 values for Detected vs Non-Detected result values
	specimenDetected= true  -&gt; desired specimens detected used to permit the entire message to be sent
	specimenDetected= false -&gt; desired specimens detected used to filter the entire message
	history:
	2024-02-24 JER - Clone of the remove_observations_from_observation_result_codes.js function
*/
function filter_non_detected_observations_results(msg) {
	
	var scriptName= &apos;filter_non_detected_observations_results&apos;;
	var debug= 1;
	var detected= false;
	var i= 1;	// used for the OBX children objects
	var j= 1;	// used for all msg children objects
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	// for each segment - child per msg.children()
	for each(child in msg.children()) {
	
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(child)+&apos; localName: &apos;+child.localName()+&apos; child: &apos;+child);
	
		if(child.localName()== &apos;OBX&apos;) {
		
			// process each OBX
			var curObservationValue=child[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString().toUpperCase();
				
			// evaluate if element value is numerical exponential
			if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
				if(debug&gt;0) { logger.error(&apos;DEBUG::&apos;+scriptName+&apos; determined value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)); }
			}
				
			// evaluate if element value is number 
			if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
				if(debug&gt;0) { logger.error(&apos;DEBUG::&apos;+scriptName+&apos; determined value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;)); }
			}
	
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] curObservationValue: &apos;+curObservationValue);
			
			// 2022-10-17 JER - Added evaluate if NaN - only 
			if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
				detected= true;
			} // end if 
				
			i++;
		}  // end if 
		j++;
	} // end for
	
	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	
	if(detected== true) {
		return true;
	} else {
		return false;
	}
} 
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>4cb42e06-7c9a-4fd2-bcb5-b9f4053a9c19</id>
            <name>Get Segments After a Particular Segment</name>
            <revision>3</revision>
            <lastModified>
              <time>1684206232165</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Returns an array of segments with the specified name that come after a given segment in the message.
*/
/*
	Author: Nick Rupley
	Date Modified: 2/13/2013
	getSegmentsAfter: Returns an array of segments with the specified name that come after a given segment in the message.

	Arguments
	---------
		Required
		--------
			root:			The root HL7Message node of the message, or the parent of the segment node.
			startSeg:		The segment AFTER which to start collecting segments.
			segName:		The name (String or RegExp) of the segments you want to collect.

		Optional
		--------
			consecutiveInd:	If true, indicates that the segments are expected to come directly after startSeg. 
							If false, segments are collected until another segment with the same name as startSeg is encountered.
							Defaults to false.
			stopSegNames:	An array of segment names that, when encountered, stop the collection of segments.
*/

function getSegmentsAfter(root, startSeg, segName, consecutiveInd, stopSegNames) {
	function test(str) {
		return segName instanceof RegExp ? segName.test(str) : segName === str;
	}

	// The index to start collection is the next one up from the starting segment
	var index = startSeg.childIndex()+1;
	// The return array
	var out = [];
	// Boolean placeholder to stop iteration
	var done = false;
	// Object that will contain all of the stopSegNames strings, bound to a truthy value (1)
	var stopNames = {};
	// Indicates whether we have any stop segments
	var stopNamesInd = false;
	// If stopSegNames is defined
	if (stopSegNames !== undefined &amp;&amp; stopSegNames !== null) {
		// Set our indicator to true
		stopNamesInd = true;
		// Add each string in the array to our object
		for each (name in stopSegNames)
			stopNames[name] = 1;
	}

	// Iterate through each child in the root, starting at the segment after startSeg, and
	// ending at the final segment, or when the done flag is set to true.
	while (index &lt; root.children().length() &amp;&amp; !done) {
		// If a stop segment is encountered, stop iteration
		if (stopNamesInd &amp;&amp; root.children()[index].name().toString() in stopNames)
			done = true;
		// If a segment with the same name as startSeg is encountered, stop iteration
		else if (root.children()[index].name().toString() == startSeg.name().toString() &amp;&amp; !consecutiveInd)
			done = true;
		// If we&apos;re only collecting consecutive segments and we encounter a segment with a name other than segName, stop iteration
		else if (!test(root.children()[index].name().toString()) &amp;&amp; consecutiveInd)
			done = true;
		// If all previous tests passed, and the current segment has a name of segName, then add it to our array
		else if (test(root.children()[index].name().toString()))
			out.push(root.children()[index]);
		// Increment our index counter
		index++;
	}

	// Return the output array
	return out;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>45a0316e-0d5a-42b6-b7cc-d786a97cceba</id>
            <name>Is Message Observation Value Detected</name>
            <revision>9</revision>
            <lastModified>
              <time>1695836657922</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc: This script is used to evaluate the provided messageObservation Value (OBX-5) to determine if the value should 
	be designated as DETECTED or NON-DETECTED

	@param {String} messageObservationValue - this only argument is the OBX-5 value provided to be evaluated by this script
	@return {String} return - to return the detected boolean value of detected= true or non-detected= false (true|false) 
	history
	2023-09-27 JER - Modified to include Conversion from Exponential value (1.00E10 or 9.44E1) to Number with Precision
*/
function isMessageObservationValueDetected(messageObservationValue) {

	var scriptName= &apos;isMessageObservationValueDetected&apos;;
	var debug= 0;
	var blnDetected= false;
	
	if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; evaluate messageObservationValue: &apos;+messageObservationValue);

	if((messageObservationValue.indexOf(&apos;.&apos;)&gt;-1) &amp;&amp; (messageObservationValue.indexOf(&apos;E&apos;)&gt;-1)) {
		messageObservationValue= Number(messageObservationValue).toPrecision();
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue CONTAINS an exponential value add precision: &apos;+messageObservationValue.toString()+&apos; type: &apos;+typeof(messageObservationValue));
	} // end if 

	// 2023-09-27 JER - Conversion from Exponential value (1.00E10 or 9.44E1) to Number with Precision 
	if(isNaN(messageObservationValue) == false) {
		blnDetected= true;
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue isNAN: &apos;+isNaN(messageObservationValue)+&apos; value: &apos;+messageObservationValue.toString().toUpperCase()+&apos; blnDetected: &apos;+blnDetected);
	// evaluate if element value is numerical exponential
	} else if(messageObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
		// IS AN EXPONENTIAL NUMERIC EXPRESSION (1.00E10, ETC.)
		blnDetected= true;
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue CONTAINS an exponential 1.00E value: &apos;+messageObservationValue.toString()+&apos; blnDetected: &apos;+blnDetected);
	} else if(messageObservationValue.toString().toUpperCase().indexOf(&apos;INVALID&apos;)&gt;-1) {				
		// INVALID
		blnDetected= false;
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue CONTAINS an INVALID text value: &apos;+messageObservationValue.toString().toUpperCase()+&apos; blnDetected: &apos;+blnDetected);
	} else if(messageObservationValue.toString().toUpperCase().indexOf(&apos;NOT DETECTED&apos;)&gt;-1) {
		// NON-DETECTED
		blnDetected= false;
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue CONTAINS NOT DETECTED text value: &apos;+messageObservationValue.toString().toUpperCase()+&apos; blnDetected: &apos;+blnDetected);
	} else if (parseInt(messageObservationValue.toString() !== &apos;NaN&apos;)) {
		// IS A NUMBER
		blnDetected= true;
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue CONTAINS a number value: &apos;+messageObservationValue.toString()+&apos; blnDetected: &apos;+blnDetected);
	} else if(messageObservationValue.toString().toUpperCase()== &apos;DETECTED&apos;) {
		// DETECTED
		blnDetected= true;
		if(debug&gt;0) logger.debug(&apos;DEBUG::&apos;+scriptName+&apos; messageObservationValue CONTAINS a number value: &apos;+messageObservationValue.toString()+&apos; blnDetected: &apos;+blnDetected);
	} // end if 
	
	if(blnDetected== true) {
		return &apos;DETECTED&apos;;
	} else {
		return &apos;NOT DETECTED&apos;;
	} // end if 
	
} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>11196ba8-3264-42a9-a59a-7a3cc2ca6754</id>
            <name>Remove Duplicate Segments</name>
            <revision>9</revision>
            <lastModified>
              <time>1685384555341</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_duplicate_segments.js
	name:		Remove Duplicate Segments
	@authored:	Jeffrey Ritz
	@created:		2023-05-29
	@description:	Remove duplicate segments

	history:
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_duplicate_segments(msg, removeDuplicateSegmentName) {
	
	var scriptName= &apos;remove_duplicate_segments&apos;;
	var debug= 0;
	var arrRemoveDuplicateSegments= new Array();

	// 2023-04-26 JER - Modified to determine if should evaluate detectable or not
	
	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);

	var lastSegmentName= &apos;&apos;;
	var lastSegmentIndex= 0;
	var lastSegment= &apos;&apos;;
	var arrDeleteSegments= new Array();

	var i= 0;
	for each(seg in msg.children()) {
		
		var segmentName= seg.name();
		if(segmentName== removeDuplicateSegmentName) {
		
			var getSegmentIndex= seg.childIndex();
		
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; segment[&apos;+i+&apos;] getSegmentIndex: &apos;+getSegmentIndex+&apos; segment: &apos;+seg);

			if(segmentName== lastSegmentName) {

				var strRemoveDuplicateSegments= segmentName+&apos;[&apos;+lastSegmentIndex+&apos;]: &apos;+seg;
				arrRemoveDuplicateSegments.push(strRemoveDuplicateSegments);
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; found seg[&apos;+i+&apos;] segmentName: &apos;+segmentName+&apos; lastSegmentName: &apos;+lastSegmentName+&apos; IF segmentName== lastSegmentName: &apos;+(segmentName== lastSegmentName)+&apos; DELETE last segment: &apos;+lastSegment);
				delete msg.children()[lastSegmentIndex]; 
			} 

			lastSegment= seg;
			lastSegmentIndex= getSegmentIndex;
			lastSegmentName= segmentName;
		} // end if 
		
	} // end for each 

	if(arrRemoveDuplicateSegments.length&gt;0) channelMap.put(&apos;removeDuplicateSegments&apos;,arrRemoveDuplicateSegments);
	return msg;

}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>25d364f7-09cf-4470-8694-a5930e88d2e3</id>
            <name>Remove Non Desired HL7 Segments</name>
            <revision>9</revision>
            <lastModified>
              <time>1678129664685</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc: Remove non-desired HL7 Segments from the HL7 message 
	&#xd;
	@fileName:	remove_non_desired_hl7_segments.js
	@name:		Remove Non Desired HL7 Segments
	@authored:	Jeffrey Ritz
	@created:		2023-03-01
	@description:	Remove non-desired HL7 Segments from Message
	@return:		XML Object - returns the HL7 XML representation of the HL7 message excluding the non-desired segments

	history:
	2023-03-02 JER - remove the carriage return line feeds from the segmentsFiltered channelMap variable
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_non_desired_hl7_segments(msg, removeSegmentsList) {
	
	var scriptName= &apos;remove_non_desired_hl7_segments&apos;;
	var debug= 0;
	var detected= false;
	var i= 0;
	var segmentsFiltered = new Array();
	var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	// for each segment - child per msg.children()
	for each(child in msg.children()) {
	
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(child)+&apos; localName: &apos;+child.localName()+&apos; child: &apos;+child);

		if(child.localName()== &apos;MSH&apos;) {
			var msgCtrlId= child[&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString();
		}
	
		if(removeSegmentsList.indexOf(child.localName())&lt;0) {
		
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] determined segment: &apos;+child.localName()+&apos; KEEP IT as is NOT CONTAINED in the removeSegments List of: &apos;+removeSegmentsList); 
			tmp.appendChild(child);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] ADD SEGMENT: &apos;+child.localName());
		} else {
			// 2023-03-01 JER - Added the collective observationFiltered channelMap variable to capture the array of filtered observations
			var segmentFiltered= &apos;Filtered segment[&apos;+i+&apos;]: &apos;+child.localName()+&apos;\r\n&apos;;
			segmentsFiltered.push(segmentFiltered);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; determined segment[&apos;+i+&apos;]: &apos;+child.localName()+&apos; REMOVE IT as it IS CONTAINED in the removeSegments List of: &apos;+removeSegmentsList); 
		} // end if 	
		i++;
		
	} // end for

	// 2023-03-02 JER - remove the carriage return line feeds from the segmentsFiltered channelMap variable
	var strSegmentsFiltered= segmentsFiltered;
	var segmentsFiltered= segmentsFiltered.toString().replace(/[\r][\n]/g,&apos;&apos;);
	channelMap.put(&apos;segmentsFiltered&apos;,segmentsFiltered);
	channelMap.put(&apos;remove_segments_msg&apos;,tmp);

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+msgCtrlId+&apos; non-desired REMOVED segments: &apos;+&apos;\r\n&apos;+strSegmentsFiltered);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; remove_segments_msg: &apos;+$c(&apos;remove_segments_msg&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp: &apos;+$c(&apos;remove_segments_msg&apos;));
	} // end if 
	
	return tmp;
}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>9b1fdd3d-b72c-4e06-af09-29acc6c98903</id>
            <name>Remove Observations From Observation Alternative Codes</name>
            <revision>3</revision>
            <lastModified>
              <time>1682530152063</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc:  Evaluate the OBX versus the observation identifier alternative identifier code (OBX-3.4) evaluated against Configuration Setting variable: TNRemoveObservations
	to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_alternative_code.js
	name:		Remove Observations From Observation Alternative Codes
	authored:		Jeffrey Ritz
	created:		2023-04-18
	description:	Evaluate the OBX versus the observed result code (OBX-3.4) evaluated against Configuration Setting variable: TNRemoveObservations
	to determine whether to exclude the Observation Results (OBX) segments from the message. 
	history:
	2023-04-18 JER - Cloned the pre-existing remove_observations_from_observation_result_codes 
*/
function remove_observations_from_observation_alternative_code(msg, removeObservations) {
	
	var scriptName= &apos;remove_observations_from_observation_alternative_code&apos;;
	var debug= 0;
	// allowedObservations
	var allowedObservationsCount= 0;
	var allowedObservations= new Array();
	// removedObservations
	var removedObservationsCount= 0;
	var removedObservations= new Array();
	
	var i= 1;
	var j= 1;

	var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	// for each segment - child per msg.children()
	for each(child in msg.children()) {
	
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(child)+&apos; localName: &apos;+child.localName()+&apos; child: &apos;+child);

		if(child.localName()== &apos;MSH&apos;) {
			var msgCtrlId= child[&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString();
		}
	
		if(child.localName()== &apos;OBX&apos;) {
		
			// process each OBX
			// 2023-03-02 JER - Modification to evaluate differences between CWE (Coded Extended) vs ST (String) data type 
			var obx21= child[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString();
			// if(child[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
			var obx31= child[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			var obx32= child[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx34= child[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
			var obx51= child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			// } // end if 
			var curObservationValue= obx51;
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; obx21: &apos;+obx21+&apos; obx34: &apos;+obx34+&apos; obx51: &apos;+obx51+&apos; observedValue: &apos;+curObservationValue);
			
			if(debug&gt;0) {
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] obx34 typeof: &apos;+typeof(obx34)+&apos; obx34: &apos;+obx34);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] TNRemoveObservations: &apos;+removeObservations);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] removeObservations.indexOf(obx34): &apos;+removeObservations.indexOf(obx34));
			}
			
			if(removeObservations.indexOf(obx34)&lt;0) {		

				// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] FOUND TN Remove Observation OBX-3.1: &apos;+obx31+&apos; value: &apos;+curObservationValue+&apos; from the list of codes: &apos;+removeObservations+&apos; evaluation: &apos;+removeObservations.indexOf(obx34)+&apos; to ADD this observation OBX Segment.&apos;); 
				
				tmp.appendChild(child);
				allowedObservationsCount++;
				var strAllowedObservations= &apos;Allowed Observations[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
				allowedObservations.push(obx31);
				
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; removeObservations[&apos;+i+&apos;] allowObservations:&apos; +strAllowedObservations);
				
			} else {
				
				// 2023-03-01 JER - Added the collective observationFiltered channelMap variable to capture the array of filtered observations
				removedObservationsCount++;
				var strRemovedObservations= &apos;Filtered Observation[&apos;+removedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos;\r\n&apos;;
				removedObservations.push(obx31);

				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; removeObservations[&apos;+i+&apos;] removedObservations:&apos; +strRemovedObservations);
			
			}
			i++;
		} else {
			// 2023-02-24 JER - Modified to use appendChild E4X denoted XML function
			tmp.appendChild(child);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] ADD SEGMENT: &apos;+child.localName());
		} // end for
		
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp[&apos;+j+&apos;] contains: &apos;+tmp);
		j++;
		
	} // end for

	// 2023-03-02 JER - remove the carriage return line feeds from the observationsFiltered channelMap variable
	// var observationsFiltered= observationsFiltered.toString().replace(/[\r][\n]/g,&apos;&apos;);
	channelMap.put(&apos;allowedObservations&apos;,allowedObservations);
	channelMap.put(&apos;removedObservations&apos;,removedObservations);

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+msgCtrlId+&apos; allowed observations: &apos;+$c(&apos;allowedObservations&apos;)+&apos; and removed observations: &apos;+$c(&apos;removedObservations&apos;));
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp: &apos;+tmp);
	} // end if 
	
	return tmp;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>227e3592-01f0-4d39-b1aa-6aeda30489e2</id>
            <name>Remove Observations From Observation Alternative Codes (NEW)</name>
            <revision>1</revision>
            <lastModified>
              <time>1684206232287</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc:  Evaluate the OBX versus the observation identifier alternative identifier code (OBX-3.4) evaluated against Configuration Setting variable: TNRemoveObservations
	to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_alternative_code_new.js
	name:		Remove Observations From Observation Alternative Codes (NEW)
	authored:		Jeffrey Ritz
	created:		2023-04-18
	description:	Evaluate the OBX versus the observed result code (OBX-3.4) evaluated against Configuration Setting variable: TNRemoveObservations
	to determine whether to exclude the Observation Results (OBX) segments from the message. 
	history:
	2023-05-08 JER - Modified to include a removeNonDetected variable if provided with a 1 - then remove nonDetected observations
	2023-05-08 JER - Modified to evaluate observation types (CWE) differently than other coded values
	2023-04-18 JER - Cloned the pre-existing remove_observations_from_observation_result_codes 
*/
function remove_observations_from_observation_alternative_code_new(msg, removeObservations, removeNonDetected) {
	
	var scriptName= &apos;remove_observations_from_observation_alternative_code_new&apos;;
	var debug= 0;
	var detected= false;
	var pathogenDetected= false;
	
	// allowedObservations
	var allowedObservationsCount= 0;
	var allowedObservations= new Array();
	
	// removedObservations
	var removedObservationsCount= 0;
	var removedObservations= new Array();
	if(typeof(removeNonDetected)== undefined) var removeNonDetected= 0;
	
	var i= 1;
	var j= 1;

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; removeObservations: &apos;+removeObservations+&apos; removeNonDetected: &apos;+removeNonDetected); 

	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	

	for each(seg in msg..OBR) {
	
		var perSegAllowedObservationSegments= 0;
		
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(seg)+&apos; seg[&apos;+j+&apos;]: &apos;+seg);
	
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			var obx21= obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString;
			var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx34= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
				var observationCode= obx34;
				var curObservationValue=	obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var observationCode= obx31;
				var curObservationValue=	obx51.toString().toUpperCase();
			} // end if
						
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] observationCode: &apos;+observationCode+&apos; obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; obx51: &apos;+obx51+&apos; curObservationValue: &apos;+curObservationValue);
			
			if(debug&gt;0) { 
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] observationCode: &apos;+observationCode+&apos; removeObservations: &apos;+removeObservations+&apos; EVAL: &apos;+removeObservations.indexOf(observationCode));
			} // end if 
			
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(removeObservations.indexOf(observationCode)&gt;-1) {	

				// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] FOUND Observation Code: &apos;+observationCode+&apos; value: &apos;+curObservationValue+&apos; from the list of codes: &apos;+removeObservations+&apos; evaluation: &apos;+removeObservations.indexOf(observationCode)+&apos; to REMOVE this observation OBX Segment.&apos;); 

				removedObservationsCount++;
				var strObservationCode= observationCode+&apos;:&apos;+curObservationValue;
				var strRemovedObservations= &apos;Filtered Observation[&apos;+removedObservationsCount+&apos;] Observation CODE: &apos;+observationCode+&apos; DESCRIPTION: &apos;+obx32+&apos; obx34: &apos;+obx34+&apos; curObservationValue: &apos;+curObservationValue+&apos;\t\r\n&apos;;
				removedObservations.push(strObservationCode);
						
				delete msg.children()[obx.childIndex()];
						
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; REMOVE removable Non-Detected observation CODE: &apos;+observationCode+&apos; removeObservations[&apos;+removedObservationsCount+&apos;] removedObservations:&apos; +strRemovedObservations);
			
			} else {
				
				pathogenDetected= true;
						
				perSegAllowedObservationSegments++;
				allowedObservationsCount++;
				var strObservationCode= observationCode+&apos;:&apos;+curObservationValue;
				var strAllowedObservations= &apos;Allowed Observations[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+observationCode+&apos; DESCRIPTION: &apos;+obx32+ &apos;obx34: &apos;+obx34;
				allowedObservations.push(strObservationCode);
					
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; PERMITTED removable Detected observation CODE: &apos;+observationCode+&apos; allowedObservations[&apos;+allowedObservationsCount+&apos;] allowObservations:&apos; +strAllowedObservations);
			
			} // end if 
			
			j++;
			
		} // end for 
		i++;
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(perSegAllowedObservationSegments&lt;1) {

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()+1]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()+1]; 

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 
			
		} // end if 
		
	} // end for each

	channelMap.put(&apos;altAllowedObservations&apos;,allowedObservations);
	channelMap.put(&apos;altRemovedObservations&apos;,removedObservations);

	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; allowedObservations: &apos;+allowedObservations);
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; removedObservations: &apos;+removedObservations);
	} // end if 
	
	channelMap.put(&apos;pathogenDetected&apos;,pathogenDetected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; pathogenDetected: &apos;+$c(&apos;pathogenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>38330d91-1b7c-4159-9530-f55314118d06</id>
            <name>Remove Observations From Observation Result Codes</name>
            <revision>65</revision>
            <lastModified>
              <time>1684206231981</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens
	to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_result_codes.js
	name:		Remove Observations From Observation Result Codes
	authored:		Jeffrey Ritz
	created:		2023-02-22
	description:	Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens
	to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	pathogenDetected= true -&gt; desired pathogens detected persist the observation result OBX segment in the transformed message (msg)
	pathogenDetected= false -&gt; failed to observe the desired pathogen or Non-Detected result remove observation result from OBX segment in transformed message (msg)
	history:
	2023-04-20 JER - Modified changed from OBX.3.4 to OBX.3.1
	2023-03-06 JER - Modified to incorporate the count of the detected in OBX[OBX.1][OBX.1.1]
	2023-03-03 JER - Moved the curObservationValue was moved up to be evaluated and accompanying logger.error statement
	2023-03-02 JER - Modification to evaluate differences between CWE (Coded Extended) vs ST (String) data type
		if obx-2.1 is EQ CWE reference observation code from obx-3.4
		if obx-2.1 is NE CWE (e.g. ST) reference observation code from obx-3.1
	2023-03-02 JER - remove the carriage return line feeds from the observationsFiltered channelMap variable
	2023-03-01 JER - Added the collective observationFiltered channelMap variable to capture the array of filtered observations obx31 and obx32 values
	2023-02-27 JER - Modified from: $cfg(&apos;ADPHNotifiablePathogens&apos;) to: allowedObservationCodeList
	2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
	2023-02-23 JER - Converted transformer to code_template 
*/
function remove_observations_from_observation_result_codes(msg, allowedObservationCodeList) {
	
	var scriptName= &apos;remove_observations_from_observation_result_codes&apos;;
	var debug= 0;
	var detected= false;
	var nonDetectedFilteredCount= 0;
	var nonDetectedFiltered= new Array();
	var permittedPathogenOrder= false;
	var i= 1;
	var j= 1;
	var observationsFiltered = new Array();
	var observationsFilteredCount= 0;
	var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	// for each segment - child per msg.children()
	for each(child in msg.children()) {
	
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(child)+&apos; localName: &apos;+child.localName()+&apos; child: &apos;+child);

		if(child.localName()== &apos;MSH&apos;) {
			var msgCtrlId= child[&apos;MSH.10&apos;][&apos;MSH.10.1&apos;].toString();
		}
	
		if(child.localName()== &apos;OBX&apos;) {
		
			// process each OBX
			// 2023-03-02 JER - Modification to evaluate differences between CWE (Coded Extended) vs ST (String) data type 
			var obx21= child[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString();
			if(child[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
				// 2023-04-20 JER - Modified changed from OBX.3.4 to OBX.3.1
				var obx31= child[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
				var obx51= child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else if(child[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;ST&apos;) {
				var obx31= child[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
				var obx51= child[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString().toUpperCase();
			} else {
				var obx31= child[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
				var obx51= child[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString().toUpperCase();
			} // end if 
			var obx32= child[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var curObservationValue= obx51;
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; obx21: &apos;+obx21+&apos; obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; obx51: &apos;+obx51+&apos; observedValue: &apos;+curObservationValue);
			
			if(debug&gt;0) {
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] typeof: &apos;+typeof(obx31)+&apos; obx31: &apos;+obx31);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] ADPHNotifiablePathogens: &apos;+$cfg(&apos;ADPHNotifiablePathogens&apos;));
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] obx31 contained in ADPHNotifiablePathogens evaluation: &apos;+$cfg(&apos;ADPHNotifiablePathogens&apos;).indexOf(obx31));
			}
			
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			// if($cfg(&apos;ADPHNotifiablePathogens&apos;).indexOf(obx31)&gt;-1) {
			if(allowedObservationCodeList.indexOf(obx31)&gt;-1) {		
				permittedPathogenOrder= true;

				// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] FOUND ADPH Notifiable Pathogens: &apos;+obx31+&apos; value: &apos;+curObservationValue+&apos; from the list of codes: &apos;+allowedObservationCodeList+&apos; evaluation: &apos;+allowedObservationCodeList.indexOf(obx31)+&apos; permitted Order Observation OBX Segment.&apos;); 
				
				// evaluate if element value is numerical exponential
				if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; determined value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
				}
	
				if(debug&gt;0) {
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;].5.1 (curObservationValue== DETECTED): &apos;+(curObservationValue== &apos;DETECTED&apos;));
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;].5.1 (curObservationValue== TRUE): &apos;+(curObservationValue== &apos;TRUE&apos;));
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;].5.1 (curObservationValue.toString().indexOf(1.00E)&gt;-1): &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;].5.1 parseInt(curObservationValue)!== NaN): &apos;+(parseInt(curObservationValue) !== &apos;NaN&apos;));
				} // end if 
				
				// 2022-10-17 JER - Added evaluate if NaN - only 
				if(((curObservationValue== &apos;DETECTED&apos;)&amp;&amp;(parseInt(curObservationValue) !== &apos;NaN&apos;))||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)) {
					detected= true;
					// 2023-03-06 JER - Modified to incorporate the count of the detected in OBX[OBX.1][OBX.1.1]
					// child[&apos;OBX.1&apos;][&apos;OBX.1.1&apos;]= detectedCount;
					// detectedCount++;
					// 2023-02-24 JER - Modified to use appendChild E4X denoted XML function
					tmp.appendChild(child);
					//if(debug&gt;0) 
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] DETECTED: &apos;+detected+&apos; ADD SEGMENT: &apos;+child.localName());
				} else {
					nonDetectedFilteredCount++;
					var strNonDetectedFiltered= &apos;Non-Detected[&apos;+nonDetectedFilteredCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
					nonDetectedFiltered.push(strNonDetectedFiltered);
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] NOT DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+child.localName());
				} // end if 
				
			} else {
					// 2023-03-01 JER - Added the collective observationFiltered channelMap variable to capture the array of filtered observations
					observationsFilteredCount++;
					var observationFiltered= &apos;Observation[&apos;+observationsFilteredCount+&apos;] CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos;\r\n&apos;;
					observationsFiltered.push(observationFiltered);
					//if(debug&gt;0)
					// 2023-03-05 JER - Modified to include description of failed to find the ADPH Notifiable Pathogen observed results 
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] DID NOT FIND ADPH Notifiable Pathogens: &apos;+obx31+&apos; value: &apos;+curObservationValue+&apos; from the list of codes: &apos;+allowedObservationCodeList+&apos; evaluation: &apos;+allowedObservationCodeList.indexOf(obx31)+&apos; rejected Order Observation OBX Segment.&apos;); 
			}
			i++;
		} else {
			// 2023-02-24 JER - Modified to use appendChild E4X denoted XML function
			// tmp+= child;
			tmp.appendChild(child);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] ADD SEGMENT: &apos;+child.localName());
		} // end for
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp[&apos;+j+&apos;] contains: &apos;+tmp);
		j++;
	} // end for

	if(observationsFiltered.length&lt;1) {
		observationsFiltered= &apos;NONE&apos;;
	} // end if 
	
	channelMap.put(&apos;pathogenDetected&apos;,detected); // true, false, invalid
	
	var strObservationsFiltered= observationsFiltered;
	// 2023-03-02 JER - remove the carriage return line feeds from the observationsFiltered channelMap variable
	var observationsFiltered= observationsFiltered.toString().replace(/[\r][\n]/g,&apos;&apos;);
	channelMap.put(&apos;observationsFiltered&apos;,observationsFiltered);
	channelMap.put(&apos;nonDetectedFiltered&apos;,nonDetectedFiltered);

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+msgCtrlId+&apos; observation required pathogens: &apos;+$c(&apos;pathogenDetected&apos;)+&apos; these observations were FILTERED: &apos;+&apos;\r\n&apos;+strObservationsFiltered);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; pathogenDetected: &apos;+$c(&apos;pathogenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp: &apos;+tmp);
	} // end if 
	
	return tmp;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>6a4a40c1-ee91-497a-b8df-e4bf5ea220b8</id>
            <name>Remove Observations From Observation Result Codes (New2)</name>
            <revision>20</revision>
            <lastModified>
              <time>1684421734891</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_result_codes_new2.js
	name:		Remove Observations From Observation Result Codes (New2)
	@authored:	Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-05-18 JER - persist the OBR segment childIndex() and msg segment children() the OBR childIndex() remove the prior segment -&gt; ORC segment
	2023-04-26 JER - Modified to determine if should evaluate detectable or not
	2023-04-21 JER - Consider following https://github.com/nextgenhealthcare/connect/discussions/5244
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_from_observation_result_codes_new2(msg, allowedObservationCodeList, filterDetectable) {
	
	var scriptName= &apos;remove_observations_from_observation_result_codes_new2&apos;;
	var debug= 0;
	var detected= false;
	// Allowed Observations Filtered List
	var nonDetectedFilteredCount= 0;
	var nonDetectedFiltered= new Array();
	// Disallowed Observations Filtered listStyleType
	var disallowedObservationsCount= 0;
	var disallowedObservations= new Array();
	
	var permittedPathogenOrder= false;
	// 2023-04-26 JER - Modified to determine if should evaluate detectable or not
	
	var i= 1;
	var j= 1;
	var k= 1;
	var observationsFiltered = new Array();
	var observationsFilteredCount= 0;
	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);

	var num_orc= msg..ORC.length();

	for each(seg in msg..OBR) {	
	
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; seg[&apos;+j+&apos;]: &apos;+seg+&apos; childIndex(): &apos;+seg.childIndex());
		
		// 2023-05-18 JER - persist the OBR segment childIndex()
		var obrChildIndex= seg.childIndex(); 
		
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
				var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
			} else {
				var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			} // end if 
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; obx51: &apos;+obx51);
			
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().length&lt;1) {
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var curObservationValue=obx51.toString().toUpperCase();
			} // end if 
			
			if(debug&gt;0) {
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; EVAL FOUND: &apos;+allowedObservationCodeList.indexOf(obx31)+&apos; allowedObservationCodeList: &apos;+allowedObservationCodeList);
			}
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(allowedObservationCodeList.indexOf(obx31)&gt;-1) {	

				channelMap.put(&apos;pathogenDetected&apos;,true);
				// evaluate if element value is numerical exponential
				if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
				} // end if 
				
				// evaluate if element value is number 
				if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;));
				} // end if 

				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; filterDetecteable: &apos;+filterDetecteable);
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				if(filterDetectable=== true) {

					// 2022-10-17 JER - Added evaluate if NaN - only 
					if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
				
						allowedObservationSegments++;
						detected= true;
						//tmp.appendChild(child);
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] DETECTED OBX.5.1 value: &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetecteable+&apos; DETECTED: &apos;+detected+&apos; KEEP SEGMENT: &apos;+obx);
					} else {
						nonDetectedFilteredCount++;
						var strNonDetectedFiltered= &apos;Non-Detected[&apos;+nonDetectedFilteredCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
						nonDetectedFiltered.push(strNonDetectedFiltered);

						delete msg.children()[obx.childIndex()];
					
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] NON-DETECTED OBX.5.1 value: &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetecteable+&apos; vs NON-DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+obx);
				
					} // end if 
				
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				} else {
					
					allowedObservationSegments++;
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] NO NON-DETECTED FILTER - ALLOW OBX.5.1 value &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetecteable+&apos; ALLOW ALL Detectable values ALLOW SEGMENT: &apos;+obx);
					
				} // end if 
			
			} else {
				
				disallowedObservationsCount++;
				var strDisallowedObservations= &apos;Disallowed Observations[&apos;+disallowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
				disallowedObservations.push(strDisallowedObservations);
				
				delete msg.children()[obx.childIndex()];
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.3.1 value: &apos;+obx31+&apos; DISALLOWED Observation[&apos;+disallowedObservationsCount+&apos;] REMOVE SEGMENT: &apos;+obx);
				
			} // end if 
			j++;
			
		} // end for 
		i++;
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(allowedObservationSegments&lt;1) {

			/*
			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 
			*/
			
			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 

			// 2023-05-18 JER - msg segment children() the OBR childIndex() remove the prior segment -&gt; ORC segment
			delete msg.children()[obrChildIndex-1];

			
		} // end if 
		
	} // end for each

	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>33061588-3e3a-43ac-8f10-862e5283ffe6</id>
            <name>Remove Observations From Observation Result Codes (New3)</name>
            <revision>2</revision>
            <lastModified>
              <time>1685382852602</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_result_codes_new3.js
	name:		Remove Observations From Observation Result Codes (New3)
	@authored:	Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
	2023-05-18 JER - persist the OBR segment childIndex() and msg segment children() the OBR childIndex() remove the prior segment -&gt; ORC segment
	2023-04-26 JER - Modified to determine if should evaluate detectable or not
	2023-04-21 JER - Consider following https://github.com/nextgenhealthcare/connect/discussions/5244
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_from_observation_result_codes_new3(msg, allowedObservationCodeList, filterDetectable) {
	
	var scriptName= &apos;remove_observations_from_observation_result_codes_new3&apos;;
	var debug= 0;
	var detected= false;
	// Allowed Observations Filtered List
	var nonDetectedFilteredCount= 0;
	var nonDetectedFiltered= new Array();
	var lstNonDetectedFiltered= new Array();
	
	// Allowed Observations Filtered List
	var allowedObservationsCount= 0;
	var allowedObservations= new Array();
	var lstAllowedObservations= new Array();
	
	// Disallowed Observations Filtered listStyleType
	var disallowedObservationsCount= 0;
	var disallowedObservations= new Array();
	var lstDisallowedObservations= new Array();
	
	var permittedPathogenOrder= false;
	// 2023-04-26 JER - Modified to determine if should evaluate detectable or not
	
	var i= 1;
	var j= 1;
	var k= 1;
	var observationsFiltered = new Array();
	var observationsFilteredCount= 0;
	// 2023-05-18 JER - persist all OBR related segment indexes
	var arrObrChildIndex= new Array();
	
	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);

	var num_orc= msg..ORC.length();

	for each(seg in msg..OBR) {	

		var allowedObservationSegments= 0;
		
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; seg[&apos;+j+&apos;]: &apos;+seg+&apos; childIndex(): &apos;+seg.childIndex());
		
		// 2023-05-18 JER - persist the OBR segment childIndex()
		var obrChildIndex= seg.childIndex(); 
		
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
				var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
				// 2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
				// 2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			} // end if 
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue);
			
			/*
			// 2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().length&lt;1) {
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var curObservationValue=obx51.toString().toUpperCase();
			} // end if 
			*/
			
			if(debug&gt;0) {
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; EVAL FOUND: &apos;+allowedObservationCodeList.indexOf(obx31)+&apos; allowedObservationCodeList: &apos;+allowedObservationCodeList);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
			}
			
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(allowedObservationCodeList.indexOf(obx31)&gt;-1) {	

				channelMap.put(&apos;pathogenDetected&apos;,true);
				// evaluate if element value is numerical exponential
				if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
					curObservationValue= &apos;DETECTED&apos;;
				} // end if 

				// 8.01E+04
				if(curObservationValue.toString().indexOf(&apos;8.01E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 8.01E value: &apos;+(curObservationValue.toString().indexOf(&apos;8.01E&apos;)&gt;-1));
					curObservationValue= &apos;DETECTED&apos;;
				} // end if 
				
				// evaluate if element value is number 
				if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;));
					curObservationValue= &apos;DETECTED&apos;;
				} // end if 

				if(debug&gt;0) {
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; filterDetectable: &apos;+filterDetectable+&apos; filterDetectable.indexOf(true): &apos;+(filterDetectable.indexOf(&apos;true&apos;)));
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; curObservationValue: &apos;+curObservationValue.toUpperCase()+&apos; curObservationValue NEQ NOT DETECTED: &apos;+(curObservationValue.toUpperCase()!== &apos;NOT DETECTED&apos;));
				} // end if
				
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				if(filterDetectable.indexOf(&apos;true&apos;)&gt;-1) {

					// 2022-10-17 JER - Added evaluate if NaN - only 
					// if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
					// 2023-05-22 JER - Modified to evaluate only the string &apos;NOT DETECTED&apos;
					if(curObservationValue.toUpperCase()!== &apos;NOT DETECTED&apos;) {

						// required to evaluate to determine if require to filter ORM and SPM segments
						allowedObservationSegments++;
						
						allowedObservationsCount++;
						detected= true;
						var strAllowedObservations= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Allowed[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
						if(allowedObservations.indexOf(strAllowedObservations)&lt;0) {
							allowedObservations.push(strAllowedObservations);
						} // end if 
				
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] DETECTED OBX.5.1 value: &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetectable+&apos; DETECTED: &apos;+detected+&apos; KEEP SEGMENT: &apos;+obx);
					} else {
						
						nonDetectedFilteredCount++;
						var strNonDetectedFiltered= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Non-Detected[&apos;+nonDetectedFilteredCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
						if(nonDetectedFiltered.indexOf(strNonDetectedFiltered)&lt;0) {
							nonDetectedFiltered.push(strNonDetectedFiltered);
						} // end if 
						delete msg.children()[obx.childIndex()];
					
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] NON-DETECTED OBX.5.1 value: &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetectable+&apos; vs NON-DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+obx);
				
					} // end if 
				
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				} else {

					detected= true;
					allowedObservationsCount++;
					var strAllowedObservations= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Allowed[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
					if(allowedObservations.indexOf(strAllowedObservations)&lt;0) {
						allowedObservations.push(strAllowedObservations);
					} // end if 
					
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Allowed Observations OBX.5.1 value &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetectable+&apos; ALLOW ALL Detectable values ALLOW SEGMENT: &apos;+obx);
					
				} // end if 
			
			} else {
				
				disallowedObservationsCount++;
				var strDisallowedObservations= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Disallowed Observations[&apos;+disallowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
				if(disallowedObservations.indexOf(strDisallowedObservations)&lt;0) {
					disallowedObservations.push(strDisallowedObservations);
				} // end if 
				
				delete msg.children()[obx.childIndex()];

				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.3.1 value: &apos;+obx31+&apos; DISALLOWED Observation[&apos;+disallowedObservationsCount+&apos;] REMOVE SEGMENT: &apos;+obx);
				
			} // end if 
			j++;
			
		} // end for 
		i++;

		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR childIndex[&apos;+obrChildIndex+&apos;] allowedObservationSegments: &apos;+allowedObservationSegments); 
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(allowedObservationSegments&lt;1) {

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);

			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; delete SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[obrChildIndex+1]+&apos; value: &apos;+getSegment);
			delete msg.children()[obrChildIndex+1]; 
			
			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; delete OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 

			// if(debug&gt;0) 
			//logger.error(&apos;DEBUG::&apos;+scriptName+&apos; delete segment typeof: &apos;+typeof(msg.children()[obrChildIndex-1])+&apos; index: &apos;+[obrChildIndex-1]+&apos; value: &apos;+msg.children()[obrChildIndex-1]);
			// 2023-05-18 JER - msg segment children() the OBR childIndex() remove the prior segment -&gt; ORC segment
			//delete msg.children()[obrChildIndex-1];

			
		} // end if 

		// per OBR segment push into an overall list to be persisted in channelMap
		lstAllowedObservations.push(allowedObservations);
		lstDisallowedObservations.push(disallowedObservations);
		lstNonDetectedFiltered.push(nonDetectedFiltered);
		
	} // end for each

	
	if(lstAllowedObservations.length&gt;0) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; lstAllowedObservations: &apos;+lstAllowedObservations); 
		channelMap.put(&apos;arrAllowedObservations&apos;,lstAllowedObservations);
	}  // end if 
	
	if(lstDisallowedObservations.length&gt;0) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; lstDisallowedObservations: &apos;+lstDisallowedObservations);  
		channelMap.put(&apos;arrDisallowedObservations&apos;,lstDisallowedObservations); 
	} // end if 
	
	if(lstNonDetectedFiltered.length&gt;0) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; lstNonDetectedFiltered: &apos;+lstNonDetectedFiltered); 
		channelMap.put(&apos;arrNonDetectedFiltered&apos;,lstNonDetectedFiltered); 
	} // end if 

	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;

}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>aa4e63f3-ba6f-443a-ad3d-549b334b33fa</id>
            <name>Remove Observations From Observation Result Codes New</name>
            <revision>44</revision>
            <lastModified>
              <time>1693008655886</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_result_codes_new.js
	name:		Remove Observations From Observation Result Codes (New)
	@authored:	Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-08-25 JER - Modified moved the static Config Map setting to a function parameterized variable and added debug to check/verify two parameterized variables
	2023-04-26 JER - Modified to determine if should evaluate detectable or not
	2023-04-21 JER - Consider following https://github.com/nextgenhealthcare/connect/discussions/5244
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_from_observation_result_codes_new(msg, allowedObservationCodeList, filterNotifiablePathogensNonDetectable) {
	
	var scriptName= &apos;remove_observations_from_observation_result_codes_new&apos;;
	var debug= 0;
	var detected= false;
	// Allowed Observations Filtered List
	var nonDetectedFilteredCount= 0;
	var nonDetectedFiltered= new Array();
	// Disallowed Observations Filtered listStyleType
	var disallowedObservationsCount= 0;
	var disallowedObservations= new Array();
	
	var permittedPathogenOrder= false;
	// 2023-04-26 JER - Modified to determine if should evaluate detectable or not
	// 2023-08-25 JER - Modified moved the static Config Map setting to a function parameterized variable and added debug to check/verify two parameterized variables
	// var filterNotifiablePathogensNonDetectable= $cfg(&apos;TNNotifiablePathogensDetectable&apos;);
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; allowedObservationCodeList: &apos;+allowedObservationCodeList);
		logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; filterNotifiablePathogensNonDetectable: &apos;+filterNotifiablePathogensNonDetectable);
	} // end if 
	
	var i= 1;
	var j= 1;
	var observationsFiltered = new Array();
	var observationsFilteredCount= 0;
	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	for each(seg in msg..OBR) {	
	
		logger.error(&apos;TEST::&apos;+scriptName+&apos; seg[&apos;+j+&apos;]: &apos;+seg);
	
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; obx51: &apos;+obx51);
			
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().length&lt;1) {
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var curObservationValue=obx51.toString().toUpperCase();
			} // end if 
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
			
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(allowedObservationCodeList.indexOf(obx31)&gt;-1) {	
			
				// evaluate if element value is numerical exponential
				if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
				} // end if 
				
				// evaluate if element value is number 
				if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;));
				} // end if 

				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				if(filterNotifiablePathogensNonDetectable== true) {

					// 2022-10-17 JER - Added evaluate if NaN - only 
					if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
				
						allowedObservationSegments++;
						detected= true;
						//tmp.appendChild(child);
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.1 value: &apos;+curObservationValue+&apos; DETECTED: &apos;+detected+&apos; KEEP SEGMENT: &apos;+obx);
					} else {
						nonDetectedFilteredCount++;
						var strNonDetectedFiltered= &apos;Non-Detected[&apos;+nonDetectedFilteredCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
						nonDetectedFiltered.push(strNonDetectedFiltered);
				
						delete msg.children()[obx.childIndex()];
					
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.1 value: &apos;+curObservationValue+&apos; NON-DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+obx);
				
					} // end if 
				
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				} else {
					
					allowedObservationSegments++;
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] ALLOW OBX.5.1 value &apos;+curObservationValue+&apos; ALLOW ALL Detectable values ALLOW SEGMENT: &apos;+obx);
					
				} // end if 
			
			} else {
				
				disallowedObservationsCount++;
				var strDisallowedObservations= &apos;Disallowed Observations[&apos;+disallowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
				disallowedObservations.push(strDisallowedObservations);
				
				delete msg.children()[obx.childIndex()];
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.3.1 value: &apos;+obx31+&apos; DISALLOWED Observation[&apos;+disallowedObservationsCount+&apos;] REMOVE SEGMENT: &apos;+obx);
				
			} // end if 
			j++;
			
		} // end for 
		i++;
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(allowedObservationSegments&lt;1) {

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()+1]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()+1]; 

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 
			
		} // end if 
		
	} // end for each

	channelMap.put(&apos;disallowedObservations&apos;,disallowedObservations); 
	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; disallowedObservations: &apos;+$c(&apos;disallowedObservations&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>9178bdf8-2739-408f-af89-2253335982ee</id>
            <name>Remove Observations From Observation Result Codes Non-Detected Results</name>
            <revision>2</revision>
            <lastModified>
              <time>1687559459663</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_from_observation_result_codes_new.js
	name:			Remove Observations From Observation Result Codes (New)
	@authored:		Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
	2023-05-18 JER - persist the OBR segment childIndex() and msg segment children() the OBR childIndex() remove the prior segment -&gt; ORC segment
	2023-04-26 JER - Modified to determine if should evaluate detectable or not
	2023-04-21 JER - Consider following https://github.com/nextgenhealthcare/connect/discussions/5244
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_from_observation_result_codes_new(msg, allowedObservationCodeList, filterDetectable) {
	
	var scriptName= &apos;remove_observations_from_observation_result_codes_new&apos;;
	var debug= 0;
	var detected= false;
	// Allowed Observations Filtered List
	var nonDetectedFilteredCount= 0;
	var nonDetectedFiltered= new Array();
	var lstNonDetectedFiltered= new Array();
	
	// Allowed Observations Filtered List
	var allowedObservationsCount= 0;
	var allowedObservations= new Array();
	var lstAllowedObservations= new Array();
	
	// Disallowed Observations Filtered listStyleType
	var disallowedObservationsCount= 0;
	var disallowedObservations= new Array();
	var lstDisallowedObservations= new Array();
	
	var permittedPathogenOrder= false;
	// 2023-04-26 JER - Modified to determine if should evaluate detectable or not
	
	var i= 1;
	var j= 1;
	var k= 1;
	var observationsFiltered = new Array();
	var observationsFilteredCount= 0;
	// 2023-05-18 JER - persist all OBR related segment indexes
	var arrObrChildIndex= new Array();
	
	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);

	var num_orc= msg..ORC.length();

	for each(seg in msg..OBR) {	

		var allowedObservationSegments= 0;
		
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; seg[&apos;+j+&apos;]: &apos;+seg+&apos; childIndex(): &apos;+seg.childIndex());
		
		// 2023-05-18 JER - persist the OBR segment childIndex()
		var obrChildIndex= seg.childIndex(); 
		
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
				var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
				// 2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
				// 2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			} // end if 
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue);
			
			/*
			// 2023-05-22 JER - Modified to include the set of the curObservationValue of OBX.5.2 based on OBX.2.1 as &apos;CWE&apos;
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().length&lt;1) {
				var curObservationValue=obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var curObservationValue=obx51.toString().toUpperCase();
			} // end if 
			*/
			
			if(debug&gt;0) {
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; EVAL FOUND: &apos;+allowedObservationCodeList.indexOf(obx31)+&apos; allowedObservationCodeList: &apos;+allowedObservationCodeList);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
			}
			
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(allowedObservationCodeList.indexOf(obx31)&gt;-1) {	

				channelMap.put(&apos;pathogenDetected&apos;,true);
				// evaluate if element value is numerical exponential
				if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
					curObservationValue= &apos;DETECTED&apos;;
				} // end if 

				// 8.01E+04
				if(curObservationValue.toString().indexOf(&apos;8.01E&apos;)&gt;-1) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 8.01E value: &apos;+(curObservationValue.toString().indexOf(&apos;8.01E&apos;)&gt;-1));
					curObservationValue= &apos;DETECTED&apos;;
				} // end if 
				
				// evaluate if element value is number 
				if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;));
					curObservationValue= &apos;DETECTED&apos;;
				} // end if 

				if(debug&gt;0) {
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; filterDetectable: &apos;+filterDetectable+&apos; filterDetectable.indexOf(true): &apos;+(filterDetectable.indexOf(&apos;true&apos;)));
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] obx31: &apos;+obx31+&apos; curObservationValue: &apos;+curObservationValue.toUpperCase()+&apos; curObservationValue NEQ NOT DETECTED: &apos;+(curObservationValue.toUpperCase()!== &apos;NOT DETECTED&apos;));
				} // end if
				
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				if(filterDetectable.indexOf(&apos;true&apos;)&gt;-1) {

					// 2022-10-17 JER - Added evaluate if NaN - only 
					// if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
					// 2023-05-22 JER - Modified to evaluate only the string &apos;NOT DETECTED&apos;
					if(curObservationValue.toUpperCase()!== &apos;NOT DETECTED&apos;) {

						// required to evaluate to determine if require to filter ORM and SPM segments
						allowedObservationSegments++;
						
						allowedObservationsCount++;
						detected= true;
						var strAllowedObservations= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Allowed[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
						if(allowedObservations.indexOf(strAllowedObservations)&lt;0) {
							allowedObservations.push(strAllowedObservations);
						} // end if 
				
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] DETECTED OBX.5.1 value: &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetectable+&apos; DETECTED: &apos;+detected+&apos; KEEP SEGMENT: &apos;+obx);
					} else {
						
						nonDetectedFilteredCount++;
						var strNonDetectedFiltered= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Non-Detected[&apos;+nonDetectedFilteredCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
						if(nonDetectedFiltered.indexOf(strNonDetectedFiltered)&lt;0) {
							nonDetectedFiltered.push(strNonDetectedFiltered);
						} // end if 
						delete msg.children()[obx.childIndex()];
					
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] NON-DETECTED OBX.5.1 value: &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetectable+&apos; vs NON-DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+obx);
				
					} // end if 
				
				// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
				} else {

					detected= true;
					allowedObservationsCount++;
					var strAllowedObservations= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Allowed[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
					if(allowedObservations.indexOf(strAllowedObservations)&lt;0) {
						allowedObservations.push(strAllowedObservations);
					} // end if 
					
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Allowed Observations OBX.5.1 value &apos;+curObservationValue+&apos; checkDetected: &apos;+filterDetectable+&apos; ALLOW ALL Detectable values ALLOW SEGMENT: &apos;+obx);
					
				} // end if 
			
			} else {
				
				disallowedObservationsCount++;
				var strDisallowedObservations= &apos;OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] Disallowed Observations[&apos;+disallowedObservationsCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32+&apos; curObservationValue: &apos;+curObservationValue;
				if(disallowedObservations.indexOf(strDisallowedObservations)&lt;0) {
					disallowedObservations.push(strDisallowedObservations);
				} // end if 
				
				delete msg.children()[obx.childIndex()];

				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.3.1 value: &apos;+obx31+&apos; DISALLOWED Observation[&apos;+disallowedObservationsCount+&apos;] REMOVE SEGMENT: &apos;+obx);
				
			} // end if 
			j++;
			
		} // end for 
		i++;

		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR childIndex[&apos;+obrChildIndex+&apos;] allowedObservationSegments: &apos;+allowedObservationSegments); 
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(allowedObservationSegments&lt;1) {

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);

			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; delete SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[obrChildIndex+1]+&apos; value: &apos;+getSegment);
			delete msg.children()[obrChildIndex+1]; 
			
			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; delete OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 

			// if(debug&gt;0) 
			//logger.error(&apos;DEBUG::&apos;+scriptName+&apos; delete segment typeof: &apos;+typeof(msg.children()[obrChildIndex-1])+&apos; index: &apos;+[obrChildIndex-1]+&apos; value: &apos;+msg.children()[obrChildIndex-1]);
			// 2023-05-18 JER - msg segment children() the OBR childIndex() remove the prior segment -&gt; ORC segment
			//delete msg.children()[obrChildIndex-1];

			
		} // end if 

		// per OBR segment push into an overall list to be persisted in channelMap
		lstAllowedObservations.push(allowedObservations);
		lstDisallowedObservations.push(disallowedObservations);
		lstNonDetectedFiltered.push(nonDetectedFiltered);
		
	} // end for each

	
	if(lstAllowedObservations.length&gt;0) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; lstAllowedObservations: &apos;+lstAllowedObservations); 
		channelMap.put(&apos;arrAllowedObservations&apos;,lstAllowedObservations);
	}  // end if 
	
	if(lstDisallowedObservations.length&gt;0) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; lstDisallowedObservations: &apos;+lstDisallowedObservations);  
		channelMap.put(&apos;arrDisallowedObservations&apos;,lstDisallowedObservations); 
	} // end if 
	
	if(lstNonDetectedFiltered.length&gt;0) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; lstNonDetectedFiltered: &apos;+lstNonDetectedFiltered); 
		channelMap.put(&apos;arrNonDetectedFiltered&apos;,lstNonDetectedFiltered); 
	} // end if 

	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;

}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>d8952806-86fd-4404-b8ed-f3bd375c9eb9</id>
            <name>Remove Observations Non Detected Results New</name>
            <revision>10</revision>
            <lastModified>
              <time>1682539562304</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc: Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered  

	@fileName:	remove_observations_non_detected_results_new.js
	@name:		Remove Observations Non Detected Results (New)
	@authored:	Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-04-21 JER - Consider following https://github.com/nextgenhealthcare/connect/discussions/5244
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_non_detected_results_new(msg) {
	
	var scriptName= &apos;remove_observations_non_detected_results_new&apos;;
	var debug= 0;
	var nonDetectedFiltered= new Array();
	var nonDetectedFilteredCount= 0;
	var detected= false;
	var i= 1;
	var j= 1;
	var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	for each(seg in msg..OBR) {	
	
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; child[OBX.5][OBX.5.2]: &apos;+child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase()+&apos; length: &apos;+child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().length);
			
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().length&lt;1) {
				var curObservationValue=child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var curObservationValue=obx51.toString().toUpperCase();
			} // end if 
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
			
			// if(debug&gt;0) 
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] typeof: &apos;+typeof(obx31)+&apos; obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; obx51: &apos;+obx51+&apos; curObservationValue: &apos;+curObservationValue);
			
			// evaluate if element value is numerical exponential
			if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
			} // end if 
				
			// evaluate if element value is number 
			if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.2 value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;));
			} // end if 

			// 2022-10-17 JER - Added evaluate if NaN - only 
			if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
				
				detected= true;
				//tmp.appendChild(child);
				// if(debug&gt;0) 
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.1 value: &apos;+curObservationValue+&apos; DETECTED: &apos;+detected+&apos; KEEP SEGMENT: &apos;+obx);
				
			} else {
				
				nonDetectedFilteredCount++;
				var strNonDetectedFiltered= &apos;Non-Detected[&apos;+nonDetectedFilteredCount+&apos;] Observation CODE: &apos;+obx31+&apos; DESCRIPTION: &apos;+obx32;
				nonDetectedFiltered.push(strNonDetectedFiltered);
				
				delete msg.children()[obx.childIndex()];
					
				// if(debug&gt;0) 
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] OBX.5.1 value: &apos;+curObservationValue+&apos; NON-DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+obx);
				
			} // end if 	
			j++;
			
		} // end for 
		
		if(getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;).length == 0) {
			// if(debug&gt;0) 
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] REMOVED related segments DELETE segment: &apos;+msg.children()[seg.childIndex()]);
			delete msg.children()[seg.childIndex()];
			
		} // end if 
		
		i++;
	} // end for each

	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,tmp);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return tmp;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>7ba5e0e9-311b-494f-812f-7afa58f047fe</id>
            <name>Remove Observations Non-Detected Observation Values</name>
            <revision>1</revision>
            <lastModified>
              <time>1684206232224</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc:  Evaluate the OBX versus the observation (OBX) segments with removeNonDetected parameter from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_non_detected_observation_values.js
	name:		Remove Observations Non-Detected Observation Values
	authored:		Jeffrey Ritz
	created:		2023-05-10
	description:	Evaluate the OBX versus the observed result code (OBX-3.4) evaluated against Configuration Setting variable: TNRemoveObservations
	to determine whether to exclude the Observation Results (OBX) segments from the message. 
	history:
	2023-04-18 JER - Cloned the pre-existing remove_observations_from_observation_result_codes 
*/
function remove_observations_non_detected_observation_values(msg, removeNonDetected) {
	
	var scriptName= &apos;remove_observations_non_detected_observation_values&apos;;
	var debug= 0;
	var detected= false;
	var pathogenDetected= false;
	
	// allowedObservations
	var allowedObservationsCount= 0;
	var allowedObservations= new Array();
	
	// removedObservations
	var removedObservationsCount= 0;
	var removedObservations= new Array();
	if(typeof(removeNonDetected)== undefined) var removeNonDetected= 0;
	
	var i= 1;
	var j= 1;

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; removeObservations: &apos;+removeObservations); 

	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	

	for each(seg in msg..OBR) {
	
		var perSegAllowedObservationSegments= 0;
		
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(seg)+&apos; seg[&apos;+j+&apos;]: &apos;+seg);
	
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {
			
			// process each OBX
			var obx21= obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString;
			var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx34= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();
			
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
				var observationCode= obx34;
				var curObservationValue=	obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
			} else {
				var observationCode= obx31;
				var curObservationValue=	obx51.toString().toUpperCase();
			} // end if
						
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] observationCode: &apos;+observationCode+&apos; obx31: &apos;+obx31+&apos; obx32: &apos;+obx32+&apos; obx51: &apos;+obx51+&apos; curObservationValue: &apos;+curObservationValue);
			
			//if(debug&gt;0) { 
				// logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] curObservationValue: &apos;+curObservationValue);
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] observationCode: &apos;+observationCode+&apos; removeObservations: &apos;+removeObservations+&apos; EVAL: &apos;+removeObservations.indexOf(observationCode));
			//}
			

			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] FOUND Observation Code: &apos;+observationCode+&apos; value: &apos;+curObservationValue+&apos; from the list of codes: &apos;+removeObservations+&apos; evaluation: &apos;+removeObservations.indexOf(observationCode)+&apos; to ADD this observation OBX Segment.&apos;); 
			
			// 2023-04-26 JER - Evaluate if allowing either Detected or Non-Detected values
			if(removeNonDetected&gt;0) {
				
				if(curObservationValue.indexOf(&apos;NOT DETECTED&apos;)&gt;-1) {
					removedObservationsCount++;
					var strObservationCode= observationCode+&apos;:&apos;+curObservationValue;
					var strRemovedObservations= &apos;Filtered Observation[&apos;+removedObservationsCount+&apos;] Observation CODE: &apos;+observationCode+&apos; DESCRIPTION: &apos;+obx32+&apos; obx34: &apos;+obx34+&apos; curObservationValue: &apos;+curObservationValue+&apos;\t\r\n&apos;;
					removedObservations.push(strObservationCode);
						
					delete msg.children()[obx.childIndex()];
						
					// if(debug&gt;0) 
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; REMOVE removable Non-Detected observation CODE: &apos;+observationCode+&apos; removeNonDetected: &apos;+removeNonDetected+&apos; removeObservations[&apos;+removedObservationsCount+&apos;] removedObservations:&apos; +strRemovedObservations);
				} else {
					pathogenDetected= true;
						
					perSegAllowedObservationSegments++;
					allowedObservationsCount++;
					var strObservationCode= observationCode+&apos;:&apos;+curObservationValue;
					var strAllowedObservations= &apos;Allowed Observations[&apos;+allowedObservationsCount+&apos;] Observation CODE: &apos;+observationCode+&apos; DESCRIPTION: &apos;+obx32+ &apos;obx34: &apos;+obx34;
					allowedObservations.push(strObservationCode);
					
					// if(debug&gt;0) 
					logger.error(&apos;DEBUG::&apos;+scriptName+&apos; PERMITTED removable Detected observation CODE: &apos;+observationCode+&apos; removeNonDetected: &apos;+removeNonDetected+&apos; allowedObservations[&apos;+allowedObservationsCount+&apos;] allowObservations:&apos; +strAllowedObservations);
				} // end if 
			
			} // end if 
			j++;
			
		} // end for 
		i++;
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(perSegAllowedObservationSegments&lt;1) {

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()+1]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()+1]; 

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 
			
		} // end if 
		
	} // end for each

	channelMap.put(&apos;allowedObservations&apos;,allowedObservations);
	channelMap.put(&apos;removedObservations&apos;,removedObservations);

	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; allowedObservations: &apos;+allowedObservations);
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; removedObservations: &apos;+removedObservations);
	} // end if 
	
	channelMap.put(&apos;pathogenDetected&apos;,pathogenDetected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; pathogenDetected: &apos;+$c(&apos;pathogenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>9b90804b-36fb-4199-9584-7cc94b798c26</id>
            <name>Remove Observations Non-Detected Results</name>
            <revision>14</revision>
            <lastModified>
              <time>1684206232088</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Desc: Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered  

	@fileName:	remove_observations_non_detected_results.js
	@name:		Remove Observations Non Detected Results
	@authored:	Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_non_detected_results(msg) {
	
	var scriptName= &apos;remove_observations_non_detected_results&apos;;
	var debug= 0;
	var detected= false;
	var i= 1;
	var j= 1;
	var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);
	
	// for each segment - child per msg.children()
	for each(child in msg.children()) {
	
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof: &apos;+typeof(child)+&apos; localName: &apos;+child.localName()+&apos; child: &apos;+child);
	
		if(child.localName()== &apos;OBX&apos;) {
		
			// process each OBX
			var obx31= child[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
			
			if(debug&gt;0) {
				logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;] typeof: &apos;+typeof(obx31)+&apos; obx31: &apos;+obx31);
			}
			
			// 2023-02-27 JER - Modified from OBX.5.1 to OBX.5.2
			var curObservationValue=child[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
				
			// evaluate if element value is numerical exponential
			if(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1) {
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; determined value contains an exponential 1.00E value: &apos;+(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1));
			}
				
			// evaluate if element value is number 
			if(parseInt(curObservationValue.toString() !== &apos;NaN&apos;)) {
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; determined value contains IS a number: &apos;+parseInt(curObservationValue.toString()!== &apos;NaN&apos;));
			}
	
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+i+&apos;].5.1 curObservationValue: &apos;+curObservationValue);
				
			// 2022-10-17 JER - Added evaluate if NaN - only 
			if((curObservationValue== &apos;DETECTED&apos;)||(curObservationValue== &apos;TRUE&apos;)||(curObservationValue.toString().indexOf(&apos;1.00E&apos;)&gt;-1)||parseInt(curObservationValue.toString()!== &apos;NaN&apos;)) {
				detected= true;
				// tmp appended child object from msg.children()
				// 2023-02-24 JER - Modified to use appendChild E4X denoted XML function
				// tmp+= child;
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] determined value CONTAINS: &apos;+curObservationValue+&apos; value - adding this segment.&apos;);
				tmp.appendChild(child);
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] ADD SEGMENT: &apos;+child.localName());
			} else {
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] determined value CONTAINS: &apos;+curObservationValue+&apos; value is a Non-Detected or an Un-expected value - skipping this segment.&apos;);
			} // end if 	
			i++;
		} else {
			// 2023-02-24 JER - Modified to use appendChild E4X denoted XML function
			// tmp+= child;
			tmp.appendChild(child);
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; [&apos;+i+&apos;] ADD SEGMENT: &apos;+child.localName());
		} // end for
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp[&apos;+j+&apos;] contains: &apos;+tmp);
		j++;
	} // end for
	
	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,tmp);
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; tmp: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return tmp;
}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>cd97709d-5752-447a-b5c0-c49d7f0f9f06</id>
            <name>Remove Observations Using Observation Result Codes</name>
            <revision>3</revision>
            <lastModified>
              <time>1690570753987</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Desc:  Evaluate the OBX versus the observed result code (OBX-3.1) evaluated against Configuration Setting variable: ADPHNotifiablePathogens to determine whether to exclude the Observation Results (OBX) segments from the message and set the pathogenDetected channelMap variable.
	
	fileName:		remove_observations_using_observation_result_codes.js
	name:			Remove Observations Using Observation Result Codes
	@authored:		Jeffrey Ritz
	@created:		2023-02-27
	@description:	Remove observations with Non-Detected Results and mark Detected to be Allowed/Filtered

	history:
	2023-07-27 JER - Modified to include isCovid boolean argument to determine how to set the observationCode and observationValue
	2023-04-26 JER - Modified to determine if should evaluate detectable or not
	2023-04-21 JER - Consider following https://github.com/nextgenhealthcare/connect/discussions/5244
	2023-02-27 JER - Cloned the Remove Observations From Observation Result Codes
*/
function remove_observations_using_observation_result_codes(msg, allowedObservationCodeList, isCovid) {
	
	var scriptName= &apos;remove_observations_using_observation_result_codes&apos;;
	var debug= 0;
	var detected= false;
	
	// Disallowed Observations Filtered List
	var disallowedObservationsCount= 0;
	var disallowedObservations= new Array();
	
	// Allowed Observations Filtered List
	var allowedObservationsCount= 0;
	var allowedObservations= new Array();
	
	var i= 1;
	var j= 1;
	var observationsFiltered = new Array();
	var observationsFilteredCount= 0;
	// var tmp= new XML(&apos;&lt;HL7Message&gt;&lt;/HL7Message&gt;&apos;);
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelId).getName();
	channelMap.put(&apos;channelName&apos;,channelName);

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; allowedObservationCodeList: &apos;+allowedObservationCodeList);
	
	for each(seg in msg..OBR) {	
	
		if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; seg[&apos;+j+&apos;]: &apos;+seg);
	
		var allowedObservationSegments= 0;
		for each(obx in getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBX&apos;,false,&apos;OBR&apos;)) {

			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+channelName+&apos;:&apos;+scriptName+&apos; obx: &apos;+obx);

			var obx32= obx[&apos;OBX.3&apos;][&apos;OBX.3.2&apos;].toString();
			var obx51= obx[&apos;OBX.5&apos;][&apos;OBX.5.1&apos;].toString();

			if(typeof(isCovid)!== undefined) {
				if(isCovid== true) {
					
					var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
					var observationCode=  obx31;
					var observationValue= obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
				
				} else {
					// process each OBX
					if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
						var obx34= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
						var observationCode=  obx34;
						var observationValue= obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
					} else {
						var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
						var observationCode=  obx31;
						var observationValue= obx51.toString().toUpperCase();
					} // end if
				} // end if 

			} else {
				// process each OBX
				if(obx[&apos;OBX.2&apos;][&apos;OBX.2.1&apos;].toString()== &apos;CWE&apos;) {
					var obx34= obx[&apos;OBX.3&apos;][&apos;OBX.3.4&apos;].toString();
					var observationCode=  obx34;
					var observationValue= obx[&apos;OBX.5&apos;][&apos;OBX.5.2&apos;].toString().toUpperCase();
				} else {
					var obx31= obx[&apos;OBX.3&apos;][&apos;OBX.3.1&apos;].toString();
					var observationCode=  obx31;
					var observationValue= obx51.toString().toUpperCase();
				} // end if
			} // end if 
			
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBX[&apos;+j+&apos;] observationCode: &apos;+observationCode+&apos; observationValue: &apos;+observationValue+&apos; Eval: &apos;+allowedObservationCodeList.indexOf(observationCode)+&apos; allowedObservationCodeList: &apos;+allowedObservationCodeList);
			
			// 2024-02-24 JER - Modified to leverage the function input parameterized variable orderCodeList to replace hardCoded configuration setting variable
			if(allowedObservationCodeList.indexOf(observationCode)&gt;-1) {	

				allowedObservationsCount++;
				detected= true;
				var logText= &apos;observationCode: &apos;+observationCode+&apos; observationValue: &apos;+observationValue;
				var strAllowedObservation= &apos;Allowed[&apos;+allowedObservationsCount+&apos;] &apos;+logText;
				allowedObservations.push(strAllowedObservation);
				allowedObservationSegments++;

				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] ALLOWED logText: &apos;+logText+&apos; DETECTED: &apos;+detected+&apos; KEEP SEGMENT: &apos;+obx);
			
			} else {
				
				disallowedObservationsCount++;
				var logText= &apos;observationCode: &apos;+observationCode+&apos; observationValue: &apos;+observationValue;
				var strDisallowedObservation= &apos;Disallowed[&apos;+disallowedObservationsCount+&apos;] &apos;+logText;
				disallowedObservations.push(strDisallowedObservation);

				delete msg.children()[obx.childIndex()];
					
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; OBR[&apos;+i+&apos;]OBX[&apos;+j+&apos;] DISALLOWED logText: &apos;+logText+&apos; DETECTED: &apos;+detected+&apos; REMOVE SEGMENT: &apos;+obx);
				
			} // end if 
			j++;
			
		} // end for 
		i++;

		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; allowedObservationSegments: &apos;+allowedObservationSegments);
		
		// 2024-04-26 JER - Modified to evaluate if any allowedObservations are found - if none then remove associated OBR and SPM segments
		if(allowedObservationSegments&lt;1) {

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;SPM&apos;,true,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; SPM getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()+1]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()+1]; 

			var getSegment= getSegmentsAfter(msg, msg.children()[seg.childIndex()],&apos;OBR&apos;,false,&apos;OBR&apos;);
			if(debug&gt;0) logger.error(&apos;TEST::&apos;+scriptName+&apos; OBR getSegment typeof: &apos;+typeof(getSegment)+&apos; index: &apos;+[seg.childIndex()]+&apos; value: &apos;+getSegment);
			delete msg.children()[seg.childIndex()]; 
			
		} // end if 
		
	} // end for each

	channelMap.put(&apos;specimenDetected&apos;,detected); // true, false, invalid
	channelMap.put(&apos;modified_msg&apos;,msg);

	channelMap.put(&apos;obsvDisallowedObservations&apos;,disallowedObservations);
	channelMap.put(&apos;obsvAllowedObservations&apos;,allowedObservations);
	
	
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; specimenDetected: &apos;+$c(&apos;specimenDetected&apos;));
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg: &apos;+$c(&apos;modified_msg&apos;));
	} // end if 
	
	return msg;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>a5f6198b-5582-4183-be32-759a1508f7b6</id>
            <name>write_msg_to_disk</name>
            <revision>18</revision>
            <lastModified>
              <time>1666983371379</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	This script is used to write a message to a local system destination folder

	@param {String} arg1 - arg1 description
	@return {String} return description
	e.g., write_msg_to_disk($(&apos;rawhl7&apos;),api_error_directory,$(&apos;ark_uuid&apos;));
	History:
	2022-10-28 JER - Modified to make destinationFile String() and then modify FileUtils.write using java.lang.String, boolean, java.lang.String corresponding to 
	public static void write(java.lang.String fileName,boolean append,java.lang.String data)
	https://javadocs.mirthcorp.com/connect/3.12.0/user-api/com/mirth/connect/server/userutil/FileUtil.html
*/
function write_msg_to_disk(msg, destinationFileDirectory, uuid) {

	var scriptName= &apos;write_msg_to_disk&apos;;
	var debug= 0;

	try {
		var destinationFilename= uuid+&apos;.err&apos;;
		var error_hl7_msg= msg;
		var destinationFile= destinationFileDirectory+&apos;\\&apos;+destinationFilename;

		if(debug&gt;0) {
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; destinationFileDirectory: &apos;+destinationFileDirectory);
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; destinationFilename: &apos;+destinationFilename);
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; error_hl7_msg: &apos;+error_hl7_msg);
		} // end if 
		
		// org.apache.commons.io.FileUtils.write(new java.io.File(destinationFileDirectory+&apos;\\&apos;+destinationFilename),false,error_hl7_msg);
		// org.apache.commons.io.FileUtils.write(String(destinationFile),boolean(false),String(error_hl7_msg));
		FileUtil.write(java.lang.String(destinationFile),false,java.lang.String(error_hl7_msg));
		
		return true;
	
	} catch (e) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; ERROR: &apos;+e);
		return false;
	} // end try
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>e9723fd9-6316-42f1-bc83-ad658b2abc7c</id>
            <name>write_msg_to_file</name>
            <revision>2</revision>
            <lastModified>
              <time>1670428915677</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	This script is used to write a message to a destination file providing both a destination folder and the fileName
	
	@param {String} args: 	msg - java.lang.String
							destinationFilename - java.lang.String
							destinationFileDirectory - java.lang.stringify
							append - java.lang.Boolean
							debug - java.lang.Boolean
	@return {boolean} - 	java.lang.boolean;  FileUtil.write success (return true|false)
	Desc:   If append parameter is not provided or has no value the default action is to overwrite the provided file.
	e.g., write_msg_to_file($(&apos;raw&apos;),destinationFilename, destinationFileDirectory);
	History:
	2022-12-06 JER - Modified to include the append and debug parameter arguments to designate whether to overwrite (append= false) or append (append= true) or required to leverage debug statements (debug= true|false)
	2022-10-28 JER - Modified to make destinationFile String() and then modify FileUtils.write using java.lang.String, boolean, java.lang.String corresponding to 
	public static void write(java.lang.String fileName,boolean append,java.lang.String data)
	http://javadocs.mirthcorp.com/connect/3.9.0/user-api/com/mirth/connect/server/userutil/FileUtil.html
*/
function write_msg_to_file(msg, destinationFilename, destinationFileDirectory, append, debug) {

	var scriptName= &apos;write_msg_to_file&apos;;
	if((typeof(debug)== &apos;undefined&apos;)||(debug.toString.length&lt;1)) {
		var debug= false;
	}
	if((typeof(append)== &apos;undefined&apos;)||(append.toString().length&lt;1)) {
		var append= false;  // default overwrite
	} // end if 
	
	try {
		// var destinationFilename= uuid+&apos;.err&apos;;
		var error_msg= msg;
		var destinationFile= destinationFileDirectory+&apos;\\&apos;+destinationFilename;

		if(debug&gt;0) {
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; destinationFileDirectory: &apos;+destinationFileDirectory);
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; destinationFilename: &apos;+destinationFilename);
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; error_msg: &apos;+error_msg);
			logger.error(&apos;DEBUG::&apos;+scriptName+&apos; append: &apos;+append);
		} // end if 
		
		// org.apache.commons.io.FileUtils.write(new java.io.File(destinationFileDirectory+&apos;\\&apos;+destinationFilename),false,error_msg);
		// org.apache.commons.io.FileUtils.write(String(destinationFile),boolean(false),String(error_msg));
		
		// 2022-12-07 JER - Modified to leverage the append parameterized variable
		// com.mirth.connect.server.userutil.FileUtil.write(java.lang.String(destinationFile),false,java.lang.String(error_msg));
		FileUtil.write(java.lang.String(destinationFile),append,java.lang.String(error_msg));
		return true;
	
	} catch (e) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; ERROR: &apos;+e);
		return false;
	} // end try
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>0e6800ae-6d84-4245-9e09-2c1a2f28d8fc</id>
        <name>WebPT-Common</name>
        <revision>2</revision>
        <lastModified>
          <time>1678715257049</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>43f73dbc-f73d-4178-9aa0-b451c05922e2</id>
            <name>Check if String contains</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122790</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>COMPILED_CODE</type>
              <code>/**
	To verify if one string (source) contains another string (target).

	@param {String} arg1 - target string to lookup in the source string
	@return {String} return true if the source string contains the target string
*/
String.prototype.contains = function(arg1) {
	
	return this.indexOf(arg1) &gt; -1;
		
};</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>6a420042-a38d-4d6b-8567-d0290086256a</id>
            <name>Check if String contains HTTP code</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122593</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>COMPILED_CODE</type>
              <code>/**
	To verify if the given string contains HTTP status code.

	@param - no parameter
	@return {String} return true if the string contains the HTTP status code, false otherwise
*/

function isHttpCode2xx(arg1) {
	var code2xx = [&apos;200&apos;,&apos;201&apos;,&apos;202&apos;,&apos;203&apos;,&apos;204&apos;,&apos;205&apos;,&apos;206&apos;,&apos;207&apos;,&apos;208&apos;];	
	var length = code2xx.length;
	
	while(length--) {
   		if (arg1.indexOf(code2xx[length]) &gt; -1) {
       		return true;
   		}   		
	}
	return false;
}

function isHttpCode4xx(arg1) {
	var code4xx = [&apos;400&apos;,&apos;401&apos;,&apos;402&apos;,&apos;403&apos;,&apos;404&apos;,&apos;405&apos;,&apos;406&apos;,&apos;407&apos;,&apos;408&apos;,&apos;409&apos;,&apos;410&apos;,&apos;411&apos;,&apos;412&apos;,&apos;413&apos;,&apos;414&apos;,&apos;415&apos;,&apos;416&apos;,&apos;417&apos;,&apos;429&apos;,&apos;431&apos;,&apos;451&apos;];	
	var length = code4xx.length;
	
	while(length--) {
   		if (arg1.indexOf(code4xx[length]) &gt; -1) {
       		return true;
   		}   		
	}
	return false;
}

function isHttpCode5xx(arg1) {
	var code5xx = [&apos;500&apos;,&apos;501&apos;,&apos;502&apos;,&apos;503&apos;,&apos;504&apos;,&apos;505&apos;,&apos;506&apos;,&apos;510&apos;,&apos;511&apos;];	
	var length = code5xx.length;
	
	while(length--) {
   		if (arg1.indexOf(code5xx[length]) &gt; -1) {
       		return true;
   		}   		
	}
	return false;
}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>8515e088-5c50-47ee-9e2f-9fad1ecf48bd</id>
            <name>Check if String is JSON</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123309</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Added by Kirby Knight
	12/21/2020
	Test for JSON

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function isJson(str) {
    try {
        JSON.parse(str);
    } catch (e) {
        return false;
    }
    return true;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>5f2f84ba-3e66-4be3-8260-8fbd8258bd92</id>
            <name>Check if the PDF is valid</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122055</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
//This function is used for checking the word &quot;PDF&quot; in inbound attachment.
function isValidBase64PDF(base64) {
	const ENCODED_PDF_SIGN = &quot;JVBERi&quot;; // %PDF sign
	const PDF_EOF = &quot;JSVFT0YNCg&quot;; // %EOF
	var pdfBase64Size = (base64.length() * (3 / 4)) - 1;
	
	return (base64.indexOf(ENCODED_PDF_SIGN) != -1 &amp;&amp; base64.indexOf(PDF_EOF) != -1 &amp;&amp; pdf_base64_size &gt; 36);
}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>42dbc1c3-72e4-4ece-a6b8-5cd188446027</id>
            <name>Convert JSON date to HL7v2 date</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122137</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	To convert JSON date/time format to HL7v2 date only format.

	@param {String} datetime - JSON date/time (yyyy-MM-ddThh:mm:ss.sss-00:00) or (yyyy-MM-dd)
	@return {String} return HL7v2 date (yyyyMMdd)
*/
function convertToHL7v2Date(datetime) { 

	var date = datetime.toString().match(/\d{4}\-\d{2}\-\d{2}/);
	return ((date.length &gt; 0) ? date[0].replace(/\-/g,&apos;&apos;) : date.replace(/\-/g,&apos;&apos;));
	
};</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>5b60cf28-571b-4aa8-94fe-d3cdf069471b</id>
            <name>Convert JSON datetime to HL7v2 datetime</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122430</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	To convert JSON date/time format to HL7v2 date only format.
	Possible formats:
	&quot;2016-01-01T00:00:00.000Z&quot;	JavaScript built-in JSON object
	&quot;2016-01-01T00:00:00-00:00&quot;	ISO 8601

	@param {String} datetime - JSON date/time with offset (yyyy-MM-ddThh:mm:ss.sss-/+00:00) or (yyyy-MM-dd)
	@return {String} return HL7v2 DTM date type
*/
function convertToHL7v2DateTime(datetime) { 

	var date = [];
	var hl7Date = &quot;&quot;;
	var timeZome = &quot;&quot;;

	if (datetime.indexOf(&quot;T&quot;) &gt; -1) {

		var zone = datetime.toString().slice(datetime.indexOf(&quot;T&quot;) + 1);
		if (zone.indexOf(&quot;+&quot;) &gt; 0) timeZone = &quot;+&quot;;
		if (zone.indexOf(&quot;-&quot;) &gt; 0) timeZone = &quot;-&quot;;

		if (datetime.indexOf(&quot;Z&quot;) &gt; 0) {
			date = datetime.toString().split(/\-|\+|T|:|\./g);
		} else {
			date = datetime.toString().split(/\-|\+|T|:/g);
		}
		
		for (var i=0; i &lt; 6; i++) {			
			hl7Date += date[i]; 
		}
		
		var offset = date.slice(6);
		for (var i=0; i &lt; offset.length; i++) {
			timeZone += offset[i];
		}

		return hl7Date + timeZone;

	} else {
		return convertToHL7v2Date(datetime);
	}
};</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>bb21449a-df39-48c6-be52-24106c8df4c4</id>
            <name>Destination Formatting</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122703</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Kirby Knight 03/10/2021
	
	This function will remove all other ROOT.Meta.Destinations nodes that are not passed in the
	destination variable and removes the ROOT.Meta.Destinations[x].Destination node

	@param {Any} destination - 
	@return {String} return description
*/
function formatDestinations(destination) {
var arrDestinations = msg[&apos;Meta&apos;][&apos;Destinations&apos;];
	//  Start at the end of the array because of the posibility of deleted array items 
	for (var i = arrDestinations.length - 1; i &gt;= 0; i--) {
		if (arrDestinations[i][&apos;Destination&apos;] == destination){
			delete arrDestinations[i][&apos;Destination&apos;]
		}else if (arrDestinations[i][&apos;Destination&apos;] != destination){
			arrDestinations.splice(i, 1);
		}
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>d014f2fc-cf80-47ad-9de8-6c84807e2f70</id>
            <name>Extract JSON node data</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121748</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Validates if node is not NULL or &quot;undefined&quot;. If the given node is an array, return a string of values.

	@param {String} node - node to extract the data from
	@return {String} return given node value or empty string if such node does not exist
*/
function extract(node) {

	try {
		var result = &quot;&quot;;

		if (null == node) return result;
		
		if ((typeof node) !== &quot;undefined&quot;) {

			if (Object.prototype.toString.call(node) === &apos;[object Array]&apos;) {
				result = org.apache.commons.lang3.StringUtils.join(node, &quot; &quot;)
			} else 
				result = node;
		}
	} finally {
		return result.toString().trim();
	}
}

</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>7ed44f8a-fa40-4f3e-9426-3021604eabe0</id>
            <name>Get Feature Value by Name and Database</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123262</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Returns a string containing the feature value (system property) for a specific client database.

	@param {String} featureName - name of the feature, ie: &quot;BetterPTBidirectionalScheduling&quot;
	@param {String} databaseIdentifier - database name or databaseID / TenantID
	@param {String} databaseIdentifierType - what value is provided in databaseIdentifier. current options include &quot;ID&quot; or &quot;NAME&quot;
	@return {String} returns feature value
*/
function getFeatureValueByNameDatabase(featureName, databaseIdentifier, databaseIdentifierType) {
	var paramList = new Packages.java.util.ArrayList();
	paramList.add(featureName);
	paramList.add(databaseIdentifier);
	paramList.add(databaseIdentifierType);
	
	var sSQL = &apos;EXEC [dbo].[pr_FeatureValueByNameDatabase] ?, ?, ?&apos;;
	
	try {
		var result = executeSharedDBStatementFhirCh(sSQL, true, paramList);
		var featureValue ;
		if(result.next()){			//Added
		 featureValue = result.getString(1);
		}
		return featureValue;
	} catch (e) {
		logger.error(e);
	}
}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>9842be2c-c633-42ac-87f1-f91aca9e370f</id>
            <name>JSON Patient IDs</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121776</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	This function populates the MR and PI patient IDS to channelMap

	@return {String} return description
*/
function jsonPatientIds() {
	for each (patId in msg[&apos;Patient&apos;][&apos;Identifiers&apos;]) {
	if (patId[&apos;IDType&apos;].toString() == &apos;MR&apos;){
		channelMap.put(&apos;extPatId&apos;, patId[&apos;ID&apos;].toString());
	}else if(patId[&apos;IDType&apos;].toString() == &apos;PI&apos;){
		channelMap.put(&apos;patId&apos;, patId[&apos;ID&apos;].toString());
	}
}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>a3f85cc2-9b95-45a9-9cb1-937197e09cdc</id>
            <name>Verify JSON node for existance</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122542</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Verify if the given node exists.

	@param {String} node - node to verify for existance
	@return {String} return true if the given node exists, false otherwise
*/
function keyExists(node) {
	return ( ((typeof node) !== &quot;undefined&quot;) &amp;&amp; ((typeof node) !== null) );
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>394664c0-d536-4310-970e-181dc03ee7da</id>
        <name>WebPT-Conversions</name>
        <revision>2</revision>
        <lastModified>
          <time>1690140133427</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>8664ea57-77f2-481d-8f1c-9b45761285e8</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>2d61ede3-55be-462f-b71c-d7ecc67baabd</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>2a908305-89cf-4e4f-9a66-c6fed1e9d976</string>
          <string>c74d49f9-3866-495c-a5b4-90cb4754c6f8</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>ace8b46e-8a2f-490e-afd1-24202f8b4b17</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>cdfecd0a-b177-441d-8b7e-9c239d4a5816</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>73070cc2-f8a4-46a8-8d28-a1c1d4648520</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>c3882ee4-e2e6-47c6-8da9-801a847e0459</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>3a388aa0-c0ba-460c-b790-1c42c081c84d</id>
            <name>Convert FHIR codes to HL7v2 codes</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122899</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Map FHIR codes to corresponding HL7v2.6 codes using the Table number.

	@param {String} FhirCode - FHIR code
	@param {String} tableName - HL7v2.6 Table Name	
	@return {String} return corresponsing HL7v2.6 code if known or &quot;Unknown&quot; result
*/
function convertToHL7v2Table(FhirCode,tableNumber) {

	var code = &apos;&apos;;
	if (&apos;undefined&apos; !== typeof FhirCode &amp;&amp; null !== FhirCode) {
		code = FhirCode.toString().toLowerCase();	
	}
	

	switch(tableNumber) {
		case &quot;0001&quot;:
			if (&apos;female&apos; == code || &apos;f&apos; == code) return &apos;F&apos;; else
			if (&apos;male&apos; == code || &apos;m&apos; == code) return &apos;M&apos;; else
			if (&apos;other&apos; == code) return &apos;O&apos;; else
			return &apos;U&apos;; 			
		break;

		case &quot;0004&quot;:
			// http://hl7.org/fhir/encounter-class
			if (&apos;emergency&apos; == code) return &apos;E&apos;; else				
			if (&apos;inpatient&apos; == code) return &apos;I&apos;; else
			if (&apos;outpatient&apos; == code) return &apos;O&apos;; else
			return &quot;U&quot;;
		break;

		case &quot;0190&quot;:
			// http://hl7.org/fhir/ValueSet/address-type
			if (&apos;postal&apos; == code) return &apos;H&apos;; else				
			if (&apos;physical&apos; == code) return &apos;P&apos;; else
			if (&apos;both&apos; == code) return &apos;H&apos;; else
			return &quot;M&quot;;
		break;		

		case &quot;0201&quot;:
			// http://hl7.org/fhir/ValueSet/contact-point-use
			if (&apos;home&apos; == code) return &apos;PRN&apos;; else				
			if (&apos;work&apos; == code) return &apos;WPN&apos;; else
			if (&apos;mobile&apos; == code) return &apos;PRS&apos;; else
			if (&apos;temp&apos; == code) return &apos;TMP&apos;; else			
			if (&apos;old&apos; == code) return &apos;OLD&apos;; else
			return &quot;PRN&quot;;
		break;	

		case &quot;0202&quot;:
			// http://hl7.org/fhir/contact-point-system
			if (&apos;phone&apos; == code) return &apos;PH&apos;; else				
			if (&apos;fax&apos; == code) return &apos;FX&apos;; else
			if (&apos;pager&apos; == code) return &apos;BP&apos;; else
			if (&apos;email&apos; == code) return &apos;Internet&apos;; else
			return &quot;PH&quot;;
		break;	

		case &quot;0063&quot;:
			// http://hl7.org/fhir/ValueSet/patient-contact-relationship
			// (SN) Partial list
			if (&apos;parent&apos; == code) return &apos;PAR&apos;; else
			if (&apos;MTH&apos; == code) return &apos;MTH&apos;; else
			if (&apos;FTH&apos; == code) return &apos;FTH&apos;; else	
			if (&apos;caregiver&apos; == code) return &apos;CGV&apos;; else
			if (&apos;SPS&apos; == code) return &apos;SPO&apos;; else
			if (&apos;CHILD&apos; == code) return &apos;CHD&apos;; else
			if (&apos;GRNDCHILD&apos; == code) return &apos;GCH&apos;; else
			if (&apos;GRPRN&apos; == code) return &apos;GRP&apos;; else
			if (&apos;SIB&apos; == code) return &apos;SIB&apos;; else
			if (&apos;BRO&apos; == code) return &apos;BRO&apos;; else
			if (&apos;SIS&apos; == code) return &apos;SIS&apos;; else
			if (&apos;friend&apos; == code) return &apos;FND&apos;; else
			if (&apos;ONESELF&apos; == code) return &apos;SEL&apos;; else
			if (&apos;emergency&apos; == code) return &apos;EMC&apos;; else
			return &apos;UNK&apos;;		
		break;
		default:
			return &apos;U&apos;;
	}


}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>2fc8cbf3-0d92-4d1d-a3d6-136c09bd9f2a</id>
        <name>WebPT-Custom Database Functions</name>
        <revision>5</revision>
        <lastModified>
          <time>1703964939898</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>b19c96b2-afb4-4248-83a8-96f521b20489</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>ed58a744-1f83-44aa-ad23-feef56e2f5e6</string>
          <string>4a98f7b0-d1f3-478d-ad65-550f8287fe24</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>5cc5d7df-228a-4d24-b774-681c717e1876</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>5c763fad-3eae-4e87-b944-0dbfe25814e0</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>2e0d9b6c-294f-4506-8632-dc4622b4f651</string>
          <string>d3f6504f-12cd-4e69-a920-6bb3a2195cc2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>57fa694a-2758-4e52-b725-967a74786d1f</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>6be39ce0-8f88-42fb-b3a4-4afd4da39734</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>8cbc4731-752e-4e2e-a61d-018ed3e0cef0</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>93f57fef-8fc0-4b05-91de-b1cdb48034a2</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>23c0b510-63e4-40fa-a4e1-7b2b92ce9a96</id>
            <name>Execute Statement Shared DB Conn clientDb Ch</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122401</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Executes a SQL statement using a shared database connection stored in the Global Map. If the
connection does not exist, creates it.

@param {String} statement - The SQL statement to execute
@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
@param {List} paramList - A Java List object containing the parameters for the statement (optional)
 */
function executeSharedDBStatementclientDbCh(statement, isQuery, paramList) {
    var result;

    try {
        var dbConnclientDbCh = globalChannelMap.get(&quot;dbConnclientDbCh&quot;);

        if (dbConnclientDbCh == null || dbConnclientDbCh.getConnection().isClosed()) {
            dbConnclientDbCh = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;), $(&apos;dbClient&apos;), $(&apos;dbUserFhir&apos;), $(&apos;dbPwFhir&apos;));
            globalChannelMap.put(&quot;dbConnclientDbCh&quot;, dbConnclientDbCh);
        }

        if (paramList == undefined) {
            paramList = new Packages.java.util.ArrayList();
        }

        if (isQuery) {
            result = dbConnclientDbCh.executeCachedQuery(statement, paramList);
        } else {
            result = dbConnclientDbCh.executeUpdate(statement, paramList);
        }
    } catch (e) {
        logger.error(e);
    }
    finally {
        return result;
    }
}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>4efb3110-a83f-48b5-93ad-79c847b51865</id>
            <name>Execute Statement Shared DB Conn clntAcl Ch</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123455</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Map. If the
	connection does not exist, creates it.

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement (optional)
*/
function executeSharedDBStatementClntAclCh(statement, isQuery, paramList)
{
	var result;

	try
	{
		var dbConnClntAclCh = globalChannelMap.get(&quot;dbConnClntAclCh&quot;);

		if (dbConnClntAclCh == null || dbConnClntAclCh.getConnection().isClosed())
		{
			dbConnClntAclCh = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),$(&apos;dbClntAcl&apos;),$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			globalChannelMap.put(&quot;dbConnClntAclCh&quot;, dbConnClntAclCh);
		}

		if (paramList == undefined)
		{
			paramList = new Packages.java.util.ArrayList();
		}

		if (isQuery)
		{
			result = dbConnClntAclCh.executeCachedQuery(statement, paramList);
		}
		else
		{
			result = dbConnClntAclCh.executeUpdate(statement, paramList);
		}
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>d96d45dd-57f7-4aa9-9bf4-e464d31b94c6</id>
            <name>Execute Statement Shared DB Conn FHIR</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121922</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Map. If the
	connection does not exist, creates it.

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement (optional)
*/
function executeSharedDBStatementFhir(statement, isQuery, paramList)
{
	var result;

	try
	{
		var dbConnFhir = globalMap.get(&quot;dbConnFhir&quot;);

		if (dbConnFhir == null || dbConnFhir.getConnection().isClosed())
		{
			dbConnFhir = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),$(&apos;dbUrlFhir&apos;),$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			globalMap.put(&quot;dbConnFhir&quot;, dbConnFhir);
		}

		if (paramList == undefined)
		{
			paramList = new Packages.java.util.ArrayList();
		}

		if (isQuery)
		{
			result = dbConnFhir.executeCachedQuery(statement, paramList);
		}
		else
		{
			result = dbConnFhir.executeUpdate(statement, paramList);
		}
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>6014068e-c021-4a38-9fa6-6f38f6a2cdab</id>
            <name>Execute Statement Shared DB Conn FHIR Ch</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123492</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Channel Map. If the
	connection does not exist, creates it.

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement (optional)
*/
function executeSharedDBStatementFhirCh(statement, isQuery, paramList)
{
	var result;

	try
	{
		var dbConnFhirCh = globalChannelMap.get(&quot;dbConnFhirCh&quot;);

		if (dbConnFhirCh == null || dbConnFhirCh.getConnection().isClosed())
		{
			dbConnFhirCh = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),$(&apos;dbUrlFhir&apos;),$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			globalChannelMap.put(&quot;dbConnFhirCh&quot;, dbConnFhirCh);
		}

		if (paramList == undefined)
		{
			paramList = new Packages.java.util.ArrayList();
		}

		if (isQuery)
		{
			result = dbConnFhirCh.executeCachedQuery(statement, paramList);
		}
		else
		{
			result = dbConnFhirCh.executeUpdate(statement, paramList);
		}
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>fbd5c4a1-b816-4496-acdf-067005f1d376</id>
            <name>Execute Statement Shared DB Conn Translations Ch</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123008</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Channel Map. If the
	connection does not exist, creates it.

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement (optional)
*/
function executeSharedDBStatementTranslationsCh(statement, isQuery, paramList)
{
	var result;

	try
	{
		var dbConnTranslationsCh = globalChannelMap.get(&quot;dbConnTranslationsCh&quot;);

		if (dbConnTranslationsCh == null || dbConnTranslationsCh.getConnection().isClosed())
		{
			dbConnTranslationsCh = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),$(&apos;dbUrlTranslations&apos;),$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			globalChannelMap.put(&quot;dbConnTranslationsCh&quot;, dbConnTranslationsCh);
		}

		if (paramList == undefined)
		{
			paramList = new Packages.java.util.ArrayList();
		}

		if (isQuery)
		{
			result = dbConnTranslationsCh.executeCachedQuery(statement, paramList);
		}
		else
		{
			result = dbConnTranslationsCh.executeUpdate(statement, paramList);
		}
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>5d1a5577-4ba4-4d1e-b6cd-e2d924164909</id>
            <name>Execute Statement with Shared DB Conn ODS Ch</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122280</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Channel Map. If the
	connection does not exist, creates it.

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement
		(optional)
	@return {Any} 
*/
function executeSharedDBStatementOdsCh(statement, isQuery, paramList)
{
	var result;

	try
	{
		var dbConnOdsCh = globalChannelMap.get(&quot;dbConnOdsCh&quot;);

		if (dbConnOdsCh == null || dbConnOdsCh.getConnection().isClosed())
		{
			dbConnOdsCh = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),$(&apos;dbUrlOds&apos;),$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			globalChannelMap.put(&quot;dbConnOdsCh&quot;, dbConnOdsCh);
		}

		if (paramList == undefined)
		{
			paramList = new Packages.java.util.ArrayList();
		}

		if (isQuery)
		{
			result = dbConnOdsCh.executeCachedQuery(statement, paramList);
		}
		else
		{
			result = dbConnOdsCh.executeUpdate(statement, paramList);
		}
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>3991db14-0c0b-4123-952c-5164c1ded501</id>
            <name>Execute Statement with Shared DB Conn ODW Ch</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122960</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Channel Map. If the
	connection does not exist, creates it.  THis connects to the ODW db in Azure

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement
		(optional)
	@return {Any} 
*/
function executeSharedDBStatementOdwCh(statement, isQuery, paramList)
{
	var result;

	try
	{
		var dbConnOdwCh = globalChannelMap.get(&quot;dbConnOdwCh&quot;);

		if (dbConnOdwCh == null || dbConnOdwCh.getConnection().isClosed())
		{
			dbConnOdwCh = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),$(&apos;dbUrlOdw&apos;),$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			globalChannelMap.put(&quot;dbConnOdwCh&quot;, dbConnOdwCh);
		}

		if (paramList == undefined)
		{
			paramList = new Packages.java.util.ArrayList();
		}

		if (isQuery)
		{
			result = dbConnOdwCh.executeCachedQuery(statement, paramList);
		}
		else
		{
			result = dbConnOdwCh.executeUpdate(statement, paramList);
		}
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>fae08c88-7550-479a-b8ed-ffef47e8eed9</id>
            <name>executeSharedDBStatementClient</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121956</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Executes a SQL statement using a shared database connection stored in the Global Map. If the
	connection does not exist, creates it.

	@param {String} statement - The SQL statement to execute
	@param {Boolean} isQuery - true if the statement is a SELECT, otherwise false
	@param {List} paramList - A Java List object containing the parameters for the statement (optional)
*/
function executeSharedDBStatementClient(statement, isQuery, paramList, dbname)
{
	var result;
 	var dburl= &apos;jdbc:sqlserver://AZW1DEV-SQL02.clinicient.com:1433;databaseName=&apos;+dbname+&apos;&apos;;
	try
	{
		var dbConnFhir = globalMap.get(&quot;dbConnFhir&quot;);

		if (dbConnFhir == null || dbConnFhir.getConnection().isClosed())
		{
			dbConnFhir = DatabaseConnectionFactory.createDatabaseConnection($(&apos;dbDriverMsSql&apos;),dburl,$(&apos;dbUserFhir&apos;),$(&apos;dbPwFhir&apos;));
			
			//globalMap.put(&quot;dbConnFhir&quot;, dbConnFhir);
		}

		result = dbConnFhir.executeCachedQuery(statement);
	
	}
	catch (e)
	{
		logger.error(e);
	}
	finally
	{
		return result;
	}
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>ed20a457-5beb-4aea-9bb9-cf91112ccc56</id>
        <name>WebPT-Default Functions</name>
        <revision>10</revision>
        <lastModified>
          <time>1690140133487</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>8664ea57-77f2-481d-8f1c-9b45761285e8</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>2d61ede3-55be-462f-b71c-d7ecc67baabd</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>2a908305-89cf-4e4f-9a66-c6fed1e9d976</string>
          <string>c74d49f9-3866-495c-a5b4-90cb4754c6f8</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>ace8b46e-8a2f-490e-afd1-24202f8b4b17</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>cdfecd0a-b177-441d-8b7e-9c239d4a5816</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>73070cc2-f8a4-46a8-8d28-a1c1d4648520</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>c3882ee4-e2e6-47c6-8da9-801a847e0459</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>a8a9a0c8-9322-46dc-bef8-011eb3d70291</id>
            <name>Create Header for CSV</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121678</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	This creates a header for csv files based on the contents of the header variable.  The header
	variable is populated in the channel from the outbound msg template

	@return {String} return description
*/
function createHeader() {
	//Destination transformer.  this creates the header for each new file

	var path = java.nio.file.Paths.get($(&apos;filePath&apos;)+$(&apos;fileName&apos;));
	var bytes = (new java.lang.String($(&apos;header&apos;))).getBytes(&quot;UTF-8&quot;);
	try {
	  java.nio.file.Files.write(path, bytes, java.nio.file.StandardOpenOption.CREATE_NEW);
	}
	catch (e) {
	  //logger.info(&quot; should throw IOException if file already exists&quot;);
	
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>5a886a1f-dab1-41b5-94c6-1a639907d7da</id>
            <name>Filter Message Evaluate Received Checksum</name>
            <revision>33</revision>
            <lastModified>
              <time>1678916806664</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**  This code works by calculating a checksum for each provided message.  We save off the most recent 100 unique checksum values in a global 
	array so if the current message has been recently received we are able to ignore it.
	
	@author:  	Jeffrey Ritz
	@scriptName: 	filterEvaluateReceivedChecksum.js
	@created: 	2023-03-09
	@param {object} msg - Inbound connectorMessage.getRawData()
	@param {boolean} filter - return filter boolean (true= filter msg, false= do not filter msg)
		persist received_checksum global ChannelMap array
		persist filterMessage ChannelMap variable
	@history
*/
function filterEvaluateReceivedChecksum(msg) {	

	var scriptName= &apos;filterEvaluateReceivedChecksum&apos;
	var filter = false;
	var received_len_limit = 999;
	var debug= 0;
	if(typeof(msg)=== &apos;object&apos;) var msg= JSON.stringify(msg);

	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; A msg typeof: &apos;+typeof(msg)+&apos; msg: &apos;+msg);
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; B connectorMessage.getRawData() typeof: &apos;+typeof(connectorMessage.getRawData())+&apos; msg: &apos;+connectorMessage.getRawData());
	} // end if 
	
	//calculate checksum for current message (ignoring MSH and ORC segments)
	var checksum = new java.util.zip.CRC32();
	// var dataBytes = new java.lang.String(connectorMessage.getRawData()).getBytes(&apos;UTF-8&apos;);
	// message = new String(message.getBytes(&quot;utf-8&quot;), &quot;utf-8&quot;);
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; C msg typeof: &apos;+typeof(msg)+&apos; msg: &apos;+msg);
	// var dataBytes = new java.lang.String(msg.getBytes(&apos;UTF-8&apos;));
	var dataBytes = new java.lang.String(msg).getBytes(&apos;UTF-8&apos;);
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; D dataBytes msg typeof: &apos;+typeof(dataBytes)+&apos; dataBytes: &apos;+dataBytes);

	// var messageObjectgetBytes= checksum.update(connectorMessage.getRawData().getBytes());
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; E msg typeof: &apos;+typeof(msg)+&apos; msg: &apos;+msg);
	var messageObjectgetBytes= checksum.update(dataBytes);

	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg typeof: &apos;+typeof(msg)+&apos; msg.getBytes(): &apos;+dataBytes);
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; messageObjectgetBytes typeof: &apos;+typeof(messageObjectgetBytes)+&apos; messageObjectgetBytes: &apos;+messageObjectgetBytes);
	} // end if 
	
	$c(&apos;checksum&apos;, checksum.getValue());
	
	//grab the global channel map variable holding the last X unique checksums that we&apos;ve received
	var received = $gc(&apos;received_checksums&apos;);
	
	if (received == undefined) {
		var received = new Array();
		received.push(checksum.getValue());
	} else {
		//check if we&apos;ve recently received this message, skip it if so
		if (received.indexOf(checksum.getValue()) &gt; -1) {
			filter = true;
		//we haven&apos;t seen it recently, so remember it and allow it through
		} else {
			var received_len = received.length;
			if (received_len &gt; received_len_limit) {
				//remove oldest/first entry, shift all entries forward, and add new entry to end
				received.shift();
				received[received_len_limit] = checksum.getValue();
			} else {
				//add new entry to end of array
				received[received_len] = checksum.getValue();
			} // end if 
		} // end if 
	} // end if 

	 //debug code
	/*for (x=0; x&lt;=received_len_limit; x++) {
		$c(&apos;received-&apos;+x, received[x]);
	} */

	$c(&apos;filterMessage&apos;,filter);
	$gc(&apos;received_checksums&apos;,received);

	return filter;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>fbd0484d-74a2-48e4-aedd-f97c2fcefa16</id>
            <name>Get Message Checksum</name>
            <revision>12</revision>
            <lastModified>
              <time>1678916806703</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**  This code works by calculating and reutrning a checksum for each provided message
	
	@author:  	Jeffrey Ritz
	@scriptName: 	getMessageChecksum.js
	@created: 	2023-03-09
	@param {object} msg - Inbound connectorMessage.getRawData()
	@param {object} result - return checksum value
	@history
	2023-03-15 JER - Modified to push in values into the arrChecksumValue new Array() to remove the exponential representation of the number value
*/
function getMessageChecksum(msg) {	

	var scriptName= &apos;getMessageChecksum&apos;;
	var debug= 0;
	if(typeof(msg)=== &apos;object&apos;) var msg= JSON.stringify(msg);
	
	//calculate checksum for current message (ignoring MSH and ORC segments)
	var checksum = new java.util.zip.CRC32();
	var dataBytes = new java.lang.String(msg).getBytes(&apos;UTF-8&apos;);
	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; D dataBytes msg typeof: &apos;+typeof(dataBytes)+&apos; dataBytes: &apos;+dataBytes);
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; E msg typeof: &apos;+typeof(msg)+&apos; msg: &apos;+msg);
	} // end if 
	var messageObjectgetBytes= checksum.update(dataBytes);

	if(debug&gt;0) {
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; msg typeof: &apos;+typeof(msg)+&apos; msg.getBytes(): &apos;+dataBytes);
		logger.error(&apos;DEBUG::&apos;+scriptName+&apos; messageObjectgetBytes typeof: &apos;+typeof(messageObjectgetBytes)+&apos; messageObjectgetBytes: &apos;+messageObjectgetBytes);
	} // end if 

	var checksumValue= checksum.getValue();
	// 2023-03-15 JER - Modified to push in values into the arrChecksumValue new Array() 
	var arrChecksumValue= new Array(); 
	arrChecksumValue.push(checksumValue);
	$c(&apos;checksum&apos;, arrChecksumValue);

	return checksumValue;

} // end function</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>91db9bd1-ca92-4dcc-bba4-e1ece603fc87</id>
            <name>Remove Child Object From Parent Object Json</name>
            <revision>22</revision>
            <lastModified>
              <time>1678916845037</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**  This function will remove a JSON child object and it&apos;s descendents from a parent object JSON
	
	@author:  	Jeffrey Ritz
	@scriptName: 	removeChildObjectFromParentObjectJson.js
	@created: 	2023-03-09
	@param {object} msg - Inbound connectorMessage.getRawData()
		{string} parentObject - place the name of the string to be designated as the parent object in the JSON
		{string} childObject  - place the name of the string to be designated as the child object to be deleted from the JSON
	@param {object} msg - return modified Json object msg excluding specified Json child object
	@history
*/
function removeChildObjectFromParentObjectJson(msg, parentObject, childObject) {
	
	var scriptName= &apos;removeChildObjectFromParentObjectJson&apos;;
	var debug= 0;

	//var strObjJson= JSON.parse(msg);
	var strObjJson= JSON.stringify(msg);
	
	//var objJson= JSON.parse(msg);
	var newParentObjects= new Object();
	var parentObjects= msg;
	var arrParentObjects= new Array();
	var arrTransactionObjects= new Array();

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof parentObjects: &apos;+typeof(parentObjects));
	for (var key in parentObjects) {
		if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; Parent Objects typeof key: &apos;+typeof(key)+&apos; key: &apos;+key);
		if(key== parentObject) {
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; Parent Objects typeof objJson[key]: &apos;+typeof(parentObjects[key])+&apos; parentObjects[key]: &apos;+JSON.stringify(parentObjects[key]));
			
			var newChildObjects= new Object();
			var childObjects= parentObjects[key];
			var arrChildObjects= new Array();
			
			for(var key2 in childObjects) {
				if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof key2: &apos;+typeof(key2)+&apos; key2: &apos;+key2+&apos; childObject: &apos;+childObject);
				for(var key3 in childObjects[key2]) {
					if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof key3: &apos;+typeof(key3)+&apos; key3: &apos;+key3+&apos; childObject: &apos;+childObject);
					if(key3== childObject) {
						var transactionObject= new Object();
						if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; childObject typeof: &apos;+typeof(childObjects[key2][key3])+&apos; childObject: &apos;+JSON.stringify(childObjects[key2][key3]));
						transactionObject.key= key3;
						transactionObject.value= childObjects[key2][key3];
						delete childObjects[key2][key3];
						if(debug&gt;0) logger.info(&apos;DEBUG::&apos;+scriptName+&apos; DELETE childObject: &apos;+key3+&apos; of parentObject: &apos;+JSON.stringify(childObjects[key2]));
						arrTransactionObjects.push(transactionObject);
					} // end if
				} // end for 
				arrChildObjects.push(childObjects[key2]);
			} // end for
			newParentObjects[key]= arrChildObjects;
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; Add all child keys: &apos;+JSON.stringify(arrChildObjects)+&apos; into ParentObject[&apos;+key+&apos;]: &apos;+newParentObjects[key]);
		} else {
			newParentObjects[key]= parentObjects[key];
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; Add key: &apos;+key+&apos; object: &apos;+parentObjects[key]+&apos; string: &apos;+JSON.stringify(parentObjects[key]));
		} // end if
		arrParentObjects.push(newParentObjects);
	} // end for 
	var newMsg= arrParentObjects;
	channelMap.put(&apos;removeChildObjectMsg&apos;,newMsg);
	channelMap.put(&apos;removedChildTransIds&apos;,arrTransactionObjects);
	
	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; AFTER msg: &apos;+JSON.stringify(newMsg));
	return newMsg;
	
} </code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>2ff28338-dfb6-445d-a04e-c74b5486a08c</id>
            <name>Remove Object From Json</name>
            <revision>26</revision>
            <lastModified>
              <time>1703964988318</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**  Desc: This function will remove a JSON object and it&apos;s descendents from the msg
	
	fileName: 	removeObjectFromJson.js
	name:		Remove Object From Json	
	Authored:  	Jeffrey Ritz
	Created: 		2023-03-09
	Details:
		@param IN {string} msg - provide parent JSON object (i.e. Inbound connectorMessage.getRawData() - msg)
		@param IN {string} removeObject - provide JSON object to evaluate and remove from parent JSON object (msg)
		OUT (object) newMsg - return JSON object from processing
	@history
	2023-03-15 JER - Modified to include removeObject function parameter to specify specific JSON object by referencing key to be removed
*/
function removeObjectFromJson(msg, removeObject) {
	
	var scriptName= &apos;removeObjectFromJson&apos;;
	var debug= 0;
	//var objJson= JSON.stringify(msg);
	var objJson= JSON.parse(msg);
	var newObjJson= new Object();

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; typeof objJson: &apos;+typeof(objJson)+&apos; objJSON: &apos;+JSON.stringify(objJson));
	for (var key in objJson) {
		if(key== removeObject) {
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; DELETE key: &apos;+key);
			// delete objJson[key];
		} else {
			newObjJson[key]= objJson[key];
			if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; Add key: &apos;+key+&apos; object: &apos;+objJson[key]+&apos; string: &apos;+JSON.stringify(objJson[key]));
		} // end if 
	} // end for 
	var newMsg= newObjJson;

	if(debug&gt;0) logger.error(&apos;DEBUG::&apos;+scriptName+&apos; AFTER msg: &apos;+JSON.stringify(newMsg));

	// return JSON.stringify(newMsg);
	return newMsg;
} 
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>993a6fd8-454a-4133-ba32-dbcfea71582b</id>
            <name>Update EDITransactionLog</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123233</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	The purpose of this function is to update the status in Insight.
	Populate the channel map with the following variables functionalGroupControlNumber, status, eventDate

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function updateStatus () {

	//  Build the llst of paramters to pass to the database
	var paramList = new Packages.java.util.ArrayList();
	paramList.add($(&apos;functionalGroupControlNumber&apos;));
	paramList.add($(&apos;eventDate&apos;));  //dateTime in the acknoledged field in this format (&quot;2017-07-31 14:15:01.577&quot;)
	paramList.add(new java.lang.Integer(parseInt($(&apos;status&apos;), 10)));
	
//	logger.info(&quot;updateStatus &quot;+paramList);

	//  SQL Statement and paramters that will be sent to SQL
	var statement = &quot;EXEC dbo.pr_EDITransactionLog_Update ?, ?, ?&quot;;
	//  Code template used for establishiing connection and passing the sql statement and parameter list  
	var result = executeSharedDBStatementFhirCh(statement, false, paramList);
	return result;
	
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>42cb290e-5fb0-46b8-82db-576ea1e1ba0d</id>
            <name>Update EDITransactionLog from responseStatus in the response transformer </name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123356</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Call this in the response transformer on the destination.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function updateReponseStatus() {
	var status = 0;
	if (responseStatus == SENT){
		var status = 1;
		channelMap.put(&apos;status&apos;,status);
	}

updateStatus()
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>2223579b-f914-4be7-a575-f1a2a2aa1ae2</id>
            <name>ValidateToString</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123044</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {Any} mapping - 
	@param {Any} defaultValue - 
	@param {Any} replacement - 
	@return {String} return description
*/
function validateToString(mapping, defaultValue, replacement) {
    if (mapping == null) {
        mapping = &apos;&apos;;
    }
    return validate(mapping, defaultValue, replacement).toString() + &apos;&apos;;
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>8c9a8268-4ef0-43e9-ae5b-bf8895f0b80c</id>
        <name>WebPT-FORMAT</name>
        <revision>4</revision>
        <lastModified>
          <time>1703964939902</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description>Include any functions or codes with 
-date &amp; time formating related
-data type formatting</description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>b19c96b2-afb4-4248-83a8-96f521b20489</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>ed58a744-1f83-44aa-ad23-feef56e2f5e6</string>
          <string>4a98f7b0-d1f3-478d-ad65-550f8287fe24</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>5cc5d7df-228a-4d24-b774-681c717e1876</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>5c763fad-3eae-4e87-b944-0dbfe25814e0</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>2e0d9b6c-294f-4506-8632-dc4622b4f651</string>
          <string>d3f6504f-12cd-4e69-a920-6bb3a2195cc2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>57fa694a-2758-4e52-b725-967a74786d1f</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>6be39ce0-8f88-42fb-b3a4-4afd4da39734</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>8cbc4731-752e-4e2e-a61d-018ed3e0cef0</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>93f57fef-8fc0-4b05-91de-b1cdb48034a2</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>920c9ead-70a6-4168-9d95-89261b73ae44</id>
            <name>12digitDateTime</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123520</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
Take any 12 digit string yyyyMMddHHmm and change to MM/dd/yyyy HH:mm 

	@param {String} arg1 - date and time digit string
	@return {String} return human readable format MM/dd/yyyy HH:mm
*/
function yyyyMMddHHmm(string) {
	return DateUtil.convertDate(&quot;yyyyMMddHHmm&quot;, &quot;MM/dd/yyyy HH:mm&quot;, string);
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>fe2689ec-1946-46d5-8dd6-8fbbf106e1e6</id>
            <name>14digitDateTime</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122871</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
    Take 14 digit string yyyyMMddHHmmss and change to MM/dd/yyyy HH:mm:ss 

	@param {String} arg1 - date and time digit string
	@return {String} return human readable format MM/dd/yyyy HH:mm:ss
*/
function yyyyMMddHHmmss(string) {
	if (string.length == 14) {
		  return DateUtil.convertDate(&quot;yyyyMMddHHmmss&quot;, &quot;MM/dd/yyyy HH:mm:ss&quot;, string);
	}
	else {
		return &quot;unregcognized string&quot;;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>b9db35e2-d5bd-48a1-8cc6-3475c698d7b4</id>
            <name>currentDT_yyyy-MM-dd HH:mm:ss.SSS</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123114</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Author: Kirby Knight
	Date Modified:  11/09/2020
	Retund the current date/time down to the millisecond

	@return {String} return description
*/
function currentDtToMilliseconds() {
	return DateUtil.getCurrentDate(&apos;yyyy-MM-dd HH:mm:ss.SSS&apos;);
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>7e747999-4bec-43fc-978d-7049d3543cf0</id>
            <name>fixHL7NodeOrder</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123155</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Author: Nick Rupley
	Date Modified: 4/18/2012

	fixHL7NodeOrder: Returns a new E4X node where the order of all siblings and descendants have been fixed as per the Mirth HL7 dot notation convention.

	Arguments
	---------
		Required
		--------
		node: The node to be fixed. 
*/

function fixHL7NodeOrder(node) {
	// Create output node
	var newNode = new XML();
	// In case the node is an XMLList of multiple siblings, loop through each sibling
	for each (sibling in node) {
		// Create new sibling node
		var newSibling = new XML(&apos;&lt;&apos;+sibling.name().toString()+&apos;/&gt;&apos;);
		// Iterate through each child node
		for each (child in sibling.children())
			// If the child has its own children, then recursively fix the node order of the child
			if (child.hasComplexContent())
				newSibling.appendChild(fixHL7NodeOrder(child));
			// If the child doesn&apos;t have its own children, then just add the child to the new sibling node
			else
				newSibling.appendChild(child);
		// After recursively fixing all of the child nodes, now we&apos;ll fix the current node
		newNode += sortHL7Node(newSibling);
	}
	// Return the fixed node
	return newNode;
}

// Helper function for fixHL7NodeOrder
function sortHL7Node(node) {
	// If the node has no children, then there&apos;s nothing to sort
	if (node.hasSimpleContent())
		return node;
	// Create new output node
	var newNode = new XML(&apos;&lt;&apos;+node.name().toString()+&apos;/&gt;&apos;);
	// Iterate through each child in the node
	for each (child in node.children()) {
		// If the child has a QName, then we can sort on it
		if (child.name()) {
			// Get the current &quot;index&quot; of the child. Id est, if the QName is PID.3.1, then the index is 1
			curChildIndex = parseInt(child.name().toString().substring(child.name().toString().lastIndexOf(&apos;.&apos;)+1),10);
			// Boolean placeholder
			var inserted = false;
			// Iterate through each child currently in the NEW node
			for (var i = 0; i &lt;= newNode.children().length()-1; i++) {
				// Get the index of the child of the new node
				loopChildIndex = parseInt(newNode.child(i).name().toString().substring(newNode.child(i).name().toString().lastIndexOf(&apos;.&apos;)+1),10);
				// If the child we want to insert has a lower index then the current child of the new node, then we&apos;re going to insert the child 
				// right before the current newNode child
				if (curChildIndex &lt; loopChildIndex) {
					// Insert the child
					newNode.insertChildBefore(newNode.children()[i],child);
					// Set our flag, indicating that an insertion was made
					inserted = true;
					// No need to continue iteration
					break;
				}
			}
			// If no insertion was made, then the index of the child we want to insert is greater than or equal to all of the
			// indices of the children that have already been inserted in newNode. So, we&apos;ll just append the child to the end.
			if (!inserted)
				newNode.appendChild(child);
		}
	}
	// Return the sorted HL7 node
	return newNode;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>dfedacf6-773b-413e-b78d-1bf16a92071d</id>
            <name>formatHL7Date</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121643</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Take any eight digit HL7 message data string (yyyyMMdd) and formats it human-readable format (MM/dd/yyyy)
	such as 20090612 -&gt; 06/12/2009

	@param {String} arg1 - 8 digit HL7 message data string yyyyMMdd
	@return {String} return date format as MM/dd/yyyy
*/
function formatHL7Date(string) {
	return DateUtil.convertDate(&quot;yyyyMMdd&quot;, &quot;MM/dd/yyyy&quot;, string);
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>a8f54921-2cb6-4134-8806-3c4e10a757d9</id>
            <name>getCurrentLocalTime</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122014</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	tmp[&apos;MSH&apos;][&apos;MSH.7&apos;][&apos;MSH.7.1&apos;] = getCurrentLocalTimestamp();

	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function getCurrentLocalTimestamp() {
   var formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyyMMddhhmmss&quot;); 
   // your local TZ
   formatter.setTimeZone(Packages.java.util.TimeZone.getTimeZone(&quot;EST&quot;)); 
   return formatter.format(new Packages.java.util.Date()); 
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>6c5f1bd8-ebbf-4c8e-b465-0be8ccaba0d0</id>
            <name>getCurrentLocalTimeToMs</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476123077</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**

	Gets the current local date/time to the milliseconds
	Converts to the timezone that is passed in Examples (America/New_York, America/Chicago, America/Phoenix )

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function getCurrentLocalTimestampToMs(timeZone) {
   var formatter = new Packages.java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); 
   // your local TZ
   formatter.setTimeZone(Packages.java.util.TimeZone.getTimeZone(timeZone)); 
   return formatter.format(new Packages.java.util.Date()); 
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>78d74c5b-c881-404a-ad96-4e909e1a19f3</id>
            <name>phoneToE164</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121982</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Convert Insight phone number to E164 format 5554446666 to +15554446666

	@param {Any} phoneIn - 
	@return {String} return description
*/
function phoneToE164(phoneIn) {
	logger.info(&apos;L1 &apos;+phoneIn);
	if(phoneIn != null ){
	//phoneIn = &apos;+1&apos; + phoneIn.toString(); 
	logger.info(&apos;L2 &apos;+phoneIn);
	return &apos;+1&apos; + phoneIn.toString(); 
	} else{
		return null;
	}
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>6a32d94d-408c-4e10-9799-e45e150b5c1f</id>
        <name>WebPT-MISC</name>
        <revision>4</revision>
        <lastModified>
          <time>1703964939909</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description>miscellaneous javascript</description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>b19c96b2-afb4-4248-83a8-96f521b20489</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>ed58a744-1f83-44aa-ad23-feef56e2f5e6</string>
          <string>4a98f7b0-d1f3-478d-ad65-550f8287fe24</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>5cc5d7df-228a-4d24-b774-681c717e1876</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>5c763fad-3eae-4e87-b944-0dbfe25814e0</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>2e0d9b6c-294f-4506-8632-dc4622b4f651</string>
          <string>d3f6504f-12cd-4e69-a920-6bb3a2195cc2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>57fa694a-2758-4e52-b725-967a74786d1f</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>6be39ce0-8f88-42fb-b3a4-4afd4da39734</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>8cbc4731-752e-4e2e-a61d-018ed3e0cef0</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>93f57fef-8fc0-4b05-91de-b1cdb48034a2</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>84b4f1c7-f82d-4140-9fbd-98a95f68ff32</id>
            <name>getChannelState</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122648</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function GetChannelState(channel_id) {

    var channel_status = &quot;NA&quot;;

    var channel_count = parseInt(Packages.com.webreach.mirth.server.controllers.ChannelStatusController.getInstance().getChannelStatusList().size());

    for(var i=0;i&lt;channel_count;i++) {
        if (channel_id == Packages.com.webreach.mirth.server.controllers.ChannelStatusController.getInstance().getChannelStatusList().get(i).getChannelId()) {
            channel_status = Packages.com.webreach.mirth.server.controllers.ChannelStatusController.getInstance().getChannelStatusList().get(i).getState();
        }
    }

    return channel_status;

}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>715435a9-cb15-4e8f-bc5b-4249eaea6e17</id>
            <name>momentjs</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122487</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>COMPILED_CODE</type>
              <code>/**
	Testing MIRTH-3794 using external JavaScript library &quot;moment.js&quot;
*/
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
!function(a,b){&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module?module.exports=b():&quot;function&quot;==typeof define&amp;&amp;define.amd?define(b):a.moment=b()}(this,function(){&quot;use strict&quot;;function a(){return Hc.apply(null,arguments)}function b(a){Hc=a}function c(a){return&quot;[object Array]&quot;===Object.prototype.toString.call(a)}function d(a){return a instanceof Date||&quot;[object Date]&quot;===Object.prototype.toString.call(a)}function e(a,b){var c,d=[];for(c=0;c&lt;a.length;++c)d.push(b(a[c],c));return d}function f(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function g(a,b){for(var c in b)f(b,c)&amp;&amp;(a[c]=b[c]);return f(b,&quot;toString&quot;)&amp;&amp;(a.toString=b.toString),f(b,&quot;valueOf&quot;)&amp;&amp;(a.valueOf=b.valueOf),a}function h(a,b,c,d){return Ca(a,b,c,d,!0).utc()}function i(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function j(a){return null==a._pf&amp;&amp;(a._pf=i()),a._pf}function k(a){if(null==a._isValid){var b=j(a);a._isValid=!(isNaN(a._d.getTime())||!(b.overflow&lt;0)||b.empty||b.invalidMonth||b.invalidWeekday||b.nullInput||b.invalidFormat||b.userInvalidated),a._strict&amp;&amp;(a._isValid=a._isValid&amp;&amp;0===b.charsLeftOver&amp;&amp;0===b.unusedTokens.length&amp;&amp;void 0===b.bigHour)}return a._isValid}function l(a){var b=h(NaN);return null!=a?g(j(b),a):j(b).userInvalidated=!0,b}function m(a,b){var c,d,e;if(&quot;undefined&quot;!=typeof b._isAMomentObject&amp;&amp;(a._isAMomentObject=b._isAMomentObject),&quot;undefined&quot;!=typeof b._i&amp;&amp;(a._i=b._i),&quot;undefined&quot;!=typeof b._f&amp;&amp;(a._f=b._f),&quot;undefined&quot;!=typeof b._l&amp;&amp;(a._l=b._l),&quot;undefined&quot;!=typeof b._strict&amp;&amp;(a._strict=b._strict),&quot;undefined&quot;!=typeof b._tzm&amp;&amp;(a._tzm=b._tzm),&quot;undefined&quot;!=typeof b._isUTC&amp;&amp;(a._isUTC=b._isUTC),&quot;undefined&quot;!=typeof b._offset&amp;&amp;(a._offset=b._offset),&quot;undefined&quot;!=typeof b._pf&amp;&amp;(a._pf=j(b)),&quot;undefined&quot;!=typeof b._locale&amp;&amp;(a._locale=b._locale),Jc.length&gt;0)for(c in Jc)d=Jc[c],e=b[d],&quot;undefined&quot;!=typeof e&amp;&amp;(a[d]=e);return a}function n(b){m(this,b),this._d=new Date(null!=b._d?b._d.getTime():NaN),Kc===!1&amp;&amp;(Kc=!0,a.updateOffset(this),Kc=!1)}function o(a){return a instanceof n||null!=a&amp;&amp;null!=a._isAMomentObject}function p(a){return 0&gt;a?Math.ceil(a):Math.floor(a)}function q(a){var b=+a,c=0;return 0!==b&amp;&amp;isFinite(b)&amp;&amp;(c=p(b)),c}function r(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e&gt;d;d++)(c&amp;&amp;a[d]!==b[d]||!c&amp;&amp;q(a[d])!==q(b[d]))&amp;&amp;g++;return g+f}function s(){}function t(a){return a?a.toLowerCase().replace(&quot;_&quot;,&quot;-&quot;):a}function u(a){for(var b,c,d,e,f=0;f&lt;a.length;){for(e=t(a[f]).split(&quot;-&quot;),b=e.length,c=t(a[f+1]),c=c?c.split(&quot;-&quot;):null;b&gt;0;){if(d=v(e.slice(0,b).join(&quot;-&quot;)))return d;if(c&amp;&amp;c.length&gt;=b&amp;&amp;r(e,c,!0)&gt;=b-1)break;b--}f++}return null}function v(a){var b=null;if(!Lc[a]&amp;&amp;&quot;undefined&quot;!=typeof module&amp;&amp;module&amp;&amp;module.exports)try{b=Ic._abbr,require(&quot;./locale/&quot;+a),w(b)}catch(c){}return Lc[a]}function w(a,b){var c;return a&amp;&amp;(c=&quot;undefined&quot;==typeof b?y(a):x(a,b),c&amp;&amp;(Ic=c)),Ic._abbr}function x(a,b){return null!==b?(b.abbr=a,Lc[a]=Lc[a]||new s,Lc[a].set(b),w(a),Lc[a]):(delete Lc[a],null)}function y(a){var b;if(a&amp;&amp;a._locale&amp;&amp;a._locale._abbr&amp;&amp;(a=a._locale._abbr),!a)return Ic;if(!c(a)){if(b=v(a))return b;a=[a]}return u(a)}function z(a,b){var c=a.toLowerCase();Mc[c]=Mc[c+&quot;s&quot;]=Mc[b]=a}function A(a){return&quot;string&quot;==typeof a?Mc[a]||Mc[a.toLowerCase()]:void 0}function B(a){var b,c,d={};for(c in a)f(a,c)&amp;&amp;(b=A(c),b&amp;&amp;(d[b]=a[c]));return d}function C(b,c){return function(d){return null!=d?(E(this,b,d),a.updateOffset(this,c),this):D(this,b)}}function D(a,b){return a._d[&quot;get&quot;+(a._isUTC?&quot;UTC&quot;:&quot;&quot;)+b]()}function E(a,b,c){return a._d[&quot;set&quot;+(a._isUTC?&quot;UTC&quot;:&quot;&quot;)+b](c)}function F(a,b){var c;if(&quot;object&quot;==typeof a)for(c in a)this.set(c,a[c]);else if(a=A(a),&quot;function&quot;==typeof this[a])return this[a](b);return this}function G(a,b,c){var d=&quot;&quot;+Math.abs(a),e=b-d.length,f=a&gt;=0;return(f?c?&quot;+&quot;:&quot;&quot;:&quot;-&quot;)+Math.pow(10,Math.max(0,e)).toString().substr(1)+d}function H(a,b,c,d){var e=d;&quot;string&quot;==typeof d&amp;&amp;(e=function(){return this[d]()}),a&amp;&amp;(Qc[a]=e),b&amp;&amp;(Qc[b[0]]=function(){return G(e.apply(this,arguments),b[1],b[2])}),c&amp;&amp;(Qc[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function I(a){return a.match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,&quot;&quot;):a.replace(/\\/g,&quot;&quot;)}function J(a){var b,c,d=a.match(Nc);for(b=0,c=d.length;c&gt;b;b++)Qc[d[b]]?d[b]=Qc[d[b]]:d[b]=I(d[b]);return function(e){var f=&quot;&quot;;for(b=0;c&gt;b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function K(a,b){return a.isValid()?(b=L(b,a.localeData()),Pc[b]=Pc[b]||J(b),Pc[b](a)):a.localeData().invalidDate()}function L(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Oc.lastIndex=0;d&gt;=0&amp;&amp;Oc.test(a);)a=a.replace(Oc,c),Oc.lastIndex=0,d-=1;return a}function M(a){return&quot;function&quot;==typeof a&amp;&amp;&quot;[object Function]&quot;===Object.prototype.toString.call(a)}function N(a,b,c){dd[a]=M(b)?b:function(a){return a&amp;&amp;c?c:b}}function O(a,b){return f(dd,a)?dd[a](b._strict,b._locale):new RegExp(P(a))}function P(a){return a.replace(&quot;\\&quot;,&quot;&quot;).replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(a,b,c,d,e){return b||c||d||e}).replace(/[-\/\\^$*+?.()|[\]{}]/g,&quot;\\$&amp;&quot;)}function Q(a,b){var c,d=b;for(&quot;string&quot;==typeof a&amp;&amp;(a=[a]),&quot;number&quot;==typeof b&amp;&amp;(d=function(a,c){c[b]=q(a)}),c=0;c&lt;a.length;c++)ed[a[c]]=d}function R(a,b){Q(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function S(a,b,c){null!=b&amp;&amp;f(ed,a)&amp;&amp;ed[a](b,c._a,c,a)}function T(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function U(a){return this._months[a.month()]}function V(a){return this._monthsShort[a.month()]}function W(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12&gt;d;d++){if(e=h([2e3,d]),c&amp;&amp;!this._longMonthsParse[d]&amp;&amp;(this._longMonthsParse[d]=new RegExp(&quot;^&quot;+this.months(e,&quot;&quot;).replace(&quot;.&quot;,&quot;&quot;)+&quot;$&quot;,&quot;i&quot;),this._shortMonthsParse[d]=new RegExp(&quot;^&quot;+this.monthsShort(e,&quot;&quot;).replace(&quot;.&quot;,&quot;&quot;)+&quot;$&quot;,&quot;i&quot;)),c||this._monthsParse[d]||(f=&quot;^&quot;+this.months(e,&quot;&quot;)+&quot;|^&quot;+this.monthsShort(e,&quot;&quot;),this._monthsParse[d]=new RegExp(f.replace(&quot;.&quot;,&quot;&quot;),&quot;i&quot;)),c&amp;&amp;&quot;MMMM&quot;===b&amp;&amp;this._longMonthsParse[d].test(a))return d;if(c&amp;&amp;&quot;MMM&quot;===b&amp;&amp;this._shortMonthsParse[d].test(a))return d;if(!c&amp;&amp;this._monthsParse[d].test(a))return d}}function X(a,b){var c;return&quot;string&quot;==typeof b&amp;&amp;(b=a.localeData().monthsParse(b),&quot;number&quot;!=typeof b)?a:(c=Math.min(a.date(),T(a.year(),b)),a._d[&quot;set&quot;+(a._isUTC?&quot;UTC&quot;:&quot;&quot;)+&quot;Month&quot;](b,c),a)}function Y(b){return null!=b?(X(this,b),a.updateOffset(this,!0),this):D(this,&quot;Month&quot;)}function Z(){return T(this.year(),this.month())}function $(a){var b,c=a._a;return c&amp;&amp;-2===j(a).overflow&amp;&amp;(b=c[gd]&lt;0||c[gd]&gt;11?gd:c[hd]&lt;1||c[hd]&gt;T(c[fd],c[gd])?hd:c[id]&lt;0||c[id]&gt;24||24===c[id]&amp;&amp;(0!==c[jd]||0!==c[kd]||0!==c[ld])?id:c[jd]&lt;0||c[jd]&gt;59?jd:c[kd]&lt;0||c[kd]&gt;59?kd:c[ld]&lt;0||c[ld]&gt;999?ld:-1,j(a)._overflowDayOfYear&amp;&amp;(fd&gt;b||b&gt;hd)&amp;&amp;(b=hd),j(a).overflow=b),a}function _(b){a.suppressDeprecationWarnings===!1&amp;&amp;&quot;undefined&quot;!=typeof console&amp;&amp;console.warn&amp;&amp;console.warn(&quot;Deprecation warning: &quot;+b)}function aa(a,b){var c=!0;return g(function(){return c&amp;&amp;(_(a+&quot;\n&quot;+(new Error).stack),c=!1),b.apply(this,arguments)},b)}function ba(a,b){od[a]||(_(b),od[a]=!0)}function ca(a){var b,c,d=a._i,e=pd.exec(d);if(e){for(j(a).iso=!0,b=0,c=qd.length;c&gt;b;b++)if(qd[b][1].exec(d)){a._f=qd[b][0];break}for(b=0,c=rd.length;c&gt;b;b++)if(rd[b][1].exec(d)){a._f+=(e[6]||&quot; &quot;)+rd[b][0];break}d.match(ad)&amp;&amp;(a._f+=&quot;Z&quot;),va(a)}else a._isValid=!1}function da(b){var c=sd.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(ca(b),void(b._isValid===!1&amp;&amp;(delete b._isValid,a.createFromInputFallback(b))))}function ea(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970&gt;a&amp;&amp;h.setFullYear(a),h}function fa(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970&gt;a&amp;&amp;b.setUTCFullYear(a),b}function ga(a){return ha(a)?366:365}function ha(a){return a%4===0&amp;&amp;a%100!==0||a%400===0}function ia(){return ha(this.year())}function ja(a,b,c){var d,e=c-b,f=c-a.day();return f&gt;e&amp;&amp;(f-=7),e-7&gt;f&amp;&amp;(f+=7),d=Da(a).add(f,&quot;d&quot;),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function ka(a){return ja(a,this._week.dow,this._week.doy).week}function la(){return this._week.dow}function ma(){return this._week.doy}function na(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),&quot;d&quot;)}function oa(a){var b=ja(this,1,4).week;return null==a?b:this.add(7*(a-b),&quot;d&quot;)}function pa(a,b,c,d,e){var f,g=6+e-d,h=fa(a,0,1+g),i=h.getUTCDay();return e&gt;i&amp;&amp;(i+=7),c=null!=c?1*c:e,f=1+g+7*(b-1)-i+c,{year:f&gt;0?a:a-1,dayOfYear:f&gt;0?f:ga(a-1)+f}}function qa(a){var b=Math.round((this.clone().startOf(&quot;day&quot;)-this.clone().startOf(&quot;year&quot;))/864e5)+1;return null==a?b:this.add(a-b,&quot;d&quot;)}function ra(a,b,c){return null!=a?a:null!=b?b:c}function sa(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function ta(a){var b,c,d,e,f=[];if(!a._d){for(d=sa(a),a._w&amp;&amp;null==a._a[hd]&amp;&amp;null==a._a[gd]&amp;&amp;ua(a),a._dayOfYear&amp;&amp;(e=ra(a._a[fd],d[fd]),a._dayOfYear&gt;ga(e)&amp;&amp;(j(a)._overflowDayOfYear=!0),c=fa(e,0,a._dayOfYear),a._a[gd]=c.getUTCMonth(),a._a[hd]=c.getUTCDate()),b=0;3&gt;b&amp;&amp;null==a._a[b];++b)a._a[b]=f[b]=d[b];for(;7&gt;b;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];24===a._a[id]&amp;&amp;0===a._a[jd]&amp;&amp;0===a._a[kd]&amp;&amp;0===a._a[ld]&amp;&amp;(a._nextDay=!0,a._a[id]=0),a._d=(a._useUTC?fa:ea).apply(null,f),null!=a._tzm&amp;&amp;a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&amp;&amp;(a._a[id]=24)}}function ua(a){var b,c,d,e,f,g,h;b=a._w,null!=b.GG||null!=b.W||null!=b.E?(f=1,g=4,c=ra(b.GG,a._a[fd],ja(Da(),1,4).year),d=ra(b.W,1),e=ra(b.E,1)):(f=a._locale._week.dow,g=a._locale._week.doy,c=ra(b.gg,a._a[fd],ja(Da(),f,g).year),d=ra(b.w,1),null!=b.d?(e=b.d,f&gt;e&amp;&amp;++d):e=null!=b.e?b.e+f:f),h=pa(c,d,e,g,f),a._a[fd]=h.year,a._dayOfYear=h.dayOfYear}function va(b){if(b._f===a.ISO_8601)return void ca(b);b._a=[],j(b).empty=!0;var c,d,e,f,g,h=&quot;&quot;+b._i,i=h.length,k=0;for(e=L(b._f,b._locale).match(Nc)||[],c=0;c&lt;e.length;c++)f=e[c],d=(h.match(O(f,b))||[])[0],d&amp;&amp;(g=h.substr(0,h.indexOf(d)),g.length&gt;0&amp;&amp;j(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),k+=d.length),Qc[f]?(d?j(b).empty=!1:j(b).unusedTokens.push(f),S(f,d,b)):b._strict&amp;&amp;!d&amp;&amp;j(b).unusedTokens.push(f);j(b).charsLeftOver=i-k,h.length&gt;0&amp;&amp;j(b).unusedInput.push(h),j(b).bigHour===!0&amp;&amp;b._a[id]&lt;=12&amp;&amp;b._a[id]&gt;0&amp;&amp;(j(b).bigHour=void 0),b._a[id]=wa(b._locale,b._a[id],b._meridiem),ta(b),$(b)}function wa(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&amp;&amp;12&gt;b&amp;&amp;(b+=12),d||12!==b||(b=0),b):b}function xa(a){var b,c,d,e,f;if(0===a._f.length)return j(a).invalidFormat=!0,void(a._d=new Date(NaN));for(e=0;e&lt;a._f.length;e++)f=0,b=m({},a),null!=a._useUTC&amp;&amp;(b._useUTC=a._useUTC),b._f=a._f[e],va(b),k(b)&amp;&amp;(f+=j(b).charsLeftOver,f+=10*j(b).unusedTokens.length,j(b).score=f,(null==d||d&gt;f)&amp;&amp;(d=f,c=b));g(a,c||b)}function ya(a){if(!a._d){var b=B(a._i);a._a=[b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],ta(a)}}function za(a){var b=new n($(Aa(a)));return b._nextDay&amp;&amp;(b.add(1,&quot;d&quot;),b._nextDay=void 0),b}function Aa(a){var b=a._i,e=a._f;return a._locale=a._locale||y(a._l),null===b||void 0===e&amp;&amp;&quot;&quot;===b?l({nullInput:!0}):(&quot;string&quot;==typeof b&amp;&amp;(a._i=b=a._locale.preparse(b)),o(b)?new n($(b)):(c(e)?xa(a):e?va(a):d(b)?a._d=b:Ba(a),a))}function Ba(b){var f=b._i;void 0===f?b._d=new Date:d(f)?b._d=new Date(+f):&quot;string&quot;==typeof f?da(b):c(f)?(b._a=e(f.slice(0),function(a){return parseInt(a,10)}),ta(b)):&quot;object&quot;==typeof f?ya(b):&quot;number&quot;==typeof f?b._d=new Date(f):a.createFromInputFallback(b)}function Ca(a,b,c,d,e){var f={};return&quot;boolean&quot;==typeof c&amp;&amp;(d=c,c=void 0),f._isAMomentObject=!0,f._useUTC=f._isUTC=e,f._l=c,f._i=a,f._f=b,f._strict=d,za(f)}function Da(a,b,c,d){return Ca(a,b,c,d,!1)}function Ea(a,b){var d,e;if(1===b.length&amp;&amp;c(b[0])&amp;&amp;(b=b[0]),!b.length)return Da();for(d=b[0],e=1;e&lt;b.length;++e)(!b[e].isValid()||b[e][a](d))&amp;&amp;(d=b[e]);return d}function Fa(){var a=[].slice.call(arguments,0);return Ea(&quot;isBefore&quot;,a)}function Ga(){var a=[].slice.call(arguments,0);return Ea(&quot;isAfter&quot;,a)}function Ha(a){var b=B(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=y(),this._bubble()}function Ia(a){return a instanceof Ha}function Ja(a,b){H(a,0,0,function(){var a=this.utcOffset(),c=&quot;+&quot;;return 0&gt;a&amp;&amp;(a=-a,c=&quot;-&quot;),c+G(~~(a/60),2)+b+G(~~a%60,2)})}function Ka(a){var b=(a||&quot;&quot;).match(ad)||[],c=b[b.length-1]||[],d=(c+&quot;&quot;).match(xd)||[&quot;-&quot;,0,0],e=+(60*d[1])+q(d[2]);return&quot;+&quot;===d[0]?e:-e}function La(b,c){var e,f;return c._isUTC?(e=c.clone(),f=(o(b)||d(b)?+b:+Da(b))-+e,e._d.setTime(+e._d+f),a.updateOffset(e,!1),e):Da(b).local()}function Ma(a){return 15*-Math.round(a._d.getTimezoneOffset()/15)}function Na(b,c){var d,e=this._offset||0;return null!=b?(&quot;string&quot;==typeof b&amp;&amp;(b=Ka(b)),Math.abs(b)&lt;16&amp;&amp;(b=60*b),!this._isUTC&amp;&amp;c&amp;&amp;(d=Ma(this)),this._offset=b,this._isUTC=!0,null!=d&amp;&amp;this.add(d,&quot;m&quot;),e!==b&amp;&amp;(!c||this._changeInProgress?bb(this,Ya(b-e,&quot;m&quot;),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?e:Ma(this)}function Oa(a,b){return null!=a?(&quot;string&quot;!=typeof a&amp;&amp;(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Pa(a){return this.utcOffset(0,a)}function Qa(a){return this._isUTC&amp;&amp;(this.utcOffset(0,a),this._isUTC=!1,a&amp;&amp;this.subtract(Ma(this),&quot;m&quot;)),this}function Ra(){return this._tzm?this.utcOffset(this._tzm):&quot;string&quot;==typeof this._i&amp;&amp;this.utcOffset(Ka(this._i)),this}function Sa(a){return a=a?Da(a).utcOffset():0,(this.utcOffset()-a)%60===0}function Ta(){return this.utcOffset()&gt;this.clone().month(0).utcOffset()||this.utcOffset()&gt;this.clone().month(5).utcOffset()}function Ua(){if(&quot;undefined&quot;!=typeof this._isDSTShifted)return this._isDSTShifted;var a={};if(m(a,this),a=Aa(a),a._a){var b=a._isUTC?h(a._a):Da(a._a);this._isDSTShifted=this.isValid()&amp;&amp;r(a._a,b.toArray())&gt;0}else this._isDSTShifted=!1;return this._isDSTShifted}function Va(){return!this._isUTC}function Wa(){return this._isUTC}function Xa(){return this._isUTC&amp;&amp;0===this._offset}function Ya(a,b){var c,d,e,g=a,h=null;return Ia(a)?g={ms:a._milliseconds,d:a._days,M:a._months}:&quot;number&quot;==typeof a?(g={},b?g[b]=a:g.milliseconds=a):(h=yd.exec(a))?(c=&quot;-&quot;===h[1]?-1:1,g={y:0,d:q(h[hd])*c,h:q(h[id])*c,m:q(h[jd])*c,s:q(h[kd])*c,ms:q(h[ld])*c}):(h=zd.exec(a))?(c=&quot;-&quot;===h[1]?-1:1,g={y:Za(h[2],c),M:Za(h[3],c),d:Za(h[4],c),h:Za(h[5],c),m:Za(h[6],c),s:Za(h[7],c),w:Za(h[8],c)}):null==g?g={}:&quot;object&quot;==typeof g&amp;&amp;(&quot;from&quot;in g||&quot;to&quot;in g)&amp;&amp;(e=_a(Da(g.from),Da(g.to)),g={},g.ms=e.milliseconds,g.M=e.months),d=new Ha(g),Ia(a)&amp;&amp;f(a,&quot;_locale&quot;)&amp;&amp;(d._locale=a._locale),d}function Za(a,b){var c=a&amp;&amp;parseFloat(a.replace(&quot;,&quot;,&quot;.&quot;));return(isNaN(c)?0:c)*b}function $a(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,&quot;M&quot;).isAfter(b)&amp;&amp;--c.months,c.milliseconds=+b-+a.clone().add(c.months,&quot;M&quot;),c}function _a(a,b){var c;return b=La(b,a),a.isBefore(b)?c=$a(a,b):(c=$a(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function ab(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(ba(b,&quot;moment().&quot;+b+&quot;(period, number) is deprecated. Please use moment().&quot;+b+&quot;(number, period).&quot;),f=c,c=d,d=f),c=&quot;string&quot;==typeof c?+c:c,e=Ya(c,d),bb(this,e,a),this}}function bb(b,c,d,e){var f=c._milliseconds,g=c._days,h=c._months;e=null==e?!0:e,f&amp;&amp;b._d.setTime(+b._d+f*d),g&amp;&amp;E(b,&quot;Date&quot;,D(b,&quot;Date&quot;)+g*d),h&amp;&amp;X(b,D(b,&quot;Month&quot;)+h*d),e&amp;&amp;a.updateOffset(b,g||h)}function cb(a,b){var c=a||Da(),d=La(c,this).startOf(&quot;day&quot;),e=this.diff(d,&quot;days&quot;,!0),f=-6&gt;e?&quot;sameElse&quot;:-1&gt;e?&quot;lastWeek&quot;:0&gt;e?&quot;lastDay&quot;:1&gt;e?&quot;sameDay&quot;:2&gt;e?&quot;nextDay&quot;:7&gt;e?&quot;nextWeek&quot;:&quot;sameElse&quot;;return this.format(b&amp;&amp;b[f]||this.localeData().calendar(f,this,Da(c)))}function db(){return new n(this)}function eb(a,b){var c;return b=A(&quot;undefined&quot;!=typeof b?b:&quot;millisecond&quot;),&quot;millisecond&quot;===b?(a=o(a)?a:Da(a),+this&gt;+a):(c=o(a)?+a:+Da(a),c&lt;+this.clone().startOf(b))}function fb(a,b){var c;return b=A(&quot;undefined&quot;!=typeof b?b:&quot;millisecond&quot;),&quot;millisecond&quot;===b?(a=o(a)?a:Da(a),+a&gt;+this):(c=o(a)?+a:+Da(a),+this.clone().endOf(b)&lt;c)}function gb(a,b,c){return this.isAfter(a,c)&amp;&amp;this.isBefore(b,c)}function hb(a,b){var c;return b=A(b||&quot;millisecond&quot;),&quot;millisecond&quot;===b?(a=o(a)?a:Da(a),+this===+a):(c=+Da(a),+this.clone().startOf(b)&lt;=c&amp;&amp;c&lt;=+this.clone().endOf(b))}function ib(a,b,c){var d,e,f=La(a,this),g=6e4*(f.utcOffset()-this.utcOffset());return b=A(b),&quot;year&quot;===b||&quot;month&quot;===b||&quot;quarter&quot;===b?(e=jb(this,f),&quot;quarter&quot;===b?e/=3:&quot;year&quot;===b&amp;&amp;(e/=12)):(d=this-f,e=&quot;second&quot;===b?d/1e3:&quot;minute&quot;===b?d/6e4:&quot;hour&quot;===b?d/36e5:&quot;day&quot;===b?(d-g)/864e5:&quot;week&quot;===b?(d-g)/6048e5:d),c?e:p(e)}function jb(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,&quot;months&quot;);return 0&gt;b-f?(c=a.clone().add(e-1,&quot;months&quot;),d=(b-f)/(f-c)):(c=a.clone().add(e+1,&quot;months&quot;),d=(b-f)/(c-f)),-(e+d)}function kb(){return this.clone().locale(&quot;en&quot;).format(&quot;ddd MMM DD YYYY HH:mm:ss [GMT]ZZ&quot;)}function lb(){var a=this.clone().utc();return 0&lt;a.year()&amp;&amp;a.year()&lt;=9999?&quot;function&quot;==typeof Date.prototype.toISOString?this.toDate().toISOString():K(a,&quot;YYYY-MM-DD[T]HH:mm:ss.SSS[Z]&quot;):K(a,&quot;YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]&quot;)}function mb(b){var c=K(this,b||a.defaultFormat);return this.localeData().postformat(c)}function nb(a,b){return this.isValid()?Ya({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function ob(a){return this.from(Da(),a)}function pb(a,b){return this.isValid()?Ya({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function qb(a){return this.to(Da(),a)}function rb(a){var b;return void 0===a?this._locale._abbr:(b=y(a),null!=b&amp;&amp;(this._locale=b),this)}function sb(){return this._locale}function tb(a){switch(a=A(a)){case&quot;year&quot;:this.month(0);case&quot;quarter&quot;:case&quot;month&quot;:this.date(1);case&quot;week&quot;:case&quot;isoWeek&quot;:case&quot;day&quot;:this.hours(0);case&quot;hour&quot;:this.minutes(0);case&quot;minute&quot;:this.seconds(0);case&quot;second&quot;:this.milliseconds(0)}return&quot;week&quot;===a&amp;&amp;this.weekday(0),&quot;isoWeek&quot;===a&amp;&amp;this.isoWeekday(1),&quot;quarter&quot;===a&amp;&amp;this.month(3*Math.floor(this.month()/3)),this}function ub(a){return a=A(a),void 0===a||&quot;millisecond&quot;===a?this:this.startOf(a).add(1,&quot;isoWeek&quot;===a?&quot;week&quot;:a).subtract(1,&quot;ms&quot;)}function vb(){return+this._d-6e4*(this._offset||0)}function wb(){return Math.floor(+this/1e3)}function xb(){return this._offset?new Date(+this):this._d}function yb(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function zb(){var a=this;return{years:a.year(),months:a.month(),date:a.date(),hours:a.hours(),minutes:a.minutes(),seconds:a.seconds(),milliseconds:a.milliseconds()}}function Ab(){return k(this)}function Bb(){return g({},j(this))}function Cb(){return j(this).overflow}function Db(a,b){H(0,[a,a.length],0,b)}function Eb(a,b,c){return ja(Da([a,11,31+b-c]),b,c).week}function Fb(a){var b=ja(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,&quot;y&quot;)}function Gb(a){var b=ja(this,1,4).year;return null==a?b:this.add(a-b,&quot;y&quot;)}function Hb(){return Eb(this.year(),1,4)}function Ib(){var a=this.localeData()._week;return Eb(this.year(),a.dow,a.doy)}function Jb(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}function Kb(a,b){return&quot;string&quot;!=typeof a?a:isNaN(a)?(a=b.weekdaysParse(a),&quot;number&quot;==typeof a?a:null):parseInt(a,10)}function Lb(a){return this._weekdays[a.day()]}function Mb(a){return this._weekdaysShort[a.day()]}function Nb(a){return this._weekdaysMin[a.day()]}function Ob(a){var b,c,d;for(this._weekdaysParse=this._weekdaysParse||[],b=0;7&gt;b;b++)if(this._weekdaysParse[b]||(c=Da([2e3,1]).day(b),d=&quot;^&quot;+this.weekdays(c,&quot;&quot;)+&quot;|^&quot;+this.weekdaysShort(c,&quot;&quot;)+&quot;|^&quot;+this.weekdaysMin(c,&quot;&quot;),this._weekdaysParse[b]=new RegExp(d.replace(&quot;.&quot;,&quot;&quot;),&quot;i&quot;)),this._weekdaysParse[b].test(a))return b}function Pb(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Kb(a,this.localeData()),this.add(a-b,&quot;d&quot;)):b}function Qb(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,&quot;d&quot;)}function Rb(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)}function Sb(a,b){H(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}function Tb(a,b){return b._meridiemParse}function Ub(a){return&quot;p&quot;===(a+&quot;&quot;).toLowerCase().charAt(0)}function Vb(a,b,c){return a&gt;11?c?&quot;pm&quot;:&quot;PM&quot;:c?&quot;am&quot;:&quot;AM&quot;}function Wb(a,b){b[ld]=q(1e3*(&quot;0.&quot;+a))}function Xb(){return this._isUTC?&quot;UTC&quot;:&quot;&quot;}function Yb(){return this._isUTC?&quot;Coordinated Universal Time&quot;:&quot;&quot;}function Zb(a){return Da(1e3*a)}function $b(){return Da.apply(null,arguments).parseZone()}function _b(a,b,c){var d=this._calendar[a];return&quot;function&quot;==typeof d?d.call(b,c):d}function ac(a){var b=this._longDateFormat[a],c=this._longDateFormat[a.toUpperCase()];return b||!c?b:(this._longDateFormat[a]=c.replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a])}function bc(){return this._invalidDate}function cc(a){return this._ordinal.replace(&quot;%d&quot;,a)}function dc(a){return a}function ec(a,b,c,d){var e=this._relativeTime[c];return&quot;function&quot;==typeof e?e(a,b,c,d):e.replace(/%d/i,a)}function fc(a,b){var c=this._relativeTime[a&gt;0?&quot;future&quot;:&quot;past&quot;];return&quot;function&quot;==typeof c?c(b):c.replace(/%s/i,b)}function gc(a){var b,c;for(c in a)b=a[c],&quot;function&quot;==typeof b?this[c]=b:this[&quot;_&quot;+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+&quot;|&quot;+/\d{1,2}/.source)}function hc(a,b,c,d){var e=y(),f=h().set(d,b);return e[c](f,a)}function ic(a,b,c,d,e){if(&quot;number&quot;==typeof a&amp;&amp;(b=a,a=void 0),a=a||&quot;&quot;,null!=b)return hc(a,b,c,e);var f,g=[];for(f=0;d&gt;f;f++)g[f]=hc(a,f,c,e);return g}function jc(a,b){return ic(a,b,&quot;months&quot;,12,&quot;month&quot;)}function kc(a,b){return ic(a,b,&quot;monthsShort&quot;,12,&quot;month&quot;)}function lc(a,b){return ic(a,b,&quot;weekdays&quot;,7,&quot;day&quot;)}function mc(a,b){return ic(a,b,&quot;weekdaysShort&quot;,7,&quot;day&quot;)}function nc(a,b){return ic(a,b,&quot;weekdaysMin&quot;,7,&quot;day&quot;)}function oc(){var a=this._data;return this._milliseconds=Wd(this._milliseconds),this._days=Wd(this._days),this._months=Wd(this._months),a.milliseconds=Wd(a.milliseconds),a.seconds=Wd(a.seconds),a.minutes=Wd(a.minutes),a.hours=Wd(a.hours),a.months=Wd(a.months),a.years=Wd(a.years),this}function pc(a,b,c,d){var e=Ya(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}function qc(a,b){return pc(this,a,b,1)}function rc(a,b){return pc(this,a,b,-1)}function sc(a){return 0&gt;a?Math.floor(a):Math.ceil(a)}function tc(){var a,b,c,d,e,f=this._milliseconds,g=this._days,h=this._months,i=this._data;return f&gt;=0&amp;&amp;g&gt;=0&amp;&amp;h&gt;=0||0&gt;=f&amp;&amp;0&gt;=g&amp;&amp;0&gt;=h||(f+=864e5*sc(vc(h)+g),g=0,h=0),i.milliseconds=f%1e3,a=p(f/1e3),i.seconds=a%60,b=p(a/60),i.minutes=b%60,c=p(b/60),i.hours=c%24,g+=p(c/24),e=p(uc(g)),h+=e,g-=sc(vc(e)),d=p(h/12),h%=12,i.days=g,i.months=h,i.years=d,this}function uc(a){return 4800*a/146097}function vc(a){return 146097*a/4800}function wc(a){var b,c,d=this._milliseconds;if(a=A(a),&quot;month&quot;===a||&quot;year&quot;===a)return b=this._days+d/864e5,c=this._months+uc(b),&quot;month&quot;===a?c:c/12;switch(b=this._days+Math.round(vc(this._months)),a){case&quot;week&quot;:return b/7+d/6048e5;case&quot;day&quot;:return b+d/864e5;case&quot;hour&quot;:return 24*b+d/36e5;case&quot;minute&quot;:return 1440*b+d/6e4;case&quot;second&quot;:return 86400*b+d/1e3;case&quot;millisecond&quot;:return Math.floor(864e5*b)+d;default:throw new Error(&quot;Unknown unit &quot;+a)}}function xc(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*q(this._months/12)}function yc(a){return function(){return this.as(a)}}function zc(a){return a=A(a),this[a+&quot;s&quot;]()}function Ac(a){return function(){return this._data[a]}}function Bc(){return p(this.days()/7)}function Cc(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function Dc(a,b,c){var d=Ya(a).abs(),e=ke(d.as(&quot;s&quot;)),f=ke(d.as(&quot;m&quot;)),g=ke(d.as(&quot;h&quot;)),h=ke(d.as(&quot;d&quot;)),i=ke(d.as(&quot;M&quot;)),j=ke(d.as(&quot;y&quot;)),k=e&lt;le.s&amp;&amp;[&quot;s&quot;,e]||1===f&amp;&amp;[&quot;m&quot;]||f&lt;le.m&amp;&amp;[&quot;mm&quot;,f]||1===g&amp;&amp;[&quot;h&quot;]||g&lt;le.h&amp;&amp;[&quot;hh&quot;,g]||1===h&amp;&amp;[&quot;d&quot;]||h&lt;le.d&amp;&amp;[&quot;dd&quot;,h]||1===i&amp;&amp;[&quot;M&quot;]||i&lt;le.M&amp;&amp;[&quot;MM&quot;,i]||1===j&amp;&amp;[&quot;y&quot;]||[&quot;yy&quot;,j];return k[2]=b,k[3]=+a&gt;0,k[4]=c,Cc.apply(null,k)}function Ec(a,b){return void 0===le[a]?!1:void 0===b?le[a]:(le[a]=b,!0)}function Fc(a){var b=this.localeData(),c=Dc(this,!a,b);return a&amp;&amp;(c=b.pastFuture(+this,c)),b.postformat(c)}function Gc(){var a,b,c,d=me(this._milliseconds)/1e3,e=me(this._days),f=me(this._months);a=p(d/60),b=p(a/60),d%=60,a%=60,c=p(f/12),f%=12;var g=c,h=f,i=e,j=b,k=a,l=d,m=this.asSeconds();return m?(0&gt;m?&quot;-&quot;:&quot;&quot;)+&quot;P&quot;+(g?g+&quot;Y&quot;:&quot;&quot;)+(h?h+&quot;M&quot;:&quot;&quot;)+(i?i+&quot;D&quot;:&quot;&quot;)+(j||k||l?&quot;T&quot;:&quot;&quot;)+(j?j+&quot;H&quot;:&quot;&quot;)+(k?k+&quot;M&quot;:&quot;&quot;)+(l?l+&quot;S&quot;:&quot;&quot;):&quot;P0D&quot;}var Hc,Ic,Jc=a.momentProperties=[],Kc=!1,Lc={},Mc={},Nc=/(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Oc=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Pc={},Qc={},Rc=/\d/,Sc=/\d\d/,Tc=/\d{3}/,Uc=/\d{4}/,Vc=/[+-]?\d{6}/,Wc=/\d\d?/,Xc=/\d{1,3}/,Yc=/\d{1,4}/,Zc=/[+-]?\d{1,6}/,$c=/\d+/,_c=/[+-]?\d+/,ad=/Z|[+-]\d\d:?\d\d/gi,bd=/[+-]?\d+(\.\d{1,3})?/,cd=/[0-9]*[&apos;a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,dd={},ed={},fd=0,gd=1,hd=2,id=3,jd=4,kd=5,ld=6;H(&quot;M&quot;,[&quot;MM&quot;,2],&quot;Mo&quot;,function(){return this.month()+1}),H(&quot;MMM&quot;,0,0,function(a){return this.localeData().monthsShort(this,a)}),H(&quot;MMMM&quot;,0,0,function(a){return this.localeData().months(this,a)}),z(&quot;month&quot;,&quot;M&quot;),N(&quot;M&quot;,Wc),N(&quot;MM&quot;,Wc,Sc),N(&quot;MMM&quot;,cd),N(&quot;MMMM&quot;,cd),Q([&quot;M&quot;,&quot;MM&quot;],function(a,b){b[gd]=q(a)-1}),Q([&quot;MMM&quot;,&quot;MMMM&quot;],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);null!=e?b[gd]=e:j(c).invalidMonth=a});var md=&quot;January_February_March_April_May_June_July_August_September_October_November_December&quot;.split(&quot;_&quot;),nd=&quot;Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec&quot;.split(&quot;_&quot;),od={};a.suppressDeprecationWarnings=!1;var pd=/^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,qd=[[&quot;YYYYYY-MM-DD&quot;,/[+-]\d{6}-\d{2}-\d{2}/],[&quot;YYYY-MM-DD&quot;,/\d{4}-\d{2}-\d{2}/],[&quot;GGGG-[W]WW-E&quot;,/\d{4}-W\d{2}-\d/],[&quot;GGGG-[W]WW&quot;,/\d{4}-W\d{2}/],[&quot;YYYY-DDD&quot;,/\d{4}-\d{3}/]],rd=[[&quot;HH:mm:ss.SSSS&quot;,/(T| )\d\d:\d\d:\d\d\.\d+/],[&quot;HH:mm:ss&quot;,/(T| )\d\d:\d\d:\d\d/],[&quot;HH:mm&quot;,/(T| )\d\d:\d\d/],[&quot;HH&quot;,/(T| )\d\d/]],sd=/^\/?Date\((\-?\d+)/i;a.createFromInputFallback=aa(&quot;moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.&quot;,function(a){a._d=new Date(a._i+(a._useUTC?&quot; UTC&quot;:&quot;&quot;))}),H(0,[&quot;YY&quot;,2],0,function(){return this.year()%100}),H(0,[&quot;YYYY&quot;,4],0,&quot;year&quot;),H(0,[&quot;YYYYY&quot;,5],0,&quot;year&quot;),H(0,[&quot;YYYYYY&quot;,6,!0],0,&quot;year&quot;),z(&quot;year&quot;,&quot;y&quot;),N(&quot;Y&quot;,_c),N(&quot;YY&quot;,Wc,Sc),N(&quot;YYYY&quot;,Yc,Uc),N(&quot;YYYYY&quot;,Zc,Vc),N(&quot;YYYYYY&quot;,Zc,Vc),Q([&quot;YYYYY&quot;,&quot;YYYYYY&quot;],fd),Q(&quot;YYYY&quot;,function(b,c){c[fd]=2===b.length?a.parseTwoDigitYear(b):q(b)}),Q(&quot;YY&quot;,function(b,c){c[fd]=a.parseTwoDigitYear(b)}),a.parseTwoDigitYear=function(a){return q(a)+(q(a)&gt;68?1900:2e3)};var td=C(&quot;FullYear&quot;,!1);H(&quot;w&quot;,[&quot;ww&quot;,2],&quot;wo&quot;,&quot;week&quot;),H(&quot;W&quot;,[&quot;WW&quot;,2],&quot;Wo&quot;,&quot;isoWeek&quot;),z(&quot;week&quot;,&quot;w&quot;),z(&quot;isoWeek&quot;,&quot;W&quot;),N(&quot;w&quot;,Wc),N(&quot;ww&quot;,Wc,Sc),N(&quot;W&quot;,Wc),N(&quot;WW&quot;,Wc,Sc),R([&quot;w&quot;,&quot;ww&quot;,&quot;W&quot;,&quot;WW&quot;],function(a,b,c,d){b[d.substr(0,1)]=q(a)});var ud={dow:0,doy:6};H(&quot;DDD&quot;,[&quot;DDDD&quot;,3],&quot;DDDo&quot;,&quot;dayOfYear&quot;),z(&quot;dayOfYear&quot;,&quot;DDD&quot;),N(&quot;DDD&quot;,Xc),N(&quot;DDDD&quot;,Tc),Q([&quot;DDD&quot;,&quot;DDDD&quot;],function(a,b,c){c._dayOfYear=q(a)}),a.ISO_8601=function(){};var vd=aa(&quot;moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548&quot;,function(){var a=Da.apply(null,arguments);return this&gt;a?this:a}),wd=aa(&quot;moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548&quot;,function(){var a=Da.apply(null,arguments);return a&gt;this?this:a});Ja(&quot;Z&quot;,&quot;:&quot;),Ja(&quot;ZZ&quot;,&quot;&quot;),N(&quot;Z&quot;,ad),N(&quot;ZZ&quot;,ad),Q([&quot;Z&quot;,&quot;ZZ&quot;],function(a,b,c){c._useUTC=!0,c._tzm=Ka(a)});var xd=/([\+\-]|\d\d)/gi;a.updateOffset=function(){};var yd=/(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,zd=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;Ya.fn=Ha.prototype;var Ad=ab(1,&quot;add&quot;),Bd=ab(-1,&quot;subtract&quot;);a.defaultFormat=&quot;YYYY-MM-DDTHH:mm:ssZ&quot;;var Cd=aa(&quot;moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.&quot;,function(a){return void 0===a?this.localeData():this.locale(a)});H(0,[&quot;gg&quot;,2],0,function(){return this.weekYear()%100}),H(0,[&quot;GG&quot;,2],0,function(){return this.isoWeekYear()%100}),Db(&quot;gggg&quot;,&quot;weekYear&quot;),Db(&quot;ggggg&quot;,&quot;weekYear&quot;),Db(&quot;GGGG&quot;,&quot;isoWeekYear&quot;),Db(&quot;GGGGG&quot;,&quot;isoWeekYear&quot;),z(&quot;weekYear&quot;,&quot;gg&quot;),z(&quot;isoWeekYear&quot;,&quot;GG&quot;),N(&quot;G&quot;,_c),N(&quot;g&quot;,_c),N(&quot;GG&quot;,Wc,Sc),N(&quot;gg&quot;,Wc,Sc),N(&quot;GGGG&quot;,Yc,Uc),N(&quot;gggg&quot;,Yc,Uc),N(&quot;GGGGG&quot;,Zc,Vc),N(&quot;ggggg&quot;,Zc,Vc),R([&quot;gggg&quot;,&quot;ggggg&quot;,&quot;GGGG&quot;,&quot;GGGGG&quot;],function(a,b,c,d){b[d.substr(0,2)]=q(a)}),R([&quot;gg&quot;,&quot;GG&quot;],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),H(&quot;Q&quot;,0,0,&quot;quarter&quot;),z(&quot;quarter&quot;,&quot;Q&quot;),N(&quot;Q&quot;,Rc),Q(&quot;Q&quot;,function(a,b){b[gd]=3*(q(a)-1)}),H(&quot;D&quot;,[&quot;DD&quot;,2],&quot;Do&quot;,&quot;date&quot;),z(&quot;date&quot;,&quot;D&quot;),N(&quot;D&quot;,Wc),N(&quot;DD&quot;,Wc,Sc),N(&quot;Do&quot;,function(a,b){return a?b._ordinalParse:b._ordinalParseLenient}),Q([&quot;D&quot;,&quot;DD&quot;],hd),Q(&quot;Do&quot;,function(a,b){b[hd]=q(a.match(Wc)[0],10)});var Dd=C(&quot;Date&quot;,!0);H(&quot;d&quot;,0,&quot;do&quot;,&quot;day&quot;),H(&quot;dd&quot;,0,0,function(a){return this.localeData().weekdaysMin(this,a)}),H(&quot;ddd&quot;,0,0,function(a){return this.localeData().weekdaysShort(this,a)}),H(&quot;dddd&quot;,0,0,function(a){return this.localeData().weekdays(this,a)}),H(&quot;e&quot;,0,0,&quot;weekday&quot;),H(&quot;E&quot;,0,0,&quot;isoWeekday&quot;),z(&quot;day&quot;,&quot;d&quot;),z(&quot;weekday&quot;,&quot;e&quot;),z(&quot;isoWeekday&quot;,&quot;E&quot;),N(&quot;d&quot;,Wc),N(&quot;e&quot;,Wc),N(&quot;E&quot;,Wc),N(&quot;dd&quot;,cd),N(&quot;ddd&quot;,cd),N(&quot;dddd&quot;,cd),R([&quot;dd&quot;,&quot;ddd&quot;,&quot;dddd&quot;],function(a,b,c){var d=c._locale.weekdaysParse(a);null!=d?b.d=d:j(c).invalidWeekday=a}),R([&quot;d&quot;,&quot;e&quot;,&quot;E&quot;],function(a,b,c,d){b[d]=q(a)});var Ed=&quot;Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday&quot;.split(&quot;_&quot;),Fd=&quot;Sun_Mon_Tue_Wed_Thu_Fri_Sat&quot;.split(&quot;_&quot;),Gd=&quot;Su_Mo_Tu_We_Th_Fr_Sa&quot;.split(&quot;_&quot;);H(&quot;H&quot;,[&quot;HH&quot;,2],0,&quot;hour&quot;),H(&quot;h&quot;,[&quot;hh&quot;,2],0,function(){return this.hours()%12||12}),Sb(&quot;a&quot;,!0),Sb(&quot;A&quot;,!1),z(&quot;hour&quot;,&quot;h&quot;),N(&quot;a&quot;,Tb),N(&quot;A&quot;,Tb),N(&quot;H&quot;,Wc),N(&quot;h&quot;,Wc),N(&quot;HH&quot;,Wc,Sc),N(&quot;hh&quot;,Wc,Sc),Q([&quot;H&quot;,&quot;HH&quot;],id),Q([&quot;a&quot;,&quot;A&quot;],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),Q([&quot;h&quot;,&quot;hh&quot;],function(a,b,c){b[id]=q(a),j(c).bigHour=!0});var Hd=/[ap]\.?m?\.?/i,Id=C(&quot;Hours&quot;,!0);H(&quot;m&quot;,[&quot;mm&quot;,2],0,&quot;minute&quot;),z(&quot;minute&quot;,&quot;m&quot;),N(&quot;m&quot;,Wc),N(&quot;mm&quot;,Wc,Sc),Q([&quot;m&quot;,&quot;mm&quot;],jd);var Jd=C(&quot;Minutes&quot;,!1);H(&quot;s&quot;,[&quot;ss&quot;,2],0,&quot;second&quot;),z(&quot;second&quot;,&quot;s&quot;),N(&quot;s&quot;,Wc),N(&quot;ss&quot;,Wc,Sc),Q([&quot;s&quot;,&quot;ss&quot;],kd);var Kd=C(&quot;Seconds&quot;,!1);H(&quot;S&quot;,0,0,function(){return~~(this.millisecond()/100)}),H(0,[&quot;SS&quot;,2],0,function(){return~~(this.millisecond()/10)}),H(0,[&quot;SSS&quot;,3],0,&quot;millisecond&quot;),H(0,[&quot;SSSS&quot;,4],0,function(){return 10*this.millisecond()}),H(0,[&quot;SSSSS&quot;,5],0,function(){return 100*this.millisecond()}),H(0,[&quot;SSSSSS&quot;,6],0,function(){return 1e3*this.millisecond()}),H(0,[&quot;SSSSSSS&quot;,7],0,function(){return 1e4*this.millisecond()}),H(0,[&quot;SSSSSSSS&quot;,8],0,function(){return 1e5*this.millisecond()}),H(0,[&quot;SSSSSSSSS&quot;,9],0,function(){return 1e6*this.millisecond()}),z(&quot;millisecond&quot;,&quot;ms&quot;),N(&quot;S&quot;,Xc,Rc),N(&quot;SS&quot;,Xc,Sc),N(&quot;SSS&quot;,Xc,Tc);var Ld;for(Ld=&quot;SSSS&quot;;Ld.length&lt;=9;Ld+=&quot;S&quot;)N(Ld,$c);for(Ld=&quot;S&quot;;Ld.length&lt;=9;Ld+=&quot;S&quot;)Q(Ld,Wb);var Md=C(&quot;Milliseconds&quot;,!1);H(&quot;z&quot;,0,0,&quot;zoneAbbr&quot;),H(&quot;zz&quot;,0,0,&quot;zoneName&quot;);var Nd=n.prototype;Nd.add=Ad,Nd.calendar=cb,Nd.clone=db,Nd.diff=ib,Nd.endOf=ub,Nd.format=mb,Nd.from=nb,Nd.fromNow=ob,Nd.to=pb,Nd.toNow=qb,Nd.get=F,Nd.invalidAt=Cb,Nd.isAfter=eb,Nd.isBefore=fb,Nd.isBetween=gb,Nd.isSame=hb,Nd.isValid=Ab,Nd.lang=Cd,Nd.locale=rb,Nd.localeData=sb,Nd.max=wd,Nd.min=vd,Nd.parsingFlags=Bb,Nd.set=F,Nd.startOf=tb,Nd.subtract=Bd,Nd.toArray=yb,Nd.toObject=zb,Nd.toDate=xb,Nd.toISOString=lb,Nd.toJSON=lb,Nd.toString=kb,Nd.unix=wb,Nd.valueOf=vb,Nd.year=td,Nd.isLeapYear=ia,Nd.weekYear=Fb,Nd.isoWeekYear=Gb,Nd.quarter=Nd.quarters=Jb,Nd.month=Y,Nd.daysInMonth=Z,Nd.week=Nd.weeks=na,Nd.isoWeek=Nd.isoWeeks=oa,Nd.weeksInYear=Ib,Nd.isoWeeksInYear=Hb,Nd.date=Dd,Nd.day=Nd.days=Pb,Nd.weekday=Qb,Nd.isoWeekday=Rb,Nd.dayOfYear=qa,Nd.hour=Nd.hours=Id,Nd.minute=Nd.minutes=Jd,Nd.second=Nd.seconds=Kd,
Nd.millisecond=Nd.milliseconds=Md,Nd.utcOffset=Na,Nd.utc=Pa,Nd.local=Qa,Nd.parseZone=Ra,Nd.hasAlignedHourOffset=Sa,Nd.isDST=Ta,Nd.isDSTShifted=Ua,Nd.isLocal=Va,Nd.isUtcOffset=Wa,Nd.isUtc=Xa,Nd.isUTC=Xa,Nd.zoneAbbr=Xb,Nd.zoneName=Yb,Nd.dates=aa(&quot;dates accessor is deprecated. Use date instead.&quot;,Dd),Nd.months=aa(&quot;months accessor is deprecated. Use month instead&quot;,Y),Nd.years=aa(&quot;years accessor is deprecated. Use year instead&quot;,td),Nd.zone=aa(&quot;moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779&quot;,Oa);var Od=Nd,Pd={sameDay:&quot;[Today at] LT&quot;,nextDay:&quot;[Tomorrow at] LT&quot;,nextWeek:&quot;dddd [at] LT&quot;,lastDay:&quot;[Yesterday at] LT&quot;,lastWeek:&quot;[Last] dddd [at] LT&quot;,sameElse:&quot;L&quot;},Qd={LTS:&quot;h:mm:ss A&quot;,LT:&quot;h:mm A&quot;,L:&quot;MM/DD/YYYY&quot;,LL:&quot;MMMM D, YYYY&quot;,LLL:&quot;MMMM D, YYYY h:mm A&quot;,LLLL:&quot;dddd, MMMM D, YYYY h:mm A&quot;},Rd=&quot;Invalid date&quot;,Sd=&quot;%d&quot;,Td=/\d{1,2}/,Ud={future:&quot;in %s&quot;,past:&quot;%s ago&quot;,s:&quot;a few seconds&quot;,m:&quot;a minute&quot;,mm:&quot;%d minutes&quot;,h:&quot;an hour&quot;,hh:&quot;%d hours&quot;,d:&quot;a day&quot;,dd:&quot;%d days&quot;,M:&quot;a month&quot;,MM:&quot;%d months&quot;,y:&quot;a year&quot;,yy:&quot;%d years&quot;},Vd=s.prototype;Vd._calendar=Pd,Vd.calendar=_b,Vd._longDateFormat=Qd,Vd.longDateFormat=ac,Vd._invalidDate=Rd,Vd.invalidDate=bc,Vd._ordinal=Sd,Vd.ordinal=cc,Vd._ordinalParse=Td,Vd.preparse=dc,Vd.postformat=dc,Vd._relativeTime=Ud,Vd.relativeTime=ec,Vd.pastFuture=fc,Vd.set=gc,Vd.months=U,Vd._months=md,Vd.monthsShort=V,Vd._monthsShort=nd,Vd.monthsParse=W,Vd.week=ka,Vd._week=ud,Vd.firstDayOfYear=ma,Vd.firstDayOfWeek=la,Vd.weekdays=Lb,Vd._weekdays=Ed,Vd.weekdaysMin=Nb,Vd._weekdaysMin=Gd,Vd.weekdaysShort=Mb,Vd._weekdaysShort=Fd,Vd.weekdaysParse=Ob,Vd.isPM=Ub,Vd._meridiemParse=Hd,Vd.meridiem=Vb,w(&quot;en&quot;,{ordinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===q(a%100/10)?&quot;th&quot;:1===b?&quot;st&quot;:2===b?&quot;nd&quot;:3===b?&quot;rd&quot;:&quot;th&quot;;return a+c}}),a.lang=aa(&quot;moment.lang is deprecated. Use moment.locale instead.&quot;,w),a.langData=aa(&quot;moment.langData is deprecated. Use moment.localeData instead.&quot;,y);var Wd=Math.abs,Xd=yc(&quot;ms&quot;),Yd=yc(&quot;s&quot;),Zd=yc(&quot;m&quot;),$d=yc(&quot;h&quot;),_d=yc(&quot;d&quot;),ae=yc(&quot;w&quot;),be=yc(&quot;M&quot;),ce=yc(&quot;y&quot;),de=Ac(&quot;milliseconds&quot;),ee=Ac(&quot;seconds&quot;),fe=Ac(&quot;minutes&quot;),ge=Ac(&quot;hours&quot;),he=Ac(&quot;days&quot;),ie=Ac(&quot;months&quot;),je=Ac(&quot;years&quot;),ke=Math.round,le={s:45,m:45,h:22,d:26,M:11},me=Math.abs,ne=Ha.prototype;ne.abs=oc,ne.add=qc,ne.subtract=rc,ne.as=wc,ne.asMilliseconds=Xd,ne.asSeconds=Yd,ne.asMinutes=Zd,ne.asHours=$d,ne.asDays=_d,ne.asWeeks=ae,ne.asMonths=be,ne.asYears=ce,ne.valueOf=xc,ne._bubble=tc,ne.get=zc,ne.milliseconds=de,ne.seconds=ee,ne.minutes=fe,ne.hours=ge,ne.days=he,ne.weeks=Bc,ne.months=ie,ne.years=je,ne.humanize=Fc,ne.toISOString=Gc,ne.toString=Gc,ne.toJSON=Gc,ne.locale=rb,ne.localeData=sb,ne.toIsoString=aa(&quot;toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)&quot;,Gc),ne.lang=Cd,H(&quot;X&quot;,0,0,&quot;unix&quot;),H(&quot;x&quot;,0,0,&quot;valueOf&quot;),N(&quot;x&quot;,_c),N(&quot;X&quot;,bd),Q(&quot;X&quot;,function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),Q(&quot;x&quot;,function(a,b,c){c._d=new Date(q(a))}),a.version=&quot;2.10.6&quot;,b(Da),a.fn=Od,a.min=Fa,a.max=Ga,a.utc=h,a.unix=Zb,a.months=jc,a.isDate=d,a.locale=w,a.invalid=l,a.duration=Ya,a.isMoment=o,a.weekdays=lc,a.parseZone=$b,a.localeData=y,a.isDuration=Ia,a.monthsShort=kc,a.weekdaysMin=nc,a.defineLocale=x,a.weekdaysShort=mc,a.normalizeUnits=A,a.relativeTimeThreshold=Ec;var oe=a;return oe});</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>2c64669f-f07e-4365-bf64-c559ace83004</id>
            <name>stopOnErrorCount</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122375</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Function to Stop a channel if it reaches a particular error count. 
	Also sends an alert message via another channel (this sends a sms via our monitoring system).

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function stopOnErrorCount(cid, errorCount) {
	var channelStatisticsController = Packages.com.mirth.connect.server.controllers.ChannelStatisticsController.getInstance();
	var channelStatusController = Packages.com.mirth.connect.server.controllers.ChannelStatusController.getInstance();
	var stats = channelStatisticsController.getStatistics(cid);
	// var numOfQueued = stats.queued;
	var numOfErrors = stats.error;

	if(numOfErrors &gt; errorCount )
	{
		//Stop Me
		channelStatusController.stopChannel(cid);
		//Alert msg sent to _SVHALERT channel
		var channelController = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance();
		var channelName = channelController.getDeployedChannelById(cid).getName();
		var alertmsg = &apos;mirth01 mirth_channel_status codeTemplate_stopOnErrorCount 0 &apos; +
					   &apos;channel &apos; + channelName + &apos; stopped&apos;;
		router.routeMessage(&apos;_SVHALERT&apos;, alertmsg);
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>08044817-3504-4fc1-80ee-404870195151</id>
            <name>test</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122745</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>COMPILED_CODE</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.
	searchword
	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function testfunc(arg1) {
	return arg1;
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>833c5444-6415-4d62-a76b-caa39589c2fa</id>
        <name>WebPT-Mirth</name>
        <revision>1</revision>
        <lastModified>
          <time>1678476121602</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>b9eceb1d-8abb-4931-8247-209d70519f99</id>
            <name>Fix HL7v2 Node Order</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476121804</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/*

	See issue: http://www.mirthcorp.com/community/issues/browse/MIRTH-625

	Author: Nick Rupley
	Date Modified: 4/18/2012

	fixHL7NodeOrder: Returns a new E4X node where the order of all siblings and descendants have been fixed as per the Mirth HL7 dot notation convention.

	Arguments
	---------
		Required
		--------
		node: The node to be fixed. 
*/
function fixHL7NodeOrder(node) {
	// Create output node
	var newNode = new XML();
	// In case the node is an XMLList of multiple siblings, loop through each sibling
	for each (sibling in node) {
		// Create new sibling node
		var newSibling = new XML(&apos;&lt;&apos;+sibling.name().toString()+&apos;/&gt;&apos;);
		// Iterate through each child node
		for each (child in sibling.children())
			// If the child has its own children, then recursively fix the node order of the child
			if (child.hasComplexContent())
				newSibling.appendChild(fixHL7NodeOrder(child));
			// If the child doesn&apos;t have its own children, then just add the child to the new sibling node
			else
				newSibling.appendChild(child);
		// After recursively fixing all of the child nodes, now we&apos;ll fix the current node
		newNode += sortHL7Node(newSibling);
	}
	// Return the fixed node
	return newNode;
}

function sortHL7Node(node) {
	// If the node has no children, then there&apos;s nothing to sort
	if (node.hasSimpleContent())
		return node;
	// Create new output node
	var newNode = new XML(&apos;&lt;&apos;+node.name().toString()+&apos;/&gt;&apos;);
	// Iterate through each child in the node
	for each (child in node.children()) {
		// If the child has a QName, then we can sort on it
		if (child.name()) {
			// Get the current &quot;index&quot; of the child. Id est, if the QName is PID.3.1, then the index is 1
			curChildIndex = parseInt(child.name().toString().substring(child.name().toString().lastIndexOf(&apos;.&apos;)+1),10);
			// Boolean placeholder
			var inserted = false;
			// Iterate through each child currently in the NEW node
			for (var i = 0; i &lt;= newNode.children().length()-1; i++) {
				// Get the index of the child of the new node
				loopChildIndex = parseInt(newNode.child(i).name().toString().substring(newNode.child(i).name().toString().lastIndexOf(&apos;.&apos;)+1),10);
				// If the child we want to insert has a lower index then the current child of the new node, then we&apos;re going to insert the child 
				// right before the current newNode child
				if (curChildIndex &lt; loopChildIndex) {
					// Insert the child
					newNode.insertChildBefore(newNode.children()[i],child);
					// Set our flag, indicating that an insertion was made
					inserted = true;
					// No need to continue iteration
					break;
				}
			}
			// If no insertion was made, then the index of the child we want to insert is greater than or equal to all of the
			// indices of the children that have already been inserted in newNode. So, we&apos;ll just append the child to the end.
			if (!inserted)
				newNode.appendChild(child);
		}
	}
	// Return the sorted HL7 node
	return newNode;
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="4.0.0">
        <id>35f4c250-08b4-4e42-8e60-f85aa98dfe50</id>
        <name>WebPT-Translations</name>
        <revision>4</revision>
        <lastModified>
          <time>1703964939924</time>
          <timezone>America/Chicago</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>c5aa527b-0e36-4790-8302-e1a6a472455e</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>65d47b29-67e5-4533-917c-337880fb8b17</string>
          <string>b7f455da-a5a4-4c75-be8f-d6f2c3561ac8</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>fd14f323-1f60-4ec5-b3e1-6ce8248bbcf3</string>
          <string>e248ef99-284c-41f3-adac-d7b43433b16f</string>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>6910529c-6cd1-4838-9a4f-d3c84faa2866</string>
          <string>8913e845-1fff-427c-bec0-e0a01d131f89</string>
          <string>19a0dcf7-3736-4b25-9049-80301c6cd04d</string>
          <string>32516e02-db8c-47f3-aba9-adfff1ea28c2</string>
          <string>b19c96b2-afb4-4248-83a8-96f521b20489</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
          <string>ed58a744-1f83-44aa-ad23-feef56e2f5e6</string>
          <string>4a98f7b0-d1f3-478d-ad65-550f8287fe24</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>0ace74f9-8ee8-45a5-8093-8d5bb95dae90</string>
          <string>32ea3c4a-9c59-4482-beb2-22d729e5e379</string>
          <string>a827a980-9c7f-410c-893a-141429f7b30a</string>
          <string>fba4345d-b56d-4b31-802c-cdac2248902d</string>
          <string>9ba29622-ed1f-4a34-9cbe-6f3df0eb3026</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>88f9a267-e37f-418d-aaf2-d077b7a0cdca</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>37b05d6c-c044-4394-a60a-deaee676ce0d</string>
          <string>71368dee-5964-4073-bab7-ae0fd3ae90b0</string>
          <string>5cc5d7df-228a-4d24-b774-681c717e1876</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>c65d1ffa-65af-4ee8-803a-2f32b201889d</string>
          <string>5c763fad-3eae-4e87-b944-0dbfe25814e0</string>
          <string>3792b059-e098-436c-81fe-23502ef5042b</string>
          <string>8a4eb453-fc7a-484a-8e15-422d9b490edf</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>631f9a02-6b74-4ecd-9582-221b98a0450e</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>c1fd4789-03e5-4ec3-91d2-cdded4b13365</string>
          <string>318f77fc-a631-48e0-8a4e-a87831bd81a7</string>
          <string>38e80069-5a80-4483-9a22-02c928973719</string>
          <string>ba9dcc01-6b1c-4fc3-afc4-cf1c5da9a8aa</string>
          <string>77033047-c5e7-4308-b2ed-d361923ed9a2</string>
          <string>2e0d9b6c-294f-4506-8632-dc4622b4f651</string>
          <string>d3f6504f-12cd-4e69-a920-6bb3a2195cc2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>57fa694a-2758-4e52-b725-967a74786d1f</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>ab7d9121-bd5f-47c1-964a-53531cd178dd</string>
          <string>bfc00235-7e2e-457a-b27f-e5288e9c28c4</string>
          <string>6be39ce0-8f88-42fb-b3a4-4afd4da39734</string>
          <string>754a8caa-2161-45d8-b261-e32d8b0fb044</string>
          <string>9370b181-aa9c-4db3-b7dc-2cd81cc91fdd</string>
          <string>e678dbf5-f021-43dc-84ae-967500d5c31a</string>
          <string>7741037b-845e-4e6d-b6aa-c9f249b06084</string>
          <string>c65024ed-4660-4423-9636-cb6309cae138</string>
          <string>0972a85f-5ad7-4a93-88e1-5f991b7f7879</string>
          <string>3fdef7e5-20e2-4e6f-aad4-a156ddb2e5e2</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>a25fa941-8ba3-47eb-81d1-24c9e45fe29d</string>
          <string>8cbc4731-752e-4e2e-a61d-018ed3e0cef0</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>5cfc8ad8-0fb2-48bf-a318-1aabd86cf60e</string>
          <string>10ef3f18-f1c1-495c-80be-026eb56436c5</string>
          <string>c15d4352-13b2-4698-a771-b3593449d7ba</string>
          <string>64e32643-e41c-4986-9550-c634cb02f9ba</string>
          <string>347deee2-a3c1-4542-bc3e-c619defe0b64</string>
          <string>9e040198-05cf-11e8-ba89-0ed5f89f718b</string>
          <string>dc8e6472-bc7e-4ebe-a8dd-968b791e2975</string>
          <string>66487d57-e34e-4a9a-8296-e62a66d3ab8b</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>0df5acd6-0251-4546-9d35-ed7f1515e00b</string>
          <string>93f57fef-8fc0-4b05-91de-b1cdb48034a2</string>
          <string>db4e2d12-f41b-4da9-87b8-a1feb4c29054</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>42e730bb-0721-435e-8dcf-d25d6d5d1dc6</string>
          <string>c90c935e-e3de-4ffe-839f-5560b39f07fb</string>
          <string>18803b99-6545-4d09-9277-a559ee2e94fd</string>
          <string>5231fded-a3aa-44e8-bd77-3ad84d39e1d2</string>
          <string>89faf430-5bd7-4440-9ed0-4b02d3462403</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="4.0.0">
            <id>be8f057b-2640-4613-b2e7-83326c59169c</id>
            <name>AddZeros</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122826</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function addZeroes(num) {
   return num.toLocaleString(&quot;en&quot;, {useGrouping: false, minimumFractionDigits: 2})
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>51913864-7702-489a-b7c6-54992c12b19d</id>
            <name>FindLookupValueWithDefault</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122218</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function FindLookupValueWithDefault ( LookupGlobalMapName, LeftValue){
    /*********************************
    DESCRIPTION: Retrieves lookup table values from the global map and uses the input values to return output values

     PARAMETERS:
       LookupGlobalMapName - name of the lookup table in the Global Map
       LeftValue - The value to look up
       DefaultValue1 - the first default value if a match was not found
       DefaultValue2 - the second default value if a match was not found

    RETURNS:
       An object containing the replacement value and associated OID if applicable

    REMARKS: 
    ********************************/
        // Retrieve the previously matched item from the globalmap
        //    We do this to save time and not look through a huge lookup table tons of times
        //    unless we absolutely have to
        var prevItem = globalChannelMap.get(LookupGlobalMapName + &apos;-Previous&apos;);

        // This is the same item requested for this globalmap name - just return the previous value
        if ( prevItem != null &amp;&amp; prevItem.LeftValue == LeftValue) {
            return prevItem;
        }

        //
        // If we reach this point the previous item either did not exist or did not match 
        //

        // Retrieve the array with lookup objects from the globalmap and search for the matching value
        var arr = globalChannelMap.get(LookupGlobalMapName);
        var obj = new Object();
        //obj.LeftValue = LeftValue;
        //obj.RightValue1 = DefaultValue1;
        //obj.RightValue2   = DefaultValue2; 
        for each ( item in arr )
        {
            var pattern=new RegExp(&quot;^&quot; + item.LeftValue + &quot;$&quot;);
            var result = pattern.test(LeftValue );

            if ( pattern.test(LeftValue ) )
            {
                obj = item;
                break;
            } 
        }

        // Store the previous value in the globalmap
        globalChannelMap.put( LookupGlobalMapName + &apos;-Previous&apos;, obj );

        // Return the object we found or created
        return obj;
    }</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>c276be9f-c8f1-4dea-8df0-e000c6745271</id>
            <name>FindLookupValueWithInsuranceId</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122080</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function FindLookupValueWithInsuranceId ( LookupGlobalMapName, LeftValue){
    /*********************************
    DESCRIPTION: Retrieves lookup table values from the global map and uses the input values to return output values

     PARAMETERS:
       LookupGlobalMapName - name of the lookup table in the Global Map
       LeftValue - The value to look up
       DefaultValue1 - the first default value if a match was not found
       DefaultValue2 - the second default value if a match was not found

    RETURNS:
       An object containing the replacement value and associated OID if applicable

    REMARKS: 
    ********************************/
        // Retrieve the previously matched item from the globalmap
        //    We do this to save time and not look through a huge lookup table tons of times
        //    unless we absolutely have to
        var prevItem = globalChannelMap.get(LookupGlobalMapName + &apos;-Previous&apos;);

        // This is the same item requested for this globalmap name - just return the previous value
        if ( prevItem != null &amp;&amp; prevItem.LeftValue == LeftValue) {
            return prevItem;
        }

        //
        // If we reach this point the previous item either did not exist or did not match 
        //

        // Retrieve the array with lookup objects from the globalmap and search for the matching value
        var arr = globalChannelMap.get(LookupGlobalMapName);
        var obj = new Object();
        for each ( item in arr )
        {
            var pattern=new RegExp(&quot;^&quot; + item.LeftValue + &quot;$&quot;);             
            var result = pattern.test(LeftValue );
	
            if ( pattern.test(LeftValue ) )
            {
                obj = item;
                break;
            } 
        }

        // Store the previous value in the globalmap
        globalChannelMap.put( LookupGlobalMapName + &apos;-Previous&apos;, obj );

        // Return the object we found or created
        return obj;
    }</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>7d746da2-58c6-44eb-ad5c-c5bfd0a0c537</id>
            <name>UseExternalProblemID</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122349</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function useExternalProblemID() {

if ([&apos;2804&apos;, &apos;2822&apos;].indexOf($(&apos;tenantId&apos;) + &apos;&apos;) &gt; -1) {
    tmp[&apos;Visit&apos;][&apos;AccountNumber&apos;] = msg[&apos;visitexternalproblemid&apos;].toString()
} else {
    tmp[&apos;Visit&apos;][&apos;AccountNumber&apos;] = msg[&apos;visitaccountnumber&apos;].toString();
}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="4.0.0">
            <id>07730e85-7f30-4ddf-90a4-78183c896ab5</id>
            <name>UseExternalVisitID</name>
            <revision>1</revision>
            <lastModified>
              <time>1678476122192</time>
              <timezone>America/Chicago</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
	Modify the description here. Modify the function name and parameters as needed. One function per
	template is recommended; create a new code template for each new function.

	@param {String} arg1 - arg1 description
	@return {String} return description
*/
function useExternalVisitID() {
	
if ($(&apos;tenantId&apos;)  == &apos;9999&apos; ) {
    tmp[&apos;Visit&apos;][&apos;VisitNumber&apos;] = msg[&apos;visitexternalvisitid&apos;].toString()
} else {
    tmp[&apos;Visit&apos;][&apos;VisitNumber&apos;] = msg[&apos;visitvisitnumber&apos;].toString();
}
}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
    </codeTemplateLibraries>
    <channelTags>
      <channelTag>
        <id>fce3bf2d-51c2-4c9c-b17a-be101d147e3a</id>
        <name>DICOM</name>
        <channelIds>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
        </channelIds>
        <backgroundColor>
          <red>128</red>
          <green>128</green>
          <blue>0</blue>
          <alpha>255</alpha>
        </backgroundColor>
      </channelTag>
      <channelTag>
        <id>28cdc2db-4028-4249-b1b8-c2ba3961a137</id>
        <name>HL7</name>
        <channelIds>
          <string>6a2a6c33-33da-4783-b823-bd95bf387981</string>
          <string>4e15d4c9-43b4-4d2c-9185-701707cd2f6a</string>
          <string>5beae4c2-e7f8-4ae3-9fca-703dea9233a2</string>
          <string>a6fc8ba1-0134-4d1a-a341-cd9a2f295595</string>
          <string>f7c77a5d-b086-4aed-aa56-e72984abd5ea</string>
          <string>a45d1db0-9b84-49d3-b26b-243dbf2a4f70</string>
          <string>272250ac-d998-41dc-b01d-7721808b3ec6</string>
          <string>6be39ce0-8f88-42fb-b3a4-4afd4da39734</string>
          <string>4964d3cc-7004-41c7-a704-da97ac92caf3</string>
          <string>81988bfb-2e74-4e25-ac01-1a000e027e97</string>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>1ae4e7ac-e62f-468c-aa2a-99cbd6139838</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>b19c96b2-afb4-4248-83a8-96f521b20489</string>
          <string>7a3b0715-12e0-4803-aa51-c1a947ef9b66</string>
          <string>dff92eca-e23d-4802-8e3c-023f3af3e640</string>
          <string>0638775c-6c87-4a71-b4b3-7ae52be05c1b</string>
          <string>d6ea31a1-1aa6-4a53-adde-10a1bcdcd3c5</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>72383579-097e-4205-b030-ce272c90b835</string>
          <string>a2b31875-5c31-4052-938f-a69550a8cb55</string>
          <string>a6ec1677-5012-430f-bcbc-f41fe39ecf1f</string>
          <string>5c5b6b2c-f3fd-456d-a90d-d684b5fb061e</string>
          <string>4c3b5879-a8d9-48be-83cc-5f7c5777a188</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1c6037e0-7bf9-41ae-b896-5be7b77e711f</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
        </channelIds>
        <backgroundColor>
          <red>128</red>
          <green>128</green>
          <blue>0</blue>
          <alpha>255</alpha>
        </backgroundColor>
      </channelTag>
      <channelTag>
        <id>a727d6e7-ed41-4197-bed5-16af58ab6813</id>
        <name>ORU</name>
        <channelIds>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
          <string>42b2b012-ffc4-41ba-a71e-00fbd1cc1c67</string>
          <string>4c2e73a8-aabe-4c04-9ba5-50ab49d3cb95</string>
          <string>6be39ce0-8f88-42fb-b3a4-4afd4da39734</string>
          <string>ead4368c-a612-459c-950e-50e49df05d9b</string>
          <string>4966bc7c-223c-4c44-8f71-4625cfcc0cc0</string>
          <string>954d2af0-df2c-46c6-95bc-02661a8d4424</string>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>1ae4e7ac-e62f-468c-aa2a-99cbd6139838</string>
          <string>a757905f-315a-43be-a624-38780a3d7574</string>
          <string>1b12c7a8-abee-4c24-85a4-d3b447e9d280</string>
          <string>c2277647-41dc-4e15-bce4-2ae23cec064b</string>
          <string>f1688a2f-ece0-4292-b5f9-e56c50b6bc5a</string>
        </channelIds>
        <backgroundColor>
          <red>0</red>
          <green>128</green>
          <blue>0</blue>
          <alpha>255</alpha>
        </backgroundColor>
      </channelTag>
      <channelTag>
        <id>441d20af-8076-4299-a200-ee020c536458</id>
        <name>PDF</name>
        <channelIds>
          <string>e20d28dc-e360-4b54-a225-5c6cddeba9a3</string>
          <string>ccd59c71-8d2a-40e9-8647-57e000ec6f43</string>
          <string>a3e80233-747a-4ce0-9f8f-59dcbe8e2ca6</string>
          <string>99b43124-34ef-4ead-a348-ef0ac0a52539</string>
        </channelIds>
        <backgroundColor>
          <red>255</red>
          <green>255</green>
          <blue>0</blue>
          <alpha>255</alpha>
        </backgroundColor>
      </channelTag>
    </channelTags>
  </exportData>
</channel>